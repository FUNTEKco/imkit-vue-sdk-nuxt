import './lib.css';var i7 = Object.defineProperty;
var u3 = (t) => {
  throw TypeError(t);
};
var s7 = (t, e, n) => e in t ? i7(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Ke = (t, e, n) => s7(t, typeof e != "symbol" ? e + "" : e, n), l3 = (t, e, n) => e.has(t) || u3("Cannot " + n);
var vs = (t, e, n) => (l3(t, e, "read from private field"), n ? n.call(t) : e.get(t)), rp = (t, e, n) => e.has(t) ? u3("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), _a = (t, e, n, r) => (l3(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n);
var H1 = (t, e, n, r) => ({
  set _(i) {
    _a(t, e, i, n);
  },
  get _() {
    return vs(t, e, r);
  }
});
import { watch as Ct, getCurrentScope as Qy, onScopeDispose as Gy, onUnmounted as Dc, getCurrentInstance as la, toRef as Ii, readonly as B0, ref as Se, customRef as a7, computed as de, toValue as ki, unref as ke, defineComponent as Ze, useAttrs as o7, onMounted as Tr, onBeforeUnmount as mi, nextTick as ca, createBlock as gt, openBlock as X, Teleport as u7, withDirectives as Gt, createCommentVNode as Fe, createElementBlock as se, mergeProps as ea, withModifiers as ar, withKeys as lh, createVNode as et, Transition as Lu, toHandlers as c3, withCtx as Zt, normalizeStyle as Qt, normalizeClass as vt, vShow as Ra, renderSlot as Jr, normalizeProps as Yy, guardReactiveProps as YS, createElementVNode as W, inject as pn, reactive as ja, Fragment as wt, renderList as on, resolveDynamicComponent as xu, createSlots as l7, markRaw as Vi, shallowReactive as ip, effectScope as XS, toDisplayString as _e, onBeforeMount as Xy, onActivated as c7, onUpdated as d7, shallowRef as ch, isRef as F0, h as sn, Text as f7, createTextVNode as An, resolveDirective as Mc, vModelText as ds, provide as Ba, Comment as U0, vModelRadio as j1, createStaticVNode as $0, useCssVars as h7, useSlots as p7, toRefs as Nl, watchEffect as If, toRaw as KS, resolveComponent as vo, isVNode as m7, vModelSelect as g7 } from "vue";
new TextEncoder();
const Q2 = new TextDecoder();
function A7(t) {
  if (Uint8Array.fromBase64)
    return Uint8Array.fromBase64(t);
  const e = atob(t), n = new Uint8Array(e.length);
  for (let r = 0; r < e.length; r++)
    n[r] = e.charCodeAt(r);
  return n;
}
function b7(t) {
  if (Uint8Array.fromBase64)
    return Uint8Array.fromBase64(typeof t == "string" ? t : Q2.decode(t), {
      alphabet: "base64url"
    });
  let e = t;
  e instanceof Uint8Array && (e = Q2.decode(e)), e = e.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return A7(e);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
class ZS extends Error {
  constructor(n, r) {
    var i;
    super(n, r);
    Ke(this, "code", "ERR_JOSE_GENERIC");
    this.name = this.constructor.name, (i = Error.captureStackTrace) == null || i.call(Error, this, this.constructor);
  }
}
Ke(ZS, "code", "ERR_JOSE_GENERIC");
class uo extends ZS {
  constructor() {
    super(...arguments);
    Ke(this, "code", "ERR_JWT_INVALID");
  }
}
Ke(uo, "code", "ERR_JWT_INVALID");
function y7(t) {
  return typeof t == "object" && t !== null;
}
const v7 = (t) => {
  if (!y7(t) || Object.prototype.toString.call(t) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(t) === null)
    return !0;
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e;
};
function T7(t) {
  if (typeof t != "string")
    throw new uo("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: e, length: n } = t.split(".");
  if (n === 5)
    throw new uo("Only JWTs using Compact JWS serialization can be decoded");
  if (n !== 3)
    throw new uo("Invalid JWT");
  if (!e)
    throw new uo("JWTs must contain a payload");
  let r;
  try {
    r = b7(e);
  } catch {
    throw new uo("Failed to base64url decode the payload");
  }
  let i;
  try {
    i = JSON.parse(Q2.decode(r));
  } catch {
    throw new uo("Failed to parse the decoded payload as JSON");
  }
  if (!v7(i))
    throw new uo("Invalid JWT Claims Set");
  return i;
}
function Ky(t) {
  return Qy() ? (Gy(t), !0) : !1;
}
const Zy = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const _7 = Object.prototype.toString, JS = (t) => _7.call(t) === "[object Object]", iu = () => {
}, G2 = /* @__PURE__ */ E7();
function E7() {
  var t, e;
  return Zy && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function x7(...t) {
  if (t.length !== 1)
    return Ii(...t);
  const e = t[0];
  return typeof e == "function" ? B0(a7(() => ({ get: e, set: iu }))) : Se(e);
}
function jl(t) {
  return Array.isArray(t) ? t : [t];
}
function w7(t) {
  return la();
}
function C7(t, e) {
  w7() && Dc(t, e);
}
function e6(t, e, n) {
  return Ct(
    t,
    e,
    {
      ...n,
      immediate: !0
    }
  );
}
const S7 = Zy ? window : void 0;
function t6(t) {
  var e;
  const n = ki(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
function ws(...t) {
  const e = [], n = () => {
    e.forEach((o) => o()), e.length = 0;
  }, r = (o, u, c, d) => (o.addEventListener(u, c, d), () => o.removeEventListener(u, c, d)), i = de(() => {
    const o = jl(ki(t[0])).filter((u) => u != null);
    return o.every((u) => typeof u != "string") ? o : void 0;
  }), s = e6(
    () => {
      var o, u;
      return [
        (u = (o = i.value) == null ? void 0 : o.map((c) => t6(c))) != null ? u : [S7].filter((c) => c != null),
        jl(ki(i.value ? t[1] : t[0])),
        jl(ke(i.value ? t[2] : t[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        ki(i.value ? t[3] : t[2])
      ];
    },
    ([o, u, c, d]) => {
      if (n(), !(o != null && o.length) || !(u != null && u.length) || !(c != null && c.length))
        return;
      const l = JS(d) ? { ...d } : d;
      e.push(
        ...o.flatMap(
          (f) => u.flatMap(
            (p) => c.map((m) => r(f, p, m, l))
          )
        )
      );
    },
    { flush: "post" }
  ), a = () => {
    s(), n();
  };
  return Ky(n), a;
}
const I7 = 500, k7 = 10;
function n6(t, e, n) {
  var r, i;
  const s = de(() => t6(t));
  let a, o, u, c = !1;
  function d() {
    a && (clearTimeout(a), a = void 0), o = void 0, u = void 0, c = !1;
  }
  function l(b) {
    var E, v, _;
    const [D, S, M] = [u, o, c];
    if (d(), !(n != null && n.onMouseUp) || !S || !D || (E = n == null ? void 0 : n.modifiers) != null && E.self && b.target !== s.value)
      return;
    (v = n == null ? void 0 : n.modifiers) != null && v.prevent && b.preventDefault(), (_ = n == null ? void 0 : n.modifiers) != null && _.stop && b.stopPropagation();
    const O = b.x - S.x, T = b.y - S.y, N = Math.sqrt(O * O + T * T);
    n.onMouseUp(b.timeStamp - D, N, M);
  }
  function f(b) {
    var E, v, _, D;
    (E = n == null ? void 0 : n.modifiers) != null && E.self && b.target !== s.value || (d(), (v = n == null ? void 0 : n.modifiers) != null && v.prevent && b.preventDefault(), (_ = n == null ? void 0 : n.modifiers) != null && _.stop && b.stopPropagation(), o = {
      x: b.x,
      y: b.y
    }, u = b.timeStamp, a = setTimeout(
      () => {
        c = !0, e(b);
      },
      (D = n == null ? void 0 : n.delay) != null ? D : I7
    ));
  }
  function p(b) {
    var E, v, _, D;
    if ((E = n == null ? void 0 : n.modifiers) != null && E.self && b.target !== s.value || !o || (n == null ? void 0 : n.distanceThreshold) === !1)
      return;
    (v = n == null ? void 0 : n.modifiers) != null && v.prevent && b.preventDefault(), (_ = n == null ? void 0 : n.modifiers) != null && _.stop && b.stopPropagation();
    const S = b.x - o.x, M = b.y - o.y;
    Math.sqrt(S * S + M * M) >= ((D = n == null ? void 0 : n.distanceThreshold) != null ? D : k7) && d();
  }
  const m = {
    capture: (r = n == null ? void 0 : n.modifiers) == null ? void 0 : r.capture,
    once: (i = n == null ? void 0 : n.modifiers) == null ? void 0 : i.once
  }, g = [
    ws(s, "pointerdown", f, m),
    ws(s, "pointermove", p, m),
    ws(s, ["pointerup", "pointerleave"], l, m)
  ];
  return () => g.forEach((b) => b());
}
function D7(t) {
  return Qy() ? (Gy(t), !0) : !1;
}
function M7(t) {
  return typeof t == "function" ? t() : ke(t);
}
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function O7(t) {
  var e;
  const n = M7(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var r6 = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], km = /* @__PURE__ */ r6.join(","), i6 = typeof Element > "u", Pu = i6 ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Dm = !i6 && Element.prototype.getRootNode ? function(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
} : function(t) {
  return t == null ? void 0 : t.ownerDocument;
}, Mm = function t(e, n) {
  var r;
  n === void 0 && (n = !0);
  var i = e == null || (r = e.getAttribute) === null || r === void 0 ? void 0 : r.call(e, "inert"), s = i === "" || i === "true", a = s || n && e && t(e.parentNode);
  return a;
}, N7 = function(e) {
  var n, r = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "contenteditable");
  return r === "" || r === "true";
}, s6 = function(e, n, r) {
  if (Mm(e))
    return [];
  var i = Array.prototype.slice.apply(e.querySelectorAll(km));
  return n && Pu.call(e, km) && i.unshift(e), i = i.filter(r), i;
}, a6 = function t(e, n, r) {
  for (var i = [], s = Array.from(e); s.length; ) {
    var a = s.shift();
    if (!Mm(a, !1))
      if (a.tagName === "SLOT") {
        var o = a.assignedElements(), u = o.length ? o : a.children, c = t(u, !0, r);
        r.flatten ? i.push.apply(i, c) : i.push({
          scopeParent: a,
          candidates: c
        });
      } else {
        var d = Pu.call(a, km);
        d && r.filter(a) && (n || !e.includes(a)) && i.push(a);
        var l = a.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(a), f = !Mm(l, !1) && (!r.shadowRootFilter || r.shadowRootFilter(a));
        if (l && f) {
          var p = t(l === !0 ? a.children : l.children, !0, r);
          r.flatten ? i.push.apply(i, p) : i.push({
            scopeParent: a,
            candidates: p
          });
        } else
          s.unshift.apply(s, a.children);
      }
  }
  return i;
}, o6 = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, ou = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || N7(e)) && !o6(e) ? 0 : e.tabIndex;
}, L7 = function(e, n) {
  var r = ou(e);
  return r < 0 && n && !o6(e) ? 0 : r;
}, P7 = function(e, n) {
  return e.tabIndex === n.tabIndex ? e.documentOrder - n.documentOrder : e.tabIndex - n.tabIndex;
}, u6 = function(e) {
  return e.tagName === "INPUT";
}, R7 = function(e) {
  return u6(e) && e.type === "hidden";
}, B7 = function(e) {
  var n = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, F7 = function(e, n) {
  for (var r = 0; r < e.length; r++)
    if (e[r].checked && e[r].form === n)
      return e[r];
}, U7 = function(e) {
  if (!e.name)
    return !0;
  var n = e.form || Dm(e), r = function(o) {
    return n.querySelectorAll('input[type="radio"][name="' + o + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(e.name));
  else
    try {
      i = r(e.name);
    } catch (a) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1;
    }
  var s = F7(i, e.form);
  return !s || s === e;
}, $7 = function(e) {
  return u6(e) && e.type === "radio";
}, H7 = function(e) {
  return $7(e) && !U7(e);
}, j7 = function(e) {
  var n, r = e && Dm(e), i = (n = r) === null || n === void 0 ? void 0 : n.host, s = !1;
  if (r && r !== e) {
    var a, o, u;
    for (s = !!((a = i) !== null && a !== void 0 && (o = a.ownerDocument) !== null && o !== void 0 && o.contains(i) || e != null && (u = e.ownerDocument) !== null && u !== void 0 && u.contains(e)); !s && i; ) {
      var c, d, l;
      r = Dm(i), i = (c = r) === null || c === void 0 ? void 0 : c.host, s = !!((d = i) !== null && d !== void 0 && (l = d.ownerDocument) !== null && l !== void 0 && l.contains(i));
    }
  }
  return s;
}, d3 = function(e) {
  var n = e.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, z7 = function(e, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var s = Pu.call(e, "details>summary:first-of-type"), a = s ? e.parentElement : e;
  if (Pu.call(a, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof i == "function") {
      for (var o = e; e; ) {
        var u = e.parentElement, c = Dm(e);
        if (u && !u.shadowRoot && i(u) === !0)
          return d3(e);
        e.assignedSlot ? e = e.assignedSlot : !u && c !== e.ownerDocument ? e = c.host : e = u;
      }
      e = o;
    }
    if (j7(e))
      return !e.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return d3(e);
  return !1;
}, q7 = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var n = e.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return Pu.call(n, "fieldset[disabled] *") ? !0 : !i.contains(e);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, Om = function(e, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  Mm(n) || R7(n) || z7(n, e) || // For a details element with a summary, the summary element gets the focus
  B7(n) || q7(n));
}, Y2 = function(e, n) {
  return !(H7(n) || ou(n) < 0 || !Om(e, n));
}, V7 = function(e) {
  var n = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, W7 = function t(e) {
  var n = [], r = [];
  return e.forEach(function(i, s) {
    var a = !!i.scopeParent, o = a ? i.scopeParent : i, u = L7(o, a), c = a ? t(i.candidates) : o;
    u === 0 ? a ? n.push.apply(n, c) : n.push(o) : r.push({
      documentOrder: s,
      tabIndex: u,
      item: i,
      isScope: a,
      content: c
    });
  }), r.sort(P7).reduce(function(i, s) {
    return s.isScope ? i.push.apply(i, s.content) : i.push(s.content), i;
  }, []).concat(n);
}, Q7 = function(e, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = a6([e], n.includeContainer, {
    filter: Y2.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: V7
  }) : r = s6(e, n.includeContainer, Y2.bind(null, n)), W7(r);
}, G7 = function(e, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = a6([e], n.includeContainer, {
    filter: Om.bind(null, n),
    flatten: !0,
    getShadowRoot: n.getShadowRoot
  }) : r = s6(e, n.includeContainer, Om.bind(null, n)), r;
}, yl = function(e, n) {
  if (n = n || {}, !e)
    throw new Error("No node provided");
  return Pu.call(e, km) === !1 ? !1 : Y2(n, e);
}, Y7 = /* @__PURE__ */ r6.concat("iframe").join(","), z1 = function(e, n) {
  if (n = n || {}, !e)
    throw new Error("No node provided");
  return Pu.call(e, Y7) === !1 ? !1 : Om(n, e);
};
/*!
* focus-trap 7.5.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function f3(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function h3(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? f3(Object(n), !0).forEach(function(r) {
      X7(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : f3(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function X7(t, e, n) {
  return e = Z7(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function K7(t, e) {
  if (typeof t != "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Z7(t) {
  var e = K7(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
var p3 = {
  activateTrap: function(e, n) {
    if (e.length > 0) {
      var r = e[e.length - 1];
      r !== n && r.pause();
    }
    var i = e.indexOf(n);
    i === -1 || e.splice(i, 1), e.push(n);
  },
  deactivateTrap: function(e, n) {
    var r = e.indexOf(n);
    r !== -1 && e.splice(r, 1), e.length > 0 && e[e.length - 1].unpause();
  }
}, J7 = function(e) {
  return e.tagName && e.tagName.toLowerCase() === "input" && typeof e.select == "function";
}, eP = function(e) {
  return (e == null ? void 0 : e.key) === "Escape" || (e == null ? void 0 : e.key) === "Esc" || (e == null ? void 0 : e.keyCode) === 27;
}, nf = function(e) {
  return (e == null ? void 0 : e.key) === "Tab" || (e == null ? void 0 : e.keyCode) === 9;
}, tP = function(e) {
  return nf(e) && !e.shiftKey;
}, nP = function(e) {
  return nf(e) && e.shiftKey;
}, m3 = function(e) {
  return setTimeout(e, 0);
}, g3 = function(e, n) {
  var r = -1;
  return e.every(function(i, s) {
    return n(i) ? (r = s, !1) : !0;
  }), r;
}, bd = function(e) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
    r[i - 1] = arguments[i];
  return typeof e == "function" ? e.apply(void 0, r) : e;
}, sp = function(e) {
  return e.target.shadowRoot && typeof e.composedPath == "function" ? e.composedPath()[0] : e.target;
}, rP = [], iP = function(e, n) {
  var r = (n == null ? void 0 : n.document) || document, i = (n == null ? void 0 : n.trapStack) || rP, s = h3({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0,
    isKeyForward: tP,
    isKeyBackward: nP
  }, n), a = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  }, o, u = function($, j, U) {
    return $ && $[j] !== void 0 ? $[j] : s[U || j];
  }, c = function($, j) {
    var U = typeof (j == null ? void 0 : j.composedPath) == "function" ? j.composedPath() : void 0;
    return a.containerGroups.findIndex(function(V) {
      var B = V.container, R = V.tabbableNodes;
      return B.contains($) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (U == null ? void 0 : U.includes(B)) || R.find(function(K) {
        return K === $;
      });
    });
  }, d = function($) {
    var j = s[$];
    if (typeof j == "function") {
      for (var U = arguments.length, V = new Array(U > 1 ? U - 1 : 0), B = 1; B < U; B++)
        V[B - 1] = arguments[B];
      j = j.apply(void 0, V);
    }
    if (j === !0 && (j = void 0), !j) {
      if (j === void 0 || j === !1)
        return j;
      throw new Error("`".concat($, "` was specified but was not a node, or did not return a node"));
    }
    var R = j;
    if (typeof j == "string" && (R = r.querySelector(j), !R))
      throw new Error("`".concat($, "` as selector refers to no known node"));
    return R;
  }, l = function() {
    var $ = d("initialFocus");
    if ($ === !1)
      return !1;
    if ($ === void 0 || !z1($, s.tabbableOptions))
      if (c(r.activeElement) >= 0)
        $ = r.activeElement;
      else {
        var j = a.tabbableGroups[0], U = j && j.firstTabbableNode;
        $ = U || d("fallbackFocus");
      }
    if (!$)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return $;
  }, f = function() {
    if (a.containerGroups = a.containers.map(function($) {
      var j = Q7($, s.tabbableOptions), U = G7($, s.tabbableOptions), V = j.length > 0 ? j[0] : void 0, B = j.length > 0 ? j[j.length - 1] : void 0, R = U.find(function(P) {
        return yl(P);
      }), K = U.slice().reverse().find(function(P) {
        return yl(P);
      }), Q = !!j.find(function(P) {
        return ou(P) > 0;
      });
      return {
        container: $,
        tabbableNodes: j,
        focusableNodes: U,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: Q,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: V,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: B,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: R,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: K,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(I) {
          var G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, te = j.indexOf(I);
          return te < 0 ? G ? U.slice(U.indexOf(I) + 1).find(function(ee) {
            return yl(ee);
          }) : U.slice(0, U.indexOf(I)).reverse().find(function(ee) {
            return yl(ee);
          }) : j[te + (G ? 1 : -1)];
        }
      };
    }), a.tabbableGroups = a.containerGroups.filter(function($) {
      return $.tabbableNodes.length > 0;
    }), a.tabbableGroups.length <= 0 && !d("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    if (a.containerGroups.find(function($) {
      return $.posTabIndexesFound;
    }) && a.containerGroups.length > 1)
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
  }, p = function H($) {
    var j = $.activeElement;
    if (j)
      return j.shadowRoot && j.shadowRoot.activeElement !== null ? H(j.shadowRoot) : j;
  }, m = function H($) {
    if ($ !== !1 && $ !== p(document)) {
      if (!$ || !$.focus) {
        H(l());
        return;
      }
      $.focus({
        preventScroll: !!s.preventScroll
      }), a.mostRecentlyFocusedNode = $, J7($) && $.select();
    }
  }, g = function($) {
    var j = d("setReturnFocus", $);
    return j || (j === !1 ? !1 : $);
  }, y = function($) {
    var j = $.target, U = $.event, V = $.isBackward, B = V === void 0 ? !1 : V;
    j = j || sp(U), f();
    var R = null;
    if (a.tabbableGroups.length > 0) {
      var K = c(j, U), Q = K >= 0 ? a.containerGroups[K] : void 0;
      if (K < 0)
        B ? R = a.tabbableGroups[a.tabbableGroups.length - 1].lastTabbableNode : R = a.tabbableGroups[0].firstTabbableNode;
      else if (B) {
        var P = g3(a.tabbableGroups, function(ye) {
          var he = ye.firstTabbableNode;
          return j === he;
        });
        if (P < 0 && (Q.container === j || z1(j, s.tabbableOptions) && !yl(j, s.tabbableOptions) && !Q.nextTabbableNode(j, !1)) && (P = K), P >= 0) {
          var I = P === 0 ? a.tabbableGroups.length - 1 : P - 1, G = a.tabbableGroups[I];
          R = ou(j) >= 0 ? G.lastTabbableNode : G.lastDomTabbableNode;
        } else nf(U) || (R = Q.nextTabbableNode(j, !1));
      } else {
        var te = g3(a.tabbableGroups, function(ye) {
          var he = ye.lastTabbableNode;
          return j === he;
        });
        if (te < 0 && (Q.container === j || z1(j, s.tabbableOptions) && !yl(j, s.tabbableOptions) && !Q.nextTabbableNode(j)) && (te = K), te >= 0) {
          var ee = te === a.tabbableGroups.length - 1 ? 0 : te + 1, Z = a.tabbableGroups[ee];
          R = ou(j) >= 0 ? Z.firstTabbableNode : Z.firstDomTabbableNode;
        } else nf(U) || (R = Q.nextTabbableNode(j));
      }
    } else
      R = d("fallbackFocus");
    return R;
  }, b = function($) {
    var j = sp($);
    if (!(c(j, $) >= 0)) {
      if (bd(s.clickOutsideDeactivates, $)) {
        o.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: s.returnFocusOnDeactivate
        });
        return;
      }
      bd(s.allowOutsideClick, $) || $.preventDefault();
    }
  }, E = function($) {
    var j = sp($), U = c(j, $) >= 0;
    if (U || j instanceof Document)
      U && (a.mostRecentlyFocusedNode = j);
    else {
      $.stopImmediatePropagation();
      var V, B = !0;
      if (a.mostRecentlyFocusedNode)
        if (ou(a.mostRecentlyFocusedNode) > 0) {
          var R = c(a.mostRecentlyFocusedNode), K = a.containerGroups[R].tabbableNodes;
          if (K.length > 0) {
            var Q = K.findIndex(function(P) {
              return P === a.mostRecentlyFocusedNode;
            });
            Q >= 0 && (s.isKeyForward(a.recentNavEvent) ? Q + 1 < K.length && (V = K[Q + 1], B = !1) : Q - 1 >= 0 && (V = K[Q - 1], B = !1));
          }
        } else
          a.containerGroups.some(function(P) {
            return P.tabbableNodes.some(function(I) {
              return ou(I) > 0;
            });
          }) || (B = !1);
      else
        B = !1;
      B && (V = y({
        // move FROM the MRU node, not event-related node (which will be the node that is
        //  outside the trap causing the focus escape we're trying to fix)
        target: a.mostRecentlyFocusedNode,
        isBackward: s.isKeyBackward(a.recentNavEvent)
      })), m(V || a.mostRecentlyFocusedNode || l());
    }
    a.recentNavEvent = void 0;
  }, v = function($) {
    var j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    a.recentNavEvent = $;
    var U = y({
      event: $,
      isBackward: j
    });
    U && (nf($) && $.preventDefault(), m(U));
  }, _ = function($) {
    if (eP($) && bd(s.escapeDeactivates, $) !== !1) {
      $.preventDefault(), o.deactivate();
      return;
    }
    (s.isKeyForward($) || s.isKeyBackward($)) && v($, s.isKeyBackward($));
  }, D = function($) {
    var j = sp($);
    c(j, $) >= 0 || bd(s.clickOutsideDeactivates, $) || bd(s.allowOutsideClick, $) || ($.preventDefault(), $.stopImmediatePropagation());
  }, S = function() {
    if (a.active)
      return p3.activateTrap(i, o), a.delayInitialFocusTimer = s.delayInitialFocus ? m3(function() {
        m(l());
      }) : m(l()), r.addEventListener("focusin", E, !0), r.addEventListener("mousedown", b, {
        capture: !0,
        passive: !1
      }), r.addEventListener("touchstart", b, {
        capture: !0,
        passive: !1
      }), r.addEventListener("click", D, {
        capture: !0,
        passive: !1
      }), r.addEventListener("keydown", _, {
        capture: !0,
        passive: !1
      }), o;
  }, M = function() {
    if (a.active)
      return r.removeEventListener("focusin", E, !0), r.removeEventListener("mousedown", b, !0), r.removeEventListener("touchstart", b, !0), r.removeEventListener("click", D, !0), r.removeEventListener("keydown", _, !0), o;
  }, O = function($) {
    var j = $.some(function(U) {
      var V = Array.from(U.removedNodes);
      return V.some(function(B) {
        return B === a.mostRecentlyFocusedNode;
      });
    });
    j && m(l());
  }, T = typeof window < "u" && "MutationObserver" in window ? new MutationObserver(O) : void 0, N = function() {
    T && (T.disconnect(), a.active && !a.paused && a.containers.map(function($) {
      T.observe($, {
        subtree: !0,
        childList: !0
      });
    }));
  };
  return o = {
    get active() {
      return a.active;
    },
    get paused() {
      return a.paused;
    },
    activate: function($) {
      if (a.active)
        return this;
      var j = u($, "onActivate"), U = u($, "onPostActivate"), V = u($, "checkCanFocusTrap");
      V || f(), a.active = !0, a.paused = !1, a.nodeFocusedBeforeActivation = r.activeElement, j == null || j();
      var B = function() {
        V && f(), S(), N(), U == null || U();
      };
      return V ? (V(a.containers.concat()).then(B, B), this) : (B(), this);
    },
    deactivate: function($) {
      if (!a.active)
        return this;
      var j = h3({
        onDeactivate: s.onDeactivate,
        onPostDeactivate: s.onPostDeactivate,
        checkCanReturnFocus: s.checkCanReturnFocus
      }, $);
      clearTimeout(a.delayInitialFocusTimer), a.delayInitialFocusTimer = void 0, M(), a.active = !1, a.paused = !1, N(), p3.deactivateTrap(i, o);
      var U = u(j, "onDeactivate"), V = u(j, "onPostDeactivate"), B = u(j, "checkCanReturnFocus"), R = u(j, "returnFocus", "returnFocusOnDeactivate");
      U == null || U();
      var K = function() {
        m3(function() {
          R && m(g(a.nodeFocusedBeforeActivation)), V == null || V();
        });
      };
      return R && B ? (B(g(a.nodeFocusedBeforeActivation)).then(K, K), this) : (K(), this);
    },
    pause: function($) {
      if (a.paused || !a.active)
        return this;
      var j = u($, "onPause"), U = u($, "onPostPause");
      return a.paused = !0, j == null || j(), M(), N(), U == null || U(), this;
    },
    unpause: function($) {
      if (!a.paused || !a.active)
        return this;
      var j = u($, "onUnpause"), U = u($, "onPostUnpause");
      return a.paused = !1, j == null || j(), f(), S(), N(), U == null || U(), this;
    },
    updateContainerElements: function($) {
      var j = [].concat($).filter(Boolean);
      return a.containers = j.map(function(U) {
        return typeof U == "string" ? r.querySelector(U) : U;
      }), a.active && f(), N(), this;
    }
  }, o.updateContainerElements(e), o;
};
function sP(t, e = {}) {
  let n;
  const { immediate: r, ...i } = e, s = Se(!1), a = Se(!1), o = (l) => n && n.activate(l), u = (l) => n && n.deactivate(l), c = () => {
    n && (n.pause(), a.value = !0);
  }, d = () => {
    n && (n.unpause(), a.value = !1);
  };
  return Ct(
    () => O7(t),
    (l) => {
      l && (n = iP(l, {
        ...i,
        onActivate() {
          s.value = !0, e.onActivate && e.onActivate();
        },
        onDeactivate() {
          s.value = !1, e.onDeactivate && e.onDeactivate();
        }
      }), r && o());
    },
    { flush: "post" }
  ), D7(() => u()), {
    hasFocus: s,
    isPaused: a,
    activate: o,
    deactivate: u,
    pause: c,
    unpause: d
  };
}
const aP = (t) => (...e) => {
  t && (t == null || t(...e), t = null);
}, kf = () => {
};
function ap(t, e, n) {
  return t > n ? n : t < e ? e : t;
}
const Jy = (t) => typeof t == "string";
function q1(t, e) {
  var n;
  const r = ((n = qd(t, e)) == null ? void 0 : n[0]) || e;
  t.push(r);
}
function qd(t, e) {
  const n = t.indexOf(e);
  if (n !== -1)
    return t.splice(n, 1);
}
function l6(t) {
  return Object.entries(t);
}
const oP = {
  /**
   * @description Set `null | false` to disable teleport.
   * @default `'body'`
   * @example
   * ```js
   * teleportTo: '#modals'
   * ```
   */
  teleportTo: {
    type: [String, null, Boolean, Object],
    default: "body"
  },
  /**
   * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
   * @default `undefined`
   * @example Symbol: `Symbol('MyModal')`
   * @example String: `'AUniqString'`
   * @example Number: `300`
   */
  modalId: {
    type: [String, Number, Symbol],
    default: void 0
  },
  /**
   * @description Display the modal or not.
   * @default `undefined`
   * @example
   * ```js
   * const showModal = ref(false)
   * v-model="showModal"
   * ```
   */
  modelValue: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Render the modal via `if` or `show`.
   * @default `'if'`
   * @example
   * ```js
   * displayDirective: 'if'
   * ```
   * @example
   * ```js
   * displayDirective: 'show'
   * ```
   */
  displayDirective: {
    type: String,
    default: "if",
    validator: (t) => ["if", "show", "visible"].includes(t)
  },
  /**
   * @description Hide the overlay or not.
   * @default `undefined`
   * @example
   * ```js
   * hideOverlay="true"
   * ```
   */
  hideOverlay: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Customize the overlay behavior.
   */
  overlayBehavior: {
    type: String,
    default: "auto",
    validator: (t) => ["auto", "persist"].includes(t)
  },
  /**
   * @description Customize the overlay transition.
   * @default `undefined`
   */
  overlayTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Customize the content transition.
   * @default `undefined`
   */
  contentTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Bind class to vfm__overlay.
   * @default `undefined`
   */
  overlayClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind class to vfm__content.
   * @default `undefined`
   */
  contentClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind style to vfm__overlay.
   * @default `undefined`
   */
  overlayStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Bind style to vfm__content.
   * @default `undefined`
   */
  contentStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Is it allow to close the modal by clicking the overlay.
   * @default `true`
   */
  clickToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to close the modal by keypress `esc`.
   * @default `true`
   */
  escToClose: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Is it allow to click outside of the vfm__content when the modal is opened
   * @default `'non-interactive'`
   */
  background: {
    type: String,
    default: "non-interactive",
    validator: (t) => ["interactive", "non-interactive"].includes(t)
  },
  /**
   * @description
   * * Use `{ disabled: true }` to disable the focusTrap.
   * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
   * @default `{ allowOutsideClick: true }`
   */
  focusTrap: {
    type: [Boolean, Object],
    default: () => ({
      allowOutsideClick: !0
    })
  },
  /**
   * @description Lock body scroll or not when the modal is opened.
   * @default `true`
   */
  lockScroll: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Creates a padding-right when scroll is locked to prevent the page from jumping
   * @default `true`
   */
  reserveScrollBarGap: {
    type: Boolean,
    default: !0
  },
  /**
   * @description Define how to increase the zIndex when there are nested modals
   * @default `({ index }) => 1000 + 2 * index`
   */
  zIndexFn: {
    type: Function,
    default: ({ index: t }) => 1e3 + 2 * t
  },
  /**
   * @description The direction of swiping to close the modal
   * @default `none`
   * @example
   * Set swipeToClose="none" to disable swiping to close
   * ```js
   * swipeToClose="none"
   * ```
   */
  swipeToClose: {
    type: String,
    default: "none",
    validator: (t) => ["none", "up", "right", "down", "left"].includes(t)
  },
  /**
   * @description Threshold for swipe to close
   * @default `0`
   */
  threshold: {
    type: Number,
    default: 0
  },
  /**
   * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
   * @default `undefined`
   * @example
   * ```js
   * swipeToClose="right"
   * :showSwipeBanner="true"
   * ```
   * ```html
   * <VueFinalModal
   *   ...
   *   swipeToClose="right"
   *   :showSwipeBanner="true"
   * >
   *   <template #swipe-banner>
   *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
   *   </template>
   *   ...modal content
   * </VueFinalModal>
   * ```
   */
  showSwipeBanner: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
   * @default `undefined`
   * @example
   * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
   * ```js
   * :preventNavigationGestures="true"
   * ```
   */
  preventNavigationGestures: {
    type: Boolean,
    default: void 0
  }
};
function A3(t = !1) {
  const e = Se(t), n = Se(e.value ? 0 : void 0);
  return [e, n, {
    beforeEnter() {
      n.value = 1;
    },
    afterEnter() {
      n.value = 0;
    },
    beforeLeave() {
      n.value = 3;
    },
    afterLeave() {
      n.value = 2;
    }
  }];
}
function uP(t, e) {
  const { modelValueLocal: n, onEntering: r, onEnter: i, onLeaving: s, onLeave: a } = e, o = Se(n.value), [u, c, d] = A3(o.value), [l, f, p] = A3(o.value), m = de(() => typeof t.contentTransition == "string" ? { name: t.contentTransition, appear: !0 } : { appear: !0, ...t.contentTransition }), g = de(() => typeof t.overlayTransition == "string" ? { name: t.overlayTransition, appear: !0 } : { appear: !0, ...t.overlayTransition }), y = de(
    () => (t.hideOverlay || f.value === 2) && c.value === 2
    /* Leave */
  );
  Ct(
    y,
    (v) => {
      v && (o.value = !1);
    }
  ), Ct(c, (v) => {
    if (v === 1) {
      if (!o.value)
        return;
      r == null || r();
    } else if (v === 0) {
      if (!o.value)
        return;
      i == null || i();
    } else
      v === 3 ? s == null || s() : v === 2 && (a == null || a());
  });
  async function b() {
    o.value = !0, await ca(), u.value = !0, l.value = !0;
  }
  function E() {
    u.value = !1, l.value = !1;
  }
  return {
    visible: o,
    contentVisible: u,
    contentListeners: d,
    contentTransition: m,
    overlayVisible: l,
    overlayListeners: p,
    overlayTransition: g,
    enterTransition: b,
    leaveTransition: E
  };
}
function lP(t, e, n) {
  const { vfmRootEl: r, vfmContentEl: i, visible: s, modelValueLocal: a } = n, o = Se();
  function u() {
    s.value && t.escToClose && (a.value = !1);
  }
  function c(l) {
    o.value = l == null ? void 0 : l.target;
  }
  function d() {
    var l;
    o.value === r.value && (t.clickToClose ? a.value = !1 : ((l = i.value) == null || l.focus(), e("clickOutside")));
  }
  return {
    onEsc: u,
    onMouseupRoot: d,
    onMousedown: c
  };
}
function cP(t, e, n) {
  let r = !1;
  const { open: i, close: s } = n, a = Se(!1), o = {
    get value() {
      return a.value;
    },
    set value(c) {
      u(c);
    }
  };
  function u(c) {
    (c ? i() : s()) ? (a.value = c, c !== t.modelValue && e("update:modelValue", c)) : (r = !0, e("update:modelValue", !c), ca(() => {
      r = !1;
    }));
  }
  return Ct(() => t.modelValue, (c) => {
    r || (o.value = !!c);
  }), {
    modelValueLocal: o
  };
}
function dP(t, e) {
  if (t.focusTrap === !1)
    return {
      focus() {
      },
      blur() {
      }
    };
  const { focusEl: n } = e, { hasFocus: r, activate: i, deactivate: s } = sP(n, t.focusTrap);
  function a() {
    requestAnimationFrame(() => {
      i();
    });
  }
  function o() {
    r.value && s();
  }
  return { focus: a, blur: o };
}
let ev = !1;
if (typeof window < "u") {
  const t = {
    get passive() {
      ev = !0;
    }
  };
  window.addEventListener("testPassive", null, t), window.removeEventListener("testPassive", null, t);
}
const c6 = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
let To = [], Nm = !1, em = 0, d6 = -1, rf, sf;
const fP = (t) => {
  if (!t || t.nodeType !== Node.ELEMENT_NODE)
    return !1;
  const e = window.getComputedStyle(t);
  return ["auto", "scroll"].includes(e.overflowY) && t.scrollHeight > t.clientHeight;
}, hP = (t, e) => !(t.scrollTop === 0 && e < 0 || t.scrollTop + t.clientHeight + e >= t.scrollHeight && e > 0), pP = (t) => {
  const e = [];
  for (; t; ) {
    if (e.push(t), t.classList.contains("vfm"))
      return e;
    t = t.parentElement;
  }
  return e;
}, mP = (t, e) => {
  let n = !1;
  return pP(t).forEach((r) => {
    fP(r) && hP(r, e) && (n = !0);
  }), n;
}, f6 = (t) => To.some(() => mP(t, -em)), tv = (t) => {
  const e = t || window.event;
  return f6(e.target) || e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1);
}, gP = (t) => {
  if (sf === void 0) {
    const e = !!t && t.reserveScrollBarGap === !0, n = window.innerWidth - document.documentElement.clientWidth;
    if (e && n > 0) {
      const r = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
      sf = document.body.style.paddingRight, document.body.style.paddingRight = `${r + n}px`;
    }
  }
  rf === void 0 && (rf = document.body.style.overflow, document.body.style.overflow = "hidden");
}, AP = () => {
  sf !== void 0 && (document.body.style.paddingRight = sf, sf = void 0), rf !== void 0 && (document.body.style.overflow = rf, rf = void 0);
}, bP = (t) => t ? t.scrollHeight - t.scrollTop <= t.clientHeight : !1, yP = (t, e) => (em = t.targetTouches[0].clientY - d6, f6(t.target) ? !1 : e && e.scrollTop === 0 && em > 0 || bP(e) && em < 0 ? tv(t) : (t.stopPropagation(), !0)), vP = (t, e) => {
  if (!t) {
    console.error(
      "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
    );
    return;
  }
  if (To.some((r) => r.targetElement === t))
    return;
  const n = {
    targetElement: t,
    options: e || {}
  };
  To = [...To, n], c6 ? (t.ontouchstart = (r) => {
    r.targetTouches.length === 1 && (d6 = r.targetTouches[0].clientY);
  }, t.ontouchmove = (r) => {
    r.targetTouches.length === 1 && yP(r, t);
  }, Nm || (document.addEventListener("touchmove", tv, ev ? { passive: !1 } : void 0), Nm = !0)) : gP(e);
}, TP = (t) => {
  if (!t) {
    console.error(
      "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
    );
    return;
  }
  To = To.filter((e) => e.targetElement !== t), c6 ? (t.ontouchstart = null, t.ontouchmove = null, Nm && To.length === 0 && (document.removeEventListener("touchmove", tv, ev ? { passive: !1 } : void 0), Nm = !1)) : To.length || AP();
};
function _P(t, e) {
  const { lockScrollEl: n, modelValueLocal: r } = e;
  let i;
  Ct(n, (o) => {
    o && (i = o);
  }, { immediate: !0 }), Ct(() => t.lockScroll, (o) => {
    o ? a() : s();
  }), mi(() => {
    s();
  });
  function s() {
    i && TP(i);
  }
  function a() {
    r.value && t.lockScroll && i && vP(i, {
      reserveScrollBarGap: t.reserveScrollBarGap,
      allowTouchMove: (o) => {
        for (; o && o !== document.body; ) {
          if (o.getAttribute("vfm-scroll-lock-ignore") !== null)
            return !0;
          o = o.parentElement;
        }
        return !1;
      }
    });
  }
  return {
    enableBodyScroll: s,
    disableBodyScroll: a
  };
}
function EP(t) {
  const e = Se();
  function n(i) {
    var s;
    e.value = (s = t.zIndexFn) == null ? void 0 : s.call(t, { index: i <= -1 ? 0 : i });
  }
  function r() {
    e.value = void 0;
  }
  return {
    zIndex: e,
    refreshZIndex: n,
    resetZIndex: r
  };
}
const V1 = {
  beforeMount(t, { value: e }, { transition: n }) {
    t._vov = t.style.visibility === "hidden" ? "" : t.style.visibility, n && e ? n.beforeEnter(t) : yd(t, e);
  },
  mounted(t, { value: e }, { transition: n }) {
    n && e && n.enter(t);
  },
  updated(t, { value: e, oldValue: n }, { transition: r }) {
    !e != !n && (r ? e ? (r.beforeEnter(t), yd(t, !0), r.enter(t)) : r.leave(t, () => {
      yd(t, !1);
    }) : yd(t, e));
  },
  beforeUnmount(t, { value: e }) {
    yd(t, e);
  }
};
function yd(t, e) {
  t.style.visibility = e ? t._vov : "hidden";
}
const b3 = (t) => {
  if (t instanceof MouseEvent) {
    const { clientX: e, clientY: n } = t;
    return { x: e, y: n };
  } else {
    const { clientX: e, clientY: n } = t.targetTouches[0];
    return { x: e, y: n };
  }
};
function xP(t) {
  if (!t)
    return !1;
  let e = !1;
  const n = {
    get passive() {
      return e = !0, !1;
    }
  };
  return t.addEventListener("x", kf, n), t.removeEventListener("x", kf), e;
}
function wP(t, {
  threshold: e = 0,
  onSwipeStart: n,
  onSwipe: r,
  onSwipeEnd: i,
  passive: s = !0
}) {
  const a = ja({ x: 0, y: 0 }), o = ja({ x: 0, y: 0 }), u = de(() => a.x - o.x), c = de(() => a.y - o.y), { max: d, abs: l } = Math, f = de(
    () => d(l(u.value), l(c.value)) >= e
  ), p = Se(!1), m = de(() => f.value ? l(u.value) > l(c.value) ? u.value > 0 ? "left" : "right" : c.value > 0 ? "up" : "down" : "none"), g = (M, O) => {
    a.x = M, a.y = O;
  }, y = (M, O) => {
    o.x = M, o.y = O;
  };
  let b, E;
  function v(M) {
    b.capture && !b.passive && M.preventDefault();
    const { x: O, y: T } = b3(M);
    g(O, T), y(O, T), n == null || n(M), E = [
      ws(t, "mousemove", _, b),
      ws(t, "touchmove", _, b),
      ws(t, "mouseup", D, b),
      ws(t, "touchend", D, b),
      ws(t, "touchcancel", D, b)
    ];
  }
  function _(M) {
    const { x: O, y: T } = b3(M);
    y(O, T), !p.value && f.value && (p.value = !0), p.value && (r == null || r(M));
  }
  function D(M) {
    p.value && (i == null || i(M, m.value)), p.value = !1, E.forEach((O) => O());
  }
  let S = [];
  return Tr(() => {
    const M = xP(window == null ? void 0 : window.document);
    s ? b = M ? { passive: !0 } : { capture: !1 } : b = M ? { passive: !1, capture: !0 } : { capture: !0 }, S = [
      ws(t, "mousedown", v, b),
      ws(t, "touchstart", v, b)
    ];
  }), {
    isSwiping: p,
    direction: m,
    coordsStart: a,
    coordsEnd: o,
    lengthX: u,
    lengthY: c,
    stop: () => {
      S.forEach((M) => M()), E.forEach((M) => M());
    }
  };
}
function CP(t, e) {
  const { vfmContentEl: n, modelValueLocal: r } = e, i = 0.1, s = 300, a = Se(), o = de(() => {
    if (!(t.swipeToClose === void 0 || t.swipeToClose === "none"))
      return t.showSwipeBanner ? a.value : n.value;
  }), u = Se(0), c = Se(!0);
  let d = kf, l = !0, f, p = !1;
  const { lengthX: m, lengthY: g, direction: y, isSwiping: b } = wP(o, {
    threshold: t.threshold,
    onSwipeStart(D) {
      d = ws(document, "selectionchange", () => {
        var S;
        c.value = (S = window.getSelection()) == null ? void 0 : S.isCollapsed;
      }), f = (/* @__PURE__ */ new Date()).getTime(), p = _(D == null ? void 0 : D.target);
    },
    onSwipe() {
      var D, S, M, O;
      if (p && c.value && y.value === t.swipeToClose) {
        if (y.value === "up") {
          const T = ap(Math.abs(g.value || 0), 0, ((D = o.value) == null ? void 0 : D.offsetHeight) || 0) - (t.threshold || 0);
          u.value = T;
        } else if (y.value === "down") {
          const T = ap(Math.abs(g.value || 0), 0, ((S = o.value) == null ? void 0 : S.offsetHeight) || 0) - (t.threshold || 0);
          u.value = -T;
        } else if (y.value === "right") {
          const T = ap(Math.abs(m.value || 0), 0, ((M = o.value) == null ? void 0 : M.offsetWidth) || 0) - (t.threshold || 0);
          u.value = -T;
        } else if (y.value === "left") {
          const T = ap(Math.abs(m.value || 0), 0, ((O = o.value) == null ? void 0 : O.offsetWidth) || 0) - (t.threshold || 0);
          u.value = T;
        }
      }
    },
    onSwipeEnd(D, S) {
      if (d(), !c.value) {
        c.value = !0;
        return;
      }
      const M = (/* @__PURE__ */ new Date()).getTime(), O = S === t.swipeToClose, T = (() => {
        var H, $;
        if (S === "up" || S === "down")
          return Math.abs((g == null ? void 0 : g.value) || 0) > i * (((H = o.value) == null ? void 0 : H.offsetHeight) || 0);
        if (S === "left" || S === "right")
          return Math.abs((m == null ? void 0 : m.value) || 0) > i * ((($ = o.value) == null ? void 0 : $.offsetWidth) || 0);
      })(), N = M - f <= s;
      if (l && p && O && (T || N)) {
        r.value = !1;
        return;
      }
      u.value = 0;
    }
  }), E = de(() => {
    if (t.swipeToClose === "none")
      return;
    const D = (() => {
      switch (t.swipeToClose) {
        case "up":
        case "down":
          return "translateY";
        case "left":
        case "right":
          return "translateX";
      }
    })();
    return {
      class: { "vfm-bounce-back": !b.value },
      style: { transform: `${D}(${-u.value}px)` }
    };
  });
  Ct(
    () => c.value,
    (D) => {
      D || (u.value = 0);
    }
  ), Ct(
    () => r.value,
    (D) => {
      D && (u.value = 0);
    }
  ), Ct(
    () => u.value,
    (D, S) => {
      switch (t.swipeToClose) {
        case "down":
        case "right":
          l = D < S;
          break;
        case "up":
        case "left":
          l = D > S;
          break;
      }
    }
  );
  function v(D) {
    t.preventNavigationGestures && D.preventDefault();
  }
  function _(D) {
    const S = D == null ? void 0 : D.tagName;
    if (!S || ["INPUT", "TEXTAREA"].includes(S))
      return !1;
    const M = (() => {
      switch (t.swipeToClose) {
        case "up":
          return (D == null ? void 0 : D.scrollTop) + (D == null ? void 0 : D.clientHeight) === (D == null ? void 0 : D.scrollHeight);
        case "left":
          return (D == null ? void 0 : D.scrollLeft) + (D == null ? void 0 : D.clientWidth) === (D == null ? void 0 : D.scrollWidth);
        case "down":
          return (D == null ? void 0 : D.scrollTop) === 0;
        case "right":
          return (D == null ? void 0 : D.scrollLeft) === 0;
        default:
          return !1;
      }
    })();
    return D === o.value ? M : M && _(D == null ? void 0 : D.parentElement);
  }
  return {
    vfmContentEl: n,
    swipeBannerEl: a,
    bindSwipe: E,
    onTouchStartSwipeBanner: v
  };
}
const h6 = Symbol("vfm");
let uu;
const SP = (t) => uu = t, IP = {
  install: kf,
  modals: [],
  openedModals: [],
  openedModalOverlays: [],
  dynamicModals: [],
  modalsContainers: Se([]),
  get: () => {
  },
  toggle: () => {
  },
  open: () => {
  },
  close: () => {
  },
  closeAll: () => Promise.allSettled([])
}, kP = () => la() && pn(h6, IP) || uu;
function DP() {
  const t = ip([]), e = ip([]), n = ip([]), r = ip([]), i = Se([]), s = Vi({
    install(a) {
      a.provide(h6, s), a.config.globalProperties.$vfm = s;
    },
    modals: t,
    openedModals: e,
    openedModalOverlays: n,
    dynamicModals: r,
    modalsContainers: i,
    get(a) {
      return t.find((o) => {
        var u, c;
        return ((c = (u = af(o)) == null ? void 0 : u.value.modalId) == null ? void 0 : c.value) === a;
      });
    },
    toggle(a, o) {
      var u;
      const c = s.get(a);
      return (u = af(c)) == null ? void 0 : u.value.toggle(o);
    },
    open(a) {
      return s.toggle(a, !0);
    },
    close(a) {
      return s.toggle(a, !1);
    },
    closeAll() {
      return Promise.allSettled(
        e.reduce((a, o) => {
          const u = af(o), c = u == null ? void 0 : u.value.toggle(!1);
          return c && a.push(c), a;
        }, [])
      );
    }
  });
  return SP(s), s;
}
function af(t) {
  var e;
  return (e = t == null ? void 0 : t.exposed) == null ? void 0 : e.modalExposed;
}
const MP = Ze({ inheritAttrs: !1 }), pr = /* @__PURE__ */ Ze({
  ...MP,
  __name: "VueFinalModal",
  props: oP,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(t, { expose: e, emit: n }) {
    const r = t, i = n, s = o7(), a = la(), { modals: o, openedModals: u, openedModalOverlays: c } = $n(), d = Se(), l = Se(), { focus: f, blur: p } = dP(r, { focusEl: d }), { zIndex: m, refreshZIndex: g, resetZIndex: y } = EP(r), { modelValueLocal: b } = cP(r, i, { open: I, close: G }), { enableBodyScroll: E, disableBodyScroll: v } = _P(r, {
      lockScrollEl: d,
      modelValueLocal: b
    });
    let _ = kf;
    const {
      visible: D,
      contentVisible: S,
      contentListeners: M,
      contentTransition: O,
      overlayVisible: T,
      overlayListeners: N,
      overlayTransition: H,
      enterTransition: $,
      leaveTransition: j
    } = uP(r, {
      modelValueLocal: b,
      onEntering() {
        ca(() => {
          v(), f();
        });
      },
      onEnter() {
        i("opened"), _("opened");
      },
      onLeave() {
        qd(u, a), y(), E(), i("closed"), _("closed");
      }
    }), { onEsc: U, onMouseupRoot: V, onMousedown: B } = lP(r, i, { vfmRootEl: d, vfmContentEl: l, visible: D, modelValueLocal: b }), {
      swipeBannerEl: R,
      bindSwipe: K,
      onTouchStartSwipeBanner: Q
    } = CP(r, { vfmContentEl: l, modelValueLocal: b }), P = de(() => a ? u.indexOf(a) : -1);
    Ct([() => r.zIndexFn, P], () => {
      D.value && g(P.value);
    }), Tr(() => {
      q1(o, a);
    }), r.modelValue && (b.value = !0);
    function I() {
      let be = !1;
      return i("beforeOpen", { stop: () => be = !0 }), be ? !1 : (q1(u, a), q1(c, a), ee(), $(), !0);
    }
    function G() {
      let be = !1;
      return i("beforeClose", { stop: () => be = !0 }), be ? !1 : (qd(c, a), ee(), p(), j(), !0);
    }
    function te() {
      b.value = !1;
    }
    mi(() => {
      E(), qd(o, a), qd(u, a), p(), ee();
    });
    async function ee() {
      await ca();
      const be = c.filter((ve) => {
        var Ce;
        const Ne = af(ve);
        return (Ne == null ? void 0 : Ne.value.overlayBehavior.value) === "auto" && !((Ce = Ne == null ? void 0 : Ne.value.hideOverlay) != null && Ce.value);
      });
      be.forEach((ve, Ce) => {
        const Ne = af(ve);
        Ne != null && Ne.value && (Ne.value.overlayVisible.value = Ce === be.length - 1);
      });
    }
    const Z = Ii(() => r.modalId), ye = Ii(() => r.hideOverlay), he = Ii(() => r.overlayBehavior), Ee = de(() => ({
      modalId: Z,
      hideOverlay: ye,
      overlayBehavior: he,
      overlayVisible: T,
      toggle(be) {
        return new Promise((ve) => {
          _ = aP((Ne) => ve(Ne));
          const Ce = typeof be == "boolean" ? be : !b.value;
          b.value = Ce;
        });
      }
    }));
    return e({
      modalExposed: Ee
    }), (be, ve) => (X(), gt(u7, {
      to: be.teleportTo ? be.teleportTo : void 0,
      disabled: !be.teleportTo
    }, [
      be.displayDirective !== "if" || ke(D) ? Gt((X(), se("div", ea({ key: 0 }, ke(s), {
        ref_key: "vfmRootEl",
        ref: d,
        class: ["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": be.background === "interactive" }],
        style: { zIndex: ke(m) },
        role: "dialog",
        "aria-modal": "true",
        onKeydown: ve[7] || (ve[7] = lh(() => ke(U)(), ["esc"])),
        onMouseup: ve[8] || (ve[8] = ar(() => ke(V)(), ["self"])),
        onMousedown: ve[9] || (ve[9] = ar((Ce) => ke(B)(Ce), ["self"]))
      }), [
        ye.value ? Fe("", !0) : (X(), gt(Lu, ea({ key: 0 }, ke(H), c3(ke(N))), {
          default: Zt(() => [
            be.displayDirective !== "if" || ke(T) ? Gt((X(), se("div", {
              key: 0,
              class: vt(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", be.overlayClass]),
              style: Qt(be.overlayStyle),
              "aria-hidden": "true"
            }, null, 6)), [
              [Ra, be.displayDirective !== "show" || ke(T)],
              [ke(V1), be.displayDirective !== "visible" || ke(T)]
            ]) : Fe("", !0)
          ]),
          _: 1
        }, 16)),
        et(Lu, ea(ke(O), c3(ke(M))), {
          default: Zt(() => [
            be.displayDirective !== "if" || ke(S) ? Gt((X(), se("div", ea({
              key: 0,
              ref_key: "vfmContentEl",
              ref: l,
              class: ["vfm__content vfm--outline-none", [be.contentClass, { "vfm--prevent-auto": be.background === "interactive" }]],
              style: be.contentStyle,
              tabindex: "0"
            }, ke(K), {
              onMousedown: ve[6] || (ve[6] = () => ke(B)())
            }), [
              Jr(be.$slots, "default", Yy(YS({ close: te }))),
              be.showSwipeBanner ? (X(), se("div", {
                key: 0,
                ref_key: "swipeBannerEl",
                ref: R,
                class: "vfm-swipe-banner-container",
                onTouchstart: ve[2] || (ve[2] = (Ce) => ke(Q)(Ce))
              }, [
                Jr(be.$slots, "swipe-banner", {}, () => [
                  W("div", {
                    class: "vfm-swipe-banner-back",
                    onTouchstart: ve[0] || (ve[0] = (Ce) => be.swipeToClose === "left" && Ce.preventDefault())
                  }, null, 32),
                  W("div", {
                    class: "vfm-swipe-banner-forward",
                    onTouchstart: ve[1] || (ve[1] = (Ce) => be.swipeToClose === "right" && Ce.preventDefault())
                  }, null, 32)
                ])
              ], 544)) : !be.showSwipeBanner && be.preventNavigationGestures ? (X(), se("div", {
                key: 1,
                class: "vfm-swipe-banner-container",
                onTouchstart: ve[5] || (ve[5] = (Ce) => ke(Q)(Ce))
              }, [
                W("div", {
                  class: "vfm-swipe-banner-back",
                  onTouchstart: ve[3] || (ve[3] = (Ce) => be.swipeToClose === "left" && Ce.preventDefault())
                }, null, 32),
                W("div", {
                  class: "vfm-swipe-banner-forward",
                  onTouchstart: ve[4] || (ve[4] = (Ce) => be.swipeToClose === "right" && Ce.preventDefault())
                }, null, 32)
              ], 32)) : Fe("", !0)
            ], 16)), [
              [Ra, be.displayDirective !== "show" || ke(S)],
              [ke(V1), be.displayDirective !== "visible" || ke(S)]
            ]) : Fe("", !0)
          ]),
          _: 3
        }, 16)
      ], 16)), [
        [Ra, be.displayDirective !== "show" || ke(D)],
        [ke(V1), be.displayDirective !== "visible" || ke(D)]
      ]) : Fe("", !0)
    ], 8, ["to", "disabled"]));
  }
});
function $n() {
  const t = kP();
  if (!t)
    throw new Error(
      `[Vue Final Modal]: getActiveVfm was called with no active Vfm. Did you forget to install vfm?
	const vfm = createVfm()
	app.use(vfm)
This will fail in production.`
    );
  return t;
}
function y3(t, e = pr) {
  const { component: n, slots: r, ...i } = t, s = typeof r > "u" ? {} : Object.fromEntries(l6(r).map(([a, o]) => Jy(o) ? [a, o] : Lm(o) ? [a, {
    ...o,
    component: Vi(o.component)
  }] : [a, Vi(o)]));
  return {
    ...i,
    component: Vi(n || e),
    slots: s
  };
}
function Jn(t) {
  const e = ja({
    id: Symbol("useModal"),
    modelValue: !!(t != null && t.defaultModelValue),
    resolveOpened: () => {
    },
    resolveClosed: () => {
    },
    attrs: {},
    ...y3(t)
  });
  C7(() => {
    e != null && e.keepAlive || o();
  }), e.modelValue === !0 && (uu ? uu == null || uu.dynamicModals.push(e) : ca(() => {
    const u = $n();
    u == null || u.dynamicModals.push(e);
  }));
  async function n() {
    let u;
    return uu ? u = uu : (await ca(), u = $n()), e.modelValue ? Promise.resolve("[Vue Final Modal] modal is already opened.") : (o(), e.modelValue = !0, u.dynamicModals.push(e), new Promise((c) => {
      e.resolveOpened = () => c("opened");
    }));
  }
  function r() {
    return e.modelValue ? (e.modelValue = !1, new Promise((u) => {
      e.resolveClosed = () => u("closed");
    })) : Promise.resolve("[Vue Final Modal] modal is already closed.");
  }
  function i(u) {
    const { slots: c, ...d } = y3(u, e.component);
    u.defaultModelValue !== void 0 && (e.defaultModelValue = u.defaultModelValue), (u == null ? void 0 : u.keepAlive) !== void 0 && (e.keepAlive = u == null ? void 0 : u.keepAlive), s(e, d), c && l6(c).forEach(([l, f]) => {
      const p = e.slots[l];
      Jy(p) ? e.slots[l] = f : Lm(p) && Lm(f) ? s(p, f) : e.slots[l] = f;
    });
  }
  function s(u, c) {
    c.component && (u.component = c.component), c.attrs && a(u.attrs, c.attrs);
  }
  function a(u, c) {
    return Object.entries(c).forEach(([d, l]) => {
      u[d] = l;
    }), u;
  }
  function o() {
    const u = $n(), c = u.dynamicModals.indexOf(e);
    c !== -1 && u.dynamicModals.splice(c, 1);
  }
  return {
    options: e,
    open: n,
    close: r,
    patchOptions: i,
    destroy: o
  };
}
function Lm(t) {
  return typeof t == "object" && t !== null ? "component" in t : !1;
}
const OP = ["innerHTML"], aXe = /* @__PURE__ */ Ze({
  __name: "ModalsContainer",
  setup(t) {
    const { modalsContainers: e, dynamicModals: n } = $n(), r = Symbol("ModalsContainer"), i = de(() => {
      var o;
      return r === ((o = e.value) == null ? void 0 : o[0]);
    });
    e.value.push(r), mi(() => {
      e.value = e.value.filter((o) => o !== r);
    });
    function s(o) {
      var u, c, d;
      (c = (u = n[o]) == null ? void 0 : u.resolveClosed) == null || c.call(u), (d = n[o]) != null && d.keepAlive || n.splice(o, 1);
    }
    function a(o) {
      var u, c;
      (c = (u = n[o]) == null ? void 0 : u.resolveOpened) == null || c.call(u);
    }
    return (o, u) => i.value ? (X(!0), se(wt, { key: 0 }, on(ke(n), (c, d) => (X(), gt(xu(c.component), ea({
      key: c.id
    }, {
      displayDirective: c != null && c.keepAlive ? "show" : void 0,
      ...typeof c.attrs == "object" ? c.attrs : {}
    }, {
      modelValue: c.modelValue,
      "onUpdate:modelValue": (l) => c.modelValue = l,
      onClosed: () => s(d),
      onOpened: () => a(d)
    }), l7({ _: 2 }, [
      on(c.slots, (l, f) => ({
        name: f,
        fn: Zt(() => [
          ke(Jy)(l) ? (X(), se("div", {
            key: 0,
            innerHTML: l
          }, null, 8, OP)) : ke(Lm)(l) ? (X(), gt(xu(l.component), Yy(ea({ key: 1 }, l.attrs)), null, 16)) : (X(), gt(xu(l), { key: 2 }))
        ])
      }))
    ]), 1040, ["modelValue", "onUpdate:modelValue", "onClosed", "onOpened"]))), 128)) : Fe("", !0);
  }
}), H0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAExElEQVR4nO2bS4hcRRSGa4yOGkUMKKKiID6yUbIRH7iI7hSiQWV0IwYXtn2rbj9OtaMBF/+5PTPEGNQZIQufCxUkAQVFRIwustfBx8ZkY1ATVCRO8DE+xiinOyNOcuvenqT71u2Z+uBup/7+63XqnDNKBQKBQCAQCAQCPqjVpi6MbTKmCc9py3uM5a8M4bCxOGos/6otftCEWW35DU08bpq4fmxs9xq1kgEwGhMeEEM08d/G8j/L+3BIE+8wFteolQSA041lYwhfL9+UE79j5u6qNtrr1bCjW8mNhvizfhiTYtQfhniqVps5Uw0hI8Zyo/MjBmDOEqMsf6IJV6lhYWxs9xpD/PKgjVnyEQ7HzeQWVXYqlefP0MRv97hFvjGWd8aW7zfUvi7aum2drLxKBWvNOC6JKLlNbjBN+MBYLOT/PfwSUbJRlZgRQ3g1f7Z5b9xK7gBwWq9/uNKcvFjOG0OYy1lJczG1N6gyEls8ln1W4LuohXtOZYx6feoiiY1yTDpwbDWW7Lay+DNj+c9GduKyfo1nLGzWttMWb6kyxTna4tOMGX231dpxTr/H1YTbDfG8e9zkblUGIoLOWjmDMGcRicyztppE78onAEZdEbKcOfU6Lh+0Bk28PeOmfFj5JM6cweTe4kIL7E/XgS/ldlW+0N2XeOpVXqQOyQw4J6qR3Kx8pSy041UucU7BckbkyZG+1flZ5QPdxH2OZf2tj9yNthw5zsLPi9bSQZJdjmW9U3mgE213E27HT9hRL4Gjdpw/8rYqXMyiJuJ9pTmHjKRJU8RUW7hWeUIi6DRNEeFBD2L4pzQxjQbOV54wlmcc275RuBhN/FeaGHl6FC7mP02YdBj0RPFiLH5LE0P09NnKE8biKUdc9njxYoi/TxPzCE1eqjyhLV5yxEJR8WIIs6mz1cKtyhMSwTtis02Fi9GOxJUkzgoX03mTYa1r29fH21cXLkhLxTN9Oe/xknZpJnem6iE+6EOPknKwYzkvSFRbuB5XJYXwuvJW3rE45Lg1porUIulcZ3aR+CHlC92plafO2pwk2IvSYSxecGz3I7UazlO+qDba610pDznEi9AQE25wFgwIzyjfGMu7HNGrnEd2kGNXLC5wN0VgIW5NXKF8U+2uIkcNHgtSfRjEuNK0YAgfuieHZ1RZMFL1dAklnpfc9QCymR+5x8QBrXGuKgu17mx+nDGbEo9slwR7f1pqsnuNdDPZrMpG7dGJK7XFj9kmYb8k2E+m0iAlJE38oiuLcNw475Wyb6hKuEm6LHrq6bEc5QWUnU4Pi7skCNQWv+f93aEwKaJkY24XxtKtt88Qv6kJ09riSfk6UTHxXtfbauhNiqm9QQ7KU/lx/fpKa1K0dds6V464b5/cVs1ks5gwlCYJ0mXR/9XUaX2ZWbzK5ccPtUkARqWRwFmW6XW7WD4iz4e0CHnoTVpEalRSDjbEX6QX+k44xA9qy6/Jqzzv4bliTPr/OSWGmSZvkdKMJNfl65aRselk2ntXnEkD61uyeCfHpPe3AGep1QqCSfkEk3ogmNQD4eDun0nTajVTyzfpZ69Nn6U3iXh+Of9DsupM0hav+NZWNpOmZVvJyhFzSpXHLhFy5qzucycQCAQCgUBA9ca/01SgfkYyM0gAAAAASUVORK5CYII=", NP = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAAAsTAAALEwEAmpwYAAADnElEQVR4nM2ZX0hTYRTA1z8o6KEiooiiCCEqiCDqxTLopR6Dbnf3nO/u7l8XSvLBhx58UZo+JEEYmUYDzQ3MhCDC6bb2FqSNVIikt0gTaTMlMPpj+cU37/Squ/d+d5uuAwf2sLPz4/z7vu/M4ShQBEHYAADbZVneL0nSYUmSylwu115FUbY51lIkSdqJiJcB4C4ixhHxIwD8RERqpgAwAwAfEPEFANwihFwQBGFLUaBqa2vXI+IlDWjWCgY5lUEjYich5HQhETsFAMPFgkJj2OeiKO6zBQcAPgD4vdpwuKhTiHiOCw4Rr68hGNVF8ockSeVWaS1HxD+lAMR5TRNCduWEq6io2AgAIyWEo1okQ0Z1J5caDucB/yLikVy1N1BqOFyEvLcEThTFA4g4Z2VYV1dHn3Z306amJkoI4Xbodrvpo2CQPunqotXV1TyAE+yE0qdXtTIK1NfTVDpN05OTGY3H49Tlclk6U1WVDg0PL9h9Hh+nN6qqLO0IIcf16W2zMujp6VlwwgupLoPLamtrqyWgJEnX9ICDVgZt7e0rHKVNII3gmAYCAZ7SeKBP8TeeOnqTTHJBqiZwLBOctRvPwAmCsJW32D0eD33d35/TcSKRyED6/X46ODSU8zvRWIzKsszbySPZ9O7hBWTq8/kMI/kykTCOXCRiq/MRcTR7vJXZAcxGsn9gICdIoZHTRXA6A+h0Ok/YBbQDGc0DTtPZbIOczQeQBzKaP1xGFUXZzGrwTL4/4DdpCH3jFASYb4qt4NKFQ87m3SS8cOnCIKcygIqi7LZjaDaEe/v6uIe5lQLAJ9uDmkXu7eCgaUN4TBrHTiQB4L3+qJu2MvB6vdxD2GcyzGOxGNfABoCoHjBpZRAKhXI6jPT25nRoBtnQ0MATxfv620wwn+tWxADOCrKlpYUnglf1gF6e2/SXVMr22erz+WhSBzk6NkYrKyst7ZxO59EFQLbs0R4rpkY1NTU0HA7T242N3N2I8wOXNjc308cdHVy3ae2isG75o+mVHaerrHdyvequ/AdglC0ORFE8ZLTnW/VlEVpr0GEksiyfRMRfJYQbFwRhhyGgNhPdPG/kYisAzLAAmcLp6pHwbE+xeHATbB/psCOEkGNr0NlziBg23GhxRvM8ADxj+7sign1FxIdLhnGhwm49AHCRLcI14HfaZtSwqQDgOyKmtLO+EwBushu8qqqbigbGI8wh+yuCEHKQ7ZvZ5xUnQZ7yD8zfzl1rwXkSAAAAAElFTkSuQmCC";
function LP() {
  return p6().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function p6() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const PP = typeof Proxy == "function", RP = "devtools-plugin:setup", BP = "plugin:settings:set";
let vl, X2;
function FP() {
  var t;
  return vl !== void 0 || (typeof window < "u" && window.performance ? (vl = !0, X2 = window.performance) : typeof globalThis < "u" && (!((t = globalThis.perf_hooks) === null || t === void 0) && t.performance) ? (vl = !0, X2 = globalThis.perf_hooks.performance) : vl = !1), vl;
}
function UP() {
  return FP() ? X2.now() : Date.now();
}
class $P {
  constructor(e, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
    const r = {};
    if (e.settings)
      for (const a in e.settings) {
        const o = e.settings[a];
        r[a] = o.defaultValue;
      }
    const i = `__vue-devtools-plugin-settings__${e.id}`;
    let s = Object.assign({}, r);
    try {
      const a = localStorage.getItem(i), o = JSON.parse(a);
      Object.assign(s, o);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return s;
      },
      setSettings(a) {
        try {
          localStorage.setItem(i, JSON.stringify(a));
        } catch {
        }
        s = a;
      },
      now() {
        return UP();
      }
    }, n && n.on(BP, (a, o) => {
      a === this.plugin.id && this.fallbacks.setSettings(o);
    }), this.proxiedOn = new Proxy({}, {
      get: (a, o) => this.target ? this.target.on[o] : (...u) => {
        this.onQueue.push({
          method: o,
          args: u
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (a, o) => this.target ? this.target[o] : o === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(o) ? (...u) => (this.targetQueue.push({
        method: o,
        args: u,
        resolve: () => {
        }
      }), this.fallbacks[o](...u)) : (...u) => new Promise((c) => {
        this.targetQueue.push({
          method: o,
          args: u,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(e) {
    this.target = e;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function m6(t, e) {
  const n = t, r = p6(), i = LP(), s = PP && n.enableEarlyProxy;
  if (i && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
    i.emit(RP, t, e);
  else {
    const a = s ? new $P(n, i) : null;
    (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: e,
      proxy: a
    }), a && e(a.proxiedTarget);
  }
}
/*!
 * vuex v4.1.0
 * (c) 2022 Evan You
 * @license MIT
 */
var g6 = "store";
function Yt(t) {
  return t === void 0 && (t = null), pn(t !== null ? t : g6);
}
function Gu(t, e) {
  Object.keys(t).forEach(function(n) {
    return e(t[n], n);
  });
}
function HP(t) {
  return t !== null && typeof t == "object";
}
function jP(t) {
  return t && typeof t.then == "function";
}
function Ms(t, e) {
  if (!t)
    throw new Error("[vuex] " + e);
}
function zP(t, e) {
  return function() {
    return t(e);
  };
}
function A6(t, e, n) {
  return e.indexOf(t) < 0 && (n && n.prepend ? e.unshift(t) : e.push(t)), function() {
    var r = e.indexOf(t);
    r > -1 && e.splice(r, 1);
  };
}
function b6(t, e) {
  t._actions = /* @__PURE__ */ Object.create(null), t._mutations = /* @__PURE__ */ Object.create(null), t._wrappedGetters = /* @__PURE__ */ Object.create(null), t._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var n = t.state;
  j0(t, n, [], t._modules.root, !0), nv(t, n, e);
}
function nv(t, e, n) {
  var r = t._state, i = t._scope;
  t.getters = {}, t._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var s = t._wrappedGetters, a = {}, o = {}, u = XS(!0);
  u.run(function() {
    Gu(s, function(c, d) {
      a[d] = zP(c, t), o[d] = de(function() {
        return a[d]();
      }), Object.defineProperty(t.getters, d, {
        get: function() {
          return o[d].value;
        },
        enumerable: !0
        // for local getters
      });
    });
  }), t._state = ja({
    data: e
  }), t._scope = u, t.strict && GP(t), r && n && t._withCommit(function() {
    r.data = null;
  }), i && i.stop();
}
function j0(t, e, n, r, i) {
  var s = !n.length, a = t._modules.getNamespace(n);
  if (r.namespaced && (t._modulesNamespaceMap[a] && process.env.NODE_ENV !== "production" && console.error("[vuex] duplicate namespace " + a + " for the namespaced module " + n.join("/")), t._modulesNamespaceMap[a] = r), !s && !i) {
    var o = rv(e, n.slice(0, -1)), u = n[n.length - 1];
    t._withCommit(function() {
      process.env.NODE_ENV !== "production" && u in o && console.warn(
        '[vuex] state field "' + u + '" was overridden by a module with the same name at "' + n.join(".") + '"'
      ), o[u] = r.state;
    });
  }
  var c = r.context = qP(t, a, n);
  r.forEachMutation(function(d, l) {
    var f = a + l;
    VP(t, f, d, c);
  }), r.forEachAction(function(d, l) {
    var f = d.root ? l : a + l, p = d.handler || d;
    WP(t, f, p, c);
  }), r.forEachGetter(function(d, l) {
    var f = a + l;
    QP(t, f, d, c);
  }), r.forEachChild(function(d, l) {
    j0(t, e, n.concat(l), d, i);
  });
}
function qP(t, e, n) {
  var r = e === "", i = {
    dispatch: r ? t.dispatch : function(s, a, o) {
      var u = Pm(s, a, o), c = u.payload, d = u.options, l = u.type;
      if ((!d || !d.root) && (l = e + l, process.env.NODE_ENV !== "production" && !t._actions[l])) {
        console.error("[vuex] unknown local action type: " + u.type + ", global type: " + l);
        return;
      }
      return t.dispatch(l, c);
    },
    commit: r ? t.commit : function(s, a, o) {
      var u = Pm(s, a, o), c = u.payload, d = u.options, l = u.type;
      if ((!d || !d.root) && (l = e + l, process.env.NODE_ENV !== "production" && !t._mutations[l])) {
        console.error("[vuex] unknown local mutation type: " + u.type + ", global type: " + l);
        return;
      }
      t.commit(l, c, d);
    }
  };
  return Object.defineProperties(i, {
    getters: {
      get: r ? function() {
        return t.getters;
      } : function() {
        return y6(t, e);
      }
    },
    state: {
      get: function() {
        return rv(t.state, n);
      }
    }
  }), i;
}
function y6(t, e) {
  if (!t._makeLocalGettersCache[e]) {
    var n = {}, r = e.length;
    Object.keys(t.getters).forEach(function(i) {
      if (i.slice(0, r) === e) {
        var s = i.slice(r);
        Object.defineProperty(n, s, {
          get: function() {
            return t.getters[i];
          },
          enumerable: !0
        });
      }
    }), t._makeLocalGettersCache[e] = n;
  }
  return t._makeLocalGettersCache[e];
}
function VP(t, e, n, r) {
  var i = t._mutations[e] || (t._mutations[e] = []);
  i.push(function(a) {
    n.call(t, r.state, a);
  });
}
function WP(t, e, n, r) {
  var i = t._actions[e] || (t._actions[e] = []);
  i.push(function(a) {
    var o = n.call(t, {
      dispatch: r.dispatch,
      commit: r.commit,
      getters: r.getters,
      state: r.state,
      rootGetters: t.getters,
      rootState: t.state
    }, a);
    return jP(o) || (o = Promise.resolve(o)), t._devtoolHook ? o.catch(function(u) {
      throw t._devtoolHook.emit("vuex:error", u), u;
    }) : o;
  });
}
function QP(t, e, n, r) {
  if (t._wrappedGetters[e]) {
    process.env.NODE_ENV !== "production" && console.error("[vuex] duplicate getter key: " + e);
    return;
  }
  t._wrappedGetters[e] = function(s) {
    return n(
      r.state,
      // local state
      r.getters,
      // local getters
      s.state,
      // root state
      s.getters
      // root getters
    );
  };
}
function GP(t) {
  Ct(function() {
    return t._state.data;
  }, function() {
    process.env.NODE_ENV !== "production" && Ms(t._committing, "do not mutate vuex store state outside mutation handlers.");
  }, { deep: !0, flush: "sync" });
}
function rv(t, e) {
  return e.reduce(function(n, r) {
    return n[r];
  }, t);
}
function Pm(t, e, n) {
  return HP(t) && t.type && (n = e, e = t, t = t.type), process.env.NODE_ENV !== "production" && Ms(typeof t == "string", "expects string as the type, but found " + typeof t + "."), { type: t, payload: e, options: n };
}
var YP = "vuex bindings", v3 = "vuex:mutations", W1 = "vuex:actions", Tl = "vuex", XP = 0;
function KP(t, e) {
  m6(
    {
      id: "org.vuejs.vuex",
      app: t,
      label: "Vuex",
      homepage: "https://next.vuex.vuejs.org/",
      logo: "https://vuejs.org/images/icons/favicon-96x96.png",
      packageName: "vuex",
      componentStateTypes: [YP]
    },
    function(n) {
      n.addTimelineLayer({
        id: v3,
        label: "Vuex Mutations",
        color: T3
      }), n.addTimelineLayer({
        id: W1,
        label: "Vuex Actions",
        color: T3
      }), n.addInspector({
        id: Tl,
        label: "Vuex",
        icon: "storage",
        treeFilterPlaceholder: "Filter stores..."
      }), n.on.getInspectorTree(function(r) {
        if (r.app === t && r.inspectorId === Tl)
          if (r.filter) {
            var i = [];
            E6(i, e._modules.root, r.filter, ""), r.rootNodes = i;
          } else
            r.rootNodes = [
              _6(e._modules.root, "")
            ];
      }), n.on.getInspectorState(function(r) {
        if (r.app === t && r.inspectorId === Tl) {
          var i = r.nodeId;
          y6(e, i), r.state = eR(
            nR(e._modules, i),
            i === "root" ? e.getters : e._makeLocalGettersCache,
            i
          );
        }
      }), n.on.editInspectorState(function(r) {
        if (r.app === t && r.inspectorId === Tl) {
          var i = r.nodeId, s = r.path;
          i !== "root" && (s = i.split("/").filter(Boolean).concat(s)), e._withCommit(function() {
            r.set(e._state.data, s, r.state.value);
          });
        }
      }), e.subscribe(function(r, i) {
        var s = {};
        r.payload && (s.payload = r.payload), s.state = i, n.notifyComponentUpdate(), n.sendInspectorTree(Tl), n.sendInspectorState(Tl), n.addTimelineEvent({
          layerId: v3,
          event: {
            time: Date.now(),
            title: r.type,
            data: s
          }
        });
      }), e.subscribeAction({
        before: function(r, i) {
          var s = {};
          r.payload && (s.payload = r.payload), r._id = XP++, r._time = Date.now(), s.state = i, n.addTimelineEvent({
            layerId: W1,
            event: {
              time: r._time,
              title: r.type,
              groupId: r._id,
              subtitle: "start",
              data: s
            }
          });
        },
        after: function(r, i) {
          var s = {}, a = Date.now() - r._time;
          s.duration = {
            _custom: {
              type: "duration",
              display: a + "ms",
              tooltip: "Action duration",
              value: a
            }
          }, r.payload && (s.payload = r.payload), s.state = i, n.addTimelineEvent({
            layerId: W1,
            event: {
              time: Date.now(),
              title: r.type,
              groupId: r._id,
              subtitle: "end",
              data: s
            }
          });
        }
      });
    }
  );
}
var T3 = 8702998, ZP = 6710886, JP = 16777215, v6 = {
  label: "namespaced",
  textColor: JP,
  backgroundColor: ZP
};
function T6(t) {
  return t && t !== "root" ? t.split("/").slice(-2, -1)[0] : "Root";
}
function _6(t, e) {
  return {
    id: e || "root",
    // all modules end with a `/`, we want the last segment only
    // cart/ -> cart
    // nested/cart/ -> cart
    label: T6(e),
    tags: t.namespaced ? [v6] : [],
    children: Object.keys(t._children).map(
      function(n) {
        return _6(
          t._children[n],
          e + n + "/"
        );
      }
    )
  };
}
function E6(t, e, n, r) {
  r.includes(n) && t.push({
    id: r || "root",
    label: r.endsWith("/") ? r.slice(0, r.length - 1) : r || "Root",
    tags: e.namespaced ? [v6] : []
  }), Object.keys(e._children).forEach(function(i) {
    E6(t, e._children[i], n, r + i + "/");
  });
}
function eR(t, e, n) {
  e = n === "root" ? e : e[n];
  var r = Object.keys(e), i = {
    state: Object.keys(t.state).map(function(a) {
      return {
        key: a,
        editable: !0,
        value: t.state[a]
      };
    })
  };
  if (r.length) {
    var s = tR(e);
    i.getters = Object.keys(s).map(function(a) {
      return {
        key: a.endsWith("/") ? T6(a) : a,
        editable: !1,
        value: K2(function() {
          return s[a];
        })
      };
    });
  }
  return i;
}
function tR(t) {
  var e = {};
  return Object.keys(t).forEach(function(n) {
    var r = n.split("/");
    if (r.length > 1) {
      var i = e, s = r.pop();
      r.forEach(function(a) {
        i[a] || (i[a] = {
          _custom: {
            value: {},
            display: a,
            tooltip: "Module",
            abstract: !0
          }
        }), i = i[a]._custom.value;
      }), i[s] = K2(function() {
        return t[n];
      });
    } else
      e[n] = K2(function() {
        return t[n];
      });
  }), e;
}
function nR(t, e) {
  var n = e.split("/").filter(function(r) {
    return r;
  });
  return n.reduce(
    function(r, i, s) {
      var a = r[i];
      if (!a)
        throw new Error('Missing module "' + i + '" for path "' + e + '".');
      return s === n.length - 1 ? a : a._children;
    },
    e === "root" ? t : t.root._children
  );
}
function K2(t) {
  try {
    return t();
  } catch (e) {
    return e;
  }
}
var Bs = function(e, n) {
  this.runtime = n, this._children = /* @__PURE__ */ Object.create(null), this._rawModule = e;
  var r = e.state;
  this.state = (typeof r == "function" ? r() : r) || {};
}, x6 = { namespaced: { configurable: !0 } };
x6.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Bs.prototype.addChild = function(e, n) {
  this._children[e] = n;
};
Bs.prototype.removeChild = function(e) {
  delete this._children[e];
};
Bs.prototype.getChild = function(e) {
  return this._children[e];
};
Bs.prototype.hasChild = function(e) {
  return e in this._children;
};
Bs.prototype.update = function(e) {
  this._rawModule.namespaced = e.namespaced, e.actions && (this._rawModule.actions = e.actions), e.mutations && (this._rawModule.mutations = e.mutations), e.getters && (this._rawModule.getters = e.getters);
};
Bs.prototype.forEachChild = function(e) {
  Gu(this._children, e);
};
Bs.prototype.forEachGetter = function(e) {
  this._rawModule.getters && Gu(this._rawModule.getters, e);
};
Bs.prototype.forEachAction = function(e) {
  this._rawModule.actions && Gu(this._rawModule.actions, e);
};
Bs.prototype.forEachMutation = function(e) {
  this._rawModule.mutations && Gu(this._rawModule.mutations, e);
};
Object.defineProperties(Bs.prototype, x6);
var Yu = function(e) {
  this.register([], e, !1);
};
Yu.prototype.get = function(e) {
  return e.reduce(function(n, r) {
    return n.getChild(r);
  }, this.root);
};
Yu.prototype.getNamespace = function(e) {
  var n = this.root;
  return e.reduce(function(r, i) {
    return n = n.getChild(i), r + (n.namespaced ? i + "/" : "");
  }, "");
};
Yu.prototype.update = function(e) {
  w6([], this.root, e);
};
Yu.prototype.register = function(e, n, r) {
  var i = this;
  r === void 0 && (r = !0), process.env.NODE_ENV !== "production" && C6(e, n);
  var s = new Bs(n, r);
  if (e.length === 0)
    this.root = s;
  else {
    var a = this.get(e.slice(0, -1));
    a.addChild(e[e.length - 1], s);
  }
  n.modules && Gu(n.modules, function(o, u) {
    i.register(e.concat(u), o, r);
  });
};
Yu.prototype.unregister = function(e) {
  var n = this.get(e.slice(0, -1)), r = e[e.length - 1], i = n.getChild(r);
  if (!i) {
    process.env.NODE_ENV !== "production" && console.warn(
      "[vuex] trying to unregister module '" + r + "', which is not registered"
    );
    return;
  }
  i.runtime && n.removeChild(r);
};
Yu.prototype.isRegistered = function(e) {
  var n = this.get(e.slice(0, -1)), r = e[e.length - 1];
  return n ? n.hasChild(r) : !1;
};
function w6(t, e, n) {
  if (process.env.NODE_ENV !== "production" && C6(t, n), e.update(n), n.modules)
    for (var r in n.modules) {
      if (!e.getChild(r)) {
        process.env.NODE_ENV !== "production" && console.warn(
          "[vuex] trying to add a new module '" + r + "' on hot reloading, manual reload is needed"
        );
        return;
      }
      w6(
        t.concat(r),
        e.getChild(r),
        n.modules[r]
      );
    }
}
var _3 = {
  assert: function(t) {
    return typeof t == "function";
  },
  expected: "function"
}, rR = {
  assert: function(t) {
    return typeof t == "function" || typeof t == "object" && typeof t.handler == "function";
  },
  expected: 'function or object with "handler" function'
}, E3 = {
  getters: _3,
  mutations: _3,
  actions: rR
};
function C6(t, e) {
  Object.keys(E3).forEach(function(n) {
    if (e[n]) {
      var r = E3[n];
      Gu(e[n], function(i, s) {
        Ms(
          r.assert(i),
          iR(t, n, s, i, r.expected)
        );
      });
    }
  });
}
function iR(t, e, n, r, i) {
  var s = e + " should be " + i + ' but "' + e + "." + n + '"';
  return t.length > 0 && (s += ' in module "' + t.join(".") + '"'), s += " is " + JSON.stringify(r) + ".", s;
}
function sR(t) {
  return new Pi(t);
}
var Pi = function t(e) {
  var n = this;
  e === void 0 && (e = {}), process.env.NODE_ENV !== "production" && (Ms(typeof Promise < "u", "vuex requires a Promise polyfill in this browser."), Ms(this instanceof t, "store must be called with the new operator."));
  var r = e.plugins;
  r === void 0 && (r = []);
  var i = e.strict;
  i === void 0 && (i = !1);
  var s = e.devtools;
  this._committing = !1, this._actions = /* @__PURE__ */ Object.create(null), this._actionSubscribers = [], this._mutations = /* @__PURE__ */ Object.create(null), this._wrappedGetters = /* @__PURE__ */ Object.create(null), this._modules = new Yu(e), this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null), this._subscribers = [], this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null), this._scope = null, this._devtools = s;
  var a = this, o = this, u = o.dispatch, c = o.commit;
  this.dispatch = function(f, p) {
    return u.call(a, f, p);
  }, this.commit = function(f, p, m) {
    return c.call(a, f, p, m);
  }, this.strict = i;
  var d = this._modules.root.state;
  j0(this, d, [], this._modules.root), nv(this, d), r.forEach(function(l) {
    return l(n);
  });
}, iv = { state: { configurable: !0 } };
Pi.prototype.install = function(e, n) {
  e.provide(n || g6, this), e.config.globalProperties.$store = this;
  var r = this._devtools !== void 0 ? this._devtools : process.env.NODE_ENV !== "production" || !1;
  r && KP(e, this);
};
iv.state.get = function() {
  return this._state.data;
};
iv.state.set = function(t) {
  process.env.NODE_ENV !== "production" && Ms(!1, "use store.replaceState() to explicit replace store state.");
};
Pi.prototype.commit = function(e, n, r) {
  var i = this, s = Pm(e, n, r), a = s.type, o = s.payload, u = s.options, c = { type: a, payload: o }, d = this._mutations[a];
  if (!d) {
    process.env.NODE_ENV !== "production" && console.error("[vuex] unknown mutation type: " + a);
    return;
  }
  this._withCommit(function() {
    d.forEach(function(f) {
      f(o);
    });
  }), this._subscribers.slice().forEach(function(l) {
    return l(c, i.state);
  }), process.env.NODE_ENV !== "production" && u && u.silent && console.warn(
    "[vuex] mutation type: " + a + ". Silent option has been removed. Use the filter functionality in the vue-devtools"
  );
};
Pi.prototype.dispatch = function(e, n) {
  var r = this, i = Pm(e, n), s = i.type, a = i.payload, o = { type: s, payload: a }, u = this._actions[s];
  if (!u) {
    process.env.NODE_ENV !== "production" && console.error("[vuex] unknown action type: " + s);
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(d) {
      return d.before;
    }).forEach(function(d) {
      return d.before(o, r.state);
    });
  } catch (d) {
    process.env.NODE_ENV !== "production" && (console.warn("[vuex] error in before action subscribers: "), console.error(d));
  }
  var c = u.length > 1 ? Promise.all(u.map(function(d) {
    return d(a);
  })) : u[0](a);
  return new Promise(function(d, l) {
    c.then(function(f) {
      try {
        r._actionSubscribers.filter(function(p) {
          return p.after;
        }).forEach(function(p) {
          return p.after(o, r.state);
        });
      } catch (p) {
        process.env.NODE_ENV !== "production" && (console.warn("[vuex] error in after action subscribers: "), console.error(p));
      }
      d(f);
    }, function(f) {
      try {
        r._actionSubscribers.filter(function(p) {
          return p.error;
        }).forEach(function(p) {
          return p.error(o, r.state, f);
        });
      } catch (p) {
        process.env.NODE_ENV !== "production" && (console.warn("[vuex] error in error action subscribers: "), console.error(p));
      }
      l(f);
    });
  });
};
Pi.prototype.subscribe = function(e, n) {
  return A6(e, this._subscribers, n);
};
Pi.prototype.subscribeAction = function(e, n) {
  var r = typeof e == "function" ? { before: e } : e;
  return A6(r, this._actionSubscribers, n);
};
Pi.prototype.watch = function(e, n, r) {
  var i = this;
  return process.env.NODE_ENV !== "production" && Ms(typeof e == "function", "store.watch only accepts a function."), Ct(function() {
    return e(i.state, i.getters);
  }, n, Object.assign({}, r));
};
Pi.prototype.replaceState = function(e) {
  var n = this;
  this._withCommit(function() {
    n._state.data = e;
  });
};
Pi.prototype.registerModule = function(e, n, r) {
  r === void 0 && (r = {}), typeof e == "string" && (e = [e]), process.env.NODE_ENV !== "production" && (Ms(Array.isArray(e), "module path must be a string or an Array."), Ms(e.length > 0, "cannot register the root module by using registerModule.")), this._modules.register(e, n), j0(this, this.state, e, this._modules.get(e), r.preserveState), nv(this, this.state);
};
Pi.prototype.unregisterModule = function(e) {
  var n = this;
  typeof e == "string" && (e = [e]), process.env.NODE_ENV !== "production" && Ms(Array.isArray(e), "module path must be a string or an Array."), this._modules.unregister(e), this._withCommit(function() {
    var r = rv(n.state, e.slice(0, -1));
    delete r[e[e.length - 1]];
  }), b6(this);
};
Pi.prototype.hasModule = function(e) {
  return typeof e == "string" && (e = [e]), process.env.NODE_ENV !== "production" && Ms(Array.isArray(e), "module path must be a string or an Array."), this._modules.isRegistered(e);
};
Pi.prototype.hotUpdate = function(e) {
  this._modules.update(e), b6(this, !0);
};
Pi.prototype._withCommit = function(e) {
  var n = this._committing;
  this._committing = !0, e(), this._committing = n;
};
Object.defineProperties(Pi.prototype, iv);
const mn = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, aR = {}, oR = {
  viewBox: "0 0 50 50",
  xmlns: "http://www.w3.org/2000/svg",
  class: "text-zinc-600 dark:text-zinc-100"
};
function uR(t, e) {
  return X(), se("svg", oR, e[0] || (e[0] = [
    W("circle", {
      cx: "25",
      cy: "25",
      r: "23",
      class: "fill-zinc-100 dark:fill-zinc-600"
    }, null, -1),
    W("path", {
      d: `M33.71,32.29L26.42,25l7.29-7.29c0.39-0.39,0.39-1.03,0-1.42c-0.39-0.39-1.03-0.39-1.42,0L25,23.58l-7.29-7.29
        c-0.39-0.39-1.03-0.39-1.42,0c-0.39,0.39-0.39,1.03,0,1.42L23.58,25l-7.29,7.29c-0.39,0.39-0.39,1.03,0,1.42
        C16.49,33.9,16.74,34,17,34s0.51-0.1,0.71-0.29L25,26.42l7.29,7.29C32.49,33.9,32.74,34,33,34s0.51-0.1,0.71-0.29
        C34.1,33.32,34.1,32.68,33.71,32.29z`,
      class: "fill-current"
    }, null, -1)
  ]));
}
const Br = /* @__PURE__ */ mn(aR, [["render", uR]]), lR = { class: "relative" }, cR = ["src"], dR = {
  key: 1,
  class: "flex h-[300px] w-[300px] items-center justify-center bg-gray-200 text-[150px] font-semibold text-gray-500 dark:bg-zinc-600 dark:text-gray-300"
}, S6 = /* @__PURE__ */ Ze({
  __name: "AvatarModal",
  props: {
    url: {},
    name: {}
  },
  setup(t) {
    const e = $n(), n = t, r = Se(!1);
    r.value = n.url.length === 0;
    const i = () => {
      r.value = !0;
    };
    return (s, a) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl overflow-hidden flex flex-col gap-3 max-w-[360px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", lR, [
          W("button", {
            class: "absolute top-2 right-2 ml-auto flex items-center justify-center rounded-full",
            onClick: a[0] || (a[0] = (o) => ke(e).closeAll())
          }, [
            et(Br, { class: "h-7 w-7" })
          ]),
          r.value ? (X(), se("div", dR, _e(s.name && s.name.length > 0 ? s.name.charAt(0).toUpperCase() : ""), 1)) : (X(), se("img", {
            key: 0,
            src: s.url,
            class: "h-[300px] w-[300px] object-cover",
            onError: i
          }, null, 40, cR))
        ])
      ]),
      _: 1
    }));
  }
}), fR = ["src"], Zr = /* @__PURE__ */ Ze({
  __name: "AvatarView",
  props: {
    url: {},
    name: {}
  },
  setup(t) {
    const e = t, n = Se(!1);
    n.value = e.url.length === 0;
    const r = () => {
      n.value = !0;
    };
    Ct(
      () => [e.url, e.name],
      () => {
        n.value = !1;
      }
    );
    const i = () => {
      const { open: s } = Jn({
        component: S6,
        attrs: {
          url: e.url,
          name: e.name
        }
      });
      s();
    };
    return (s, a) => n.value ? (X(), se("div", {
      key: 1,
      class: "flex h-[50px] w-[50px] cursor-pointer items-center justify-center rounded-2xl bg-gray-200 text-xl font-semibold text-gray-500 dark:bg-zinc-600 dark:text-gray-300",
      onClick: ar(i, ["stop"])
    }, _e(s.name && s.name.length > 0 ? s.name.charAt(0).toUpperCase() : ""), 1)) : (X(), se("img", {
      key: 0,
      src: s.url,
      class: "cursor-pointer rounded-2xl bg-[#FFFFFF] object-cover",
      onError: r,
      onClick: ar(i, ["stop"])
    }, null, 40, fR));
  }
});
function x3(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function op(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? x3(Object(n), !0).forEach(function(r) {
      gR(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : x3(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function hR(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function pR(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
  }
}
function mR(t, e, n) {
  return e && pR(t.prototype, e), t;
}
function gR(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function AR(t) {
  return bR(t) || yR(t) || vR(t) || TR();
}
function bR(t) {
  if (Array.isArray(t)) return Z2(t);
}
function yR(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function vR(t, e) {
  if (t) {
    if (typeof t == "string") return Z2(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Z2(t, e);
  }
}
function Z2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function TR() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var _l = {
  FRONT: "FRONT",
  // scroll up or left
  BEHIND: "BEHIND"
  // scroll down or right
}, Xo = {
  INIT: "INIT",
  FIXED: "FIXED",
  DYNAMIC: "DYNAMIC"
}, w3 = 2, _R = /* @__PURE__ */ function() {
  function t(e, n) {
    hR(this, t), this.init(e, n);
  }
  return mR(t, [{
    key: "init",
    value: function(n, r) {
      this.param = n, this.callUpdate = r, this.sizes = /* @__PURE__ */ new Map(), this.firstRangeTotalSize = 0, this.firstRangeAverageSize = 0, this.lastCalcIndex = 0, this.fixedSizeValue = 0, this.calcType = Xo.INIT, this.offset = 0, this.direction = "", this.range = /* @__PURE__ */ Object.create(null), n && this.checkRange(0, n.keeps - 1);
    }
  }, {
    key: "destroy",
    value: function() {
      this.init(null, null);
    }
    // return current render range
  }, {
    key: "getRange",
    value: function() {
      var n = /* @__PURE__ */ Object.create(null);
      return n.start = this.range.start, n.end = this.range.end, n.padFront = this.range.padFront, n.padBehind = this.range.padBehind, n;
    }
  }, {
    key: "isBehind",
    value: function() {
      return this.direction === _l.BEHIND;
    }
  }, {
    key: "isFront",
    value: function() {
      return this.direction === _l.FRONT;
    }
    // return start index offset
  }, {
    key: "getOffset",
    value: function(n) {
      return (n < 1 ? 0 : this.getIndexOffset(n)) + this.param.slotHeaderSize;
    }
  }, {
    key: "updateParam",
    value: function(n, r) {
      var i = this;
      this.param && n in this.param && (n === "uniqueIds" && this.sizes.forEach(function(s, a) {
        r.includes(a) || i.sizes.delete(a);
      }), this.param[n] = r);
    }
    // save each size map by id
  }, {
    key: "saveSize",
    value: function(n, r) {
      this.sizes.set(n, r), this.calcType === Xo.INIT ? (this.fixedSizeValue = r, this.calcType = Xo.FIXED) : this.calcType === Xo.FIXED && this.fixedSizeValue !== r && (this.calcType = Xo.DYNAMIC, delete this.fixedSizeValue), this.calcType !== Xo.FIXED && typeof this.firstRangeTotalSize < "u" && (this.sizes.size < Math.min(this.param.keeps, this.param.uniqueIds.length) ? (this.firstRangeTotalSize = AR(this.sizes.values()).reduce(function(i, s) {
        return i + s;
      }, 0), this.firstRangeAverageSize = Math.round(this.firstRangeTotalSize / this.sizes.size)) : delete this.firstRangeTotalSize);
    }
    // in some special situation (e.g. length change) we need to update in a row
    // try goiong to render next range by a leading buffer according to current direction
  }, {
    key: "handleDataSourcesChange",
    value: function() {
      var n = this.range.start;
      this.isFront() ? n = n - w3 : this.isBehind() && (n = n + w3), n = Math.max(n, 0), this.updateRange(this.range.start, this.getEndByStart(n));
    }
    // when slot size change, we also need force update
  }, {
    key: "handleSlotSizeChange",
    value: function() {
      this.handleDataSourcesChange();
    }
    // calculating range on scroll
  }, {
    key: "handleScroll",
    value: function(n) {
      this.direction = n < this.offset ? _l.FRONT : _l.BEHIND, this.offset = n, this.param && (this.direction === _l.FRONT ? this.handleFront() : this.direction === _l.BEHIND && this.handleBehind());
    }
    // ----------- public method end -----------
  }, {
    key: "handleFront",
    value: function() {
      var n = this.getScrollOvers();
      if (!(n > this.range.start)) {
        var r = Math.max(n - this.param.buffer, 0);
        this.checkRange(r, this.getEndByStart(r));
      }
    }
  }, {
    key: "handleBehind",
    value: function() {
      var n = this.getScrollOvers();
      n < this.range.start + this.param.buffer || this.checkRange(n, this.getEndByStart(n));
    }
    // return the pass overs according to current scroll offset
  }, {
    key: "getScrollOvers",
    value: function() {
      var n = this.offset - this.param.slotHeaderSize;
      if (n <= 0)
        return 0;
      if (this.isFixedType())
        return Math.floor(n / this.fixedSizeValue);
      for (var r = 0, i = 0, s = 0, a = this.param.uniqueIds.length; r <= a; ) {
        if (i = r + Math.floor((a - r) / 2), s = this.getIndexOffset(i), s === n)
          return i;
        s < n ? r = i + 1 : s > n && (a = i - 1);
      }
      return r > 0 ? --r : 0;
    }
    // return a scroll offset from given index, can efficiency be improved more here?
    // although the call frequency is very high, its only a superposition of numbers
  }, {
    key: "getIndexOffset",
    value: function(n) {
      if (!n)
        return 0;
      for (var r = 0, i = 0, s = 0; s < n; s++)
        i = this.sizes.get(this.param.uniqueIds[s]), r = r + (typeof i == "number" ? i : this.getEstimateSize());
      return this.lastCalcIndex = Math.max(this.lastCalcIndex, n - 1), this.lastCalcIndex = Math.min(this.lastCalcIndex, this.getLastIndex()), r;
    }
    // is fixed size type
  }, {
    key: "isFixedType",
    value: function() {
      return this.calcType === Xo.FIXED;
    }
    // return the real last index
  }, {
    key: "getLastIndex",
    value: function() {
      return this.param.uniqueIds.length - 1;
    }
    // in some conditions range is broke, we need correct it
    // and then decide whether need update to next range
  }, {
    key: "checkRange",
    value: function(n, r) {
      var i = this.param.keeps, s = this.param.uniqueIds.length;
      s <= i ? (n = 0, r = this.getLastIndex()) : r - n < i - 1 && (n = r - i + 1), this.range.start !== n && this.updateRange(n, r);
    }
    // setting to a new range and rerender
  }, {
    key: "updateRange",
    value: function(n, r) {
      this.range.start = n, this.range.end = r, this.range.padFront = this.getPadFront(), this.range.padBehind = this.getPadBehind(), this.callUpdate(this.getRange());
    }
    // return end base on start
  }, {
    key: "getEndByStart",
    value: function(n) {
      var r = n + this.param.keeps - 1, i = Math.min(r, this.getLastIndex());
      return i;
    }
    // return total front offset
  }, {
    key: "getPadFront",
    value: function() {
      return this.isFixedType() ? this.fixedSizeValue * this.range.start : this.getIndexOffset(this.range.start);
    }
    // return total behind offset
  }, {
    key: "getPadBehind",
    value: function() {
      var n = this.range.end, r = this.getLastIndex();
      return this.isFixedType() ? (r - n) * this.fixedSizeValue : this.lastCalcIndex === r ? this.getIndexOffset(r) - this.getIndexOffset(n) : (r - n) * this.getEstimateSize();
    }
    // get the item estimate size
  }, {
    key: "getEstimateSize",
    value: function() {
      return this.isFixedType() ? this.fixedSizeValue : this.firstRangeAverageSize || this.param.estimateSize;
    }
  }]), t;
}(), ER = {
  dataKey: {
    type: [String, Function],
    required: !0
  },
  dataSources: {
    type: Array,
    required: !0,
    default: function() {
      return [];
    }
  },
  dataComponent: {
    type: [Object, Function],
    required: !0
  },
  keeps: {
    type: Number,
    default: 30
  },
  extraProps: {
    type: Object
  },
  estimateSize: {
    type: Number,
    default: 50
  },
  direction: {
    type: String,
    default: "vertical"
    // the other value is horizontal
  },
  start: {
    type: Number,
    default: 0
  },
  offset: {
    type: Number,
    default: 0
  },
  topThreshold: {
    type: Number,
    default: 0
  },
  bottomThreshold: {
    type: Number,
    default: 0
  },
  pageMode: {
    type: Boolean,
    default: !1
  },
  rootTag: {
    type: String,
    default: "div"
  },
  wrapTag: {
    type: String,
    default: "div"
  },
  wrapClass: {
    type: String,
    default: "wrap"
  },
  wrapStyle: {
    type: Object
  },
  itemTag: {
    type: String,
    default: "div"
  },
  itemClass: {
    type: String,
    default: ""
  },
  itemClassAdd: {
    type: Function
  },
  itemStyle: {
    type: Object
  },
  headerTag: {
    type: String,
    default: "div"
  },
  headerClass: {
    type: String,
    default: ""
  },
  headerStyle: {
    type: Object
  },
  footerTag: {
    type: String,
    default: "div"
  },
  footerClass: {
    type: String,
    default: ""
  },
  footerStyle: {
    type: Object
  },
  itemScopedSlots: {
    type: Object
  }
}, xR = {
  index: {
    type: Number
  },
  event: {
    type: String
  },
  tag: {
    type: String
  },
  horizontal: {
    type: Boolean
  },
  source: {
    type: Object
  },
  component: {
    type: [Object, Function]
  },
  uniqueKey: {
    type: [String, Number]
  },
  extraProps: {
    type: Object
  },
  scopedSlots: {
    type: Object
  }
}, wR = {
  event: {
    type: String
  },
  uniqueKey: {
    type: String
  },
  tag: {
    type: String
  },
  horizontal: {
    type: Boolean
  }
}, I6 = function(e, n, r) {
  var i = null, s = de(function() {
    return e.horizontal ? "offsetWidth" : "offsetHeight";
  }), a = function() {
    return n.value ? n.value[s.value] : 0;
  }, o = function() {
    var c = e.event, d = e.uniqueKey, l = e.hasInitial;
    r(c, d, a(), l);
  };
  Tr(function() {
    typeof ResizeObserver < "u" && (i = new ResizeObserver(function() {
      o();
    }), n.value && i.observe(n.value));
  }), d7(function() {
    o();
  }), Dc(function() {
    i && (i.disconnect(), i = null);
  });
}, CR = Ze({
  name: "VirtualListItem",
  props: xR,
  emits: ["itemResize"],
  setup: function(e, n) {
    var r = n.emit, i = Se(null);
    return I6(e, i, r), function() {
      var s = e.tag, a = e.component, o = e.extraProps, u = o === void 0 ? {} : o, c = e.index, d = e.source, l = e.scopedSlots, f = l === void 0 ? {} : l, p = e.uniqueKey, m = op(op({}, u), {}, {
        source: d,
        index: c
      });
      return et(s, {
        key: p,
        ref: i
      }, {
        default: function() {
          return [et(a, op(op({}, m), {}, {
            scopedSlots: f
          }), null)];
        }
      });
    };
  }
}), C3 = Ze({
  name: "VirtualListSlot",
  props: wR,
  emits: ["slotResize"],
  setup: function(e, n) {
    var r = n.slots, i = n.emit, s = Se(null);
    return I6(e, s, i), function() {
      var a, o = e.tag, u = e.uniqueKey;
      return et(o, {
        ref: s,
        key: u
      }, {
        default: function() {
          return [(a = r.default) === null || a === void 0 ? void 0 : a.call(r)];
        }
      });
    };
  }
}), of;
(function(t) {
  t.ITEM = "itemResize", t.SLOT = "slotResize";
})(of || (of = {}));
var Ll;
(function(t) {
  t.HEADER = "thead", t.FOOTER = "tfoot";
})(Ll || (Ll = {}));
var z0 = Ze({
  name: "VirtualList",
  props: ER,
  setup: function(e, n) {
    var r = n.emit, i = n.slots, s = n.expose, a = e.direction === "horizontal", o = a ? "scrollLeft" : "scrollTop", u = Se(null), c = Se(), d = Se(null), l;
    Ct(function() {
      return e.dataSources.length;
    }, function() {
      l.updateParam("uniqueIds", E()), l.handleDataSourcesChange();
    }), Ct(function() {
      return e.keeps;
    }, function(j) {
      l.updateParam("keeps", j), l.handleSlotSizeChange();
    }), Ct(function() {
      return e.start;
    }, function(j) {
      D(j);
    }), Ct(function() {
      return e.offset;
    }, function(j) {
      return S(j);
    });
    var f = function(U) {
      return l.sizes.get(U);
    }, p = function() {
      return e.pageMode ? document.documentElement[o] || document.body[o] : c.value ? Math.ceil(c.value[o]) : 0;
    }, m = function() {
      var U = a ? "clientWidth" : "clientHeight";
      return e.pageMode ? document.documentElement[U] || document.body[U] : c.value ? Math.ceil(c.value[U]) : 0;
    }, g = function() {
      var U = a ? "scrollWidth" : "scrollHeight";
      return e.pageMode ? document.documentElement[U] || document.body[U] : c.value ? Math.ceil(c.value[U]) : 0;
    }, y = function(U, V, B, R) {
      r("scroll", R, l.getRange()), l.isFront() && e.dataSources.length && U - e.topThreshold <= 0 ? r("totop") : l.isBehind() && U + V + e.bottomThreshold >= B && r("tobottom");
    }, b = function(U) {
      var V = p(), B = m(), R = g();
      V < 0 || V + B > R + 1 || !R || (l.handleScroll(V), y(V, B, R, U));
    }, E = function() {
      var U = e.dataKey, V = e.dataSources, B = V === void 0 ? [] : V;
      return B.map(function(R) {
        return typeof U == "function" ? U(R) : R[U];
      });
    }, v = function(U) {
      u.value = U;
    }, _ = function() {
      l = new _R({
        slotHeaderSize: 0,
        slotFooterSize: 0,
        keeps: e.keeps,
        estimateSize: e.estimateSize,
        buffer: Math.round(e.keeps / 3),
        // recommend for a third of keeps
        uniqueIds: E()
      }, v), u.value = l.getRange();
    }, D = function(U) {
      if (U >= e.dataSources.length - 1)
        N();
      else {
        var V = l.getOffset(U);
        S(V);
      }
    }, S = function(U) {
      e.pageMode ? (document.body[o] = U, document.documentElement[o] = U) : c.value && (c.value[o] = U);
    }, M = function() {
      for (var U = [], V = u.value, B = V.start, R = V.end, K = e.dataSources, Q = e.dataKey, P = e.itemClass, I = e.itemTag, G = e.itemStyle, te = e.extraProps, ee = e.dataComponent, Z = e.itemScopedSlots, ye = B; ye <= R; ye++) {
        var he = K[ye];
        if (he) {
          var Ee = typeof Q == "function" ? Q(he) : he[Q];
          typeof Ee == "string" || typeof Ee == "number" ? U.push(et(CR, {
            index: ye,
            tag: I,
            event: of.ITEM,
            horizontal: a,
            uniqueKey: Ee,
            source: he,
            extraProps: te,
            component: ee,
            scopedSlots: Z,
            style: G,
            class: "".concat(P).concat(e.itemClassAdd ? " " + e.itemClassAdd(ye) : ""),
            onItemResize: O
          }, null)) : console.warn("Cannot get the data-key '".concat(Q, "' from data-sources."));
        } else
          console.warn("Cannot get the index '".concat(ye, "' from data-sources."));
      }
      return U;
    }, O = function(U, V) {
      l.saveSize(U, V), r("resized", U, V);
    }, T = function(U, V, B) {
      U === Ll.HEADER ? l.updateParam("slotHeaderSize", V) : U === Ll.FOOTER && l.updateParam("slotFooterSize", V), B && l.handleSlotSizeChange();
    }, N = function j() {
      if (d.value) {
        var U = d.value[a ? "offsetLeft" : "offsetTop"];
        S(U), setTimeout(function() {
          p() + m() < g() && j();
        }, 3);
      }
    }, H = function() {
      if (c.value) {
        var U = c.value.getBoundingClientRect(), V = c.value.ownerDocument.defaultView, B = a ? U.left + V.pageXOffset : U.top + V.pageYOffset;
        l.updateParam("slotHeaderSize", B);
      }
    }, $ = function() {
      return l.sizes.size;
    };
    return Xy(function() {
      _();
    }), c7(function() {
      S(l.offset);
    }), Tr(function() {
      e.start ? D(e.start) : e.offset && S(e.offset), e.pageMode && (H(), document.addEventListener("scroll", b, {
        passive: !1
      }));
    }), Dc(function() {
      l.destroy(), e.pageMode && document.removeEventListener("scroll", b);
    }), s({
      scrollToBottom: N,
      getSizes: $,
      getSize: f,
      getOffset: p,
      getScrollSize: g,
      getClientSize: m,
      scrollToOffset: S,
      scrollToIndex: D
    }), function() {
      var j = e.pageMode, U = e.rootTag, V = e.wrapTag, B = e.wrapClass, R = e.wrapStyle, K = e.headerTag, Q = e.headerClass, P = e.headerStyle, I = e.footerTag, G = e.footerClass, te = e.footerStyle, ee = u.value, Z = ee.padFront, ye = ee.padBehind, he = {
        padding: a ? "0px ".concat(ye, "px 0px ").concat(Z, "px") : "".concat(Z, "px 0px ").concat(ye, "px")
      }, Ee = R ? Object.assign({}, R, he) : he, be = i.header, ve = i.footer;
      return et(U, {
        ref: c,
        onScroll: !j && b
      }, {
        default: function() {
          return [be && et(C3, {
            class: Q,
            style: P,
            tag: K,
            event: of.SLOT,
            uniqueKey: Ll.HEADER,
            onSlotResize: T
          }, {
            default: function() {
              return [be()];
            }
          }), et(V, {
            class: B,
            style: Ee
          }, {
            default: function() {
              return [M()];
            }
          }), ve && et(C3, {
            class: G,
            style: te,
            tag: I,
            event: of.SLOT,
            uniqueKey: Ll.FOOTER,
            onSlotResize: T
          }, {
            default: function() {
              return [ve()];
            }
          }), et("div", {
            ref: d,
            style: {
              width: a ? "0px" : "100%",
              height: a ? "100%" : "0px"
            }
          }, null)];
        }
      });
    };
  }
});
const S3 = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M16.875%205H3.125'%20stroke='%234D5562'%20stroke-width='1.15'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M8.125%208.75V13.75'%20stroke='%234D5562'%20stroke-width='1.15'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M11.875%208.75V13.75'%20stroke='%234D5562'%20stroke-width='1.15'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15.625%205V16.875C15.625%2017.0408%2015.5592%2017.1997%2015.4419%2017.3169C15.3247%2017.4342%2015.1658%2017.5%2015%2017.5H5C4.83424%2017.5%204.67527%2017.4342%204.55806%2017.3169C4.44085%2017.1997%204.375%2017.0408%204.375%2016.875V5'%20stroke='%234D5562'%20stroke-width='1.15'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.125%205V3.75C13.125%203.41848%2012.9933%203.10054%2012.7589%202.86612C12.5245%202.6317%2012.2065%202.5%2011.875%202.5H8.125C7.79348%202.5%207.47554%202.6317%207.24112%202.86612C7.0067%203.10054%206.875%203.41848%206.875%203.75V5'%20stroke='%234D5562'%20stroke-width='1.15'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", SR = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3csvg%20id='Layer'%20height='512'%20viewBox='0%200%2024%2024'%20width='512'%20version='1.1'%20sodipodi:docname='unsend-message.svg'%20inkscape:version='1.2%20(dc2aeda,%202022-05-15)'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3cdefs%20id='defs1053'%20/%3e%3csodipodi:namedview%20id='namedview1051'%20pagecolor='%23ffffff'%20bordercolor='%23000000'%20borderopacity='0.25'%20inkscape:showpageshadow='2'%20inkscape:pageopacity='0.0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23d1d1d1'%20showgrid='false'%20inkscape:zoom='1.7128906'%20inkscape:cx='256'%20inkscape:cy='256.58381'%20inkscape:window-width='1390'%20inkscape:window-height='847'%20inkscape:window-x='1828'%20inkscape:window-y='70'%20inkscape:window-maximized='0'%20inkscape:current-layer='Layer'%20/%3e%3cpath%20id='chat-dots-times'%20d='m13.745%2020.847a.749.749%200%200%201%20-.654.835%209.688%209.688%200%200%201%20-5.165-.835%201.189%201.189%200%200%200%20-.875-.025l-2.489.836a1.77%201.77%200%200%201%20-.557.091%201.76%201.76%200%200%201%20-1.664-2.308l.841-2.5a1.181%201.181%200%200%200%20-.027-.858%209.746%209.746%200%201%201%2018.595-4.083%208.936%208.936%200%200%201%20-.065%201.09.75.75%200%201%201%20-1.489-.181%207.585%207.585%200%200%200%20.054-.909%208.249%208.249%200%201%200%20-15.737%203.442%202.68%202.68%200%200%201%20.094%201.963l-.843%202.512a.24.24%200%200%200%20.064.255.244.244%200%200%200%20.257.064l2.5-.839a2.681%202.681%200%200%201%201.981.093%208.159%208.159%200%200%200%204.347.7.756.756%200%200%201%20.832.657zm7.785-4.377a.749.749%200%200%200%20-1.06%200l-1.47%201.469-1.47-1.469a.75.75%200%200%200%20-1.06%201.06l1.469%201.47-1.469%201.47a.75.75%200%201%200%201.06%201.06l1.47-1.469%201.47%201.469a.75.75%200%200%200%201.06-1.06l-1.469-1.47%201.469-1.47a.749.749%200%200%200%200-1.06zm-9.52-5.47a1.005%201.005%200%201%200%20.01%200zm5.01%201a1%201%200%200%200%20-1-1h-.01a1%201%200%201%200%201.01%201zm-9.01-1a1.005%201.005%200%201%200%20.01%200z'%20fill='rgb(0,0,0)'%20style='fill:%234b5563;fill-opacity:1'%20/%3e%3c/svg%3e", I3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6UlEQVR4nO2ZS0oDQRCGBwT1AD5AfN1E0KhJV1QSuzSuYqqCiOBar6AHiBHBA3gLieglfIsLcRPduFBQesKYjijCTLckWB/MIh3yd1X13wn8CQJBEP4vs8vFcUDaB6Q7hfwGyO9xHxV+nu4AqaryNOa9+OwizSjk5yRFw0+P5idYKqW8Tt5b8dhsIotro14aaNgmOnq6zGB5EhG7k2giYnd2kaZA89Wntua9wAcNrzY2McW71M6aJprDuXEjurLWB8hH0Wv7wiad/FeMnn2xg6TMFXgQkC+MYLRmezXwALjUV0iHX8U6qwFNjx3dAHwjJg38AsgJWIiFYgBiIQuxUAxALGQhFooBiIUsxEIxALGQhVgoBiAW+mUaHZVKqNZiu8I1zbe+ciFYKqWsoV0nFlSa7yPB+QINhZsgVa0I8Mps6iKZyyBPtyRzSJXkDSDXmsVSIVzL01gYwPrMRpHqTrJRhbxtebLWctTemqC6iRgDFywsr46A5pdm4Eob0XtmQuaYTYbp4v8BFepQxXkqDci71nRe7SY6golisRc0nbVMTdOJwvJKOlcejr6d2prp3PqAQj71eHGPvDeRTm/2KKQd+044eTSdmwg/+CvCi420BZqPze9E/AtMD4B0kMZS/58VLwhC0FZ8ALiaxMwFZ/dcAAAAAElFTkSuQmCC", k3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAACEElEQVR4nO2Xu4sUQRCHC8HHJYqgiAgmXqKpkQgqIjjTtRss9m/v9MBzqpbB9TA08MUECv4DcslhaCSYGZkoCAZiYCCoaGRwoKKooIi6K+OB2w4LB+exsyX9wUQzDPV1PbqbKBKpj2RmZqOD3GpCJ8li8OzlIUP7DF1MkO0ho8H3GdpzkFNkNfgUnTmyQBKDr4kkrnxNJP/ZyveHPl7eM+Q1Qx8x5KaDXuRjeujg7OyGWgUcZL4SbG9Zmb/E9Kvzcoe9TAOYGN8MYPnHQT8w9ErjeL6lbokeQ7vhN3yiu5lxckfa1v0OmbKX6wx9OlxEPjP0cpKcXT9WEsNoIN/JkAsMfTYkIy9cWw7QuEuUFEWxhpG1nNfHFYkfzsul8v3YS5SUgaZeOw76riJye2QT618lSprTuo293q1MrPtHkG8iKxJLZSVXK5m4V2smVnIfSNGZc15+huVUV08suindvZL/NCCnK+V0nqzdiRlybSAh38s9hSxRlD0RNraX5yPd7FaDo618+9LBsIZSWi0Y2g0EPpbHFLJWSg7y5M9U8lKQNRyydiDw1lwvFL8bWl4OplLWIms4L0W4uZE1mtDJQODT3jxfS9bgoIwakH1kDYYsBDe5c2QN5+XMYBrpDbJGis7h4GjxgKyRTOW7glPqK7JGgmxrIPCGrAFgIhilX8gaANYFAt/IGogCkUgkQiPgF1+GFsoZdsMBAAAAAElFTkSuQmCC";
var vn;
(function(t) {
  t.Root = "root", t.Text = "text", t.Directive = "directive", t.Comment = "comment", t.Script = "script", t.Style = "style", t.Tag = "tag", t.CDATA = "cdata", t.Doctype = "doctype";
})(vn || (vn = {}));
function IR(t) {
  return t.type === vn.Tag || t.type === vn.Script || t.type === vn.Style;
}
const sv = vn.Root, k6 = vn.Text, kR = vn.Directive, D6 = vn.Comment, DR = vn.Script, MR = vn.Style, J2 = vn.Tag, OR = vn.CDATA, NR = vn.Doctype;
let M6 = class {
  constructor() {
    this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(e) {
    this.parent = e;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(e) {
    this.prev = e;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(e) {
    this.next = e;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(e = !1) {
    return Mf(this, e);
  }
};
class av extends M6 {
  /**
   * @param data The content of the data node
   */
  constructor(e) {
    super(), this.data = e;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(e) {
    this.data = e;
  }
}
class Df extends av {
  constructor() {
    super(...arguments), this.type = vn.Text;
  }
  get nodeType() {
    return 3;
  }
}
class ov extends av {
  constructor() {
    super(...arguments), this.type = vn.Comment;
  }
  get nodeType() {
    return 8;
  }
}
class uv extends av {
  constructor(e, n) {
    super(n), this.name = e, this.type = vn.Directive;
  }
  get nodeType() {
    return 1;
  }
}
class lv extends M6 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(e) {
    super(), this.children = e;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var e;
    return (e = this.children[0]) !== null && e !== void 0 ? e : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(e) {
    this.children = e;
  }
}
class O6 extends lv {
  constructor() {
    super(...arguments), this.type = vn.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
let Ru = class extends lv {
  constructor() {
    super(...arguments), this.type = vn.Root;
  }
  get nodeType() {
    return 9;
  }
}, cv = class extends lv {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(e, n, r = [], i = e === "script" ? vn.Script : e === "style" ? vn.Style : vn.Tag) {
    super(r), this.name = e, this.attribs = n, this.type = i;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(e) {
    this.name = e;
  }
  get attributes() {
    return Object.keys(this.attribs).map((e) => {
      var n, r;
      return {
        name: e,
        value: this.attribs[e],
        namespace: (n = this["x-attribsNamespace"]) === null || n === void 0 ? void 0 : n[e],
        prefix: (r = this["x-attribsPrefix"]) === null || r === void 0 ? void 0 : r[e]
      };
    });
  }
};
function Lt(t) {
  return IR(t);
}
function q0(t) {
  return t.type === vn.CDATA;
}
function sa(t) {
  return t.type === vn.Text;
}
function V0(t) {
  return t.type === vn.Comment;
}
function eb(t) {
  return t.type === vn.Directive;
}
function Lo(t) {
  return t.type === vn.Root;
}
function hr(t) {
  return Object.prototype.hasOwnProperty.call(t, "children");
}
function Mf(t, e = !1) {
  let n;
  if (sa(t))
    n = new Df(t.data);
  else if (V0(t))
    n = new ov(t.data);
  else if (Lt(t)) {
    const r = e ? Q1(t.children) : [], i = new cv(t.name, { ...t.attribs }, r);
    r.forEach((s) => s.parent = i), t.namespace != null && (i.namespace = t.namespace), t["x-attribsNamespace"] && (i["x-attribsNamespace"] = { ...t["x-attribsNamespace"] }), t["x-attribsPrefix"] && (i["x-attribsPrefix"] = { ...t["x-attribsPrefix"] }), n = i;
  } else if (q0(t)) {
    const r = e ? Q1(t.children) : [], i = new O6(r);
    r.forEach((s) => s.parent = i), n = i;
  } else if (Lo(t)) {
    const r = e ? Q1(t.children) : [], i = new Ru(r);
    r.forEach((s) => s.parent = i), t["x-mode"] && (i["x-mode"] = t["x-mode"]), n = i;
  } else if (eb(t)) {
    const r = new uv(t.name, t.data);
    t["x-name"] != null && (r["x-name"] = t["x-name"], r["x-publicId"] = t["x-publicId"], r["x-systemId"] = t["x-systemId"]), n = r;
  } else
    throw new Error(`Not implemented yet: ${t.type}`);
  return n.startIndex = t.startIndex, n.endIndex = t.endIndex, t.sourceCodeLocation != null && (n.sourceCodeLocation = t.sourceCodeLocation), n;
}
function Q1(t) {
  const e = t.map((n) => Mf(n, !0));
  for (let n = 1; n < e.length; n++)
    e[n].prev = e[n - 1], e[n - 1].next = e[n];
  return e;
}
const D3 = {
  withStartIndices: !1,
  withEndIndices: !1,
  xmlMode: !1
};
class LR {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(e, n, r) {
    this.dom = [], this.root = new Ru(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof n == "function" && (r = n, n = D3), typeof e == "object" && (n = e, e = void 0), this.callback = e ?? null, this.options = n ?? D3, this.elementCB = r ?? null;
  }
  onparserinit(e) {
    this.parser = e;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [], this.root = new Ru(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
  }
  onerror(e) {
    this.handleCallback(e);
  }
  onclosetag() {
    this.lastNode = null;
    const e = this.tagStack.pop();
    this.options.withEndIndices && (e.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(e);
  }
  onopentag(e, n) {
    const r = this.options.xmlMode ? vn.Tag : void 0, i = new cv(e, n, void 0, r);
    this.addNode(i), this.tagStack.push(i);
  }
  ontext(e) {
    const { lastNode: n } = this;
    if (n && n.type === vn.Text)
      n.data += e, this.options.withEndIndices && (n.endIndex = this.parser.endIndex);
    else {
      const r = new Df(e);
      this.addNode(r), this.lastNode = r;
    }
  }
  oncomment(e) {
    if (this.lastNode && this.lastNode.type === vn.Comment) {
      this.lastNode.data += e;
      return;
    }
    const n = new ov(e);
    this.addNode(n), this.lastNode = n;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const e = new Df(""), n = new O6([e]);
    this.addNode(n), e.parent = n, this.lastNode = e;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(e, n) {
    const r = new uv(e, n);
    this.addNode(r);
  }
  handleCallback(e) {
    if (typeof this.callback == "function")
      this.callback(e, this.dom);
    else if (e)
      throw e;
  }
  addNode(e) {
    const n = this.tagStack[this.tagStack.length - 1], r = n.children[n.children.length - 1];
    this.options.withStartIndices && (e.startIndex = this.parser.startIndex), this.options.withEndIndices && (e.endIndex = this.parser.endIndex), n.children.push(e), r && (e.prev = r, r.next = e), e.parent = n, this.lastNode = null;
  }
}
const M3 = /["&'<>$\x80-\uFFFF]/g, PR = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]), RR = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (t, e) => t.codePointAt(e) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (t, e) => (t.charCodeAt(e) & 64512) === 55296 ? (t.charCodeAt(e) - 55296) * 1024 + t.charCodeAt(e + 1) - 56320 + 65536 : t.charCodeAt(e)
  )
);
function N6(t) {
  let e = "", n = 0, r;
  for (; (r = M3.exec(t)) !== null; ) {
    const i = r.index, s = t.charCodeAt(i), a = PR.get(s);
    a !== void 0 ? (e += t.substring(n, i) + a, n = i + 1) : (e += `${t.substring(n, i)}&#x${RR(t, i).toString(16)};`, n = M3.lastIndex += +((s & 64512) === 55296));
  }
  return e + t.substr(n);
}
function L6(t, e) {
  return function(r) {
    let i, s = 0, a = "";
    for (; i = t.exec(r); )
      s !== i.index && (a += r.substring(s, i.index)), a += e.get(i[0].charCodeAt(0)), s = i.index + 1;
    return a + r.substring(s);
  };
}
const BR = L6(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
])), FR = L6(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
])), UR = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t) => [t.toLowerCase(), t])), $R = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t) => [t.toLowerCase(), t])), HR = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function jR(t) {
  return t.replace(/"/g, "&quot;");
}
function zR(t, e) {
  var n;
  if (!t)
    return;
  const r = ((n = e.encodeEntities) !== null && n !== void 0 ? n : e.decodeEntities) === !1 ? jR : e.xmlMode || e.encodeEntities !== "utf8" ? N6 : BR;
  return Object.keys(t).map((i) => {
    var s, a;
    const o = (s = t[i]) !== null && s !== void 0 ? s : "";
    return e.xmlMode === "foreign" && (i = (a = $R.get(i)) !== null && a !== void 0 ? a : i), !e.emptyAttrs && !e.xmlMode && o === "" ? i : `${i}="${r(o)}"`;
  }).join(" ");
}
const O3 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function W0(t, e = {}) {
  const n = "length" in t ? t : [t];
  let r = "";
  for (let i = 0; i < n.length; i++)
    r += qR(n[i], e);
  return r;
}
function qR(t, e) {
  switch (t.type) {
    case sv:
      return W0(t.children, e);
    // @ts-expect-error We don't use `Doctype` yet
    case NR:
    case kR:
      return GR(t);
    case D6:
      return KR(t);
    case OR:
      return XR(t);
    case DR:
    case MR:
    case J2:
      return QR(t, e);
    case k6:
      return YR(t, e);
  }
}
const VR = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]), WR = /* @__PURE__ */ new Set(["svg", "math"]);
function QR(t, e) {
  var n;
  e.xmlMode === "foreign" && (t.name = (n = UR.get(t.name)) !== null && n !== void 0 ? n : t.name, t.parent && VR.has(t.parent.name) && (e = { ...e, xmlMode: !1 })), !e.xmlMode && WR.has(t.name) && (e = { ...e, xmlMode: "foreign" });
  let r = `<${t.name}`;
  const i = zR(t.attribs, e);
  return i && (r += ` ${i}`), t.children.length === 0 && (e.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    e.selfClosingTags !== !1
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    e.selfClosingTags && O3.has(t.name)
  )) ? (e.xmlMode || (r += " "), r += "/>") : (r += ">", t.children.length > 0 && (r += W0(t.children, e)), (e.xmlMode || !O3.has(t.name)) && (r += `</${t.name}>`)), r;
}
function GR(t) {
  return `<${t.data}>`;
}
function YR(t, e) {
  var n;
  let r = t.data || "";
  return ((n = e.encodeEntities) !== null && n !== void 0 ? n : e.decodeEntities) !== !1 && !(!e.xmlMode && t.parent && HR.has(t.parent.name)) && (r = e.xmlMode || e.encodeEntities !== "utf8" ? N6(r) : FR(r)), r;
}
function XR(t) {
  return `<![CDATA[${t.children[0].data}]]>`;
}
function KR(t) {
  return `<!--${t.data}-->`;
}
function P6(t, e) {
  return W0(t, e);
}
function ZR(t, e) {
  return hr(t) ? t.children.map((n) => P6(n, e)).join("") : "";
}
function tm(t) {
  return Array.isArray(t) ? t.map(tm).join("") : Lt(t) ? t.name === "br" ? `
` : tm(t.children) : q0(t) ? tm(t.children) : sa(t) ? t.data : "";
}
function ic(t) {
  return Array.isArray(t) ? t.map(ic).join("") : hr(t) && !V0(t) ? ic(t.children) : sa(t) ? t.data : "";
}
function Rm(t) {
  return Array.isArray(t) ? t.map(Rm).join("") : hr(t) && (t.type === vn.Tag || q0(t)) ? Rm(t.children) : sa(t) ? t.data : "";
}
function Q0(t) {
  return hr(t) ? t.children : [];
}
function R6(t) {
  return t.parent || null;
}
function B6(t) {
  const e = R6(t);
  if (e != null)
    return Q0(e);
  const n = [t];
  let { prev: r, next: i } = t;
  for (; r != null; )
    n.unshift(r), { prev: r } = r;
  for (; i != null; )
    n.push(i), { next: i } = i;
  return n;
}
function JR(t, e) {
  var n;
  return (n = t.attribs) === null || n === void 0 ? void 0 : n[e];
}
function eB(t, e) {
  return t.attribs != null && Object.prototype.hasOwnProperty.call(t.attribs, e) && t.attribs[e] != null;
}
function tB(t) {
  return t.name;
}
function dv(t) {
  let { next: e } = t;
  for (; e !== null && !Lt(e); )
    ({ next: e } = e);
  return e;
}
function fv(t) {
  let { prev: e } = t;
  for (; e !== null && !Lt(e); )
    ({ prev: e } = e);
  return e;
}
function Xu(t) {
  if (t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.parent) {
    const e = t.parent.children, n = e.lastIndexOf(t);
    n >= 0 && e.splice(n, 1);
  }
  t.next = null, t.prev = null, t.parent = null;
}
function nB(t, e) {
  const n = e.prev = t.prev;
  n && (n.next = e);
  const r = e.next = t.next;
  r && (r.prev = e);
  const i = e.parent = t.parent;
  if (i) {
    const s = i.children;
    s[s.lastIndexOf(t)] = e, t.parent = null;
  }
}
function rB(t, e) {
  if (Xu(e), e.next = null, e.parent = t, t.children.push(e) > 1) {
    const n = t.children[t.children.length - 2];
    n.next = e, e.prev = n;
  } else
    e.prev = null;
}
function iB(t, e) {
  Xu(e);
  const { parent: n } = t, r = t.next;
  if (e.next = r, e.prev = t, t.next = e, e.parent = n, r) {
    if (r.prev = e, n) {
      const i = n.children;
      i.splice(i.lastIndexOf(r), 0, e);
    }
  } else n && n.children.push(e);
}
function sB(t, e) {
  if (Xu(e), e.parent = t, e.prev = null, t.children.unshift(e) !== 1) {
    const n = t.children[1];
    n.prev = e, e.next = n;
  } else
    e.next = null;
}
function aB(t, e) {
  Xu(e);
  const { parent: n } = t;
  if (n) {
    const r = n.children;
    r.splice(r.indexOf(t), 0, e);
  }
  t.prev && (t.prev.next = e), e.parent = n, e.prev = t.prev, e.next = t, t.prev = e;
}
function dh(t, e, n = !0, r = 1 / 0) {
  return hv(t, Array.isArray(e) ? e : [e], n, r);
}
function hv(t, e, n, r) {
  const i = [], s = [Array.isArray(e) ? e : [e]], a = [0];
  for (; ; ) {
    if (a[0] >= s[0].length) {
      if (a.length === 1)
        return i;
      s.shift(), a.shift();
      continue;
    }
    const o = s[0][a[0]++];
    if (t(o) && (i.push(o), --r <= 0))
      return i;
    n && hr(o) && o.children.length > 0 && (a.unshift(0), s.unshift(o.children));
  }
}
function oB(t, e) {
  return e.find(t);
}
function pv(t, e, n = !0) {
  const r = Array.isArray(e) ? e : [e];
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    if (Lt(s) && t(s))
      return s;
    if (n && hr(s) && s.children.length > 0) {
      const a = pv(t, s.children, !0);
      if (a)
        return a;
    }
  }
  return null;
}
function F6(t, e) {
  return (Array.isArray(e) ? e : [e]).some((n) => Lt(n) && t(n) || hr(n) && F6(t, n.children));
}
function uB(t, e) {
  const n = [], r = [Array.isArray(e) ? e : [e]], i = [0];
  for (; ; ) {
    if (i[0] >= r[0].length) {
      if (r.length === 1)
        return n;
      r.shift(), i.shift();
      continue;
    }
    const s = r[0][i[0]++];
    Lt(s) && t(s) && n.push(s), hr(s) && s.children.length > 0 && (i.unshift(0), r.unshift(s.children));
  }
}
const Bm = {
  tag_name(t) {
    return typeof t == "function" ? (e) => Lt(e) && t(e.name) : t === "*" ? Lt : (e) => Lt(e) && e.name === t;
  },
  tag_type(t) {
    return typeof t == "function" ? (e) => t(e.type) : (e) => e.type === t;
  },
  tag_contains(t) {
    return typeof t == "function" ? (e) => sa(e) && t(e.data) : (e) => sa(e) && e.data === t;
  }
};
function mv(t, e) {
  return typeof e == "function" ? (n) => Lt(n) && e(n.attribs[t]) : (n) => Lt(n) && n.attribs[t] === e;
}
function lB(t, e) {
  return (n) => t(n) || e(n);
}
function U6(t) {
  const e = Object.keys(t).map((n) => {
    const r = t[n];
    return Object.prototype.hasOwnProperty.call(Bm, n) ? Bm[n](r) : mv(n, r);
  });
  return e.length === 0 ? null : e.reduce(lB);
}
function cB(t, e) {
  const n = U6(t);
  return n ? n(e) : !0;
}
function dB(t, e, n, r = 1 / 0) {
  const i = U6(t);
  return i ? dh(i, e, n, r) : [];
}
function fB(t, e, n = !0) {
  return Array.isArray(e) || (e = [e]), pv(mv("id", t), e, n);
}
function Oc(t, e, n = !0, r = 1 / 0) {
  return dh(Bm.tag_name(t), e, n, r);
}
function hB(t, e, n = !0, r = 1 / 0) {
  return dh(mv("class", t), e, n, r);
}
function pB(t, e, n = !0, r = 1 / 0) {
  return dh(Bm.tag_type(t), e, n, r);
}
function mB(t) {
  let e = t.length;
  for (; --e >= 0; ) {
    const n = t[e];
    if (e > 0 && t.lastIndexOf(n, e - 1) >= 0) {
      t.splice(e, 1);
      continue;
    }
    for (let r = n.parent; r; r = r.parent)
      if (t.includes(r)) {
        t.splice(e, 1);
        break;
      }
  }
  return t;
}
var Ji;
(function(t) {
  t[t.DISCONNECTED = 1] = "DISCONNECTED", t[t.PRECEDING = 2] = "PRECEDING", t[t.FOLLOWING = 4] = "FOLLOWING", t[t.CONTAINS = 8] = "CONTAINS", t[t.CONTAINED_BY = 16] = "CONTAINED_BY";
})(Ji || (Ji = {}));
function $6(t, e) {
  const n = [], r = [];
  if (t === e)
    return 0;
  let i = hr(t) ? t : t.parent;
  for (; i; )
    n.unshift(i), i = i.parent;
  for (i = hr(e) ? e : e.parent; i; )
    r.unshift(i), i = i.parent;
  const s = Math.min(n.length, r.length);
  let a = 0;
  for (; a < s && n[a] === r[a]; )
    a++;
  if (a === 0)
    return Ji.DISCONNECTED;
  const o = n[a - 1], u = o.children, c = n[a], d = r[a];
  return u.indexOf(c) > u.indexOf(d) ? o === e ? Ji.FOLLOWING | Ji.CONTAINED_BY : Ji.FOLLOWING : o === t ? Ji.PRECEDING | Ji.CONTAINS : Ji.PRECEDING;
}
function Nc(t) {
  return t = t.filter((e, n, r) => !r.includes(e, n + 1)), t.sort((e, n) => {
    const r = $6(e, n);
    return r & Ji.PRECEDING ? -1 : r & Ji.FOLLOWING ? 1 : 0;
  }), t;
}
function gB(t) {
  const e = Fm(TB, t);
  return e ? e.name === "feed" ? AB(e) : bB(e) : null;
}
function AB(t) {
  var e;
  const n = t.children, r = {
    type: "atom",
    items: Oc("entry", n).map((a) => {
      var o;
      const { children: u } = a, c = { media: H6(u) };
      _i(c, "id", "id", u), _i(c, "title", "title", u);
      const d = (o = Fm("link", u)) === null || o === void 0 ? void 0 : o.attribs.href;
      d && (c.link = d);
      const l = _o("summary", u) || _o("content", u);
      l && (c.description = l);
      const f = _o("updated", u);
      return f && (c.pubDate = new Date(f)), c;
    })
  };
  _i(r, "id", "id", n), _i(r, "title", "title", n);
  const i = (e = Fm("link", n)) === null || e === void 0 ? void 0 : e.attribs.href;
  i && (r.link = i), _i(r, "description", "subtitle", n);
  const s = _o("updated", n);
  return s && (r.updated = new Date(s)), _i(r, "author", "email", n, !0), r;
}
function bB(t) {
  var e, n;
  const r = (n = (e = Fm("channel", t.children)) === null || e === void 0 ? void 0 : e.children) !== null && n !== void 0 ? n : [], i = {
    type: t.name.substr(0, 3),
    id: "",
    items: Oc("item", t.children).map((a) => {
      const { children: o } = a, u = { media: H6(o) };
      _i(u, "id", "guid", o), _i(u, "title", "title", o), _i(u, "link", "link", o), _i(u, "description", "description", o);
      const c = _o("pubDate", o) || _o("dc:date", o);
      return c && (u.pubDate = new Date(c)), u;
    })
  };
  _i(i, "title", "title", r), _i(i, "link", "link", r), _i(i, "description", "description", r);
  const s = _o("lastBuildDate", r);
  return s && (i.updated = new Date(s)), _i(i, "author", "managingEditor", r, !0), i;
}
const yB = ["url", "type", "lang"], vB = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function H6(t) {
  return Oc("media:content", t).map((e) => {
    const { attribs: n } = e, r = {
      medium: n.medium,
      isDefault: !!n.isDefault
    };
    for (const i of yB)
      n[i] && (r[i] = n[i]);
    for (const i of vB)
      n[i] && (r[i] = parseInt(n[i], 10));
    return n.expression && (r.expression = n.expression), r;
  });
}
function Fm(t, e) {
  return Oc(t, e, !0, 1)[0];
}
function _o(t, e, n = !1) {
  return ic(Oc(t, e, n, 1)).trim();
}
function _i(t, e, n, r, i = !1) {
  const s = _o(n, r, i);
  s && (t[e] = s);
}
function TB(t) {
  return t === "rss" || t === "feed" || t === "rdf:RDF";
}
const G0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return Ji;
  },
  append: iB,
  appendChild: rB,
  compareDocumentPosition: $6,
  existsOne: F6,
  filter: dh,
  find: hv,
  findAll: uB,
  findOne: pv,
  findOneChild: oB,
  getAttributeValue: JR,
  getChildren: Q0,
  getElementById: fB,
  getElements: dB,
  getElementsByClassName: hB,
  getElementsByTagName: Oc,
  getElementsByTagType: pB,
  getFeed: gB,
  getInnerHTML: ZR,
  getName: tB,
  getOuterHTML: P6,
  getParent: R6,
  getSiblings: B6,
  getText: tm,
  hasAttrib: eB,
  hasChildren: hr,
  innerText: Rm,
  isCDATA: q0,
  isComment: V0,
  isDocument: Lo,
  isTag: Lt,
  isText: sa,
  nextElementSibling: dv,
  prepend: aB,
  prependChild: sB,
  prevElementSibling: fv,
  removeElement: Xu,
  removeSubsets: mB,
  replaceElement: nB,
  testElement: cB,
  textContent: ic,
  uniqueSort: Nc
}, Symbol.toStringTag, { value: "Module" })), _B = {
  _useHtmlParser2: !1
};
function tb(t, e) {
  if (!t)
    return e ?? _B;
  const n = {
    _useHtmlParser2: !!t.xmlMode,
    ...e,
    ...t
  };
  return t.xml ? (n._useHtmlParser2 = !0, n.xmlMode = !0, t.xml !== !0 && Object.assign(n, t.xml)) : t.xmlMode && (n._useHtmlParser2 = !0), n;
}
function j6(t, e, n) {
  return t ? t(e ?? t._root.children, null, void 0, n).toString() : "";
}
function EB(t, e) {
  return typeof t == "object" && t != null && !("length" in t) && !("type" in t);
}
function xB(t, e) {
  const n = EB(t) ? (e = t, void 0) : t, r = {
    ...this === null || this === void 0 ? void 0 : this._options,
    ...tb(e)
  };
  return j6(this, n, r);
}
function wB(t) {
  const e = { ...this._options, xmlMode: !0 };
  return j6(this, t, e);
}
function Of(t) {
  const e = t ?? (this ? this.root() : []);
  let n = "";
  for (let r = 0; r < e.length; r++)
    n += ic(e[r]);
  return n;
}
function CB(t, e, n = typeof e == "boolean" ? e : !1) {
  if (!t || typeof t != "string")
    return null;
  typeof e == "boolean" && (n = e);
  const r = this.load(t, this._options, !1);
  return n || r("script").remove(), [...r.root()[0].children];
}
function SB() {
  return this(this._root);
}
function z6(t, e) {
  if (e === t)
    return !1;
  let n = e;
  for (; n && n !== n.parent; )
    if (n = n.parent, n === t)
      return !0;
  return !1;
}
function IB(t) {
  return this.root().extract(t);
}
function kB(t, e) {
  if (!N3(t) || !N3(e))
    return;
  let n = t.length;
  const r = +e.length;
  for (let i = 0; i < r; i++)
    t[n++] = e[i];
  return t.length = n, t;
}
function N3(t) {
  if (Array.isArray(t))
    return !0;
  if (typeof t != "object" || t === null || !("length" in t) || typeof t.length != "number" || t.length < 0)
    return !1;
  for (let e = 0; e < t.length; e++)
    if (!(e in t))
      return !1;
  return !0;
}
const DB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contains: z6,
  extract: IB,
  html: xB,
  merge: kB,
  parseHTML: CB,
  root: SB,
  text: Of,
  xml: wB
}, Symbol.toStringTag, { value: "Module" }));
function Fa(t) {
  return t.cheerio != null;
}
function MB(t) {
  return t.replace(/[._-](\w|$)/g, (e, n) => n.toUpperCase());
}
function OB(t) {
  return t.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function tr(t, e) {
  const n = t.length;
  for (let r = 0; r < n; r++)
    e(t[r], r);
  return t;
}
var lu;
(function(t) {
  t[t.LowerA = 97] = "LowerA", t[t.LowerZ = 122] = "LowerZ", t[t.UpperA = 65] = "UpperA", t[t.UpperZ = 90] = "UpperZ", t[t.Exclamation = 33] = "Exclamation";
})(lu || (lu = {}));
function nb(t) {
  const e = t.indexOf("<");
  if (e === -1 || e > t.length - 3)
    return !1;
  const n = t.charCodeAt(e + 1);
  return (n >= lu.LowerA && n <= lu.LowerZ || n >= lu.UpperA && n <= lu.UpperZ || n === lu.Exclamation) && t.includes(">", e + 2);
}
const q6 = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ 'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((t) => t.charCodeAt(0))
), NB = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((t) => t.charCodeAt(0))
);
var G1;
const LB = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), L3 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (G1 = String.fromCodePoint) !== null && G1 !== void 0 ? G1 : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function PB(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = LB.get(t)) !== null && e !== void 0 ? e : t;
}
var kr;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(kr || (kr = {}));
const RB = 32;
var Eo;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Eo || (Eo = {}));
function rb(t) {
  return t >= kr.ZERO && t <= kr.NINE;
}
function BB(t) {
  return t >= kr.UPPER_A && t <= kr.UPPER_F || t >= kr.LOWER_A && t <= kr.LOWER_F;
}
function FB(t) {
  return t >= kr.UPPER_A && t <= kr.UPPER_Z || t >= kr.LOWER_A && t <= kr.LOWER_Z || rb(t);
}
function UB(t) {
  return t === kr.EQUALS || FB(t);
}
var Sr;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(Sr || (Sr = {}));
var ns;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(ns || (ns = {}));
class V6 {
  constructor(e, n, r) {
    this.decodeTree = e, this.emitCodePoint = n, this.errors = r, this.state = Sr.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = ns.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = Sr.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, n) {
    switch (this.state) {
      case Sr.EntityStart:
        return e.charCodeAt(n) === kr.NUM ? (this.state = Sr.NumericStart, this.consumed += 1, this.stateNumericStart(e, n + 1)) : (this.state = Sr.NamedEntity, this.stateNamedEntity(e, n));
      case Sr.NumericStart:
        return this.stateNumericStart(e, n);
      case Sr.NumericDecimal:
        return this.stateNumericDecimal(e, n);
      case Sr.NumericHex:
        return this.stateNumericHex(e, n);
      case Sr.NamedEntity:
        return this.stateNamedEntity(e, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, n) {
    return n >= e.length ? -1 : (e.charCodeAt(n) | RB) === kr.LOWER_X ? (this.state = Sr.NumericHex, this.consumed += 1, this.stateNumericHex(e, n + 1)) : (this.state = Sr.NumericDecimal, this.stateNumericDecimal(e, n));
  }
  addToNumericResult(e, n, r, i) {
    if (n !== r) {
      const s = r - n;
      this.result = this.result * Math.pow(i, s) + Number.parseInt(e.substr(n, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (rb(i) || BB(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (rb(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === kr.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === ns.Strict)
      return 0;
    return this.emitCodePoint(PB(this.result), this.consumed), this.errors && (e !== kr.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], s = (i & Eo.VALUE_LENGTH) >> 14;
    for (; n < e.length; n++, this.excess++) {
      const a = e.charCodeAt(n);
      if (this.treeIndex = $B(r, i, this.treeIndex + Math.max(1, s), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === ns.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        UB(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], s = (i & Eo.VALUE_LENGTH) >> 14, s !== 0) {
        if (a === kr.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== ns.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: n, decodeTree: r } = this, i = (r[n] & Eo.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[e] & ~Eo.VALUE_LENGTH : i[e + 1], r), n === 3 && this.emitCodePoint(i[e + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case Sr.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== ns.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case Sr.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Sr.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Sr.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Sr.EntityStart:
        return 0;
    }
  }
}
function $B(t, e, n, r) {
  const i = (e & Eo.BRANCH_LENGTH) >> 7, s = e & Eo.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && r === s ? n : -1;
  if (s) {
    const u = r - s;
    return u < 0 || u >= i ? -1 : t[n + u] - 1;
  }
  let a = n, o = a + i - 1;
  for (; a <= o; ) {
    const u = a + o >>> 1, c = t[u];
    if (c < r)
      a = u + 1;
    else if (c > r)
      o = u - 1;
    else
      return t[u + i];
  }
  return -1;
}
var Ot;
(function(t) {
  t[t.Tab = 9] = "Tab", t[t.NewLine = 10] = "NewLine", t[t.FormFeed = 12] = "FormFeed", t[t.CarriageReturn = 13] = "CarriageReturn", t[t.Space = 32] = "Space", t[t.ExclamationMark = 33] = "ExclamationMark", t[t.Number = 35] = "Number", t[t.Amp = 38] = "Amp", t[t.SingleQuote = 39] = "SingleQuote", t[t.DoubleQuote = 34] = "DoubleQuote", t[t.Dash = 45] = "Dash", t[t.Slash = 47] = "Slash", t[t.Zero = 48] = "Zero", t[t.Nine = 57] = "Nine", t[t.Semi = 59] = "Semi", t[t.Lt = 60] = "Lt", t[t.Eq = 61] = "Eq", t[t.Gt = 62] = "Gt", t[t.Questionmark = 63] = "Questionmark", t[t.UpperA = 65] = "UpperA", t[t.LowerA = 97] = "LowerA", t[t.UpperF = 70] = "UpperF", t[t.LowerF = 102] = "LowerF", t[t.UpperZ = 90] = "UpperZ", t[t.LowerZ = 122] = "LowerZ", t[t.LowerX = 120] = "LowerX", t[t.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(Ot || (Ot = {}));
var tt;
(function(t) {
  t[t.Text = 1] = "Text", t[t.BeforeTagName = 2] = "BeforeTagName", t[t.InTagName = 3] = "InTagName", t[t.InSelfClosingTag = 4] = "InSelfClosingTag", t[t.BeforeClosingTagName = 5] = "BeforeClosingTagName", t[t.InClosingTagName = 6] = "InClosingTagName", t[t.AfterClosingTagName = 7] = "AfterClosingTagName", t[t.BeforeAttributeName = 8] = "BeforeAttributeName", t[t.InAttributeName = 9] = "InAttributeName", t[t.AfterAttributeName = 10] = "AfterAttributeName", t[t.BeforeAttributeValue = 11] = "BeforeAttributeValue", t[t.InAttributeValueDq = 12] = "InAttributeValueDq", t[t.InAttributeValueSq = 13] = "InAttributeValueSq", t[t.InAttributeValueNq = 14] = "InAttributeValueNq", t[t.BeforeDeclaration = 15] = "BeforeDeclaration", t[t.InDeclaration = 16] = "InDeclaration", t[t.InProcessingInstruction = 17] = "InProcessingInstruction", t[t.BeforeComment = 18] = "BeforeComment", t[t.CDATASequence = 19] = "CDATASequence", t[t.InSpecialComment = 20] = "InSpecialComment", t[t.InCommentLike = 21] = "InCommentLike", t[t.BeforeSpecialS = 22] = "BeforeSpecialS", t[t.BeforeSpecialT = 23] = "BeforeSpecialT", t[t.SpecialStartSequence = 24] = "SpecialStartSequence", t[t.InSpecialTag = 25] = "InSpecialTag", t[t.InEntity = 26] = "InEntity";
})(tt || (tt = {}));
function Sa(t) {
  return t === Ot.Space || t === Ot.NewLine || t === Ot.Tab || t === Ot.FormFeed || t === Ot.CarriageReturn;
}
function up(t) {
  return t === Ot.Slash || t === Ot.Gt || Sa(t);
}
function HB(t) {
  return t >= Ot.LowerA && t <= Ot.LowerZ || t >= Ot.UpperA && t <= Ot.UpperZ;
}
var Zs;
(function(t) {
  t[t.NoValue = 0] = "NoValue", t[t.Unquoted = 1] = "Unquoted", t[t.Single = 2] = "Single", t[t.Double = 3] = "Double";
})(Zs || (Zs = {}));
const gr = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ]),
  // `</textarea`
  XmpEnd: new Uint8Array([60, 47, 120, 109, 112])
  // `</xmp`
};
let jB = class {
  constructor({ xmlMode: e = !1, decodeEntities: n = !0 }, r) {
    this.cbs = r, this.state = tt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = tt.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = e, this.decodeEntities = n, this.entityDecoder = new V6(e ? NB : q6, (i, s) => this.emitCodePoint(i, s));
  }
  reset() {
    this.state = tt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = tt.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
  }
  write(e) {
    this.offset += this.buffer.length, this.buffer = e, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = !1;
  }
  resume() {
    this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
  }
  stateText(e) {
    e === Ot.Lt || !this.decodeEntities && this.fastForwardTo(Ot.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = tt.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && e === Ot.Amp && this.startEntity();
  }
  stateSpecialStartSequence(e) {
    const n = this.sequenceIndex === this.currentSequence.length;
    if (!(n ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      up(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = !1;
    else if (!n) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = tt.InTagName, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === Ot.Gt || Sa(e)) {
        const n = this.index - this.currentSequence.length;
        if (this.sectionStart < n) {
          const r = this.index;
          this.index = n, this.cbs.ontext(this.sectionStart, n), this.index = r;
        }
        this.isSpecial = !1, this.sectionStart = n + 2, this.stateInClosingTagName(e);
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === gr.TitleEnd ? this.decodeEntities && e === Ot.Amp && this.startEntity() : this.fastForwardTo(Ot.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === Ot.Lt);
  }
  stateCDATASequence(e) {
    e === gr.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === gr.Cdata.length && (this.state = tt.InCommentLike, this.currentSequence = gr.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = tt.InDeclaration, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === e)
        return !0;
    return this.index = this.buffer.length + this.offset - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === gr.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = tt.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(e) {
    return this.xmlMode ? !up(e) : HB(e);
  }
  startSpecial(e, n) {
    this.isSpecial = !0, this.currentSequence = e, this.sequenceIndex = n, this.state = tt.SpecialStartSequence;
  }
  stateBeforeTagName(e) {
    if (e === Ot.ExclamationMark)
      this.state = tt.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (e === Ot.Questionmark)
      this.state = tt.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(e)) {
      const n = e | 32;
      this.sectionStart = this.index, this.xmlMode ? this.state = tt.InTagName : n === gr.ScriptEnd[2] ? this.state = tt.BeforeSpecialS : n === gr.TitleEnd[2] || n === gr.XmpEnd[2] ? this.state = tt.BeforeSpecialT : this.state = tt.InTagName;
    } else e === Ot.Slash ? this.state = tt.BeforeClosingTagName : (this.state = tt.Text, this.stateText(e));
  }
  stateInTagName(e) {
    up(e) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = tt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateBeforeClosingTagName(e) {
    Sa(e) || (e === Ot.Gt ? this.state = tt.Text : (this.state = this.isTagStartChar(e) ? tt.InClosingTagName : tt.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === Ot.Gt || Sa(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = tt.AfterClosingTagName, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    (e === Ot.Gt || this.fastForwardTo(Ot.Gt)) && (this.state = tt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(e) {
    e === Ot.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = tt.InSpecialTag, this.sequenceIndex = 0) : this.state = tt.Text, this.sectionStart = this.index + 1) : e === Ot.Slash ? this.state = tt.InSelfClosingTag : Sa(e) || (this.state = tt.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === Ot.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = tt.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : Sa(e) || (this.state = tt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateInAttributeName(e) {
    (e === Ot.Eq || up(e)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = this.index, this.state = tt.AfterAttributeName, this.stateAfterAttributeName(e));
  }
  stateAfterAttributeName(e) {
    e === Ot.Eq ? this.state = tt.BeforeAttributeValue : e === Ot.Slash || e === Ot.Gt ? (this.cbs.onattribend(Zs.NoValue, this.sectionStart), this.sectionStart = -1, this.state = tt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : Sa(e) || (this.cbs.onattribend(Zs.NoValue, this.sectionStart), this.state = tt.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(e) {
    e === Ot.DoubleQuote ? (this.state = tt.InAttributeValueDq, this.sectionStart = this.index + 1) : e === Ot.SingleQuote ? (this.state = tt.InAttributeValueSq, this.sectionStart = this.index + 1) : Sa(e) || (this.sectionStart = this.index, this.state = tt.InAttributeValueNq, this.stateInAttributeValueNoQuotes(e));
  }
  handleInAttributeValue(e, n) {
    e === n || !this.decodeEntities && this.fastForwardTo(n) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(n === Ot.DoubleQuote ? Zs.Double : Zs.Single, this.index + 1), this.state = tt.BeforeAttributeName) : this.decodeEntities && e === Ot.Amp && this.startEntity();
  }
  stateInAttributeValueDoubleQuotes(e) {
    this.handleInAttributeValue(e, Ot.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(e) {
    this.handleInAttributeValue(e, Ot.SingleQuote);
  }
  stateInAttributeValueNoQuotes(e) {
    Sa(e) || e === Ot.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(Zs.Unquoted, this.index), this.state = tt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : this.decodeEntities && e === Ot.Amp && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === Ot.OpeningSquareBracket ? (this.state = tt.CDATASequence, this.sequenceIndex = 0) : this.state = e === Ot.Dash ? tt.BeforeComment : tt.InDeclaration;
  }
  stateInDeclaration(e) {
    (e === Ot.Gt || this.fastForwardTo(Ot.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = tt.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === Ot.Gt || this.fastForwardTo(Ot.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = tt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === Ot.Dash ? (this.state = tt.InCommentLike, this.currentSequence = gr.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = tt.InDeclaration;
  }
  stateInSpecialComment(e) {
    (e === Ot.Gt || this.fastForwardTo(Ot.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = tt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    const n = e | 32;
    n === gr.ScriptEnd[3] ? this.startSpecial(gr.ScriptEnd, 4) : n === gr.StyleEnd[3] ? this.startSpecial(gr.StyleEnd, 4) : (this.state = tt.InTagName, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    switch (e | 32) {
      case gr.TitleEnd[3]: {
        this.startSpecial(gr.TitleEnd, 4);
        break;
      }
      case gr.TextareaEnd[3]: {
        this.startSpecial(gr.TextareaEnd, 4);
        break;
      }
      case gr.XmpEnd[3]: {
        this.startSpecial(gr.XmpEnd, 4);
        break;
      }
      default:
        this.state = tt.InTagName, this.stateInTagName(e);
    }
  }
  startEntity() {
    this.baseState = this.state, this.state = tt.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? ns.Strict : this.baseState === tt.Text || this.baseState === tt.InSpecialTag ? ns.Legacy : ns.Attribute);
  }
  stateInEntity() {
    const e = this.entityDecoder.write(this.buffer, this.index - this.offset);
    e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === tt.Text || this.state === tt.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === tt.InAttributeValueDq || this.state === tt.InAttributeValueSq || this.state === tt.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const e = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case tt.Text: {
          this.stateText(e);
          break;
        }
        case tt.SpecialStartSequence: {
          this.stateSpecialStartSequence(e);
          break;
        }
        case tt.InSpecialTag: {
          this.stateInSpecialTag(e);
          break;
        }
        case tt.CDATASequence: {
          this.stateCDATASequence(e);
          break;
        }
        case tt.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(e);
          break;
        }
        case tt.InAttributeName: {
          this.stateInAttributeName(e);
          break;
        }
        case tt.InCommentLike: {
          this.stateInCommentLike(e);
          break;
        }
        case tt.InSpecialComment: {
          this.stateInSpecialComment(e);
          break;
        }
        case tt.BeforeAttributeName: {
          this.stateBeforeAttributeName(e);
          break;
        }
        case tt.InTagName: {
          this.stateInTagName(e);
          break;
        }
        case tt.InClosingTagName: {
          this.stateInClosingTagName(e);
          break;
        }
        case tt.BeforeTagName: {
          this.stateBeforeTagName(e);
          break;
        }
        case tt.AfterAttributeName: {
          this.stateAfterAttributeName(e);
          break;
        }
        case tt.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(e);
          break;
        }
        case tt.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(e);
          break;
        }
        case tt.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(e);
          break;
        }
        case tt.AfterClosingTagName: {
          this.stateAfterClosingTagName(e);
          break;
        }
        case tt.BeforeSpecialS: {
          this.stateBeforeSpecialS(e);
          break;
        }
        case tt.BeforeSpecialT: {
          this.stateBeforeSpecialT(e);
          break;
        }
        case tt.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(e);
          break;
        }
        case tt.InSelfClosingTag: {
          this.stateInSelfClosingTag(e);
          break;
        }
        case tt.InDeclaration: {
          this.stateInDeclaration(e);
          break;
        }
        case tt.BeforeDeclaration: {
          this.stateBeforeDeclaration(e);
          break;
        }
        case tt.BeforeComment: {
          this.stateBeforeComment(e);
          break;
        }
        case tt.InProcessingInstruction: {
          this.stateInProcessingInstruction(e);
          break;
        }
        case tt.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === tt.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length + this.offset;
    this.sectionStart >= e || (this.state === tt.InCommentLike ? this.currentSequence === gr.CdataEnd ? this.cbs.oncdata(this.sectionStart, e, 0) : this.cbs.oncomment(this.sectionStart, e, 0) : this.state === tt.InTagName || this.state === tt.BeforeAttributeName || this.state === tt.BeforeAttributeValue || this.state === tt.AfterAttributeName || this.state === tt.InAttributeName || this.state === tt.InAttributeValueSq || this.state === tt.InAttributeValueDq || this.state === tt.InAttributeValueNq || this.state === tt.InClosingTagName || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, n) {
    this.baseState !== tt.Text && this.baseState !== tt.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + n, this.index = this.sectionStart - 1, this.cbs.onattribentity(e)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + n, this.index = this.sectionStart - 1, this.cbs.ontextentity(e, this.sectionStart));
  }
};
const El = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]), In = /* @__PURE__ */ new Set(["p"]), P3 = /* @__PURE__ */ new Set(["thead", "tbody"]), R3 = /* @__PURE__ */ new Set(["dd", "dt"]), B3 = /* @__PURE__ */ new Set(["rt", "rp"]), zB = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", In],
  ["h1", In],
  ["h2", In],
  ["h3", In],
  ["h4", In],
  ["h5", In],
  ["h6", In],
  ["select", El],
  ["input", El],
  ["output", El],
  ["button", El],
  ["datalist", El],
  ["textarea", El],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", R3],
  ["dt", R3],
  ["address", In],
  ["article", In],
  ["aside", In],
  ["blockquote", In],
  ["details", In],
  ["div", In],
  ["dl", In],
  ["fieldset", In],
  ["figcaption", In],
  ["figure", In],
  ["footer", In],
  ["form", In],
  ["header", In],
  ["hr", In],
  ["main", In],
  ["nav", In],
  ["ol", In],
  ["pre", In],
  ["section", In],
  ["table", In],
  ["ul", In],
  ["rt", B3],
  ["rp", B3],
  ["tbody", P3],
  ["tfoot", P3]
]), qB = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]), F3 = /* @__PURE__ */ new Set(["math", "svg"]), U3 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]), VB = /\s|\//;
let WB = class {
  constructor(e, n = {}) {
    var r, i, s, a, o, u;
    this.options = n, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = e ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (r = n.lowerCaseTags) !== null && r !== void 0 ? r : this.htmlMode, this.lowerCaseAttributeNames = (i = n.lowerCaseAttributeNames) !== null && i !== void 0 ? i : this.htmlMode, this.recognizeSelfClosing = (s = n.recognizeSelfClosing) !== null && s !== void 0 ? s : !this.htmlMode, this.tokenizer = new ((a = n.Tokenizer) !== null && a !== void 0 ? a : jB)(this.options, this), this.foreignContext = [!this.htmlMode], (u = (o = this.cbs).onparserinit) === null || u === void 0 || u.call(o, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(e, n) {
    var r, i;
    const s = this.getSlice(e, n);
    this.endIndex = n - 1, (i = (r = this.cbs).ontext) === null || i === void 0 || i.call(r, s), this.startIndex = n;
  }
  /** @internal */
  ontextentity(e, n) {
    var r, i;
    this.endIndex = n - 1, (i = (r = this.cbs).ontext) === null || i === void 0 || i.call(r, L3(e)), this.startIndex = n;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(e) {
    return this.htmlMode && qB.has(e);
  }
  /** @internal */
  onopentagname(e, n) {
    this.endIndex = n;
    let r = this.getSlice(e, n);
    this.lowerCaseTagNames && (r = r.toLowerCase()), this.emitOpenTag(r);
  }
  emitOpenTag(e) {
    var n, r, i, s;
    this.openTagStart = this.startIndex, this.tagname = e;
    const a = this.htmlMode && zB.get(e);
    if (a)
      for (; this.stack.length > 0 && a.has(this.stack[0]); ) {
        const o = this.stack.shift();
        (r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, o, !0);
      }
    this.isVoidElement(e) || (this.stack.unshift(e), this.htmlMode && (F3.has(e) ? this.foreignContext.unshift(!0) : U3.has(e) && this.foreignContext.unshift(!1))), (s = (i = this.cbs).onopentagname) === null || s === void 0 || s.call(i, e), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(e) {
    var n, r;
    this.startIndex = this.openTagStart, this.attribs && ((r = (n = this.cbs).onopentag) === null || r === void 0 || r.call(n, this.tagname, this.attribs, e), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
  }
  /** @internal */
  onopentagend(e) {
    this.endIndex = e, this.endOpenTag(!1), this.startIndex = e + 1;
  }
  /** @internal */
  onclosetag(e, n) {
    var r, i, s, a, o, u, c, d;
    this.endIndex = n;
    let l = this.getSlice(e, n);
    if (this.lowerCaseTagNames && (l = l.toLowerCase()), this.htmlMode && (F3.has(l) || U3.has(l)) && this.foreignContext.shift(), this.isVoidElement(l))
      this.htmlMode && l === "br" && ((a = (s = this.cbs).onopentagname) === null || a === void 0 || a.call(s, "br"), (u = (o = this.cbs).onopentag) === null || u === void 0 || u.call(o, "br", {}, !0), (d = (c = this.cbs).onclosetag) === null || d === void 0 || d.call(c, "br", !1));
    else {
      const f = this.stack.indexOf(l);
      if (f !== -1)
        for (let p = 0; p <= f; p++) {
          const m = this.stack.shift();
          (i = (r = this.cbs).onclosetag) === null || i === void 0 || i.call(r, m, p !== f);
        }
      else this.htmlMode && l === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
    }
    this.startIndex = n + 1;
  }
  /** @internal */
  onselfclosingtag(e) {
    this.endIndex = e, this.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(!1), this.startIndex = e + 1) : this.onopentagend(e);
  }
  closeCurrentTag(e) {
    var n, r;
    const i = this.tagname;
    this.endOpenTag(e), this.stack[0] === i && ((r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, i, !e), this.stack.shift());
  }
  /** @internal */
  onattribname(e, n) {
    this.startIndex = e;
    const r = this.getSlice(e, n);
    this.attribname = this.lowerCaseAttributeNames ? r.toLowerCase() : r;
  }
  /** @internal */
  onattribdata(e, n) {
    this.attribvalue += this.getSlice(e, n);
  }
  /** @internal */
  onattribentity(e) {
    this.attribvalue += L3(e);
  }
  /** @internal */
  onattribend(e, n) {
    var r, i;
    this.endIndex = n, (i = (r = this.cbs).onattribute) === null || i === void 0 || i.call(r, this.attribname, this.attribvalue, e === Zs.Double ? '"' : e === Zs.Single ? "'" : e === Zs.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(e) {
    const n = e.search(VB);
    let r = n < 0 ? e : e.substr(0, n);
    return this.lowerCaseTagNames && (r = r.toLowerCase()), r;
  }
  /** @internal */
  ondeclaration(e, n) {
    this.endIndex = n;
    const r = this.getSlice(e, n);
    if (this.cbs.onprocessinginstruction) {
      const i = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`!${i}`, `!${r}`);
    }
    this.startIndex = n + 1;
  }
  /** @internal */
  onprocessinginstruction(e, n) {
    this.endIndex = n;
    const r = this.getSlice(e, n);
    if (this.cbs.onprocessinginstruction) {
      const i = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`?${i}`, `?${r}`);
    }
    this.startIndex = n + 1;
  }
  /** @internal */
  oncomment(e, n, r) {
    var i, s, a, o;
    this.endIndex = n, (s = (i = this.cbs).oncomment) === null || s === void 0 || s.call(i, this.getSlice(e, n - r)), (o = (a = this.cbs).oncommentend) === null || o === void 0 || o.call(a), this.startIndex = n + 1;
  }
  /** @internal */
  oncdata(e, n, r) {
    var i, s, a, o, u, c, d, l, f, p;
    this.endIndex = n;
    const m = this.getSlice(e, n - r);
    !this.htmlMode || this.options.recognizeCDATA ? ((s = (i = this.cbs).oncdatastart) === null || s === void 0 || s.call(i), (o = (a = this.cbs).ontext) === null || o === void 0 || o.call(a, m), (c = (u = this.cbs).oncdataend) === null || c === void 0 || c.call(u)) : ((l = (d = this.cbs).oncomment) === null || l === void 0 || l.call(d, `[CDATA[${m}]]`), (p = (f = this.cbs).oncommentend) === null || p === void 0 || p.call(f)), this.startIndex = n + 1;
  }
  /** @internal */
  onend() {
    var e, n;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let r = 0; r < this.stack.length; r++)
        this.cbs.onclosetag(this.stack[r], !0);
    }
    (n = (e = this.cbs).onend) === null || n === void 0 || n.call(e);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var e, n, r, i;
    (n = (e = this.cbs).onreset) === null || n === void 0 || n.call(e), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (i = (r = this.cbs).onparserinit) === null || i === void 0 || i.call(r, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(e) {
    this.reset(), this.end(e);
  }
  getSlice(e, n) {
    for (; e - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let r = this.buffers[0].slice(e - this.bufferOffset, n - this.bufferOffset);
    for (; n - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), r += this.buffers[0].slice(0, n - this.bufferOffset);
    return r;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(e) {
    var n, r;
    if (this.ended) {
      (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(e), this.tokenizer.running && (this.tokenizer.write(e), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(e) {
    var n, r;
    if (this.ended) {
      (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".end() after done!"));
      return;
    }
    e && this.write(e), this.ended = !0, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(e) {
    this.write(e);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(e) {
    this.end(e);
  }
};
function QB(t, e) {
  const n = new LR(void 0, e);
  return new WB(n, e).end(t), n.root;
}
var Y1;
const Nf = (
  // @ts-expect-error `hasOwn` is a standard object method
  (Y1 = Object.hasOwn) !== null && Y1 !== void 0 ? Y1 : (t, e) => Object.prototype.hasOwnProperty.call(t, e)
), Lf = /\s+/, ib = "data-", gv = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, GB = /^{[^]*}$|^\[[^]*]$/;
function Um(t, e, n) {
  var r;
  if (!(!t || !Lt(t))) {
    if ((r = t.attribs) !== null && r !== void 0 || (t.attribs = {}), !e)
      return t.attribs;
    if (Nf(t.attribs, e))
      return !n && gv.test(e) ? e : t.attribs[e];
    if (t.name === "option" && e === "value")
      return Of(t.children);
    if (t.name === "input" && (t.attribs.type === "radio" || t.attribs.type === "checkbox") && e === "value")
      return "on";
  }
}
function zl(t, e, n) {
  n === null ? Q6(t, e) : t.attribs[e] = `${n}`;
}
function YB(t, e) {
  if (typeof t == "object" || e !== void 0) {
    if (typeof e == "function") {
      if (typeof t != "string")
        throw new Error("Bad combination of arguments.");
      return tr(this, (n, r) => {
        Lt(n) && zl(n, t, e.call(n, r, n.attribs[t]));
      });
    }
    return tr(this, (n) => {
      if (Lt(n))
        if (typeof t == "object")
          for (const r of Object.keys(t)) {
            const i = t[r];
            zl(n, r, i);
          }
        else
          zl(n, t, e);
    });
  }
  return arguments.length > 1 ? this : Um(this[0], t, this.options.xmlMode);
}
function $3(t, e, n) {
  return e in t ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    t[e]
  ) : !n && gv.test(e) ? Um(t, e, !1) !== void 0 : Um(t, e, n);
}
function X1(t, e, n, r) {
  e in t ? t[e] = n : zl(t, e, !r && gv.test(e) ? n ? "" : null : `${n}`);
}
function XB(t, e) {
  var n;
  if (typeof t == "string" && e === void 0) {
    const r = this[0];
    if (!r)
      return;
    switch (t) {
      case "style": {
        const i = this.css(), s = Object.keys(i);
        for (let a = 0; a < s.length; a++)
          i[a] = s[a];
        return i.length = s.length, i;
      }
      case "tagName":
      case "nodeName":
        return Lt(r) ? r.name.toUpperCase() : void 0;
      case "href":
      case "src": {
        if (!Lt(r))
          return;
        const i = (n = r.attribs) === null || n === void 0 ? void 0 : n[t];
        return typeof URL < "u" && (t === "href" && (r.tagName === "a" || r.tagName === "link") || t === "src" && (r.tagName === "img" || r.tagName === "iframe" || r.tagName === "audio" || r.tagName === "video" || r.tagName === "source")) && i !== void 0 && this.options.baseURI ? new URL(i, this.options.baseURI).href : i;
      }
      case "innerText":
        return Rm(r);
      case "textContent":
        return ic(r);
      case "outerHTML":
        return r.type === sv ? this.html() : this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return Lt(r) ? $3(r, t, this.options.xmlMode) : void 0;
    }
  }
  if (typeof t == "object" || e !== void 0) {
    if (typeof e == "function") {
      if (typeof t == "object")
        throw new TypeError("Bad combination of arguments.");
      return tr(this, (r, i) => {
        Lt(r) && X1(r, t, e.call(r, i, $3(r, t, this.options.xmlMode)), this.options.xmlMode);
      });
    }
    return tr(this, (r) => {
      if (Lt(r))
        if (typeof t == "object")
          for (const i of Object.keys(t)) {
            const s = t[i];
            X1(r, i, s, this.options.xmlMode);
          }
        else
          X1(r, t, e, this.options.xmlMode);
    });
  }
}
function H3(t, e, n) {
  var r;
  (r = t.data) !== null && r !== void 0 || (t.data = {}), typeof e == "object" ? Object.assign(t.data, e) : typeof e == "string" && n !== void 0 && (t.data[e] = n);
}
function KB(t) {
  for (const e of Object.keys(t.attribs)) {
    if (!e.startsWith(ib))
      continue;
    const n = MB(e.slice(ib.length));
    Nf(t.data, n) || (t.data[n] = W6(t.attribs[e]));
  }
  return t.data;
}
function ZB(t, e) {
  const n = ib + OB(e), r = t.data;
  if (Nf(r, e))
    return r[e];
  if (Nf(t.attribs, n))
    return r[e] = W6(t.attribs[n]);
}
function W6(t) {
  if (t === "null")
    return null;
  if (t === "true")
    return !0;
  if (t === "false")
    return !1;
  const e = Number(t);
  if (t === String(e))
    return e;
  if (GB.test(t))
    try {
      return JSON.parse(t);
    } catch {
    }
  return t;
}
function JB(t, e) {
  var n;
  const r = this[0];
  if (!r || !Lt(r))
    return;
  const i = r;
  return (n = i.data) !== null && n !== void 0 || (i.data = {}), t == null ? KB(i) : typeof t == "object" || e !== void 0 ? (tr(this, (s) => {
    Lt(s) && (typeof t == "object" ? H3(s, t) : H3(s, t, e));
  }), this) : ZB(i, t);
}
function eF(t) {
  const e = arguments.length === 0, n = this[0];
  if (!n || !Lt(n))
    return e ? void 0 : this;
  switch (n.name) {
    case "textarea":
      return this.text(t);
    case "select": {
      const r = this.find("option:selected");
      if (!e) {
        if (this.attr("multiple") == null && typeof t == "object")
          return this;
        this.find("option").removeAttr("selected");
        const i = typeof t == "object" ? t : [t];
        for (const s of i)
          this.find(`option[value="${s}"]`).attr("selected", "");
        return this;
      }
      return this.attr("multiple") ? r.toArray().map((i) => Of(i.children)) : r.attr("value");
    }
    case "input":
    case "option":
      return e ? this.attr("value") : this.attr("value", t);
  }
}
function Q6(t, e) {
  !t.attribs || !Nf(t.attribs, e) || delete t.attribs[e];
}
function $m(t) {
  return t ? t.trim().split(Lf) : [];
}
function tF(t) {
  const e = $m(t);
  for (const n of e)
    tr(this, (r) => {
      Lt(r) && Q6(r, n);
    });
  return this;
}
function nF(t) {
  return this.toArray().some((e) => {
    const n = Lt(e) && e.attribs.class;
    let r = -1;
    if (n && t.length > 0)
      for (; (r = n.indexOf(t, r + 1)) > -1; ) {
        const i = r + t.length;
        if ((r === 0 || Lf.test(n[r - 1])) && (i === n.length || Lf.test(n[i])))
          return !0;
      }
    return !1;
  });
}
function G6(t) {
  if (typeof t == "function")
    return tr(this, (r, i) => {
      if (Lt(r)) {
        const s = r.attribs.class || "";
        G6.call([r], t.call(r, i, s));
      }
    });
  if (!t || typeof t != "string")
    return this;
  const e = t.split(Lf), n = this.length;
  for (let r = 0; r < n; r++) {
    const i = this[r];
    if (!Lt(i))
      continue;
    const s = Um(i, "class", !1);
    if (s) {
      let a = ` ${s} `;
      for (const o of e) {
        const u = `${o} `;
        a.includes(` ${u}`) || (a += u);
      }
      zl(i, "class", a.trim());
    } else
      zl(i, "class", e.join(" ").trim());
  }
  return this;
}
function Y6(t) {
  if (typeof t == "function")
    return tr(this, (i, s) => {
      Lt(i) && Y6.call([i], t.call(i, s, i.attribs.class || ""));
    });
  const e = $m(t), n = e.length, r = arguments.length === 0;
  return tr(this, (i) => {
    if (Lt(i))
      if (r)
        i.attribs.class = "";
      else {
        const s = $m(i.attribs.class);
        let a = !1;
        for (let o = 0; o < n; o++) {
          const u = s.indexOf(e[o]);
          u !== -1 && (s.splice(u, 1), a = !0, o--);
        }
        a && (i.attribs.class = s.join(" "));
      }
  });
}
function X6(t, e) {
  if (typeof t == "function")
    return tr(this, (a, o) => {
      Lt(a) && X6.call([a], t.call(a, o, a.attribs.class || "", e), e);
    });
  if (!t || typeof t != "string")
    return this;
  const n = t.split(Lf), r = n.length, i = typeof e == "boolean" ? e ? 1 : -1 : 0, s = this.length;
  for (let a = 0; a < s; a++) {
    const o = this[a];
    if (!Lt(o))
      continue;
    const u = $m(o.attribs.class);
    for (let c = 0; c < r; c++) {
      const d = u.indexOf(n[c]);
      i >= 0 && d === -1 ? u.push(n[c]) : i <= 0 && d !== -1 && u.splice(d, 1);
    }
    o.attribs.class = u.join(" ");
  }
  return this;
}
const rF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addClass: G6,
  attr: YB,
  data: JB,
  hasClass: nF,
  prop: XB,
  removeAttr: tF,
  removeClass: Y6,
  toggleClass: X6,
  val: eF
}, Symbol.toStringTag, { value: "Module" }));
var Mt;
(function(t) {
  t.Attribute = "attribute", t.Pseudo = "pseudo", t.PseudoElement = "pseudo-element", t.Tag = "tag", t.Universal = "universal", t.Adjacent = "adjacent", t.Child = "child", t.Descendant = "descendant", t.Parent = "parent", t.Sibling = "sibling", t.ColumnCombinator = "column-combinator";
})(Mt || (Mt = {}));
var Er;
(function(t) {
  t.Any = "any", t.Element = "element", t.End = "end", t.Equals = "equals", t.Exists = "exists", t.Hyphen = "hyphen", t.Not = "not", t.Start = "start";
})(Er || (Er = {}));
const j3 = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/, iF = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, sF = /* @__PURE__ */ new Map([
  [126, Er.Element],
  [94, Er.Start],
  [36, Er.End],
  [42, Er.Any],
  [33, Er.Not],
  [124, Er.Hyphen]
]), aF = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function uf(t) {
  switch (t.type) {
    case Mt.Adjacent:
    case Mt.Child:
    case Mt.Descendant:
    case Mt.Parent:
    case Mt.Sibling:
    case Mt.ColumnCombinator:
      return !0;
    default:
      return !1;
  }
}
const oF = /* @__PURE__ */ new Set(["contains", "icontains"]);
function uF(t, e, n) {
  const r = parseInt(e, 16) - 65536;
  return r !== r || n ? e : r < 0 ? (
    // BMP codepoint
    String.fromCharCode(r + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(r >> 10 | 55296, r & 1023 | 56320)
  );
}
function vd(t) {
  return t.replace(iF, uF);
}
function K1(t) {
  return t === 39 || t === 34;
}
function z3(t) {
  return t === 32 || t === 9 || t === 10 || t === 12 || t === 13;
}
function Y0(t) {
  const e = [], n = K6(e, `${t}`, 0);
  if (n < t.length)
    throw new Error(`Unmatched selector: ${t.slice(n)}`);
  return e;
}
function K6(t, e, n) {
  let r = [];
  function i(f) {
    const p = e.slice(n + f).match(j3);
    if (!p)
      throw new Error(`Expected name, found ${e.slice(n)}`);
    const [m] = p;
    return n += f + m.length, vd(m);
  }
  function s(f) {
    for (n += f; n < e.length && z3(e.charCodeAt(n)); )
      n++;
  }
  function a() {
    n += 1;
    const f = n;
    let p = 1;
    for (; p > 0 && n < e.length; n++)
      e.charCodeAt(n) === 40 && !o(n) ? p++ : e.charCodeAt(n) === 41 && !o(n) && p--;
    if (p)
      throw new Error("Parenthesis not matched");
    return vd(e.slice(f, n - 1));
  }
  function o(f) {
    let p = 0;
    for (; e.charCodeAt(--f) === 92; )
      p++;
    return (p & 1) === 1;
  }
  function u() {
    if (r.length > 0 && uf(r[r.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function c(f) {
    if (r.length > 0 && r[r.length - 1].type === Mt.Descendant) {
      r[r.length - 1].type = f;
      return;
    }
    u(), r.push({ type: f });
  }
  function d(f, p) {
    r.push({
      type: Mt.Attribute,
      name: f,
      action: p,
      value: i(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function l() {
    if (r.length && r[r.length - 1].type === Mt.Descendant && r.pop(), r.length === 0)
      throw new Error("Empty sub-selector");
    t.push(r);
  }
  if (s(0), e.length === n)
    return n;
  e: for (; n < e.length; ) {
    const f = e.charCodeAt(n);
    switch (f) {
      // Whitespace
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        (r.length === 0 || r[0].type !== Mt.Descendant) && (u(), r.push({ type: Mt.Descendant })), s(1);
        break;
      }
      // Traversals
      case 62: {
        c(Mt.Child), s(1);
        break;
      }
      case 60: {
        c(Mt.Parent), s(1);
        break;
      }
      case 126: {
        c(Mt.Sibling), s(1);
        break;
      }
      case 43: {
        c(Mt.Adjacent), s(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case 46: {
        d("class", Er.Element);
        break;
      }
      case 35: {
        d("id", Er.Equals);
        break;
      }
      case 91: {
        s(1);
        let p, m = null;
        e.charCodeAt(n) === 124 ? p = i(1) : e.startsWith("*|", n) ? (m = "*", p = i(2)) : (p = i(0), e.charCodeAt(n) === 124 && e.charCodeAt(n + 1) !== 61 && (m = p, p = i(1))), s(0);
        let g = Er.Exists;
        const y = sF.get(e.charCodeAt(n));
        if (y) {
          if (g = y, e.charCodeAt(n + 1) !== 61)
            throw new Error("Expected `=`");
          s(2);
        } else e.charCodeAt(n) === 61 && (g = Er.Equals, s(1));
        let b = "", E = null;
        if (g !== "exists") {
          if (K1(e.charCodeAt(n))) {
            const D = e.charCodeAt(n);
            let S = n + 1;
            for (; S < e.length && (e.charCodeAt(S) !== D || o(S)); )
              S += 1;
            if (e.charCodeAt(S) !== D)
              throw new Error("Attribute value didn't end");
            b = vd(e.slice(n + 1, S)), n = S + 1;
          } else {
            const D = n;
            for (; n < e.length && (!z3(e.charCodeAt(n)) && e.charCodeAt(n) !== 93 || o(n)); )
              n += 1;
            b = vd(e.slice(D, n));
          }
          s(0);
          const _ = e.charCodeAt(n) | 32;
          _ === 115 ? (E = !1, s(1)) : _ === 105 && (E = !0, s(1));
        }
        if (e.charCodeAt(n) !== 93)
          throw new Error("Attribute selector didn't terminate");
        n += 1;
        const v = {
          type: Mt.Attribute,
          name: p,
          action: g,
          value: b,
          namespace: m,
          ignoreCase: E
        };
        r.push(v);
        break;
      }
      case 58: {
        if (e.charCodeAt(n + 1) === 58) {
          r.push({
            type: Mt.PseudoElement,
            name: i(2).toLowerCase(),
            data: e.charCodeAt(n) === 40 ? a() : null
          });
          continue;
        }
        const p = i(1).toLowerCase();
        let m = null;
        if (e.charCodeAt(n) === 40)
          if (aF.has(p)) {
            if (K1(e.charCodeAt(n + 1)))
              throw new Error(`Pseudo-selector ${p} cannot be quoted`);
            if (m = [], n = K6(m, e, n + 1), e.charCodeAt(n) !== 41)
              throw new Error(`Missing closing parenthesis in :${p} (${e})`);
            n += 1;
          } else {
            if (m = a(), oF.has(p)) {
              const g = m.charCodeAt(0);
              g === m.charCodeAt(m.length - 1) && K1(g) && (m = m.slice(1, -1));
            }
            m = vd(m);
          }
        r.push({ type: Mt.Pseudo, name: p, data: m });
        break;
      }
      case 44: {
        l(), r = [], s(1);
        break;
      }
      default: {
        if (e.startsWith("/*", n)) {
          const g = e.indexOf("*/", n + 2);
          if (g < 0)
            throw new Error("Comment was not terminated");
          n = g + 2, r.length === 0 && s(0);
          break;
        }
        let p = null, m;
        if (f === 42)
          n += 1, m = "*";
        else if (f === 124) {
          if (m = "", e.charCodeAt(n + 1) === 124) {
            c(Mt.ColumnCombinator), s(2);
            break;
          }
        } else if (j3.test(e.slice(n)))
          m = i(0);
        else
          break e;
        e.charCodeAt(n) === 124 && e.charCodeAt(n + 1) !== 124 && (p = m, e.charCodeAt(n + 1) === 42 ? (m = "*", n += 2) : m = i(1)), r.push(m === "*" ? { type: Mt.Universal, namespace: p } : { type: Mt.Tag, name: m, namespace: p });
      }
    }
  }
  return l(), n;
}
var cn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fr(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function lF(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var Z1, q3;
function cF() {
  return q3 || (q3 = 1, Z1 = {
    trueFunc: function() {
      return !0;
    },
    falseFunc: function() {
      return !1;
    }
  }), Z1;
}
var Hm = cF();
const Jt = /* @__PURE__ */ Fr(Hm), Z6 = /* @__PURE__ */ new Map([
  [Mt.Universal, 50],
  [Mt.Tag, 30],
  [Mt.Attribute, 1],
  [Mt.Pseudo, 0]
]);
function Av(t) {
  return !Z6.has(t.type);
}
const dF = /* @__PURE__ */ new Map([
  [Er.Exists, 10],
  [Er.Equals, 8],
  [Er.Not, 7],
  [Er.Start, 6],
  [Er.End, 6],
  [Er.Any, 5]
]);
function fF(t) {
  const e = t.map(J6);
  for (let n = 1; n < t.length; n++) {
    const r = e[n];
    if (!(r < 0))
      for (let i = n - 1; i >= 0 && r < e[i]; i--) {
        const s = t[i + 1];
        t[i + 1] = t[i], t[i] = s, e[i + 1] = e[i], e[i] = r;
      }
  }
}
function J6(t) {
  var e, n;
  let r = (e = Z6.get(t.type)) !== null && e !== void 0 ? e : -1;
  return t.type === Mt.Attribute ? (r = (n = dF.get(t.action)) !== null && n !== void 0 ? n : 4, t.action === Er.Equals && t.name === "id" && (r = 9), t.ignoreCase && (r >>= 1)) : t.type === Mt.Pseudo && (t.data ? t.name === "has" || t.name === "contains" ? r = 0 : Array.isArray(t.data) ? (r = Math.min(...t.data.map((i) => Math.min(...i.map(J6)))), r < 0 && (r = 0)) : r = 2 : r = 3), r;
}
const hF = /[-[\]{}()*+?.,\\^$|#\s]/g;
function V3(t) {
  return t.replace(hF, "\\$&");
}
const pF = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function Ko(t, e) {
  return typeof t.ignoreCase == "boolean" ? t.ignoreCase : t.ignoreCase === "quirks" ? !!e.quirksMode : !e.xmlMode && pF.has(t.name);
}
const mF = {
  equals(t, e, n) {
    const { adapter: r } = n, { name: i } = e;
    let { value: s } = e;
    return Ko(e, n) ? (s = s.toLowerCase(), (a) => {
      const o = r.getAttributeValue(a, i);
      return o != null && o.length === s.length && o.toLowerCase() === s && t(a);
    }) : (a) => r.getAttributeValue(a, i) === s && t(a);
  },
  hyphen(t, e, n) {
    const { adapter: r } = n, { name: i } = e;
    let { value: s } = e;
    const a = s.length;
    return Ko(e, n) ? (s = s.toLowerCase(), function(u) {
      const c = r.getAttributeValue(u, i);
      return c != null && (c.length === a || c.charAt(a) === "-") && c.substr(0, a).toLowerCase() === s && t(u);
    }) : function(u) {
      const c = r.getAttributeValue(u, i);
      return c != null && (c.length === a || c.charAt(a) === "-") && c.substr(0, a) === s && t(u);
    };
  },
  element(t, e, n) {
    const { adapter: r } = n, { name: i, value: s } = e;
    if (/\s/.test(s))
      return Jt.falseFunc;
    const a = new RegExp(`(?:^|\\s)${V3(s)}(?:$|\\s)`, Ko(e, n) ? "i" : "");
    return function(u) {
      const c = r.getAttributeValue(u, i);
      return c != null && c.length >= s.length && a.test(c) && t(u);
    };
  },
  exists(t, { name: e }, { adapter: n }) {
    return (r) => n.hasAttrib(r, e) && t(r);
  },
  start(t, e, n) {
    const { adapter: r } = n, { name: i } = e;
    let { value: s } = e;
    const a = s.length;
    return a === 0 ? Jt.falseFunc : Ko(e, n) ? (s = s.toLowerCase(), (o) => {
      const u = r.getAttributeValue(o, i);
      return u != null && u.length >= a && u.substr(0, a).toLowerCase() === s && t(o);
    }) : (o) => {
      var u;
      return !!(!((u = r.getAttributeValue(o, i)) === null || u === void 0) && u.startsWith(s)) && t(o);
    };
  },
  end(t, e, n) {
    const { adapter: r } = n, { name: i } = e;
    let { value: s } = e;
    const a = -s.length;
    return a === 0 ? Jt.falseFunc : Ko(e, n) ? (s = s.toLowerCase(), (o) => {
      var u;
      return ((u = r.getAttributeValue(o, i)) === null || u === void 0 ? void 0 : u.substr(a).toLowerCase()) === s && t(o);
    }) : (o) => {
      var u;
      return !!(!((u = r.getAttributeValue(o, i)) === null || u === void 0) && u.endsWith(s)) && t(o);
    };
  },
  any(t, e, n) {
    const { adapter: r } = n, { name: i, value: s } = e;
    if (s === "")
      return Jt.falseFunc;
    if (Ko(e, n)) {
      const a = new RegExp(V3(s), "i");
      return function(u) {
        const c = r.getAttributeValue(u, i);
        return c != null && c.length >= s.length && a.test(c) && t(u);
      };
    }
    return (a) => {
      var o;
      return !!(!((o = r.getAttributeValue(a, i)) === null || o === void 0) && o.includes(s)) && t(a);
    };
  },
  not(t, e, n) {
    const { adapter: r } = n, { name: i } = e;
    let { value: s } = e;
    return s === "" ? (a) => !!r.getAttributeValue(a, i) && t(a) : Ko(e, n) ? (s = s.toLowerCase(), (a) => {
      const o = r.getAttributeValue(a, i);
      return (o == null || o.length !== s.length || o.toLowerCase() !== s) && t(a);
    }) : (a) => r.getAttributeValue(a, i) !== s && t(a);
  }
}, gF = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]), W3 = 48, AF = 57;
function bF(t) {
  if (t = t.trim().toLowerCase(), t === "even")
    return [2, 0];
  if (t === "odd")
    return [2, 1];
  let e = 0, n = 0, r = s(), i = a();
  if (e < t.length && t.charAt(e) === "n" && (e++, n = r * (i ?? 1), o(), e < t.length ? (r = s(), o(), i = a()) : r = i = 0), i === null || e < t.length)
    throw new Error(`n-th rule couldn't be parsed ('${t}')`);
  return [n, r * i];
  function s() {
    return t.charAt(e) === "-" ? (e++, -1) : (t.charAt(e) === "+" && e++, 1);
  }
  function a() {
    const u = e;
    let c = 0;
    for (; e < t.length && t.charCodeAt(e) >= W3 && t.charCodeAt(e) <= AF; )
      c = c * 10 + (t.charCodeAt(e) - W3), e++;
    return e === u ? null : c;
  }
  function o() {
    for (; e < t.length && gF.has(t.charCodeAt(e)); )
      e++;
  }
}
function yF(t) {
  const e = t[0], n = t[1] - 1;
  if (n < 0 && e <= 0)
    return Jt.falseFunc;
  if (e === -1)
    return (s) => s <= n;
  if (e === 0)
    return (s) => s === n;
  if (e === 1)
    return n < 0 ? Jt.trueFunc : (s) => s >= n;
  const r = Math.abs(e), i = (n % r + r) % r;
  return e > 1 ? (s) => s >= n && s % r === i : (s) => s <= n && s % r === i;
}
function lp(t) {
  return yF(bF(t));
}
function cp(t, e) {
  return (n) => {
    const r = e.getParent(n);
    return r != null && e.isTag(r) && t(n);
  };
}
const sb = {
  contains(t, e, { adapter: n }) {
    return function(i) {
      return t(i) && n.getText(i).includes(e);
    };
  },
  icontains(t, e, { adapter: n }) {
    const r = e.toLowerCase();
    return function(s) {
      return t(s) && n.getText(s).toLowerCase().includes(r);
    };
  },
  // Location specific methods
  "nth-child"(t, e, { adapter: n, equals: r }) {
    const i = lp(e);
    return i === Jt.falseFunc ? Jt.falseFunc : i === Jt.trueFunc ? cp(t, n) : function(a) {
      const o = n.getSiblings(a);
      let u = 0;
      for (let c = 0; c < o.length && !r(a, o[c]); c++)
        n.isTag(o[c]) && u++;
      return i(u) && t(a);
    };
  },
  "nth-last-child"(t, e, { adapter: n, equals: r }) {
    const i = lp(e);
    return i === Jt.falseFunc ? Jt.falseFunc : i === Jt.trueFunc ? cp(t, n) : function(a) {
      const o = n.getSiblings(a);
      let u = 0;
      for (let c = o.length - 1; c >= 0 && !r(a, o[c]); c--)
        n.isTag(o[c]) && u++;
      return i(u) && t(a);
    };
  },
  "nth-of-type"(t, e, { adapter: n, equals: r }) {
    const i = lp(e);
    return i === Jt.falseFunc ? Jt.falseFunc : i === Jt.trueFunc ? cp(t, n) : function(a) {
      const o = n.getSiblings(a);
      let u = 0;
      for (let c = 0; c < o.length; c++) {
        const d = o[c];
        if (r(a, d))
          break;
        n.isTag(d) && n.getName(d) === n.getName(a) && u++;
      }
      return i(u) && t(a);
    };
  },
  "nth-last-of-type"(t, e, { adapter: n, equals: r }) {
    const i = lp(e);
    return i === Jt.falseFunc ? Jt.falseFunc : i === Jt.trueFunc ? cp(t, n) : function(a) {
      const o = n.getSiblings(a);
      let u = 0;
      for (let c = o.length - 1; c >= 0; c--) {
        const d = o[c];
        if (r(a, d))
          break;
        n.isTag(d) && n.getName(d) === n.getName(a) && u++;
      }
      return i(u) && t(a);
    };
  },
  // TODO determine the actual root element
  root(t, e, { adapter: n }) {
    return (r) => {
      const i = n.getParent(r);
      return (i == null || !n.isTag(i)) && t(r);
    };
  },
  scope(t, e, n, r) {
    const { equals: i } = n;
    return !r || r.length === 0 ? sb.root(t, e, n) : r.length === 1 ? (s) => i(r[0], s) && t(s) : (s) => r.includes(s) && t(s);
  },
  hover: J1("isHovered"),
  visited: J1("isVisited"),
  active: J1("isActive")
};
function J1(t) {
  return function(n, r, { adapter: i }) {
    const s = i[t];
    return typeof s != "function" ? Jt.falseFunc : function(o) {
      return s(o) && n(o);
    };
  };
}
const Q3 = {
  empty(t, { adapter: e }) {
    return !e.getChildren(t).some((n) => (
      // FIXME: `getText` call is potentially expensive.
      e.isTag(n) || e.getText(n) !== ""
    ));
  },
  "first-child"(t, { adapter: e, equals: n }) {
    if (e.prevElementSibling)
      return e.prevElementSibling(t) == null;
    const r = e.getSiblings(t).find((i) => e.isTag(i));
    return r != null && n(t, r);
  },
  "last-child"(t, { adapter: e, equals: n }) {
    const r = e.getSiblings(t);
    for (let i = r.length - 1; i >= 0; i--) {
      if (n(t, r[i]))
        return !0;
      if (e.isTag(r[i]))
        break;
    }
    return !1;
  },
  "first-of-type"(t, { adapter: e, equals: n }) {
    const r = e.getSiblings(t), i = e.getName(t);
    for (let s = 0; s < r.length; s++) {
      const a = r[s];
      if (n(t, a))
        return !0;
      if (e.isTag(a) && e.getName(a) === i)
        break;
    }
    return !1;
  },
  "last-of-type"(t, { adapter: e, equals: n }) {
    const r = e.getSiblings(t), i = e.getName(t);
    for (let s = r.length - 1; s >= 0; s--) {
      const a = r[s];
      if (n(t, a))
        return !0;
      if (e.isTag(a) && e.getName(a) === i)
        break;
    }
    return !1;
  },
  "only-of-type"(t, { adapter: e, equals: n }) {
    const r = e.getName(t);
    return e.getSiblings(t).every((i) => n(t, i) || !e.isTag(i) || e.getName(i) !== r);
  },
  "only-child"(t, { adapter: e, equals: n }) {
    return e.getSiblings(t).every((r) => n(t, r) || !e.isTag(r));
  }
};
function G3(t, e, n, r) {
  if (n === null) {
    if (t.length > r)
      throw new Error(`Pseudo-class :${e} requires an argument`);
  } else if (t.length === r)
    throw new Error(`Pseudo-class :${e} doesn't have any arguments`);
}
const vF = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
}, eI = {};
function TF(t, e) {
  return t === Jt.falseFunc ? Jt.falseFunc : (n) => e.isTag(n) && t(n);
}
function tI(t, e) {
  const n = e.getSiblings(t);
  if (n.length <= 1)
    return [];
  const r = n.indexOf(t);
  return r < 0 || r === n.length - 1 ? [] : n.slice(r + 1).filter(e.isTag);
}
function ab(t) {
  return {
    xmlMode: !!t.xmlMode,
    lowerCaseAttributeNames: !!t.lowerCaseAttributeNames,
    lowerCaseTags: !!t.lowerCaseTags,
    quirksMode: !!t.quirksMode,
    cacheResults: !!t.cacheResults,
    pseudos: t.pseudos,
    adapter: t.adapter,
    equals: t.equals
  };
}
const eA = (t, e, n, r, i) => {
  const s = i(e, ab(n), r);
  return s === Jt.trueFunc ? t : s === Jt.falseFunc ? Jt.falseFunc : (a) => s(a) && t(a);
}, tA = {
  is: eA,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: eA,
  where: eA,
  not(t, e, n, r, i) {
    const s = i(e, ab(n), r);
    return s === Jt.falseFunc ? t : s === Jt.trueFunc ? Jt.falseFunc : (a) => !s(a) && t(a);
  },
  has(t, e, n, r, i) {
    const { adapter: s } = n, a = ab(n);
    a.relativeSelector = !0;
    const o = e.some((d) => d.some(Av)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [eI]
    ) : void 0, u = i(e, a, o);
    if (u === Jt.falseFunc)
      return Jt.falseFunc;
    const c = TF(u, s);
    if (o && u !== Jt.trueFunc) {
      const { shouldTestNextSiblings: d = !1 } = u;
      return (l) => {
        if (!t(l))
          return !1;
        o[0] = l;
        const f = s.getChildren(l), p = d ? [...f, ...tI(l, s)] : f;
        return s.existsOne(c, p);
      };
    }
    return (d) => t(d) && s.existsOne(c, s.getChildren(d));
  }
};
function _F(t, e, n, r, i) {
  var s;
  const { name: a, data: o } = e;
  if (Array.isArray(o)) {
    if (!(a in tA))
      throw new Error(`Unknown pseudo-class :${a}(${o})`);
    return tA[a](t, o, n, r, i);
  }
  const u = (s = n.pseudos) === null || s === void 0 ? void 0 : s[a], c = typeof u == "string" ? u : vF[a];
  if (typeof c == "string") {
    if (o != null)
      throw new Error(`Pseudo ${a} doesn't have any arguments`);
    const d = Y0(c);
    return tA.is(t, d, n, r, i);
  }
  if (typeof u == "function")
    return G3(u, a, o, 1), (d) => u(d, o) && t(d);
  if (a in sb)
    return sb[a](t, o, n, r);
  if (a in Q3) {
    const d = Q3[a];
    return G3(d, a, o, 2), (l) => d(l, n, o) && t(l);
  }
  throw new Error(`Unknown pseudo-class :${a}`);
}
function nA(t, e) {
  const n = e.getParent(t);
  return n && e.isTag(n) ? n : null;
}
function EF(t, e, n, r, i) {
  const { adapter: s, equals: a } = n;
  switch (e.type) {
    case Mt.PseudoElement:
      throw new Error("Pseudo-elements are not supported by css-select");
    case Mt.ColumnCombinator:
      throw new Error("Column combinators are not yet supported by css-select");
    case Mt.Attribute: {
      if (e.namespace != null)
        throw new Error("Namespaced attributes are not yet supported by css-select");
      return (!n.xmlMode || n.lowerCaseAttributeNames) && (e.name = e.name.toLowerCase()), mF[e.action](t, e, n);
    }
    case Mt.Pseudo:
      return _F(t, e, n, r, i);
    // Tags
    case Mt.Tag: {
      if (e.namespace != null)
        throw new Error("Namespaced tag names are not yet supported by css-select");
      let { name: o } = e;
      return (!n.xmlMode || n.lowerCaseTags) && (o = o.toLowerCase()), function(c) {
        return s.getName(c) === o && t(c);
      };
    }
    // Traversal
    case Mt.Descendant: {
      if (n.cacheResults === !1 || typeof WeakSet > "u")
        return function(c) {
          let d = c;
          for (; d = nA(d, s); )
            if (t(d))
              return !0;
          return !1;
        };
      const o = /* @__PURE__ */ new WeakSet();
      return function(c) {
        let d = c;
        for (; d = nA(d, s); )
          if (!o.has(d)) {
            if (s.isTag(d) && t(d))
              return !0;
            o.add(d);
          }
        return !1;
      };
    }
    case "_flexibleDescendant":
      return function(u) {
        let c = u;
        do
          if (t(c))
            return !0;
        while (c = nA(c, s));
        return !1;
      };
    case Mt.Parent:
      return function(u) {
        return s.getChildren(u).some((c) => s.isTag(c) && t(c));
      };
    case Mt.Child:
      return function(u) {
        const c = s.getParent(u);
        return c != null && s.isTag(c) && t(c);
      };
    case Mt.Sibling:
      return function(u) {
        const c = s.getSiblings(u);
        for (let d = 0; d < c.length; d++) {
          const l = c[d];
          if (a(u, l))
            break;
          if (s.isTag(l) && t(l))
            return !0;
        }
        return !1;
      };
    case Mt.Adjacent:
      return s.prevElementSibling ? function(u) {
        const c = s.prevElementSibling(u);
        return c != null && t(c);
      } : function(u) {
        const c = s.getSiblings(u);
        let d;
        for (let l = 0; l < c.length; l++) {
          const f = c[l];
          if (a(u, f))
            break;
          s.isTag(f) && (d = f);
        }
        return !!d && t(d);
      };
    case Mt.Universal: {
      if (e.namespace != null && e.namespace !== "*")
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      return t;
    }
  }
}
function nI(t) {
  return t.type === Mt.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((e) => e.some(nI)));
}
const xF = { type: Mt.Descendant }, wF = {
  type: "_flexibleDescendant"
}, CF = {
  type: Mt.Pseudo,
  name: "scope",
  data: null
};
function SF(t, { adapter: e }, n) {
  const r = !!(n != null && n.every((i) => {
    const s = e.isTag(i) && e.getParent(i);
    return i === eI || s && e.isTag(s);
  }));
  for (const i of t) {
    if (!(i.length > 0 && Av(i[0]) && i[0].type !== Mt.Descendant)) if (r && !i.some(nI))
      i.unshift(xF);
    else
      continue;
    i.unshift(CF);
  }
}
function rI(t, e, n) {
  var r;
  t.forEach(fF), n = (r = e.context) !== null && r !== void 0 ? r : n;
  const i = Array.isArray(n), s = n && (Array.isArray(n) ? n : [n]);
  if (e.relativeSelector !== !1)
    SF(t, e, s);
  else if (t.some((u) => u.length > 0 && Av(u[0])))
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  let a = !1;
  const o = t.map((u) => {
    if (u.length >= 2) {
      const [c, d] = u;
      c.type !== Mt.Pseudo || c.name !== "scope" || (i && d.type === Mt.Descendant ? u[1] = wF : (d.type === Mt.Adjacent || d.type === Mt.Sibling) && (a = !0));
    }
    return IF(u, e, s);
  }).reduce(kF, Jt.falseFunc);
  return o.shouldTestNextSiblings = a, o;
}
function IF(t, e, n) {
  var r;
  return t.reduce((i, s) => i === Jt.falseFunc ? Jt.falseFunc : EF(i, s, e, n, rI), (r = e.rootFunc) !== null && r !== void 0 ? r : Jt.trueFunc);
}
function kF(t, e) {
  return e === Jt.falseFunc || t === Jt.trueFunc ? t : t === Jt.falseFunc || e === Jt.trueFunc ? e : function(r) {
    return t(r) || e(r);
  };
}
const iI = (t, e) => t === e, DF = {
  adapter: G0,
  equals: iI
};
function MF(t) {
  var e, n, r, i;
  const s = t ?? DF;
  return (e = s.adapter) !== null && e !== void 0 || (s.adapter = G0), (n = s.equals) !== null && n !== void 0 || (s.equals = (i = (r = s.adapter) === null || r === void 0 ? void 0 : r.equals) !== null && i !== void 0 ? i : iI), s;
}
function OF(t) {
  return function(n, r, i) {
    const s = MF(r);
    return t(n, s, i);
  };
}
const bv = OF(rI);
function sI(t, e, n = !1) {
  return n && (t = NF(t, e)), Array.isArray(t) ? e.removeSubsets(t) : e.getChildren(t);
}
function NF(t, e) {
  const n = Array.isArray(t) ? t.slice(0) : [t], r = n.length;
  for (let i = 0; i < r; i++) {
    const s = tI(n[i], e);
    n.push(...s);
  }
  return n;
}
const LF = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function jm(t) {
  return t.type !== "pseudo" ? !1 : LF.has(t.name) ? !0 : t.name === "not" && Array.isArray(t.data) ? t.data.some((e) => e.some(jm)) : !1;
}
function PF(t, e, n) {
  const r = e != null ? parseInt(e, 10) : NaN;
  switch (t) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(r) ? r >= 0 ? r + 1 : 1 / 0 : 0;
    case "lt":
      return isFinite(r) ? r >= 0 ? Math.min(r, n) : 1 / 0 : 0;
    case "gt":
      return isFinite(r) ? 1 / 0 : 0;
    case "odd":
      return 2 * n;
    case "even":
      return 2 * n - 1;
    case "last":
    case "not":
      return 1 / 0;
  }
}
function RF(t) {
  for (; t.parent; )
    t = t.parent;
  return t;
}
function yv(t) {
  const e = [], n = [];
  for (const r of t)
    r.some(jm) ? e.push(r) : n.push(r);
  return [n, e];
}
const BF = {
  type: Mt.Universal,
  namespace: null
}, FF = {
  type: Mt.Pseudo,
  name: "scope",
  data: null
};
function aI(t, e, n = {}) {
  return oI([t], e, n);
}
function oI(t, e, n = {}) {
  if (typeof e == "function")
    return t.some(e);
  const [r, i] = yv(Y0(e));
  return r.length > 0 && t.some(bv(r, n)) || i.some((s) => cI(s, t, n).length > 0);
}
function UF(t, e, n, r) {
  const i = typeof n == "string" ? parseInt(n, 10) : NaN;
  switch (t) {
    case "first":
    case "lt":
      return e;
    case "last":
      return e.length > 0 ? [e[e.length - 1]] : e;
    case "nth":
    case "eq":
      return isFinite(i) && Math.abs(i) < e.length ? [i < 0 ? e[e.length + i] : e[i]] : [];
    case "gt":
      return isFinite(i) ? e.slice(i + 1) : [];
    case "even":
      return e.filter((s, a) => a % 2 === 0);
    case "odd":
      return e.filter((s, a) => a % 2 === 1);
    case "not": {
      const s = new Set(lI(n, e, r));
      return e.filter((a) => !s.has(a));
    }
  }
}
function uI(t, e, n = {}) {
  return lI(Y0(t), e, n);
}
function lI(t, e, n) {
  if (e.length === 0)
    return [];
  const [r, i] = yv(t);
  let s;
  if (r.length) {
    const a = ub(e, r, n);
    if (i.length === 0)
      return a;
    a.length && (s = new Set(a));
  }
  for (let a = 0; a < i.length && (s == null ? void 0 : s.size) !== e.length; a++) {
    const o = i[a];
    if ((s ? e.filter((d) => Lt(d) && !s.has(d)) : e).length === 0)
      break;
    const c = cI(o, e, n);
    if (c.length)
      if (s)
        c.forEach((d) => s.add(d));
      else {
        if (a === i.length - 1)
          return c;
        s = new Set(c);
      }
  }
  return typeof s < "u" ? s.size === e.length ? e : (
    // Filter elements to preserve order
    e.filter((a) => s.has(a))
  ) : [];
}
function cI(t, e, n) {
  var r;
  if (t.some(uf)) {
    const i = (r = n.root) !== null && r !== void 0 ? r : RF(e[0]), s = { ...n, context: e, relativeSelector: !1 };
    return t.push(FF), zm(i, t, s, !0, e.length);
  }
  return zm(e, t, n, !1, e.length);
}
function $F(t, e, n = {}, r = 1 / 0) {
  if (typeof t == "function")
    return dI(e, t);
  const [i, s] = yv(Y0(t)), a = s.map((o) => zm(e, o, n, !0, r));
  return i.length && a.push(ob(e, i, n, r)), a.length === 0 ? [] : a.length === 1 ? a[0] : Nc(a.reduce((o, u) => [...o, ...u]));
}
function zm(t, e, n, r, i) {
  const s = e.findIndex(jm), a = e.slice(0, s), o = e[s], u = e.length - 1 === s ? i : 1 / 0, c = PF(o.name, o.data, u);
  if (c === 0)
    return [];
  const l = (a.length === 0 && !Array.isArray(t) ? Q0(t).filter(Lt) : a.length === 0 ? (Array.isArray(t) ? t : [t]).filter(Lt) : r || a.some(uf) ? ob(t, [a], n, c) : ub(t, [a], n)).slice(0, c);
  let f = UF(o.name, l, o.data, n);
  if (f.length === 0 || e.length === s + 1)
    return f;
  const p = e.slice(s + 1), m = p.some(uf);
  if (m) {
    if (uf(p[0])) {
      const { type: g } = p[0];
      (g === Mt.Sibling || g === Mt.Adjacent) && (f = sI(f, G0, !0)), p.unshift(BF);
    }
    n = {
      ...n,
      // Avoid absolutizing the selector
      relativeSelector: !1,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (g) => f.includes(g)
    };
  } else n.rootFunc && n.rootFunc !== Hm.trueFunc && (n = { ...n, rootFunc: Hm.trueFunc });
  return p.some(jm) ? zm(f, p, n, !1, i) : m ? (
    // Query existing elements to resolve traversal.
    ob(f, [p], n, i)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    ub(f, [p], n)
  );
}
function ob(t, e, n, r) {
  const i = bv(e, n, t);
  return dI(t, i, r);
}
function dI(t, e, n = 1 / 0) {
  const r = sI(t, G0, e.shouldTestNextSiblings);
  return hv((i) => Lt(i) && e(i), r, !0, n);
}
function ub(t, e, n) {
  const r = (Array.isArray(t) ? t : [t]).filter(Lt);
  if (r.length === 0)
    return r;
  const i = bv(e, n);
  return i === Hm.trueFunc ? r : r.filter(i);
}
const HF = /^\s*[+~]/;
function jF(t) {
  if (!t)
    return this._make([]);
  if (typeof t != "string") {
    const e = Fa(t) ? t.toArray() : [t], n = this.toArray();
    return this._make(e.filter((r) => n.some((i) => z6(i, r))));
  }
  return this._findBySelector(t, Number.POSITIVE_INFINITY);
}
function zF(t, e) {
  var n;
  const r = this.toArray(), i = HF.test(t) ? r : this.children().toArray(), s = {
    context: r,
    root: (n = this._root) === null || n === void 0 ? void 0 : n[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make($F(t, i, s, e));
}
function vv(t) {
  return function(e, ...n) {
    return function(r) {
      var i;
      let s = t(e, this);
      return r && (s = Ev(s, r, this.options.xmlMode, (i = this._root) === null || i === void 0 ? void 0 : i[0])), this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && s.length > 1 ? n.reduce((a, o) => o(a), s) : s
      );
    };
  };
}
const fh = vv((t, e) => {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    const i = t(e[r]);
    i.length > 0 && (n = n.concat(i));
  }
  return n;
}), Tv = vv((t, e) => {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = t(e[r]);
    i !== null && n.push(i);
  }
  return n;
});
function _v(t, ...e) {
  let n = null;
  const r = vv((i, s) => {
    const a = [];
    return tr(s, (o) => {
      for (let u; (u = i(o)) && !(n != null && n(u, a.length)); o = u)
        a.push(u);
    }), a;
  })(t, ...e);
  return function(i, s) {
    n = typeof i == "string" ? (o) => aI(o, i, this.options) : i ? hh(i) : null;
    const a = r.call(this, s);
    return n = null, a;
  };
}
function Lc(t) {
  return t.length > 1 ? Array.from(new Set(t)) : t;
}
const qF = Tv(({ parent: t }) => t && !Lo(t) ? t : null, Lc), VF = fh((t) => {
  const e = [];
  for (; t.parent && !Lo(t.parent); )
    e.push(t.parent), t = t.parent;
  return e;
}, Nc, (t) => t.reverse()), WF = _v(({ parent: t }) => t && !Lo(t) ? t : null, Nc, (t) => t.reverse());
function QF(t) {
  var e;
  const n = [];
  if (!t)
    return this._make(n);
  const r = {
    xmlMode: this.options.xmlMode,
    root: (e = this._root) === null || e === void 0 ? void 0 : e[0]
  }, i = typeof t == "string" ? (s) => aI(s, t, r) : hh(t);
  return tr(this, (s) => {
    for (s && !Lo(s) && !Lt(s) && (s = s.parent); s && Lt(s); ) {
      if (i(s, 0)) {
        n.includes(s) || n.push(s);
        break;
      }
      s = s.parent;
    }
  }), this._make(n);
}
const GF = Tv((t) => dv(t)), YF = fh((t) => {
  const e = [];
  for (; t.next; )
    t = t.next, Lt(t) && e.push(t);
  return e;
}, Lc), XF = _v((t) => dv(t), Lc), KF = Tv((t) => fv(t)), ZF = fh((t) => {
  const e = [];
  for (; t.prev; )
    t = t.prev, Lt(t) && e.push(t);
  return e;
}, Lc), JF = _v((t) => fv(t), Lc), eU = fh((t) => B6(t).filter((e) => Lt(e) && e !== t), Nc), tU = fh((t) => Q0(t).filter(Lt), Lc);
function nU() {
  const t = this.toArray().reduce((e, n) => hr(n) ? e.concat(n.children) : e, []);
  return this._make(t);
}
function rU(t) {
  let e = 0;
  const n = this.length;
  for (; e < n && t.call(this[e], e, this[e]) !== !1; )
    ++e;
  return this;
}
function iU(t) {
  let e = [];
  for (let n = 0; n < this.length; n++) {
    const r = this[n], i = t.call(r, n, r);
    i != null && (e = e.concat(i));
  }
  return this._make(e);
}
function hh(t) {
  return typeof t == "function" ? (e, n) => t.call(e, n, e) : Fa(t) ? (e) => Array.prototype.includes.call(t, e) : function(e) {
    return t === e;
  };
}
function sU(t) {
  var e;
  return this._make(Ev(this.toArray(), t, this.options.xmlMode, (e = this._root) === null || e === void 0 ? void 0 : e[0]));
}
function Ev(t, e, n, r) {
  return typeof e == "string" ? uI(e, t, { xmlMode: n, root: r }) : t.filter(hh(e));
}
function aU(t) {
  const e = this.toArray();
  return typeof t == "string" ? oI(e.filter(Lt), t, this.options) : t ? e.some(hh(t)) : !1;
}
function oU(t) {
  let e = this.toArray();
  if (typeof t == "string") {
    const n = new Set(uI(t, e, this.options));
    e = e.filter((r) => !n.has(r));
  } else {
    const n = hh(t);
    e = e.filter((r, i) => !n(r, i));
  }
  return this._make(e);
}
function uU(t) {
  return this.filter(typeof t == "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${t})`
  ) : (e, n) => this._make(n).find(t).length > 0);
}
function lU() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function cU() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function dU(t) {
  var e;
  return t = +t, t === 0 && this.length <= 1 ? this : (t < 0 && (t = this.length + t), this._make((e = this[t]) !== null && e !== void 0 ? e : []));
}
function fU(t) {
  return t == null ? this.toArray() : this[t < 0 ? this.length + t : t];
}
function hU() {
  return Array.prototype.slice.call(this);
}
function pU(t) {
  let e, n;
  return t == null ? (e = this.parent().children(), n = this[0]) : typeof t == "string" ? (e = this._make(t), n = this[0]) : (e = this, n = Fa(t) ? t[0] : t), Array.prototype.indexOf.call(e, n);
}
function mU(t, e) {
  return this._make(Array.prototype.slice.call(this, t, e));
}
function gU() {
  var t;
  return (t = this.prevObject) !== null && t !== void 0 ? t : this._make([]);
}
function AU(t, e) {
  const n = this._make(t, e), r = Nc([...this.get(), ...n.get()]);
  return this._make(r);
}
function bU(t) {
  return this.prevObject ? this.add(t ? this.prevObject.filter(t) : this.prevObject) : this;
}
const yU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _findBySelector: zF,
  add: AU,
  addBack: bU,
  children: tU,
  closest: QF,
  contents: nU,
  each: rU,
  end: gU,
  eq: dU,
  filter: sU,
  filterArray: Ev,
  find: jF,
  first: lU,
  get: fU,
  has: uU,
  index: pU,
  is: aU,
  last: cU,
  map: iU,
  next: GF,
  nextAll: YF,
  nextUntil: XF,
  not: oU,
  parent: qF,
  parents: VF,
  parentsUntil: WF,
  prev: KF,
  prevAll: ZF,
  prevUntil: JF,
  siblings: eU,
  slice: mU,
  toArray: hU
}, Symbol.toStringTag, { value: "Module" }));
function vU(t) {
  return function(n, r, i, s) {
    if (typeof Buffer < "u" && Buffer.isBuffer(n) && (n = n.toString()), typeof n == "string")
      return t(n, r, i, s);
    const a = n;
    if (!Array.isArray(a) && Lo(a))
      return a;
    const o = new Ru([]);
    return Bu(a, o), o;
  };
}
function Bu(t, e) {
  const n = Array.isArray(t) ? t : [t];
  e ? e.children = n : e = null;
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    i.parent && i.parent.children !== n && Xu(i), e ? (i.prev = n[r - 1] || null, i.next = n[r + 1] || null) : i.prev = i.next = null, i.parent = e;
  }
  return e;
}
function TU(t, e) {
  if (t == null)
    return [];
  if (typeof t == "string")
    return this._parse(t, this.options, !1, null).children.slice(0);
  if ("length" in t) {
    if (t.length === 1)
      return this._makeDomArray(t[0], e);
    const n = [];
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      if (typeof i == "object") {
        if (i == null)
          continue;
        if (!("length" in i)) {
          n.push(e ? Mf(i, !0) : i);
          continue;
        }
      }
      n.push(...this._makeDomArray(i, e));
    }
    return n;
  }
  return [e ? Mf(t, !0) : t];
}
function fI(t) {
  return function(...e) {
    const n = this.length - 1;
    return tr(this, (r, i) => {
      if (!hr(r))
        return;
      const s = typeof e[0] == "function" ? e[0].call(r, i, this._render(r.children)) : e, a = this._makeDomArray(s, i < n);
      t(a, r.children, r);
    });
  };
}
function Po(t, e, n, r, i) {
  var s, a;
  const o = [
    e,
    n,
    ...r
  ], u = e === 0 ? null : t[e - 1], c = e + n >= t.length ? null : t[e + n];
  for (let d = 0; d < r.length; ++d) {
    const l = r[d], f = l.parent;
    if (f) {
      const m = f.children.indexOf(l);
      m !== -1 && (f.children.splice(m, 1), i === f && e > m && o[0]--);
    }
    l.parent = i, l.prev && (l.prev.next = (s = l.next) !== null && s !== void 0 ? s : null), l.next && (l.next.prev = (a = l.prev) !== null && a !== void 0 ? a : null), l.prev = d === 0 ? u : r[d - 1], l.next = d === r.length - 1 ? c : r[d + 1];
  }
  return u && (u.next = r[0]), c && (c.prev = r[r.length - 1]), t.splice(...o);
}
function _U(t) {
  return (Fa(t) ? t : this._make(t)).append(this), this;
}
function EU(t) {
  return (Fa(t) ? t : this._make(t)).prepend(this), this;
}
const xU = fI((t, e, n) => {
  Po(e, e.length, 0, t, n);
}), wU = fI((t, e, n) => {
  Po(e, 0, 0, t, n);
});
function hI(t) {
  return function(e) {
    const n = this.length - 1, r = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const s = this[i], a = typeof e == "function" ? e.call(s, i, s) : typeof e == "string" && !nb(e) ? r.find(e).clone() : e, [o] = this._makeDomArray(a, i < n);
      if (!o || !hr(o))
        continue;
      let u = o, c = 0;
      for (; c < u.children.length; ) {
        const d = u.children[c];
        Lt(d) ? (u = d, c = 0) : c++;
      }
      t(s, u, [o]);
    }
    return this;
  };
}
const CU = hI((t, e, n) => {
  const { parent: r } = t;
  if (!r)
    return;
  const i = r.children, s = i.indexOf(t);
  Bu([t], e), Po(i, s, 0, n, r);
}), SU = hI((t, e, n) => {
  hr(t) && (Bu(t.children, e), Bu(n, t));
});
function IU(t) {
  return this.parent(t).not("body").each((e, n) => {
    this._make(n).replaceWith(n.children);
  }), this;
}
function kU(t) {
  const e = this[0];
  if (e) {
    const n = this._make(typeof t == "function" ? t.call(e, 0, e) : t).insertBefore(e);
    let r;
    for (let s = 0; s < n.length; s++)
      n[s].type === J2 && (r = n[s]);
    let i = 0;
    for (; r && i < r.children.length; ) {
      const s = r.children[i];
      s.type === J2 ? (r = s, i = 0) : i++;
    }
    r && this._make(r).append(this);
  }
  return this;
}
function DU(...t) {
  const e = this.length - 1;
  return tr(this, (n, r) => {
    if (!hr(n) || !n.parent)
      return;
    const i = n.parent.children, s = i.indexOf(n);
    if (s === -1)
      return;
    const a = typeof t[0] == "function" ? t[0].call(n, r, this._render(n.children)) : t, o = this._makeDomArray(a, r < e);
    Po(i, s + 1, 0, o, n.parent);
  });
}
function MU(t) {
  typeof t == "string" && (t = this._make(t)), this.remove();
  const e = [];
  for (const n of this._makeDomArray(t)) {
    const r = this.clone().toArray(), { parent: i } = n;
    if (!i)
      continue;
    const s = i.children, a = s.indexOf(n);
    a !== -1 && (Po(s, a + 1, 0, r, i), e.push(...r));
  }
  return this._make(e);
}
function OU(...t) {
  const e = this.length - 1;
  return tr(this, (n, r) => {
    if (!hr(n) || !n.parent)
      return;
    const i = n.parent.children, s = i.indexOf(n);
    if (s === -1)
      return;
    const a = typeof t[0] == "function" ? t[0].call(n, r, this._render(n.children)) : t, o = this._makeDomArray(a, r < e);
    Po(i, s, 0, o, n.parent);
  });
}
function NU(t) {
  const e = this._make(t);
  this.remove();
  const n = [];
  return tr(e, (r) => {
    const i = this.clone().toArray(), { parent: s } = r;
    if (!s)
      return;
    const a = s.children, o = a.indexOf(r);
    o !== -1 && (Po(a, o, 0, i, s), n.push(...i));
  }), this._make(n);
}
function LU(t) {
  const e = t ? this.filter(t) : this;
  return tr(e, (n) => {
    Xu(n), n.prev = n.next = n.parent = null;
  }), this;
}
function PU(t) {
  return tr(this, (e, n) => {
    const { parent: r } = e;
    if (!r)
      return;
    const i = r.children, s = typeof t == "function" ? t.call(e, n, e) : t, a = this._makeDomArray(s);
    Bu(a, null);
    const o = i.indexOf(e);
    Po(i, o, 1, a, r), a.includes(e) || (e.parent = e.prev = e.next = null);
  });
}
function RU() {
  return tr(this, (t) => {
    if (hr(t)) {
      for (const e of t.children)
        e.next = e.prev = e.parent = null;
      t.children.length = 0;
    }
  });
}
function BU(t) {
  if (t === void 0) {
    const e = this[0];
    return !e || !hr(e) ? null : this._render(e.children);
  }
  return tr(this, (e) => {
    if (!hr(e))
      return;
    for (const r of e.children)
      r.next = r.prev = r.parent = null;
    const n = Fa(t) ? t.toArray() : this._parse(`${t}`, this.options, !1, e).children;
    Bu(n, e);
  });
}
function FU() {
  return this._render(this);
}
function UU(t) {
  return t === void 0 ? Of(this) : typeof t == "function" ? tr(this, (e, n) => this._make(e).text(t.call(e, n, Of([e])))) : tr(this, (e) => {
    if (!hr(e))
      return;
    for (const r of e.children)
      r.next = r.prev = r.parent = null;
    const n = new Df(`${t}`);
    Bu(n, e);
  });
}
function $U() {
  const t = Array.prototype.map.call(this.get(), (n) => Mf(n, !0)), e = new Ru(t);
  for (const n of t)
    n.parent = e;
  return this._make(t);
}
const HU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _makeDomArray: TU,
  after: DU,
  append: xU,
  appendTo: _U,
  before: OU,
  clone: $U,
  empty: RU,
  html: BU,
  insertAfter: MU,
  insertBefore: NU,
  prepend: wU,
  prependTo: EU,
  remove: LU,
  replaceWith: PU,
  text: UU,
  toString: FU,
  unwrap: IU,
  wrap: CU,
  wrapAll: kU,
  wrapInner: SU
}, Symbol.toStringTag, { value: "Module" }));
function jU(t, e) {
  if (t != null && e != null || // When `prop` is a "plain" object
  typeof t == "object" && !Array.isArray(t))
    return tr(this, (n, r) => {
      Lt(n) && pI(n, t, e, r);
    });
  if (this.length !== 0)
    return mI(this[0], t);
}
function pI(t, e, n, r) {
  if (typeof e == "string") {
    const i = mI(t), s = typeof n == "function" ? n.call(t, r, i[e]) : n;
    s === "" ? delete i[e] : s != null && (i[e] = s), t.attribs.style = zU(i);
  } else if (typeof e == "object") {
    const i = Object.keys(e);
    for (let s = 0; s < i.length; s++) {
      const a = i[s];
      pI(t, a, e[a], s);
    }
  }
}
function mI(t, e) {
  if (!t || !Lt(t))
    return;
  const n = qU(t.attribs.style);
  if (typeof e == "string")
    return n[e];
  if (Array.isArray(e)) {
    const r = {};
    for (const i of e)
      n[i] != null && (r[i] = n[i]);
    return r;
  }
  return n;
}
function zU(t) {
  return Object.keys(t).reduce((e, n) => `${e}${e ? " " : ""}${n}: ${t[n]};`, "");
}
function qU(t) {
  if (t = (t || "").trim(), !t)
    return {};
  const e = {};
  let n;
  for (const r of t.split(";")) {
    const i = r.indexOf(":");
    if (i < 1 || i === r.length - 1) {
      const s = r.trimEnd();
      s.length > 0 && n !== void 0 && (e[n] += `;${s}`);
    } else
      n = r.slice(0, i).trim(), e[n] = r.slice(i + 1).trim();
  }
  return e;
}
const VU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  css: jU
}, Symbol.toStringTag, { value: "Module" })), Y3 = "input,select,textarea,keygen", WU = /%20/g, X3 = /\r?\n/g;
function QU() {
  return this.serializeArray().map((n) => `${encodeURIComponent(n.name)}=${encodeURIComponent(n.value)}`).join("&").replace(WU, "+");
}
function GU() {
  return this.map((t, e) => {
    const n = this._make(e);
    return Lt(e) && e.name === "form" ? n.find(Y3).toArray() : n.filter(Y3).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
  ).map((t, e) => {
    var n;
    const r = this._make(e), i = r.attr("name"), s = (n = r.val()) !== null && n !== void 0 ? n : "";
    return Array.isArray(s) ? s.map((a) => (
      /*
       * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
       * These can occur inside of `<textarea>'s`
       */
      { name: i, value: a.replace(X3, `\r
`) }
    )) : { name: i, value: s.replace(X3, `\r
`) };
  }).toArray();
}
const YU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  serialize: QU,
  serializeArray: GU
}, Symbol.toStringTag, { value: "Module" }));
function XU(t) {
  var e;
  return typeof t == "string" ? { selector: t, value: "textContent" } : {
    selector: t.selector,
    value: (e = t.value) !== null && e !== void 0 ? e : "textContent"
  };
}
function KU(t) {
  const e = {};
  for (const n in t) {
    const r = t[n], i = Array.isArray(r), { selector: s, value: a } = XU(i ? r[0] : r), o = typeof a == "function" ? a : typeof a == "string" ? (u) => this._make(u).prop(a) : (u) => this._make(u).extract(a);
    if (i)
      e[n] = this._findBySelector(s, Number.POSITIVE_INFINITY).map((u, c) => o(c, n, e)).get();
    else {
      const u = this._findBySelector(s, 1);
      e[n] = u.length > 0 ? o(u[0], n, e) : void 0;
    }
  }
  return e;
}
const ZU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extract: KU
}, Symbol.toStringTag, { value: "Module" }));
class ph {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(e, n, r) {
    if (this.length = 0, this.options = r, this._root = n, e) {
      for (let i = 0; i < e.length; i++)
        this[i] = e[i];
      this.length = e.length;
    }
  }
}
ph.prototype.cheerio = "[cheerio object]";
ph.prototype.splice = Array.prototype.splice;
ph.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(ph.prototype, rF, yU, HU, VU, YU, ZU);
function JU(t, e) {
  return function n(r, i, s = !0) {
    if (r == null)
      throw new Error("cheerio.load() expects a string");
    const a = tb(i), o = t(r, a, s, null);
    class u extends ph {
      _make(l, f) {
        const p = c(l, f);
        return p.prevObject = this, p;
      }
      _parse(l, f, p, m) {
        return t(l, f, p, m);
      }
      _render(l) {
        return e(l, this.options);
      }
    }
    function c(d, l, f = o, p) {
      if (d && Fa(d))
        return d;
      const m = tb(p, a), g = typeof f == "string" ? [t(f, m, !1, null)] : "length" in f ? f : [f], y = Fa(g) ? g : new u(g, null, m);
      if (y._root = y, !d)
        return new u(void 0, y, m);
      const b = typeof d == "string" && nb(d) ? (
        // $(<html>)
        t(d, m, !1, null).children
      ) : e$(d) ? (
        // $(dom)
        [d]
      ) : Array.isArray(d) ? (
        // $([dom])
        d
      ) : void 0, E = new u(b, y, m);
      if (b)
        return E;
      if (typeof d != "string")
        throw new TypeError("Unexpected type of selector");
      let v = d;
      const _ = l ? (
        // If we don't have a context, maybe we have a root, from loading
        typeof l == "string" ? nb(l) ? (
          // $('li', '<ul>...</ul>')
          new u([t(l, m, !1, null)], y, m)
        ) : (
          // $('li', 'ul')
          (v = `${l} ${v}`, y)
        ) : Fa(l) ? (
          // $('li', $)
          l
        ) : (
          // $('li', node), $('li', [nodes])
          new u(Array.isArray(l) ? l : [l], y, m)
        )
      ) : y;
      return _ ? _.find(v) : E;
    }
    return Object.assign(c, DB, {
      load: n,
      // `_root` and `_options` are used in static methods.
      _root: o,
      _options: a,
      // Add `fn` for plugins
      fn: u.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: u.prototype
    }), c;
  };
}
function e$(t) {
  return (
    // @ts-expect-error: TS doesn't know about the `name` property.
    !!t.name || // @ts-expect-error: TS doesn't know about the `type` property.
    t.type === sv || // @ts-expect-error: TS doesn't know about the `type` property.
    t.type === k6 || // @ts-expect-error: TS doesn't know about the `type` property.
    t.type === D6
  );
}
const t$ = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), Gn = "�";
var ae;
(function(t) {
  t[t.EOF = -1] = "EOF", t[t.NULL = 0] = "NULL", t[t.TABULATION = 9] = "TABULATION", t[t.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", t[t.LINE_FEED = 10] = "LINE_FEED", t[t.FORM_FEED = 12] = "FORM_FEED", t[t.SPACE = 32] = "SPACE", t[t.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", t[t.QUOTATION_MARK = 34] = "QUOTATION_MARK", t[t.AMPERSAND = 38] = "AMPERSAND", t[t.APOSTROPHE = 39] = "APOSTROPHE", t[t.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", t[t.SOLIDUS = 47] = "SOLIDUS", t[t.DIGIT_0 = 48] = "DIGIT_0", t[t.DIGIT_9 = 57] = "DIGIT_9", t[t.SEMICOLON = 59] = "SEMICOLON", t[t.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", t[t.EQUALS_SIGN = 61] = "EQUALS_SIGN", t[t.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", t[t.QUESTION_MARK = 63] = "QUESTION_MARK", t[t.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", t[t.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", t[t.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", t[t.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", t[t.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", t[t.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(ae || (ae = {}));
const yi = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function gI(t) {
  return t >= 55296 && t <= 57343;
}
function n$(t) {
  return t >= 56320 && t <= 57343;
}
function r$(t, e) {
  return (t - 55296) * 1024 + 9216 + e;
}
function AI(t) {
  return t !== 32 && t !== 10 && t !== 13 && t !== 9 && t !== 12 && t >= 1 && t <= 31 || t >= 127 && t <= 159;
}
function bI(t) {
  return t >= 64976 && t <= 65007 || t$.has(t);
}
var Ue;
(function(t) {
  t.controlCharacterInInputStream = "control-character-in-input-stream", t.noncharacterInInputStream = "noncharacter-in-input-stream", t.surrogateInInputStream = "surrogate-in-input-stream", t.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", t.endTagWithAttributes = "end-tag-with-attributes", t.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", t.unexpectedSolidusInTag = "unexpected-solidus-in-tag", t.unexpectedNullCharacter = "unexpected-null-character", t.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", t.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", t.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", t.missingEndTagName = "missing-end-tag-name", t.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", t.unknownNamedCharacterReference = "unknown-named-character-reference", t.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", t.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", t.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", t.eofBeforeTagName = "eof-before-tag-name", t.eofInTag = "eof-in-tag", t.missingAttributeValue = "missing-attribute-value", t.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", t.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", t.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", t.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", t.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", t.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", t.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", t.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", t.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", t.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", t.cdataInHtmlContent = "cdata-in-html-content", t.incorrectlyOpenedComment = "incorrectly-opened-comment", t.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", t.eofInDoctype = "eof-in-doctype", t.nestedComment = "nested-comment", t.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", t.eofInComment = "eof-in-comment", t.incorrectlyClosedComment = "incorrectly-closed-comment", t.eofInCdata = "eof-in-cdata", t.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", t.nullCharacterReference = "null-character-reference", t.surrogateCharacterReference = "surrogate-character-reference", t.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", t.controlCharacterReference = "control-character-reference", t.noncharacterCharacterReference = "noncharacter-character-reference", t.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", t.missingDoctypeName = "missing-doctype-name", t.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", t.duplicateAttribute = "duplicate-attribute", t.nonConformingDoctype = "non-conforming-doctype", t.missingDoctype = "missing-doctype", t.misplacedDoctype = "misplaced-doctype", t.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", t.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", t.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", t.openElementsLeftAfterEof = "open-elements-left-after-eof", t.abandonedHeadElementChild = "abandoned-head-element-child", t.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", t.nestedNoscriptInHead = "nested-noscript-in-head", t.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(Ue || (Ue = {}));
const i$ = 65536;
class s$ {
  constructor(e) {
    this.handler = e, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = i$, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(e, n) {
    const { line: r, col: i, offset: s } = this, a = i + n, o = s + n;
    return {
      code: e,
      startLine: r,
      endLine: r,
      startCol: a,
      endCol: a,
      startOffset: o,
      endOffset: o
    };
  }
  _err(e) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(e, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(e) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (n$(n))
        return this.pos++, this._addGap(), r$(e, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, ae.EOF;
    return this._err(Ue.surrogateInInputStream), e;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(e, n) {
    this.html.length > 0 ? this.html += e : this.html = e, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(e) {
    this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(e, n) {
    if (this.pos + e.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(e, this.pos);
    for (let r = 0; r < e.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== e.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(e) {
    const n = this.pos + e;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, ae.EOF;
    const r = this.html.charCodeAt(n);
    return r === ae.CARRIAGE_RETURN ? ae.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, ae.EOF;
    let e = this.html.charCodeAt(this.pos);
    return e === ae.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, ae.LINE_FEED) : e === ae.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, gI(e) && (e = this._processSurrogate(e)), this.handler.onParseError === null || e > 31 && e < 127 || e === ae.LINE_FEED || e === ae.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e);
  }
  _checkForProblematicCharacters(e) {
    AI(e) ? this._err(Ue.controlCharacterInInputStream) : bI(e) && this._err(Ue.noncharacterInInputStream);
  }
  retreat(e) {
    for (this.pos -= e; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var fn;
(function(t) {
  t[t.CHARACTER = 0] = "CHARACTER", t[t.NULL_CHARACTER = 1] = "NULL_CHARACTER", t[t.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", t[t.START_TAG = 3] = "START_TAG", t[t.END_TAG = 4] = "END_TAG", t[t.COMMENT = 5] = "COMMENT", t[t.DOCTYPE = 6] = "DOCTYPE", t[t.EOF = 7] = "EOF", t[t.HIBERNATION = 8] = "HIBERNATION";
})(fn || (fn = {}));
function yI(t, e) {
  for (let n = t.attrs.length - 1; n >= 0; n--)
    if (t.attrs[n].name === e)
      return t.attrs[n].value;
  return null;
}
var Ye;
(function(t) {
  t.HTML = "http://www.w3.org/1999/xhtml", t.MATHML = "http://www.w3.org/1998/Math/MathML", t.SVG = "http://www.w3.org/2000/svg", t.XLINK = "http://www.w3.org/1999/xlink", t.XML = "http://www.w3.org/XML/1998/namespace", t.XMLNS = "http://www.w3.org/2000/xmlns/";
})(Ye || (Ye = {}));
var wu;
(function(t) {
  t.TYPE = "type", t.ACTION = "action", t.ENCODING = "encoding", t.PROMPT = "prompt", t.NAME = "name", t.COLOR = "color", t.FACE = "face", t.SIZE = "size";
})(wu || (wu = {}));
var zi;
(function(t) {
  t.NO_QUIRKS = "no-quirks", t.QUIRKS = "quirks", t.LIMITED_QUIRKS = "limited-quirks";
})(zi || (zi = {}));
var De;
(function(t) {
  t.A = "a", t.ADDRESS = "address", t.ANNOTATION_XML = "annotation-xml", t.APPLET = "applet", t.AREA = "area", t.ARTICLE = "article", t.ASIDE = "aside", t.B = "b", t.BASE = "base", t.BASEFONT = "basefont", t.BGSOUND = "bgsound", t.BIG = "big", t.BLOCKQUOTE = "blockquote", t.BODY = "body", t.BR = "br", t.BUTTON = "button", t.CAPTION = "caption", t.CENTER = "center", t.CODE = "code", t.COL = "col", t.COLGROUP = "colgroup", t.DD = "dd", t.DESC = "desc", t.DETAILS = "details", t.DIALOG = "dialog", t.DIR = "dir", t.DIV = "div", t.DL = "dl", t.DT = "dt", t.EM = "em", t.EMBED = "embed", t.FIELDSET = "fieldset", t.FIGCAPTION = "figcaption", t.FIGURE = "figure", t.FONT = "font", t.FOOTER = "footer", t.FOREIGN_OBJECT = "foreignObject", t.FORM = "form", t.FRAME = "frame", t.FRAMESET = "frameset", t.H1 = "h1", t.H2 = "h2", t.H3 = "h3", t.H4 = "h4", t.H5 = "h5", t.H6 = "h6", t.HEAD = "head", t.HEADER = "header", t.HGROUP = "hgroup", t.HR = "hr", t.HTML = "html", t.I = "i", t.IMG = "img", t.IMAGE = "image", t.INPUT = "input", t.IFRAME = "iframe", t.KEYGEN = "keygen", t.LABEL = "label", t.LI = "li", t.LINK = "link", t.LISTING = "listing", t.MAIN = "main", t.MALIGNMARK = "malignmark", t.MARQUEE = "marquee", t.MATH = "math", t.MENU = "menu", t.META = "meta", t.MGLYPH = "mglyph", t.MI = "mi", t.MO = "mo", t.MN = "mn", t.MS = "ms", t.MTEXT = "mtext", t.NAV = "nav", t.NOBR = "nobr", t.NOFRAMES = "noframes", t.NOEMBED = "noembed", t.NOSCRIPT = "noscript", t.OBJECT = "object", t.OL = "ol", t.OPTGROUP = "optgroup", t.OPTION = "option", t.P = "p", t.PARAM = "param", t.PLAINTEXT = "plaintext", t.PRE = "pre", t.RB = "rb", t.RP = "rp", t.RT = "rt", t.RTC = "rtc", t.RUBY = "ruby", t.S = "s", t.SCRIPT = "script", t.SEARCH = "search", t.SECTION = "section", t.SELECT = "select", t.SOURCE = "source", t.SMALL = "small", t.SPAN = "span", t.STRIKE = "strike", t.STRONG = "strong", t.STYLE = "style", t.SUB = "sub", t.SUMMARY = "summary", t.SUP = "sup", t.TABLE = "table", t.TBODY = "tbody", t.TEMPLATE = "template", t.TEXTAREA = "textarea", t.TFOOT = "tfoot", t.TD = "td", t.TH = "th", t.THEAD = "thead", t.TITLE = "title", t.TR = "tr", t.TRACK = "track", t.TT = "tt", t.U = "u", t.UL = "ul", t.SVG = "svg", t.VAR = "var", t.WBR = "wbr", t.XMP = "xmp";
})(De || (De = {}));
var w;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.A = 1] = "A", t[t.ADDRESS = 2] = "ADDRESS", t[t.ANNOTATION_XML = 3] = "ANNOTATION_XML", t[t.APPLET = 4] = "APPLET", t[t.AREA = 5] = "AREA", t[t.ARTICLE = 6] = "ARTICLE", t[t.ASIDE = 7] = "ASIDE", t[t.B = 8] = "B", t[t.BASE = 9] = "BASE", t[t.BASEFONT = 10] = "BASEFONT", t[t.BGSOUND = 11] = "BGSOUND", t[t.BIG = 12] = "BIG", t[t.BLOCKQUOTE = 13] = "BLOCKQUOTE", t[t.BODY = 14] = "BODY", t[t.BR = 15] = "BR", t[t.BUTTON = 16] = "BUTTON", t[t.CAPTION = 17] = "CAPTION", t[t.CENTER = 18] = "CENTER", t[t.CODE = 19] = "CODE", t[t.COL = 20] = "COL", t[t.COLGROUP = 21] = "COLGROUP", t[t.DD = 22] = "DD", t[t.DESC = 23] = "DESC", t[t.DETAILS = 24] = "DETAILS", t[t.DIALOG = 25] = "DIALOG", t[t.DIR = 26] = "DIR", t[t.DIV = 27] = "DIV", t[t.DL = 28] = "DL", t[t.DT = 29] = "DT", t[t.EM = 30] = "EM", t[t.EMBED = 31] = "EMBED", t[t.FIELDSET = 32] = "FIELDSET", t[t.FIGCAPTION = 33] = "FIGCAPTION", t[t.FIGURE = 34] = "FIGURE", t[t.FONT = 35] = "FONT", t[t.FOOTER = 36] = "FOOTER", t[t.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", t[t.FORM = 38] = "FORM", t[t.FRAME = 39] = "FRAME", t[t.FRAMESET = 40] = "FRAMESET", t[t.H1 = 41] = "H1", t[t.H2 = 42] = "H2", t[t.H3 = 43] = "H3", t[t.H4 = 44] = "H4", t[t.H5 = 45] = "H5", t[t.H6 = 46] = "H6", t[t.HEAD = 47] = "HEAD", t[t.HEADER = 48] = "HEADER", t[t.HGROUP = 49] = "HGROUP", t[t.HR = 50] = "HR", t[t.HTML = 51] = "HTML", t[t.I = 52] = "I", t[t.IMG = 53] = "IMG", t[t.IMAGE = 54] = "IMAGE", t[t.INPUT = 55] = "INPUT", t[t.IFRAME = 56] = "IFRAME", t[t.KEYGEN = 57] = "KEYGEN", t[t.LABEL = 58] = "LABEL", t[t.LI = 59] = "LI", t[t.LINK = 60] = "LINK", t[t.LISTING = 61] = "LISTING", t[t.MAIN = 62] = "MAIN", t[t.MALIGNMARK = 63] = "MALIGNMARK", t[t.MARQUEE = 64] = "MARQUEE", t[t.MATH = 65] = "MATH", t[t.MENU = 66] = "MENU", t[t.META = 67] = "META", t[t.MGLYPH = 68] = "MGLYPH", t[t.MI = 69] = "MI", t[t.MO = 70] = "MO", t[t.MN = 71] = "MN", t[t.MS = 72] = "MS", t[t.MTEXT = 73] = "MTEXT", t[t.NAV = 74] = "NAV", t[t.NOBR = 75] = "NOBR", t[t.NOFRAMES = 76] = "NOFRAMES", t[t.NOEMBED = 77] = "NOEMBED", t[t.NOSCRIPT = 78] = "NOSCRIPT", t[t.OBJECT = 79] = "OBJECT", t[t.OL = 80] = "OL", t[t.OPTGROUP = 81] = "OPTGROUP", t[t.OPTION = 82] = "OPTION", t[t.P = 83] = "P", t[t.PARAM = 84] = "PARAM", t[t.PLAINTEXT = 85] = "PLAINTEXT", t[t.PRE = 86] = "PRE", t[t.RB = 87] = "RB", t[t.RP = 88] = "RP", t[t.RT = 89] = "RT", t[t.RTC = 90] = "RTC", t[t.RUBY = 91] = "RUBY", t[t.S = 92] = "S", t[t.SCRIPT = 93] = "SCRIPT", t[t.SEARCH = 94] = "SEARCH", t[t.SECTION = 95] = "SECTION", t[t.SELECT = 96] = "SELECT", t[t.SOURCE = 97] = "SOURCE", t[t.SMALL = 98] = "SMALL", t[t.SPAN = 99] = "SPAN", t[t.STRIKE = 100] = "STRIKE", t[t.STRONG = 101] = "STRONG", t[t.STYLE = 102] = "STYLE", t[t.SUB = 103] = "SUB", t[t.SUMMARY = 104] = "SUMMARY", t[t.SUP = 105] = "SUP", t[t.TABLE = 106] = "TABLE", t[t.TBODY = 107] = "TBODY", t[t.TEMPLATE = 108] = "TEMPLATE", t[t.TEXTAREA = 109] = "TEXTAREA", t[t.TFOOT = 110] = "TFOOT", t[t.TD = 111] = "TD", t[t.TH = 112] = "TH", t[t.THEAD = 113] = "THEAD", t[t.TITLE = 114] = "TITLE", t[t.TR = 115] = "TR", t[t.TRACK = 116] = "TRACK", t[t.TT = 117] = "TT", t[t.U = 118] = "U", t[t.UL = 119] = "UL", t[t.SVG = 120] = "SVG", t[t.VAR = 121] = "VAR", t[t.WBR = 122] = "WBR", t[t.XMP = 123] = "XMP";
})(w || (w = {}));
const a$ = /* @__PURE__ */ new Map([
  [De.A, w.A],
  [De.ADDRESS, w.ADDRESS],
  [De.ANNOTATION_XML, w.ANNOTATION_XML],
  [De.APPLET, w.APPLET],
  [De.AREA, w.AREA],
  [De.ARTICLE, w.ARTICLE],
  [De.ASIDE, w.ASIDE],
  [De.B, w.B],
  [De.BASE, w.BASE],
  [De.BASEFONT, w.BASEFONT],
  [De.BGSOUND, w.BGSOUND],
  [De.BIG, w.BIG],
  [De.BLOCKQUOTE, w.BLOCKQUOTE],
  [De.BODY, w.BODY],
  [De.BR, w.BR],
  [De.BUTTON, w.BUTTON],
  [De.CAPTION, w.CAPTION],
  [De.CENTER, w.CENTER],
  [De.CODE, w.CODE],
  [De.COL, w.COL],
  [De.COLGROUP, w.COLGROUP],
  [De.DD, w.DD],
  [De.DESC, w.DESC],
  [De.DETAILS, w.DETAILS],
  [De.DIALOG, w.DIALOG],
  [De.DIR, w.DIR],
  [De.DIV, w.DIV],
  [De.DL, w.DL],
  [De.DT, w.DT],
  [De.EM, w.EM],
  [De.EMBED, w.EMBED],
  [De.FIELDSET, w.FIELDSET],
  [De.FIGCAPTION, w.FIGCAPTION],
  [De.FIGURE, w.FIGURE],
  [De.FONT, w.FONT],
  [De.FOOTER, w.FOOTER],
  [De.FOREIGN_OBJECT, w.FOREIGN_OBJECT],
  [De.FORM, w.FORM],
  [De.FRAME, w.FRAME],
  [De.FRAMESET, w.FRAMESET],
  [De.H1, w.H1],
  [De.H2, w.H2],
  [De.H3, w.H3],
  [De.H4, w.H4],
  [De.H5, w.H5],
  [De.H6, w.H6],
  [De.HEAD, w.HEAD],
  [De.HEADER, w.HEADER],
  [De.HGROUP, w.HGROUP],
  [De.HR, w.HR],
  [De.HTML, w.HTML],
  [De.I, w.I],
  [De.IMG, w.IMG],
  [De.IMAGE, w.IMAGE],
  [De.INPUT, w.INPUT],
  [De.IFRAME, w.IFRAME],
  [De.KEYGEN, w.KEYGEN],
  [De.LABEL, w.LABEL],
  [De.LI, w.LI],
  [De.LINK, w.LINK],
  [De.LISTING, w.LISTING],
  [De.MAIN, w.MAIN],
  [De.MALIGNMARK, w.MALIGNMARK],
  [De.MARQUEE, w.MARQUEE],
  [De.MATH, w.MATH],
  [De.MENU, w.MENU],
  [De.META, w.META],
  [De.MGLYPH, w.MGLYPH],
  [De.MI, w.MI],
  [De.MO, w.MO],
  [De.MN, w.MN],
  [De.MS, w.MS],
  [De.MTEXT, w.MTEXT],
  [De.NAV, w.NAV],
  [De.NOBR, w.NOBR],
  [De.NOFRAMES, w.NOFRAMES],
  [De.NOEMBED, w.NOEMBED],
  [De.NOSCRIPT, w.NOSCRIPT],
  [De.OBJECT, w.OBJECT],
  [De.OL, w.OL],
  [De.OPTGROUP, w.OPTGROUP],
  [De.OPTION, w.OPTION],
  [De.P, w.P],
  [De.PARAM, w.PARAM],
  [De.PLAINTEXT, w.PLAINTEXT],
  [De.PRE, w.PRE],
  [De.RB, w.RB],
  [De.RP, w.RP],
  [De.RT, w.RT],
  [De.RTC, w.RTC],
  [De.RUBY, w.RUBY],
  [De.S, w.S],
  [De.SCRIPT, w.SCRIPT],
  [De.SEARCH, w.SEARCH],
  [De.SECTION, w.SECTION],
  [De.SELECT, w.SELECT],
  [De.SOURCE, w.SOURCE],
  [De.SMALL, w.SMALL],
  [De.SPAN, w.SPAN],
  [De.STRIKE, w.STRIKE],
  [De.STRONG, w.STRONG],
  [De.STYLE, w.STYLE],
  [De.SUB, w.SUB],
  [De.SUMMARY, w.SUMMARY],
  [De.SUP, w.SUP],
  [De.TABLE, w.TABLE],
  [De.TBODY, w.TBODY],
  [De.TEMPLATE, w.TEMPLATE],
  [De.TEXTAREA, w.TEXTAREA],
  [De.TFOOT, w.TFOOT],
  [De.TD, w.TD],
  [De.TH, w.TH],
  [De.THEAD, w.THEAD],
  [De.TITLE, w.TITLE],
  [De.TR, w.TR],
  [De.TRACK, w.TRACK],
  [De.TT, w.TT],
  [De.U, w.U],
  [De.UL, w.UL],
  [De.SVG, w.SVG],
  [De.VAR, w.VAR],
  [De.WBR, w.WBR],
  [De.XMP, w.XMP]
]);
function X0(t) {
  var e;
  return (e = a$.get(t)) !== null && e !== void 0 ? e : w.UNKNOWN;
}
const it = w, o$ = {
  [Ye.HTML]: /* @__PURE__ */ new Set([
    it.ADDRESS,
    it.APPLET,
    it.AREA,
    it.ARTICLE,
    it.ASIDE,
    it.BASE,
    it.BASEFONT,
    it.BGSOUND,
    it.BLOCKQUOTE,
    it.BODY,
    it.BR,
    it.BUTTON,
    it.CAPTION,
    it.CENTER,
    it.COL,
    it.COLGROUP,
    it.DD,
    it.DETAILS,
    it.DIR,
    it.DIV,
    it.DL,
    it.DT,
    it.EMBED,
    it.FIELDSET,
    it.FIGCAPTION,
    it.FIGURE,
    it.FOOTER,
    it.FORM,
    it.FRAME,
    it.FRAMESET,
    it.H1,
    it.H2,
    it.H3,
    it.H4,
    it.H5,
    it.H6,
    it.HEAD,
    it.HEADER,
    it.HGROUP,
    it.HR,
    it.HTML,
    it.IFRAME,
    it.IMG,
    it.INPUT,
    it.LI,
    it.LINK,
    it.LISTING,
    it.MAIN,
    it.MARQUEE,
    it.MENU,
    it.META,
    it.NAV,
    it.NOEMBED,
    it.NOFRAMES,
    it.NOSCRIPT,
    it.OBJECT,
    it.OL,
    it.P,
    it.PARAM,
    it.PLAINTEXT,
    it.PRE,
    it.SCRIPT,
    it.SECTION,
    it.SELECT,
    it.SOURCE,
    it.STYLE,
    it.SUMMARY,
    it.TABLE,
    it.TBODY,
    it.TD,
    it.TEMPLATE,
    it.TEXTAREA,
    it.TFOOT,
    it.TH,
    it.THEAD,
    it.TITLE,
    it.TR,
    it.TRACK,
    it.UL,
    it.WBR,
    it.XMP
  ]),
  [Ye.MATHML]: /* @__PURE__ */ new Set([it.MI, it.MO, it.MN, it.MS, it.MTEXT, it.ANNOTATION_XML]),
  [Ye.SVG]: /* @__PURE__ */ new Set([it.TITLE, it.FOREIGN_OBJECT, it.DESC]),
  [Ye.XLINK]: /* @__PURE__ */ new Set(),
  [Ye.XML]: /* @__PURE__ */ new Set(),
  [Ye.XMLNS]: /* @__PURE__ */ new Set()
}, lb = /* @__PURE__ */ new Set([it.H1, it.H2, it.H3, it.H4, it.H5, it.H6]), u$ = /* @__PURE__ */ new Set([
  De.STYLE,
  De.SCRIPT,
  De.XMP,
  De.IFRAME,
  De.NOEMBED,
  De.NOFRAMES,
  De.PLAINTEXT
]);
function l$(t, e) {
  return u$.has(t) || e && t === De.NOSCRIPT;
}
var ce;
(function(t) {
  t[t.DATA = 0] = "DATA", t[t.RCDATA = 1] = "RCDATA", t[t.RAWTEXT = 2] = "RAWTEXT", t[t.SCRIPT_DATA = 3] = "SCRIPT_DATA", t[t.PLAINTEXT = 4] = "PLAINTEXT", t[t.TAG_OPEN = 5] = "TAG_OPEN", t[t.END_TAG_OPEN = 6] = "END_TAG_OPEN", t[t.TAG_NAME = 7] = "TAG_NAME", t[t.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", t[t.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", t[t.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", t[t.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", t[t.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", t[t.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", t[t.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", t[t.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", t[t.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", t[t.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", t[t.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", t[t.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", t[t.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", t[t.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", t[t.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", t[t.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", t[t.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", t[t.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", t[t.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", t[t.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", t[t.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", t[t.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", t[t.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", t[t.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", t[t.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", t[t.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", t[t.COMMENT_START = 42] = "COMMENT_START", t[t.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", t[t.COMMENT = 44] = "COMMENT", t[t.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", t[t.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", t[t.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", t[t.COMMENT_END = 50] = "COMMENT_END", t[t.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", t[t.DOCTYPE = 52] = "DOCTYPE", t[t.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", t[t.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", t[t.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", t[t.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", t[t.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", t[t.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", t[t.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", t[t.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", t[t.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", t[t.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", t[t.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", t[t.CDATA_SECTION = 68] = "CDATA_SECTION", t[t.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", t[t.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", t[t.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", t[t.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(ce || (ce = {}));
const Ci = {
  DATA: ce.DATA,
  RCDATA: ce.RCDATA,
  RAWTEXT: ce.RAWTEXT,
  SCRIPT_DATA: ce.SCRIPT_DATA,
  PLAINTEXT: ce.PLAINTEXT,
  CDATA_SECTION: ce.CDATA_SECTION
};
function c$(t) {
  return t >= ae.DIGIT_0 && t <= ae.DIGIT_9;
}
function Vd(t) {
  return t >= ae.LATIN_CAPITAL_A && t <= ae.LATIN_CAPITAL_Z;
}
function d$(t) {
  return t >= ae.LATIN_SMALL_A && t <= ae.LATIN_SMALL_Z;
}
function lo(t) {
  return d$(t) || Vd(t);
}
function K3(t) {
  return lo(t) || c$(t);
}
function dp(t) {
  return t + 32;
}
function vI(t) {
  return t === ae.SPACE || t === ae.LINE_FEED || t === ae.TABULATION || t === ae.FORM_FEED;
}
function Z3(t) {
  return vI(t) || t === ae.SOLIDUS || t === ae.GREATER_THAN_SIGN;
}
function f$(t) {
  return t === ae.NULL ? Ue.nullCharacterReference : t > 1114111 ? Ue.characterReferenceOutsideUnicodeRange : gI(t) ? Ue.surrogateCharacterReference : bI(t) ? Ue.noncharacterCharacterReference : AI(t) || t === ae.CARRIAGE_RETURN ? Ue.controlCharacterReference : null;
}
class h$ {
  constructor(e, n) {
    this.options = e, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = ce.DATA, this.returnState = ce.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new s$(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new V6(q6, (r, i) => {
      this.preprocessor.pos = this.entityStartPos + i - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(Ue.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(Ue.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const i = f$(r);
        i && this._err(i, 1);
      }
    } : void 0);
  }
  //Errors
  _err(e, n = 0) {
    var r, i;
    (i = (r = this.handler).onParseError) === null || i === void 0 || i.call(r, this.preprocessor.getError(e, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(e) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - e,
      startOffset: this.preprocessor.offset - e,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const e = this._consume();
        this._ensureHibernation() || this._callState(e);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(e) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || e == null || e());
  }
  write(e, n, r) {
    this.active = !0, this.preprocessor.write(e, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(e) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(e) {
    this.consumedAfterSnapshot += e;
    for (let n = 0; n < e; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(e, n) {
    return this.preprocessor.startsWith(e, n) ? (this._advanceBy(e.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: fn.START_TAG,
      tagName: "",
      tagID: w.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: fn.END_TAG,
      tagName: "",
      tagID: w.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(e) {
    this.currentToken = {
      type: fn.COMMENT,
      data: "",
      location: this.getCurrentLocation(e)
    };
  }
  _createDoctypeToken(e) {
    this.currentToken = {
      type: fn.DOCTYPE,
      name: e,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(e, n) {
    this.currentCharacterToken = {
      type: e,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(e) {
    this.currentAttr = {
      name: e,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var e, n;
    const r = this.currentToken;
    if (yI(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const i = (e = (n = r.location).attrs) !== null && e !== void 0 ? e : n.attrs = /* @__PURE__ */ Object.create(null);
        i[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(Ue.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(e) {
    this._emitCurrentCharacterToken(e.location), this.currentToken = null, e.location && (e.location.endLine = this.preprocessor.line, e.location.endCol = this.preprocessor.col + 1, e.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const e = this.currentToken;
    this.prepareToken(e), e.tagID = X0(e.tagName), e.type === fn.START_TAG ? (this.lastStartTagName = e.tagName, this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(Ue.endTagWithAttributes), e.selfClosing && this._err(Ue.endTagWithTrailingSolidus), this.handler.onEndTag(e)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(e) {
    this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(e) {
    this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(e) {
    if (this.currentCharacterToken) {
      switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine, this.currentCharacterToken.location.endCol = e.startCol, this.currentCharacterToken.location.endOffset = e.startOffset), this.currentCharacterToken.type) {
        case fn.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case fn.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case fn.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const e = this.getCurrentLocation(0);
    e && (e.endLine = e.startLine, e.endCol = e.startCol, e.endOffset = e.startOffset), this._emitCurrentCharacterToken(e), this.handler.onEof({ type: fn.EOF, location: e }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(e, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === e) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(e, n);
  }
  _emitCodePoint(e) {
    const n = vI(e) ? fn.WHITESPACE_CHARACTER : e === ae.NULL ? fn.NULL_CHARACTER : fn.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(e));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(e) {
    this._appendCharToCurrentCharacterToken(fn.CHARACTER, e);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = ce.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? ns.Attribute : ns.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === ce.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === ce.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === ce.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(e) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(e) {
    switch (this.state) {
      case ce.DATA: {
        this._stateData(e);
        break;
      }
      case ce.RCDATA: {
        this._stateRcdata(e);
        break;
      }
      case ce.RAWTEXT: {
        this._stateRawtext(e);
        break;
      }
      case ce.SCRIPT_DATA: {
        this._stateScriptData(e);
        break;
      }
      case ce.PLAINTEXT: {
        this._statePlaintext(e);
        break;
      }
      case ce.TAG_OPEN: {
        this._stateTagOpen(e);
        break;
      }
      case ce.END_TAG_OPEN: {
        this._stateEndTagOpen(e);
        break;
      }
      case ce.TAG_NAME: {
        this._stateTagName(e);
        break;
      }
      case ce.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(e);
        break;
      }
      case ce.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(e);
        break;
      }
      case ce.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(e);
        break;
      }
      case ce.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(e);
        break;
      }
      case ce.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(e);
        break;
      }
      case ce.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(e);
        break;
      }
      case ce.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(e);
        break;
      }
      case ce.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(e);
        break;
      }
      case ce.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(e);
        break;
      }
      case ce.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(e);
        break;
      }
      case ce.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(e);
        break;
      }
      case ce.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(e);
        break;
      }
      case ce.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(e);
        break;
      }
      case ce.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(e);
        break;
      }
      case ce.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(e);
        break;
      }
      case ce.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(e);
        break;
      }
      case ce.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(e);
        break;
      }
      case ce.ATTRIBUTE_NAME: {
        this._stateAttributeName(e);
        break;
      }
      case ce.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(e);
        break;
      }
      case ce.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(e);
        break;
      }
      case ce.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(e);
        break;
      }
      case ce.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(e);
        break;
      }
      case ce.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(e);
        break;
      }
      case ce.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(e);
        break;
      }
      case ce.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(e);
        break;
      }
      case ce.BOGUS_COMMENT: {
        this._stateBogusComment(e);
        break;
      }
      case ce.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(e);
        break;
      }
      case ce.COMMENT_START: {
        this._stateCommentStart(e);
        break;
      }
      case ce.COMMENT_START_DASH: {
        this._stateCommentStartDash(e);
        break;
      }
      case ce.COMMENT: {
        this._stateComment(e);
        break;
      }
      case ce.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(e);
        break;
      }
      case ce.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(e);
        break;
      }
      case ce.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(e);
        break;
      }
      case ce.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(e);
        break;
      }
      case ce.COMMENT_END_DASH: {
        this._stateCommentEndDash(e);
        break;
      }
      case ce.COMMENT_END: {
        this._stateCommentEnd(e);
        break;
      }
      case ce.COMMENT_END_BANG: {
        this._stateCommentEndBang(e);
        break;
      }
      case ce.DOCTYPE: {
        this._stateDoctype(e);
        break;
      }
      case ce.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(e);
        break;
      }
      case ce.DOCTYPE_NAME: {
        this._stateDoctypeName(e);
        break;
      }
      case ce.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(e);
        break;
      }
      case ce.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(e);
        break;
      }
      case ce.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(e);
        break;
      }
      case ce.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(e);
        break;
      }
      case ce.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(e);
        break;
      }
      case ce.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(e);
        break;
      }
      case ce.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(e);
        break;
      }
      case ce.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(e);
        break;
      }
      case ce.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(e);
        break;
      }
      case ce.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(e);
        break;
      }
      case ce.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(e);
        break;
      }
      case ce.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(e);
        break;
      }
      case ce.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(e);
        break;
      }
      case ce.CDATA_SECTION: {
        this._stateCdataSection(e);
        break;
      }
      case ce.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(e);
        break;
      }
      case ce.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(e);
        break;
      }
      case ce.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case ce.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(e);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(e) {
    switch (e) {
      case ae.LESS_THAN_SIGN: {
        this.state = ce.TAG_OPEN;
        break;
      }
      case ae.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this._emitCodePoint(e);
        break;
      }
      case ae.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(e) {
    switch (e) {
      case ae.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case ae.LESS_THAN_SIGN: {
        this.state = ce.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(e) {
    switch (e) {
      case ae.LESS_THAN_SIGN: {
        this.state = ce.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(e) {
    switch (e) {
      case ae.LESS_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(e) {
    switch (e) {
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(e) {
    if (lo(e))
      this._createStartTagToken(), this.state = ce.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case ae.EXCLAMATION_MARK: {
          this.state = ce.MARKUP_DECLARATION_OPEN;
          break;
        }
        case ae.SOLIDUS: {
          this.state = ce.END_TAG_OPEN;
          break;
        }
        case ae.QUESTION_MARK: {
          this._err(Ue.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = ce.BOGUS_COMMENT, this._stateBogusComment(e);
          break;
        }
        case ae.EOF: {
          this._err(Ue.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(Ue.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = ce.DATA, this._stateData(e);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(e) {
    if (lo(e))
      this._createEndTagToken(), this.state = ce.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case ae.GREATER_THAN_SIGN: {
          this._err(Ue.missingEndTagName), this.state = ce.DATA;
          break;
        }
        case ae.EOF: {
          this._err(Ue.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(Ue.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = ce.BOGUS_COMMENT, this._stateBogusComment(e);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this.state = ce.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case ae.SOLIDUS: {
        this.state = ce.SELF_CLOSING_START_TAG;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA, this.emitCurrentTagToken();
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.tagName += Gn;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(Vd(e) ? dp(e) : e);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(e) {
    e === ae.SOLIDUS ? this.state = ce.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = ce.RCDATA, this._stateRcdata(e));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(e) {
    lo(e) ? (this.state = ce.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(e)) : (this._emitChars("</"), this.state = ce.RCDATA, this._stateRcdata(e));
  }
  handleSpecialEndTag(e) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = ce.BEFORE_ATTRIBUTE_NAME, !1;
      case ae.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = ce.SELF_CLOSING_START_TAG, !1;
      case ae.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = ce.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = ce.RCDATA, this._stateRcdata(e));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(e) {
    e === ae.SOLIDUS ? this.state = ce.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = ce.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(e) {
    lo(e) ? (this.state = ce.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(e)) : (this._emitChars("</"), this.state = ce.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = ce.RAWTEXT, this._stateRawtext(e));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(e) {
    switch (e) {
      case ae.SOLIDUS: {
        this.state = ce.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case ae.EXCLAMATION_MARK: {
        this.state = ce.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = ce.SCRIPT_DATA, this._stateScriptData(e);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(e) {
    lo(e) ? (this.state = ce.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(e)) : (this._emitChars("</"), this.state = ce.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = ce.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(e) {
    e === ae.HYPHEN_MINUS ? (this.state = ce.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = ce.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(e) {
    e === ae.HYPHEN_MINUS ? (this.state = ce.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = ce.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(e) {
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case ae.LESS_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(e) {
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case ae.LESS_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.state = ce.SCRIPT_DATA_ESCAPED, this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = ce.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(e) {
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case ae.LESS_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.state = ce.SCRIPT_DATA_ESCAPED, this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = ce.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(e) {
    e === ae.SOLIDUS ? this.state = ce.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : lo(e) ? (this._emitChars("<"), this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"), this.state = ce.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(e) {
    lo(e) ? (this.state = ce.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"), this.state = ce.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = ce.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(e) {
    if (this.preprocessor.startsWith(yi.SCRIPT, !1) && Z3(this.preprocessor.peek(yi.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < yi.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = ce.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(e) {
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case ae.LESS_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(e) {
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case ae.LESS_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(e) {
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case ae.LESS_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Gn);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(e) {
    e === ae.SOLIDUS ? (this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(e) {
    if (this.preprocessor.startsWith(yi.SCRIPT, !1) && Z3(this.preprocessor.peek(yi.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < yi.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = ce.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = ce.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(e) {
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.SOLIDUS:
      case ae.GREATER_THAN_SIGN:
      case ae.EOF: {
        this.state = ce.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case ae.EQUALS_SIGN: {
        this._err(Ue.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = ce.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = ce.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(e) {
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
      case ae.SOLIDUS:
      case ae.GREATER_THAN_SIGN:
      case ae.EOF: {
        this._leaveAttrName(), this.state = ce.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case ae.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = ce.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case ae.QUOTATION_MARK:
      case ae.APOSTROPHE:
      case ae.LESS_THAN_SIGN: {
        this._err(Ue.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(e);
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.currentAttr.name += Gn;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Vd(e) ? dp(e) : e);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(e) {
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.SOLIDUS: {
        this.state = ce.SELF_CLOSING_START_TAG;
        break;
      }
      case ae.EQUALS_SIGN: {
        this.state = ce.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA, this.emitCurrentTagToken();
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = ce.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(e) {
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.QUOTATION_MARK: {
        this.state = ce.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case ae.APOSTROPHE: {
        this.state = ce.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.missingAttributeValue), this.state = ce.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = ce.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(e);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(e) {
    switch (e) {
      case ae.QUOTATION_MARK: {
        this.state = ce.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case ae.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.currentAttr.value += Gn;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(e) {
    switch (e) {
      case ae.APOSTROPHE: {
        this.state = ce.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case ae.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.currentAttr.value += Gn;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(e) {
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this._leaveAttrValue(), this.state = ce.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case ae.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = ce.DATA, this.emitCurrentTagToken();
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), this.currentAttr.value += Gn;
        break;
      }
      case ae.QUOTATION_MARK:
      case ae.APOSTROPHE:
      case ae.LESS_THAN_SIGN:
      case ae.EQUALS_SIGN:
      case ae.GRAVE_ACCENT: {
        this._err(Ue.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(e);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(e) {
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this._leaveAttrValue(), this.state = ce.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case ae.SOLIDUS: {
        this._leaveAttrValue(), this.state = ce.SELF_CLOSING_START_TAG;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = ce.DATA, this.emitCurrentTagToken();
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingWhitespaceBetweenAttributes), this.state = ce.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(e) {
    switch (e) {
      case ae.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = ce.DATA, this.emitCurrentTagToken();
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.unexpectedSolidusInTag), this.state = ce.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA, this.emitCurrentComment(n);
        break;
      }
      case ae.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.data += Gn;
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(e) {
    this._consumeSequenceIfMatch(yi.DASH_DASH, !0) ? (this._createCommentToken(yi.DASH_DASH.length + 1), this.state = ce.COMMENT_START) : this._consumeSequenceIfMatch(yi.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(yi.DOCTYPE.length + 1), this.state = ce.DOCTYPE) : this._consumeSequenceIfMatch(yi.CDATA_START, !0) ? this.inForeignNode ? this.state = ce.CDATA_SECTION : (this._err(Ue.cdataInHtmlContent), this._createCommentToken(yi.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = ce.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(Ue.incorrectlyOpenedComment), this._createCommentToken(2), this.state = ce.BOGUS_COMMENT, this._stateBogusComment(e));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(e) {
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.COMMENT_START_DASH;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.abruptClosingOfEmptyComment), this.state = ce.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = ce.COMMENT, this._stateComment(e);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.COMMENT_END;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.abruptClosingOfEmptyComment), this.state = ce.DATA, this.emitCurrentComment(n);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = ce.COMMENT, this._stateComment(e);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.COMMENT_END_DASH;
        break;
      }
      case ae.LESS_THAN_SIGN: {
        n.data += "<", this.state = ce.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.data += Gn;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.EXCLAMATION_MARK: {
        n.data += "!", this.state = ce.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case ae.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = ce.COMMENT, this._stateComment(e);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(e) {
    e === ae.HYPHEN_MINUS ? this.state = ce.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = ce.COMMENT, this._stateComment(e));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(e) {
    e === ae.HYPHEN_MINUS ? this.state = ce.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = ce.COMMENT_END_DASH, this._stateCommentEndDash(e));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(e) {
    e !== ae.GREATER_THAN_SIGN && e !== ae.EOF && this._err(Ue.nestedComment), this.state = ce.COMMENT_END, this._stateCommentEnd(e);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.HYPHEN_MINUS: {
        this.state = ce.COMMENT_END;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = ce.COMMENT, this._stateComment(e);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA, this.emitCurrentComment(n);
        break;
      }
      case ae.EXCLAMATION_MARK: {
        this.state = ce.COMMENT_END_BANG;
        break;
      }
      case ae.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = ce.COMMENT, this._stateComment(e);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.HYPHEN_MINUS: {
        n.data += "--!", this.state = ce.COMMENT_END_DASH;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.incorrectlyClosedComment), this.state = ce.DATA, this.emitCurrentComment(n);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = ce.COMMENT, this._stateComment(e);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(e) {
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this.state = ce.BEFORE_DOCTYPE_NAME;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingWhitespaceBeforeDoctypeName), this.state = ce.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(e) {
    if (Vd(e))
      this._createDoctypeToken(String.fromCharCode(dp(e))), this.state = ce.DOCTYPE_NAME;
    else
      switch (e) {
        case ae.SPACE:
        case ae.LINE_FEED:
        case ae.TABULATION:
        case ae.FORM_FEED:
          break;
        case ae.NULL: {
          this._err(Ue.unexpectedNullCharacter), this._createDoctypeToken(Gn), this.state = ce.DOCTYPE_NAME;
          break;
        }
        case ae.GREATER_THAN_SIGN: {
          this._err(Ue.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = ce.DATA;
          break;
        }
        case ae.EOF: {
          this._err(Ue.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(e)), this.state = ce.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this.state = ce.AFTER_DOCTYPE_NAME;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.name += Gn;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(Vd(e) ? dp(e) : e);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(yi.PUBLIC, !1) ? this.state = ce.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(yi.SYSTEM, !1) ? this.state = ce.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(Ue.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this.state = ce.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case ae.QUOTATION_MARK: {
        this._err(Ue.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = ce.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case ae.APOSTROPHE: {
        this._err(Ue.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = ce.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = ce.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.QUOTATION_MARK: {
        n.publicId = "", this.state = ce.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case ae.APOSTROPHE: {
        n.publicId = "", this.state = ce.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = ce.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.QUOTATION_MARK: {
        this.state = ce.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.publicId += Gn;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = ce.DATA;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.APOSTROPHE: {
        this.state = ce.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.publicId += Gn;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = ce.DATA;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this.state = ce.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case ae.QUOTATION_MARK: {
        this._err(Ue.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case ae.APOSTROPHE: {
        this._err(Ue.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = ce.DATA;
        break;
      }
      case ae.QUOTATION_MARK: {
        n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case ae.APOSTROPHE: {
        n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED: {
        this.state = ce.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case ae.QUOTATION_MARK: {
        this._err(Ue.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case ae.APOSTROPHE: {
        this._err(Ue.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = ce.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.QUOTATION_MARK: {
        n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case ae.APOSTROPHE: {
        n.systemId = "", this.state = ce.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = ce.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.QUOTATION_MARK: {
        this.state = ce.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.systemId += Gn;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = ce.DATA;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.APOSTROPHE: {
        this.state = ce.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter), n.systemId += Gn;
        break;
      }
      case ae.GREATER_THAN_SIGN: {
        this._err(Ue.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = ce.DATA;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.SPACE:
      case ae.LINE_FEED:
      case ae.TABULATION:
      case ae.FORM_FEED:
        break;
      case ae.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = ce.DATA;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(Ue.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = ce.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(e) {
    const n = this.currentToken;
    switch (e) {
      case ae.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = ce.DATA;
        break;
      }
      case ae.NULL: {
        this._err(Ue.unexpectedNullCharacter);
        break;
      }
      case ae.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(e) {
    switch (e) {
      case ae.RIGHT_SQUARE_BRACKET: {
        this.state = ce.CDATA_SECTION_BRACKET;
        break;
      }
      case ae.EOF: {
        this._err(Ue.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(e) {
    e === ae.RIGHT_SQUARE_BRACKET ? this.state = ce.CDATA_SECTION_END : (this._emitChars("]"), this.state = ce.CDATA_SECTION, this._stateCdataSection(e));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(e) {
    switch (e) {
      case ae.GREATER_THAN_SIGN: {
        this.state = ce.DATA;
        break;
      }
      case ae.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = ce.CDATA_SECTION, this._stateCdataSection(e);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let e = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (e < 0)
      if (this.preprocessor.lastChunkWritten)
        e = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    e === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(ae.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && K3(this.preprocessor.peek(1)) ? ce.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(e) {
    K3(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === ae.SEMICOLON && this._err(Ue.unknownNamedCharacterReference), this.state = this.returnState, this._callState(e));
  }
}
const TI = /* @__PURE__ */ new Set([w.DD, w.DT, w.LI, w.OPTGROUP, w.OPTION, w.P, w.RB, w.RP, w.RT, w.RTC]), J3 = /* @__PURE__ */ new Set([
  ...TI,
  w.CAPTION,
  w.COLGROUP,
  w.TBODY,
  w.TD,
  w.TFOOT,
  w.TH,
  w.THEAD,
  w.TR
]), qm = /* @__PURE__ */ new Set([
  w.APPLET,
  w.CAPTION,
  w.HTML,
  w.MARQUEE,
  w.OBJECT,
  w.TABLE,
  w.TD,
  w.TEMPLATE,
  w.TH
]), p$ = /* @__PURE__ */ new Set([...qm, w.OL, w.UL]), m$ = /* @__PURE__ */ new Set([...qm, w.BUTTON]), eE = /* @__PURE__ */ new Set([w.ANNOTATION_XML, w.MI, w.MN, w.MO, w.MS, w.MTEXT]), tE = /* @__PURE__ */ new Set([w.DESC, w.FOREIGN_OBJECT, w.TITLE]), g$ = /* @__PURE__ */ new Set([w.TR, w.TEMPLATE, w.HTML]), A$ = /* @__PURE__ */ new Set([w.TBODY, w.TFOOT, w.THEAD, w.TEMPLATE, w.HTML]), b$ = /* @__PURE__ */ new Set([w.TABLE, w.TEMPLATE, w.HTML]), y$ = /* @__PURE__ */ new Set([w.TD, w.TH]);
class v$ {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(e, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = w.UNKNOWN, this.current = e;
  }
  //Index of element
  _indexOf(e) {
    return this.items.lastIndexOf(e, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === w.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Ye.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(e, n) {
    this.stackTop++, this.items[this.stackTop] = e, this.current = e, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(e, n, !0);
  }
  pop() {
    const e = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !0);
  }
  replace(e, n) {
    const r = this._indexOf(e);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(e, n, r) {
    const i = this._indexOf(e) + 1;
    this.items.splice(i, 0, n), this.tagIDs.splice(i, 0, r), this.stackTop++, i === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, i === this.stackTop);
  }
  popUntilTagNamePopped(e) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(e, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== Ye.HTML);
    this.shortenToLength(Math.max(n, 0));
  }
  shortenToLength(e) {
    for (; this.stackTop >= e; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < e);
    }
  }
  popUntilElementPopped(e) {
    const n = this._indexOf(e);
    this.shortenToLength(Math.max(n, 0));
  }
  popUntilPopped(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(Math.max(r, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(lb, Ye.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(y$, Ye.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(e, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (e.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(b$, Ye.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(A$, Ye.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(g$, Ye.HTML);
  }
  remove(e) {
    const n = this._indexOf(e);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === w.BODY ? this.items[1] : null;
  }
  contains(e) {
    return this._indexOf(e) > -1;
  }
  getCommonAncestor(e) {
    const n = this._indexOf(e) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === w.HTML;
  }
  //Element in scope
  hasInDynamicScope(e, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case Ye.HTML: {
          if (i === e)
            return !0;
          if (n.has(i))
            return !1;
          break;
        }
        case Ye.SVG: {
          if (tE.has(i))
            return !1;
          break;
        }
        case Ye.MATHML: {
          if (eE.has(i))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(e) {
    return this.hasInDynamicScope(e, qm);
  }
  hasInListItemScope(e) {
    return this.hasInDynamicScope(e, p$);
  }
  hasInButtonScope(e) {
    return this.hasInDynamicScope(e, m$);
  }
  hasNumberedHeaderInScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.tagIDs[e];
      switch (this.treeAdapter.getNamespaceURI(this.items[e])) {
        case Ye.HTML: {
          if (lb.has(n))
            return !0;
          if (qm.has(n))
            return !1;
          break;
        }
        case Ye.SVG: {
          if (tE.has(n))
            return !1;
          break;
        }
        case Ye.MATHML: {
          if (eE.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ye.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case w.TABLE:
          case w.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let e = this.stackTop; e >= 0; e--)
      if (this.treeAdapter.getNamespaceURI(this.items[e]) === Ye.HTML)
        switch (this.tagIDs[e]) {
          case w.TBODY:
          case w.THEAD:
          case w.TFOOT:
            return !0;
          case w.TABLE:
          case w.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ye.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case w.OPTION:
          case w.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; this.currentTagId !== void 0 && TI.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; this.currentTagId !== void 0 && J3.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(e) {
    for (; this.currentTagId !== void 0 && this.currentTagId !== e && J3.has(this.currentTagId); )
      this.pop();
  }
}
const rA = 3;
var Ys;
(function(t) {
  t[t.Marker = 0] = "Marker", t[t.Element = 1] = "Element";
})(Ys || (Ys = {}));
const nE = { type: Ys.Marker };
class T$ {
  constructor(e) {
    this.treeAdapter = e, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(e, n) {
    const r = [], i = n.length, s = this.treeAdapter.getTagName(e), a = this.treeAdapter.getNamespaceURI(e);
    for (let o = 0; o < this.entries.length; o++) {
      const u = this.entries[o];
      if (u.type === Ys.Marker)
        break;
      const { element: c } = u;
      if (this.treeAdapter.getTagName(c) === s && this.treeAdapter.getNamespaceURI(c) === a) {
        const d = this.treeAdapter.getAttrList(c);
        d.length === i && r.push({ idx: o, attrs: d });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(e) {
    if (this.entries.length < rA)
      return;
    const n = this.treeAdapter.getAttrList(e), r = this._getNoahArkConditionCandidates(e, n);
    if (r.length < rA)
      return;
    const i = new Map(n.map((a) => [a.name, a.value]));
    let s = 0;
    for (let a = 0; a < r.length; a++) {
      const o = r[a];
      o.attrs.every((u) => i.get(u.name) === u.value) && (s += 1, s >= rA && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(nE);
  }
  pushElement(e, n) {
    this._ensureNoahArkCondition(e), this.entries.unshift({
      type: Ys.Element,
      element: e,
      token: n
    });
  }
  insertElementAfterBookmark(e, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: Ys.Element,
      element: e,
      token: n
    });
  }
  removeEntry(e) {
    const n = this.entries.indexOf(e);
    n !== -1 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const e = this.entries.indexOf(nE);
    e === -1 ? this.entries.length = 0 : this.entries.splice(0, e + 1);
  }
  //Search
  getElementEntryInScopeWithTagName(e) {
    const n = this.entries.find((r) => r.type === Ys.Marker || this.treeAdapter.getTagName(r.element) === e);
    return n && n.type === Ys.Element ? n : null;
  }
  getElementEntry(e) {
    return this.entries.find((n) => n.type === Ys.Element && n.element === e);
  }
}
const Ia = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: zi.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(t, e, n) {
    return {
      nodeName: t,
      tagName: t,
      attrs: n,
      namespaceURI: e,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(t) {
    return {
      nodeName: "#comment",
      data: t,
      parentNode: null
    };
  },
  createTextNode(t) {
    return {
      nodeName: "#text",
      value: t,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(t, e) {
    t.childNodes.push(e), e.parentNode = t;
  },
  insertBefore(t, e, n) {
    const r = t.childNodes.indexOf(n);
    t.childNodes.splice(r, 0, e), e.parentNode = t;
  },
  setTemplateContent(t, e) {
    t.content = e;
  },
  getTemplateContent(t) {
    return t.content;
  },
  setDocumentType(t, e, n, r) {
    const i = t.childNodes.find((s) => s.nodeName === "#documentType");
    if (i)
      i.name = e, i.publicId = n, i.systemId = r;
    else {
      const s = {
        nodeName: "#documentType",
        name: e,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      Ia.appendChild(t, s);
    }
  },
  setDocumentMode(t, e) {
    t.mode = e;
  },
  getDocumentMode(t) {
    return t.mode;
  },
  detachNode(t) {
    if (t.parentNode) {
      const e = t.parentNode.childNodes.indexOf(t);
      t.parentNode.childNodes.splice(e, 1), t.parentNode = null;
    }
  },
  insertText(t, e) {
    if (t.childNodes.length > 0) {
      const n = t.childNodes[t.childNodes.length - 1];
      if (Ia.isTextNode(n)) {
        n.value += e;
        return;
      }
    }
    Ia.appendChild(t, Ia.createTextNode(e));
  },
  insertTextBefore(t, e, n) {
    const r = t.childNodes[t.childNodes.indexOf(n) - 1];
    r && Ia.isTextNode(r) ? r.value += e : Ia.insertBefore(t, Ia.createTextNode(e), n);
  },
  adoptAttributes(t, e) {
    const n = new Set(t.attrs.map((r) => r.name));
    for (let r = 0; r < e.length; r++)
      n.has(e[r].name) || t.attrs.push(e[r]);
  },
  //Tree traversing
  getFirstChild(t) {
    return t.childNodes[0];
  },
  getChildNodes(t) {
    return t.childNodes;
  },
  getParentNode(t) {
    return t.parentNode;
  },
  getAttrList(t) {
    return t.attrs;
  },
  //Node data
  getTagName(t) {
    return t.tagName;
  },
  getNamespaceURI(t) {
    return t.namespaceURI;
  },
  getTextNodeContent(t) {
    return t.value;
  },
  getCommentNodeContent(t) {
    return t.data;
  },
  getDocumentTypeNodeName(t) {
    return t.name;
  },
  getDocumentTypeNodePublicId(t) {
    return t.publicId;
  },
  getDocumentTypeNodeSystemId(t) {
    return t.systemId;
  },
  //Node types
  isTextNode(t) {
    return t.nodeName === "#text";
  },
  isCommentNode(t) {
    return t.nodeName === "#comment";
  },
  isDocumentTypeNode(t) {
    return t.nodeName === "#documentType";
  },
  isElementNode(t) {
    return Object.prototype.hasOwnProperty.call(t, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = e;
  },
  getNodeSourceCodeLocation(t) {
    return t.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = { ...t.sourceCodeLocation, ...e };
  }
}, _I = "html", _$ = "about:legacy-compat", E$ = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", EI = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], x$ = [
  ...EI,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], w$ = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), xI = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], C$ = [
  ...xI,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function rE(t, e) {
  return e.some((n) => t.startsWith(n));
}
function S$(t) {
  return t.name === _I && t.publicId === null && (t.systemId === null || t.systemId === _$);
}
function I$(t) {
  if (t.name !== _I)
    return zi.QUIRKS;
  const { systemId: e } = t;
  if (e && e.toLowerCase() === E$)
    return zi.QUIRKS;
  let { publicId: n } = t;
  if (n !== null) {
    if (n = n.toLowerCase(), w$.has(n))
      return zi.QUIRKS;
    let r = e === null ? x$ : EI;
    if (rE(n, r))
      return zi.QUIRKS;
    if (r = e === null ? xI : C$, rE(n, r))
      return zi.LIMITED_QUIRKS;
  }
  return zi.NO_QUIRKS;
}
const iE = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, k$ = "definitionurl", D$ = "definitionURL", M$ = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t) => [t.toLowerCase(), t])), O$ = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Ye.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Ye.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: Ye.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: Ye.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: Ye.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: Ye.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: Ye.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: Ye.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: Ye.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: Ye.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Ye.XMLNS }]
]), N$ = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t) => [t.toLowerCase(), t])), L$ = /* @__PURE__ */ new Set([
  w.B,
  w.BIG,
  w.BLOCKQUOTE,
  w.BODY,
  w.BR,
  w.CENTER,
  w.CODE,
  w.DD,
  w.DIV,
  w.DL,
  w.DT,
  w.EM,
  w.EMBED,
  w.H1,
  w.H2,
  w.H3,
  w.H4,
  w.H5,
  w.H6,
  w.HEAD,
  w.HR,
  w.I,
  w.IMG,
  w.LI,
  w.LISTING,
  w.MENU,
  w.META,
  w.NOBR,
  w.OL,
  w.P,
  w.PRE,
  w.RUBY,
  w.S,
  w.SMALL,
  w.SPAN,
  w.STRONG,
  w.STRIKE,
  w.SUB,
  w.SUP,
  w.TABLE,
  w.TT,
  w.U,
  w.UL,
  w.VAR
]);
function P$(t) {
  const e = t.tagID;
  return e === w.FONT && t.attrs.some(({ name: r }) => r === wu.COLOR || r === wu.SIZE || r === wu.FACE) || L$.has(e);
}
function wI(t) {
  for (let e = 0; e < t.attrs.length; e++)
    if (t.attrs[e].name === k$) {
      t.attrs[e].name = D$;
      break;
    }
}
function CI(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = M$.get(t.attrs[e].name);
    n != null && (t.attrs[e].name = n);
  }
}
function xv(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = O$.get(t.attrs[e].name);
    n && (t.attrs[e].prefix = n.prefix, t.attrs[e].name = n.name, t.attrs[e].namespace = n.namespace);
  }
}
function R$(t) {
  const e = N$.get(t.tagName);
  e != null && (t.tagName = e, t.tagID = X0(t.tagName));
}
function B$(t, e) {
  return e === Ye.MATHML && (t === w.MI || t === w.MO || t === w.MN || t === w.MS || t === w.MTEXT);
}
function F$(t, e, n) {
  if (e === Ye.MATHML && t === w.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === wu.ENCODING) {
        const i = n[r].value.toLowerCase();
        return i === iE.TEXT_HTML || i === iE.APPLICATION_XML;
      }
  }
  return e === Ye.SVG && (t === w.FOREIGN_OBJECT || t === w.DESC || t === w.TITLE);
}
function U$(t, e, n, r) {
  return (!r || r === Ye.HTML) && F$(t, e, n) || (!r || r === Ye.MATHML) && B$(t, e);
}
const $$ = "hidden", H$ = 8, j$ = 3;
var Ae;
(function(t) {
  t[t.INITIAL = 0] = "INITIAL", t[t.BEFORE_HTML = 1] = "BEFORE_HTML", t[t.BEFORE_HEAD = 2] = "BEFORE_HEAD", t[t.IN_HEAD = 3] = "IN_HEAD", t[t.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", t[t.AFTER_HEAD = 5] = "AFTER_HEAD", t[t.IN_BODY = 6] = "IN_BODY", t[t.TEXT = 7] = "TEXT", t[t.IN_TABLE = 8] = "IN_TABLE", t[t.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", t[t.IN_CAPTION = 10] = "IN_CAPTION", t[t.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", t[t.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", t[t.IN_ROW = 13] = "IN_ROW", t[t.IN_CELL = 14] = "IN_CELL", t[t.IN_SELECT = 15] = "IN_SELECT", t[t.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", t[t.IN_TEMPLATE = 17] = "IN_TEMPLATE", t[t.AFTER_BODY = 18] = "AFTER_BODY", t[t.IN_FRAMESET = 19] = "IN_FRAMESET", t[t.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", t[t.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", t[t.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(Ae || (Ae = {}));
const z$ = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, SI = /* @__PURE__ */ new Set([w.TABLE, w.TBODY, w.TFOOT, w.THEAD, w.TR]), sE = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: Ia,
  onParseError: null
};
let II = class {
  constructor(e, n, r = null, i = null) {
    this.fragmentContext = r, this.scriptHandler = i, this.currentToken = null, this.stopped = !1, this.insertionMode = Ae.INITIAL, this.originalInsertionMode = Ae.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...sE,
      ...e
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new h$(this.options, this), this.activeFormattingElements = new T$(this.treeAdapter), this.fragmentContextID = r ? X0(this.treeAdapter.getTagName(r)) : w.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new v$(this.document, this.treeAdapter, this);
  }
  // API
  static parse(e, n) {
    const r = new this(n);
    return r.tokenizer.write(e, !0), r.document;
  }
  static getFragmentParser(e, n) {
    const r = {
      ...sE,
      ...n
    };
    e ?? (e = r.treeAdapter.createElement(De.TEMPLATE, Ye.HTML, []));
    const i = r.treeAdapter.createElement("documentmock", Ye.HTML, []), s = new this(r, i, e);
    return s.fragmentContextID === w.TEMPLATE && s.tmplInsertionModeStack.unshift(Ae.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s;
  }
  getFragment() {
    const e = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(e, n), n;
  }
  //Errors
  /** @internal */
  _err(e, n, r) {
    var i;
    if (!this.onParseError)
      return;
    const s = (i = e.location) !== null && i !== void 0 ? i : z$, a = {
      code: n,
      startLine: s.startLine,
      startCol: s.startCol,
      startOffset: s.startOffset,
      endLine: r ? s.startLine : s.endLine,
      endCol: r ? s.startCol : s.endCol,
      endOffset: r ? s.startOffset : s.endOffset
    };
    this.onParseError(a);
  }
  //Stack events
  /** @internal */
  onItemPush(e, n, r) {
    var i, s;
    (s = (i = this.treeAdapter).onItemPush) === null || s === void 0 || s.call(i, e), r && this.openElements.stackTop > 0 && this._setContextModes(e, n);
  }
  /** @internal */
  onItemPop(e, n) {
    var r, i;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken), (i = (r = this.treeAdapter).onItemPop) === null || i === void 0 || i.call(r, e, this.openElements.current), n) {
      let s, a;
      this.openElements.stackTop === 0 && this.fragmentContext ? (s = this.fragmentContext, a = this.fragmentContextID) : { current: s, currentTagId: a } = this.openElements, this._setContextModes(s, a);
    }
  }
  _setContextModes(e, n) {
    const r = e === this.document || e && this.treeAdapter.getNamespaceURI(e) === Ye.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && e !== void 0 && n !== void 0 && !this._isIntegrationPoint(n, e);
  }
  /** @protected */
  _switchToTextParsing(e, n) {
    this._insertElement(e, Ye.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = Ae.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = Ae.TEXT, this.originalInsertionMode = Ae.IN_BODY, this.tokenizer.state = Ci.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let e = this.fragmentContext;
    for (; e; ) {
      if (this.treeAdapter.getTagName(e) === De.FORM) {
        this.formElement = e;
        break;
      }
      e = this.treeAdapter.getParentNode(e);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== Ye.HTML))
      switch (this.fragmentContextID) {
        case w.TITLE:
        case w.TEXTAREA: {
          this.tokenizer.state = Ci.RCDATA;
          break;
        }
        case w.STYLE:
        case w.XMP:
        case w.IFRAME:
        case w.NOEMBED:
        case w.NOFRAMES:
        case w.NOSCRIPT: {
          this.tokenizer.state = Ci.RAWTEXT;
          break;
        }
        case w.SCRIPT: {
          this.tokenizer.state = Ci.SCRIPT_DATA;
          break;
        }
        case w.PLAINTEXT: {
          this.tokenizer.state = Ci.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(e) {
    const n = e.name || "", r = e.publicId || "", i = e.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, i), e.location) {
      const a = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      a && this.treeAdapter.setNodeSourceCodeLocation(a, e.location);
    }
  }
  /** @protected */
  _attachElementToTree(e, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(e, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(e);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r ?? this.document, e);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location);
  }
  /** @protected */
  _insertElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location), this.openElements.push(r, e.tagID);
  }
  /** @protected */
  _insertFakeElement(e, n) {
    const r = this.treeAdapter.createElement(e, Ye.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(e) {
    const n = this.treeAdapter.createElement(e.tagName, Ye.HTML, e.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const e = this.treeAdapter.createElement(De.HTML, Ye.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null), this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e, w.HTML);
  }
  /** @protected */
  _appendCommentNode(e, n) {
    const r = this.treeAdapter.createCommentNode(e.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, e.location);
  }
  /** @protected */
  _insertCharacters(e) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, e.chars, r) : this.treeAdapter.insertText(n, e.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, e.chars)), !e.location)
      return;
    const i = this.treeAdapter.getChildNodes(n), s = r ? i.lastIndexOf(r) : i.length, a = i[s - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(a)) {
      const { endLine: u, endCol: c, endOffset: d } = e.location;
      this.treeAdapter.updateNodeSourceCodeLocation(a, { endLine: u, endCol: c, endOffset: d });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(a, e.location);
  }
  /** @protected */
  _adoptNodes(e, n) {
    for (let r = this.treeAdapter.getFirstChild(e); r; r = this.treeAdapter.getFirstChild(e))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(e, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(e) && n.location) {
      const r = n.location, i = this.treeAdapter.getTagName(e), s = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === fn.END_TAG && i === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(e, s);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(e) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, e.tagID === w.SVG && this.treeAdapter.getTagName(n) === De.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === Ye.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (e.tagID === w.MGLYPH || e.tagID === w.MALIGNMARK) && r !== void 0 && !this._isIntegrationPoint(r, n, Ye.HTML)
    );
  }
  /** @protected */
  _processToken(e) {
    switch (e.type) {
      case fn.CHARACTER: {
        this.onCharacter(e);
        break;
      }
      case fn.NULL_CHARACTER: {
        this.onNullCharacter(e);
        break;
      }
      case fn.COMMENT: {
        this.onComment(e);
        break;
      }
      case fn.DOCTYPE: {
        this.onDoctype(e);
        break;
      }
      case fn.START_TAG: {
        this._processStartTag(e);
        break;
      }
      case fn.END_TAG: {
        this.onEndTag(e);
        break;
      }
      case fn.EOF: {
        this.onEof(e);
        break;
      }
      case fn.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(e);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(e, n, r) {
    const i = this.treeAdapter.getNamespaceURI(n), s = this.treeAdapter.getAttrList(n);
    return U$(e, i, s, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const e = this.activeFormattingElements.entries.length;
    if (e) {
      const n = this.activeFormattingElements.entries.findIndex((i) => i.type === Ys.Marker || this.openElements.contains(i.element)), r = n === -1 ? e - 1 : n - 1;
      for (let i = r; i >= 0; i--) {
        const s = this.activeFormattingElements.entries[i];
        this._insertElement(s.token, this.treeAdapter.getNamespaceURI(s.element)), s.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = Ae.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(w.P), this.openElements.popUntilTagNamePopped(w.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let e = this.openElements.stackTop; e >= 0; e--)
      switch (e === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) {
        case w.TR: {
          this.insertionMode = Ae.IN_ROW;
          return;
        }
        case w.TBODY:
        case w.THEAD:
        case w.TFOOT: {
          this.insertionMode = Ae.IN_TABLE_BODY;
          return;
        }
        case w.CAPTION: {
          this.insertionMode = Ae.IN_CAPTION;
          return;
        }
        case w.COLGROUP: {
          this.insertionMode = Ae.IN_COLUMN_GROUP;
          return;
        }
        case w.TABLE: {
          this.insertionMode = Ae.IN_TABLE;
          return;
        }
        case w.BODY: {
          this.insertionMode = Ae.IN_BODY;
          return;
        }
        case w.FRAMESET: {
          this.insertionMode = Ae.IN_FRAMESET;
          return;
        }
        case w.SELECT: {
          this._resetInsertionModeForSelect(e);
          return;
        }
        case w.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case w.HTML: {
          this.insertionMode = this.headElement ? Ae.AFTER_HEAD : Ae.BEFORE_HEAD;
          return;
        }
        case w.TD:
        case w.TH: {
          if (e > 0) {
            this.insertionMode = Ae.IN_CELL;
            return;
          }
          break;
        }
        case w.HEAD: {
          if (e > 0) {
            this.insertionMode = Ae.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = Ae.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(e) {
    if (e > 0)
      for (let n = e - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === w.TEMPLATE)
          break;
        if (r === w.TABLE) {
          this.insertionMode = Ae.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = Ae.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(e) {
    return SI.has(e);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let e = this.openElements.stackTop; e >= 0; e--) {
      const n = this.openElements.items[e];
      switch (this.openElements.tagIDs[e]) {
        case w.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === Ye.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case w.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[e - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, e, n.beforeElement) : this.treeAdapter.appendChild(n.parent, e);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(e, n) {
    const r = this.treeAdapter.getNamespaceURI(e);
    return o$[r].has(n);
  }
  /** @internal */
  onCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      yj(this, e);
      return;
    }
    switch (this.insertionMode) {
      case Ae.INITIAL: {
        Td(this, e);
        break;
      }
      case Ae.BEFORE_HTML: {
        lf(this, e);
        break;
      }
      case Ae.BEFORE_HEAD: {
        cf(this, e);
        break;
      }
      case Ae.IN_HEAD: {
        df(this, e);
        break;
      }
      case Ae.IN_HEAD_NO_SCRIPT: {
        ff(this, e);
        break;
      }
      case Ae.AFTER_HEAD: {
        hf(this, e);
        break;
      }
      case Ae.IN_BODY:
      case Ae.IN_CAPTION:
      case Ae.IN_CELL:
      case Ae.IN_TEMPLATE: {
        DI(this, e);
        break;
      }
      case Ae.TEXT:
      case Ae.IN_SELECT:
      case Ae.IN_SELECT_IN_TABLE: {
        this._insertCharacters(e);
        break;
      }
      case Ae.IN_TABLE:
      case Ae.IN_TABLE_BODY:
      case Ae.IN_ROW: {
        iA(this, e);
        break;
      }
      case Ae.IN_TABLE_TEXT: {
        RI(this, e);
        break;
      }
      case Ae.IN_COLUMN_GROUP: {
        Vm(this, e);
        break;
      }
      case Ae.AFTER_BODY: {
        Wm(this, e);
        break;
      }
      case Ae.AFTER_AFTER_BODY: {
        nm(this, e);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      bj(this, e);
      return;
    }
    switch (this.insertionMode) {
      case Ae.INITIAL: {
        Td(this, e);
        break;
      }
      case Ae.BEFORE_HTML: {
        lf(this, e);
        break;
      }
      case Ae.BEFORE_HEAD: {
        cf(this, e);
        break;
      }
      case Ae.IN_HEAD: {
        df(this, e);
        break;
      }
      case Ae.IN_HEAD_NO_SCRIPT: {
        ff(this, e);
        break;
      }
      case Ae.AFTER_HEAD: {
        hf(this, e);
        break;
      }
      case Ae.TEXT: {
        this._insertCharacters(e);
        break;
      }
      case Ae.IN_TABLE:
      case Ae.IN_TABLE_BODY:
      case Ae.IN_ROW: {
        iA(this, e);
        break;
      }
      case Ae.IN_COLUMN_GROUP: {
        Vm(this, e);
        break;
      }
      case Ae.AFTER_BODY: {
        Wm(this, e);
        break;
      }
      case Ae.AFTER_AFTER_BODY: {
        nm(this, e);
        break;
      }
    }
  }
  /** @internal */
  onComment(e) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      cb(this, e);
      return;
    }
    switch (this.insertionMode) {
      case Ae.INITIAL:
      case Ae.BEFORE_HTML:
      case Ae.BEFORE_HEAD:
      case Ae.IN_HEAD:
      case Ae.IN_HEAD_NO_SCRIPT:
      case Ae.AFTER_HEAD:
      case Ae.IN_BODY:
      case Ae.IN_TABLE:
      case Ae.IN_CAPTION:
      case Ae.IN_COLUMN_GROUP:
      case Ae.IN_TABLE_BODY:
      case Ae.IN_ROW:
      case Ae.IN_CELL:
      case Ae.IN_SELECT:
      case Ae.IN_SELECT_IN_TABLE:
      case Ae.IN_TEMPLATE:
      case Ae.IN_FRAMESET:
      case Ae.AFTER_FRAMESET: {
        cb(this, e);
        break;
      }
      case Ae.IN_TABLE_TEXT: {
        _d(this, e);
        break;
      }
      case Ae.AFTER_BODY: {
        X$(this, e);
        break;
      }
      case Ae.AFTER_AFTER_BODY:
      case Ae.AFTER_AFTER_FRAMESET: {
        K$(this, e);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(e) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case Ae.INITIAL: {
        Z$(this, e);
        break;
      }
      case Ae.BEFORE_HEAD:
      case Ae.IN_HEAD:
      case Ae.IN_HEAD_NO_SCRIPT:
      case Ae.AFTER_HEAD: {
        this._err(e, Ue.misplacedDoctype);
        break;
      }
      case Ae.IN_TABLE_TEXT: {
        _d(this, e);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this._processStartTag(e), e.selfClosing && !e.ackSelfClosing && this._err(e, Ue.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(e) {
    this.shouldProcessStartTagTokenInForeignContent(e) ? vj(this, e) : this._startTagOutsideForeignContent(e);
  }
  /** @protected */
  _startTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case Ae.INITIAL: {
        Td(this, e);
        break;
      }
      case Ae.BEFORE_HTML: {
        J$(this, e);
        break;
      }
      case Ae.BEFORE_HEAD: {
        tH(this, e);
        break;
      }
      case Ae.IN_HEAD: {
        Fs(this, e);
        break;
      }
      case Ae.IN_HEAD_NO_SCRIPT: {
        iH(this, e);
        break;
      }
      case Ae.AFTER_HEAD: {
        aH(this, e);
        break;
      }
      case Ae.IN_BODY: {
        ri(this, e);
        break;
      }
      case Ae.IN_TABLE: {
        sc(this, e);
        break;
      }
      case Ae.IN_TABLE_TEXT: {
        _d(this, e);
        break;
      }
      case Ae.IN_CAPTION: {
        nj(this, e);
        break;
      }
      case Ae.IN_COLUMN_GROUP: {
        Sv(this, e);
        break;
      }
      case Ae.IN_TABLE_BODY: {
        J0(this, e);
        break;
      }
      case Ae.IN_ROW: {
        eg(this, e);
        break;
      }
      case Ae.IN_CELL: {
        sj(this, e);
        break;
      }
      case Ae.IN_SELECT: {
        UI(this, e);
        break;
      }
      case Ae.IN_SELECT_IN_TABLE: {
        oj(this, e);
        break;
      }
      case Ae.IN_TEMPLATE: {
        lj(this, e);
        break;
      }
      case Ae.AFTER_BODY: {
        dj(this, e);
        break;
      }
      case Ae.IN_FRAMESET: {
        fj(this, e);
        break;
      }
      case Ae.AFTER_FRAMESET: {
        pj(this, e);
        break;
      }
      case Ae.AFTER_AFTER_BODY: {
        gj(this, e);
        break;
      }
      case Ae.AFTER_AFTER_FRAMESET: {
        Aj(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this.currentNotInHTML ? Tj(this, e) : this._endTagOutsideForeignContent(e);
  }
  /** @protected */
  _endTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case Ae.INITIAL: {
        Td(this, e);
        break;
      }
      case Ae.BEFORE_HTML: {
        eH(this, e);
        break;
      }
      case Ae.BEFORE_HEAD: {
        nH(this, e);
        break;
      }
      case Ae.IN_HEAD: {
        rH(this, e);
        break;
      }
      case Ae.IN_HEAD_NO_SCRIPT: {
        sH(this, e);
        break;
      }
      case Ae.AFTER_HEAD: {
        oH(this, e);
        break;
      }
      case Ae.IN_BODY: {
        Z0(this, e);
        break;
      }
      case Ae.TEXT: {
        WH(this, e);
        break;
      }
      case Ae.IN_TABLE: {
        Pf(this, e);
        break;
      }
      case Ae.IN_TABLE_TEXT: {
        _d(this, e);
        break;
      }
      case Ae.IN_CAPTION: {
        rj(this, e);
        break;
      }
      case Ae.IN_COLUMN_GROUP: {
        ij(this, e);
        break;
      }
      case Ae.IN_TABLE_BODY: {
        db(this, e);
        break;
      }
      case Ae.IN_ROW: {
        FI(this, e);
        break;
      }
      case Ae.IN_CELL: {
        aj(this, e);
        break;
      }
      case Ae.IN_SELECT: {
        $I(this, e);
        break;
      }
      case Ae.IN_SELECT_IN_TABLE: {
        uj(this, e);
        break;
      }
      case Ae.IN_TEMPLATE: {
        cj(this, e);
        break;
      }
      case Ae.AFTER_BODY: {
        jI(this, e);
        break;
      }
      case Ae.IN_FRAMESET: {
        hj(this, e);
        break;
      }
      case Ae.AFTER_FRAMESET: {
        mj(this, e);
        break;
      }
      case Ae.AFTER_AFTER_BODY: {
        nm(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEof(e) {
    switch (this.insertionMode) {
      case Ae.INITIAL: {
        Td(this, e);
        break;
      }
      case Ae.BEFORE_HTML: {
        lf(this, e);
        break;
      }
      case Ae.BEFORE_HEAD: {
        cf(this, e);
        break;
      }
      case Ae.IN_HEAD: {
        df(this, e);
        break;
      }
      case Ae.IN_HEAD_NO_SCRIPT: {
        ff(this, e);
        break;
      }
      case Ae.AFTER_HEAD: {
        hf(this, e);
        break;
      }
      case Ae.IN_BODY:
      case Ae.IN_TABLE:
      case Ae.IN_CAPTION:
      case Ae.IN_COLUMN_GROUP:
      case Ae.IN_TABLE_BODY:
      case Ae.IN_ROW:
      case Ae.IN_CELL:
      case Ae.IN_SELECT:
      case Ae.IN_SELECT_IN_TABLE: {
        LI(this, e);
        break;
      }
      case Ae.TEXT: {
        QH(this, e);
        break;
      }
      case Ae.IN_TABLE_TEXT: {
        _d(this, e);
        break;
      }
      case Ae.IN_TEMPLATE: {
        HI(this, e);
        break;
      }
      case Ae.AFTER_BODY:
      case Ae.IN_FRAMESET:
      case Ae.AFTER_FRAMESET:
      case Ae.AFTER_AFTER_BODY:
      case Ae.AFTER_AFTER_FRAMESET: {
        Cv(this, e);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(e) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, e.chars.charCodeAt(0) === ae.LINE_FEED)) {
      if (e.chars.length === 1)
        return;
      e.chars = e.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(e);
      return;
    }
    switch (this.insertionMode) {
      case Ae.IN_HEAD:
      case Ae.IN_HEAD_NO_SCRIPT:
      case Ae.AFTER_HEAD:
      case Ae.TEXT:
      case Ae.IN_COLUMN_GROUP:
      case Ae.IN_SELECT:
      case Ae.IN_SELECT_IN_TABLE:
      case Ae.IN_FRAMESET:
      case Ae.AFTER_FRAMESET: {
        this._insertCharacters(e);
        break;
      }
      case Ae.IN_BODY:
      case Ae.IN_CAPTION:
      case Ae.IN_CELL:
      case Ae.IN_TEMPLATE:
      case Ae.AFTER_BODY:
      case Ae.AFTER_AFTER_BODY:
      case Ae.AFTER_AFTER_FRAMESET: {
        kI(this, e);
        break;
      }
      case Ae.IN_TABLE:
      case Ae.IN_TABLE_BODY:
      case Ae.IN_ROW: {
        iA(this, e);
        break;
      }
      case Ae.IN_TABLE_TEXT: {
        PI(this, e);
        break;
      }
    }
  }
};
function q$(t, e) {
  let n = t.activeFormattingElements.getElementEntryInScopeWithTagName(e.tagName);
  return n ? t.openElements.contains(n.element) ? t.openElements.hasInScope(e.tagID) || (n = null) : (t.activeFormattingElements.removeEntry(n), n = null) : NI(t, e), n;
}
function V$(t, e) {
  let n = null, r = t.openElements.stackTop;
  for (; r >= 0; r--) {
    const i = t.openElements.items[r];
    if (i === e.element)
      break;
    t._isSpecialElement(i, t.openElements.tagIDs[r]) && (n = i);
  }
  return n || (t.openElements.shortenToLength(Math.max(r, 0)), t.activeFormattingElements.removeEntry(e)), n;
}
function W$(t, e, n) {
  let r = e, i = t.openElements.getCommonAncestor(e);
  for (let s = 0, a = i; a !== n; s++, a = i) {
    i = t.openElements.getCommonAncestor(a);
    const o = t.activeFormattingElements.getElementEntry(a), u = o && s >= j$;
    !o || u ? (u && t.activeFormattingElements.removeEntry(o), t.openElements.remove(a)) : (a = Q$(t, o), r === e && (t.activeFormattingElements.bookmark = o), t.treeAdapter.detachNode(r), t.treeAdapter.appendChild(a, r), r = a);
  }
  return r;
}
function Q$(t, e) {
  const n = t.treeAdapter.getNamespaceURI(e.element), r = t.treeAdapter.createElement(e.token.tagName, n, e.token.attrs);
  return t.openElements.replace(e.element, r), e.element = r, r;
}
function G$(t, e, n) {
  const r = t.treeAdapter.getTagName(e), i = X0(r);
  if (t._isElementCausesFosterParenting(i))
    t._fosterParentElement(n);
  else {
    const s = t.treeAdapter.getNamespaceURI(e);
    i === w.TEMPLATE && s === Ye.HTML && (e = t.treeAdapter.getTemplateContent(e)), t.treeAdapter.appendChild(e, n);
  }
}
function Y$(t, e, n) {
  const r = t.treeAdapter.getNamespaceURI(n.element), { token: i } = n, s = t.treeAdapter.createElement(i.tagName, r, i.attrs);
  t._adoptNodes(e, s), t.treeAdapter.appendChild(e, s), t.activeFormattingElements.insertElementAfterBookmark(s, i), t.activeFormattingElements.removeEntry(n), t.openElements.remove(n.element), t.openElements.insertAfter(e, s, i.tagID);
}
function wv(t, e) {
  for (let n = 0; n < H$; n++) {
    const r = q$(t, e);
    if (!r)
      break;
    const i = V$(t, r);
    if (!i)
      break;
    t.activeFormattingElements.bookmark = r;
    const s = W$(t, i, r.element), a = t.openElements.getCommonAncestor(r.element);
    t.treeAdapter.detachNode(s), a && G$(t, a, s), Y$(t, i, r);
  }
}
function cb(t, e) {
  t._appendCommentNode(e, t.openElements.currentTmplContentOrNode);
}
function X$(t, e) {
  t._appendCommentNode(e, t.openElements.items[0]);
}
function K$(t, e) {
  t._appendCommentNode(e, t.document);
}
function Cv(t, e) {
  if (t.stopped = !0, e.location) {
    const n = t.fragmentContext ? 0 : 2;
    for (let r = t.openElements.stackTop; r >= n; r--)
      t._setEndLocation(t.openElements.items[r], e);
    if (!t.fragmentContext && t.openElements.stackTop >= 0) {
      const r = t.openElements.items[0], i = t.treeAdapter.getNodeSourceCodeLocation(r);
      if (i && !i.endTag && (t._setEndLocation(r, e), t.openElements.stackTop >= 1)) {
        const s = t.openElements.items[1], a = t.treeAdapter.getNodeSourceCodeLocation(s);
        a && !a.endTag && t._setEndLocation(s, e);
      }
    }
  }
}
function Z$(t, e) {
  t._setDocumentType(e);
  const n = e.forceQuirks ? zi.QUIRKS : I$(e);
  S$(e) || t._err(e, Ue.nonConformingDoctype), t.treeAdapter.setDocumentMode(t.document, n), t.insertionMode = Ae.BEFORE_HTML;
}
function Td(t, e) {
  t._err(e, Ue.missingDoctype, !0), t.treeAdapter.setDocumentMode(t.document, zi.QUIRKS), t.insertionMode = Ae.BEFORE_HTML, t._processToken(e);
}
function J$(t, e) {
  e.tagID === w.HTML ? (t._insertElement(e, Ye.HTML), t.insertionMode = Ae.BEFORE_HEAD) : lf(t, e);
}
function eH(t, e) {
  const n = e.tagID;
  (n === w.HTML || n === w.HEAD || n === w.BODY || n === w.BR) && lf(t, e);
}
function lf(t, e) {
  t._insertFakeRootElement(), t.insertionMode = Ae.BEFORE_HEAD, t._processToken(e);
}
function tH(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.HEAD: {
      t._insertElement(e, Ye.HTML), t.headElement = t.openElements.current, t.insertionMode = Ae.IN_HEAD;
      break;
    }
    default:
      cf(t, e);
  }
}
function nH(t, e) {
  const n = e.tagID;
  n === w.HEAD || n === w.BODY || n === w.HTML || n === w.BR ? cf(t, e) : t._err(e, Ue.endTagWithoutMatchingOpenElement);
}
function cf(t, e) {
  t._insertFakeElement(De.HEAD, w.HEAD), t.headElement = t.openElements.current, t.insertionMode = Ae.IN_HEAD, t._processToken(e);
}
function Fs(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.BASE:
    case w.BASEFONT:
    case w.BGSOUND:
    case w.LINK:
    case w.META: {
      t._appendElement(e, Ye.HTML), e.ackSelfClosing = !0;
      break;
    }
    case w.TITLE: {
      t._switchToTextParsing(e, Ci.RCDATA);
      break;
    }
    case w.NOSCRIPT: {
      t.options.scriptingEnabled ? t._switchToTextParsing(e, Ci.RAWTEXT) : (t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_HEAD_NO_SCRIPT);
      break;
    }
    case w.NOFRAMES:
    case w.STYLE: {
      t._switchToTextParsing(e, Ci.RAWTEXT);
      break;
    }
    case w.SCRIPT: {
      t._switchToTextParsing(e, Ci.SCRIPT_DATA);
      break;
    }
    case w.TEMPLATE: {
      t._insertTemplate(e), t.activeFormattingElements.insertMarker(), t.framesetOk = !1, t.insertionMode = Ae.IN_TEMPLATE, t.tmplInsertionModeStack.unshift(Ae.IN_TEMPLATE);
      break;
    }
    case w.HEAD: {
      t._err(e, Ue.misplacedStartTagForHeadElement);
      break;
    }
    default:
      df(t, e);
  }
}
function rH(t, e) {
  switch (e.tagID) {
    case w.HEAD: {
      t.openElements.pop(), t.insertionMode = Ae.AFTER_HEAD;
      break;
    }
    case w.BODY:
    case w.BR:
    case w.HTML: {
      df(t, e);
      break;
    }
    case w.TEMPLATE: {
      Ku(t, e);
      break;
    }
    default:
      t._err(e, Ue.endTagWithoutMatchingOpenElement);
  }
}
function Ku(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.generateImpliedEndTagsThoroughly(), t.openElements.currentTagId !== w.TEMPLATE && t._err(e, Ue.closingOfElementWithOpenChildElements), t.openElements.popUntilTagNamePopped(w.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode()) : t._err(e, Ue.endTagWithoutMatchingOpenElement);
}
function df(t, e) {
  t.openElements.pop(), t.insertionMode = Ae.AFTER_HEAD, t._processToken(e);
}
function iH(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.BASEFONT:
    case w.BGSOUND:
    case w.HEAD:
    case w.LINK:
    case w.META:
    case w.NOFRAMES:
    case w.STYLE: {
      Fs(t, e);
      break;
    }
    case w.NOSCRIPT: {
      t._err(e, Ue.nestedNoscriptInHead);
      break;
    }
    default:
      ff(t, e);
  }
}
function sH(t, e) {
  switch (e.tagID) {
    case w.NOSCRIPT: {
      t.openElements.pop(), t.insertionMode = Ae.IN_HEAD;
      break;
    }
    case w.BR: {
      ff(t, e);
      break;
    }
    default:
      t._err(e, Ue.endTagWithoutMatchingOpenElement);
  }
}
function ff(t, e) {
  const n = e.type === fn.EOF ? Ue.openElementsLeftAfterEof : Ue.disallowedContentInNoscriptInHead;
  t._err(e, n), t.openElements.pop(), t.insertionMode = Ae.IN_HEAD, t._processToken(e);
}
function aH(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.BODY: {
      t._insertElement(e, Ye.HTML), t.framesetOk = !1, t.insertionMode = Ae.IN_BODY;
      break;
    }
    case w.FRAMESET: {
      t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_FRAMESET;
      break;
    }
    case w.BASE:
    case w.BASEFONT:
    case w.BGSOUND:
    case w.LINK:
    case w.META:
    case w.NOFRAMES:
    case w.SCRIPT:
    case w.STYLE:
    case w.TEMPLATE:
    case w.TITLE: {
      t._err(e, Ue.abandonedHeadElementChild), t.openElements.push(t.headElement, w.HEAD), Fs(t, e), t.openElements.remove(t.headElement);
      break;
    }
    case w.HEAD: {
      t._err(e, Ue.misplacedStartTagForHeadElement);
      break;
    }
    default:
      hf(t, e);
  }
}
function oH(t, e) {
  switch (e.tagID) {
    case w.BODY:
    case w.HTML:
    case w.BR: {
      hf(t, e);
      break;
    }
    case w.TEMPLATE: {
      Ku(t, e);
      break;
    }
    default:
      t._err(e, Ue.endTagWithoutMatchingOpenElement);
  }
}
function hf(t, e) {
  t._insertFakeElement(De.BODY, w.BODY), t.insertionMode = Ae.IN_BODY, K0(t, e);
}
function K0(t, e) {
  switch (e.type) {
    case fn.CHARACTER: {
      DI(t, e);
      break;
    }
    case fn.WHITESPACE_CHARACTER: {
      kI(t, e);
      break;
    }
    case fn.COMMENT: {
      cb(t, e);
      break;
    }
    case fn.START_TAG: {
      ri(t, e);
      break;
    }
    case fn.END_TAG: {
      Z0(t, e);
      break;
    }
    case fn.EOF: {
      LI(t, e);
      break;
    }
  }
}
function kI(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e);
}
function DI(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e), t.framesetOk = !1;
}
function uH(t, e) {
  t.openElements.tmplCount === 0 && t.treeAdapter.adoptAttributes(t.openElements.items[0], e.attrs);
}
function lH(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  n && t.openElements.tmplCount === 0 && (t.framesetOk = !1, t.treeAdapter.adoptAttributes(n, e.attrs));
}
function cH(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  t.framesetOk && n && (t.treeAdapter.detachNode(n), t.openElements.popAllUpToHtmlElement(), t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_FRAMESET);
}
function dH(t, e) {
  t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._insertElement(e, Ye.HTML);
}
function fH(t, e) {
  t.openElements.hasInButtonScope(w.P) && t._closePElement(), t.openElements.currentTagId !== void 0 && lb.has(t.openElements.currentTagId) && t.openElements.pop(), t._insertElement(e, Ye.HTML);
}
function hH(t, e) {
  t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._insertElement(e, Ye.HTML), t.skipNextNewLine = !0, t.framesetOk = !1;
}
function pH(t, e) {
  const n = t.openElements.tmplCount > 0;
  (!t.formElement || n) && (t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._insertElement(e, Ye.HTML), n || (t.formElement = t.openElements.current));
}
function mH(t, e) {
  t.framesetOk = !1;
  const n = e.tagID;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const i = t.openElements.tagIDs[r];
    if (n === w.LI && i === w.LI || (n === w.DD || n === w.DT) && (i === w.DD || i === w.DT)) {
      t.openElements.generateImpliedEndTagsWithExclusion(i), t.openElements.popUntilTagNamePopped(i);
      break;
    }
    if (i !== w.ADDRESS && i !== w.DIV && i !== w.P && t._isSpecialElement(t.openElements.items[r], i))
      break;
  }
  t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._insertElement(e, Ye.HTML);
}
function gH(t, e) {
  t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._insertElement(e, Ye.HTML), t.tokenizer.state = Ci.PLAINTEXT;
}
function AH(t, e) {
  t.openElements.hasInScope(w.BUTTON) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(w.BUTTON)), t._reconstructActiveFormattingElements(), t._insertElement(e, Ye.HTML), t.framesetOk = !1;
}
function bH(t, e) {
  const n = t.activeFormattingElements.getElementEntryInScopeWithTagName(De.A);
  n && (wv(t, e), t.openElements.remove(n.element), t.activeFormattingElements.removeEntry(n)), t._reconstructActiveFormattingElements(), t._insertElement(e, Ye.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function yH(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ye.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function vH(t, e) {
  t._reconstructActiveFormattingElements(), t.openElements.hasInScope(w.NOBR) && (wv(t, e), t._reconstructActiveFormattingElements()), t._insertElement(e, Ye.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function TH(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ye.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1;
}
function _H(t, e) {
  t.treeAdapter.getDocumentMode(t.document) !== zi.QUIRKS && t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._insertElement(e, Ye.HTML), t.framesetOk = !1, t.insertionMode = Ae.IN_TABLE;
}
function MI(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, Ye.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function OI(t) {
  const e = yI(t, wu.TYPE);
  return e != null && e.toLowerCase() === $$;
}
function EH(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, Ye.HTML), OI(e) || (t.framesetOk = !1), e.ackSelfClosing = !0;
}
function xH(t, e) {
  t._appendElement(e, Ye.HTML), e.ackSelfClosing = !0;
}
function wH(t, e) {
  t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._appendElement(e, Ye.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function CH(t, e) {
  e.tagName = De.IMG, e.tagID = w.IMG, MI(t, e);
}
function SH(t, e) {
  t._insertElement(e, Ye.HTML), t.skipNextNewLine = !0, t.tokenizer.state = Ci.RCDATA, t.originalInsertionMode = t.insertionMode, t.framesetOk = !1, t.insertionMode = Ae.TEXT;
}
function IH(t, e) {
  t.openElements.hasInButtonScope(w.P) && t._closePElement(), t._reconstructActiveFormattingElements(), t.framesetOk = !1, t._switchToTextParsing(e, Ci.RAWTEXT);
}
function kH(t, e) {
  t.framesetOk = !1, t._switchToTextParsing(e, Ci.RAWTEXT);
}
function aE(t, e) {
  t._switchToTextParsing(e, Ci.RAWTEXT);
}
function DH(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ye.HTML), t.framesetOk = !1, t.insertionMode = t.insertionMode === Ae.IN_TABLE || t.insertionMode === Ae.IN_CAPTION || t.insertionMode === Ae.IN_TABLE_BODY || t.insertionMode === Ae.IN_ROW || t.insertionMode === Ae.IN_CELL ? Ae.IN_SELECT_IN_TABLE : Ae.IN_SELECT;
}
function MH(t, e) {
  t.openElements.currentTagId === w.OPTION && t.openElements.pop(), t._reconstructActiveFormattingElements(), t._insertElement(e, Ye.HTML);
}
function OH(t, e) {
  t.openElements.hasInScope(w.RUBY) && t.openElements.generateImpliedEndTags(), t._insertElement(e, Ye.HTML);
}
function NH(t, e) {
  t.openElements.hasInScope(w.RUBY) && t.openElements.generateImpliedEndTagsWithExclusion(w.RTC), t._insertElement(e, Ye.HTML);
}
function LH(t, e) {
  t._reconstructActiveFormattingElements(), wI(e), xv(e), e.selfClosing ? t._appendElement(e, Ye.MATHML) : t._insertElement(e, Ye.MATHML), e.ackSelfClosing = !0;
}
function PH(t, e) {
  t._reconstructActiveFormattingElements(), CI(e), xv(e), e.selfClosing ? t._appendElement(e, Ye.SVG) : t._insertElement(e, Ye.SVG), e.ackSelfClosing = !0;
}
function oE(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Ye.HTML);
}
function ri(t, e) {
  switch (e.tagID) {
    case w.I:
    case w.S:
    case w.B:
    case w.U:
    case w.EM:
    case w.TT:
    case w.BIG:
    case w.CODE:
    case w.FONT:
    case w.SMALL:
    case w.STRIKE:
    case w.STRONG: {
      yH(t, e);
      break;
    }
    case w.A: {
      bH(t, e);
      break;
    }
    case w.H1:
    case w.H2:
    case w.H3:
    case w.H4:
    case w.H5:
    case w.H6: {
      fH(t, e);
      break;
    }
    case w.P:
    case w.DL:
    case w.OL:
    case w.UL:
    case w.DIV:
    case w.DIR:
    case w.NAV:
    case w.MAIN:
    case w.MENU:
    case w.ASIDE:
    case w.CENTER:
    case w.FIGURE:
    case w.FOOTER:
    case w.HEADER:
    case w.HGROUP:
    case w.DIALOG:
    case w.DETAILS:
    case w.ADDRESS:
    case w.ARTICLE:
    case w.SEARCH:
    case w.SECTION:
    case w.SUMMARY:
    case w.FIELDSET:
    case w.BLOCKQUOTE:
    case w.FIGCAPTION: {
      dH(t, e);
      break;
    }
    case w.LI:
    case w.DD:
    case w.DT: {
      mH(t, e);
      break;
    }
    case w.BR:
    case w.IMG:
    case w.WBR:
    case w.AREA:
    case w.EMBED:
    case w.KEYGEN: {
      MI(t, e);
      break;
    }
    case w.HR: {
      wH(t, e);
      break;
    }
    case w.RB:
    case w.RTC: {
      OH(t, e);
      break;
    }
    case w.RT:
    case w.RP: {
      NH(t, e);
      break;
    }
    case w.PRE:
    case w.LISTING: {
      hH(t, e);
      break;
    }
    case w.XMP: {
      IH(t, e);
      break;
    }
    case w.SVG: {
      PH(t, e);
      break;
    }
    case w.HTML: {
      uH(t, e);
      break;
    }
    case w.BASE:
    case w.LINK:
    case w.META:
    case w.STYLE:
    case w.TITLE:
    case w.SCRIPT:
    case w.BGSOUND:
    case w.BASEFONT:
    case w.TEMPLATE: {
      Fs(t, e);
      break;
    }
    case w.BODY: {
      lH(t, e);
      break;
    }
    case w.FORM: {
      pH(t, e);
      break;
    }
    case w.NOBR: {
      vH(t, e);
      break;
    }
    case w.MATH: {
      LH(t, e);
      break;
    }
    case w.TABLE: {
      _H(t, e);
      break;
    }
    case w.INPUT: {
      EH(t, e);
      break;
    }
    case w.PARAM:
    case w.TRACK:
    case w.SOURCE: {
      xH(t, e);
      break;
    }
    case w.IMAGE: {
      CH(t, e);
      break;
    }
    case w.BUTTON: {
      AH(t, e);
      break;
    }
    case w.APPLET:
    case w.OBJECT:
    case w.MARQUEE: {
      TH(t, e);
      break;
    }
    case w.IFRAME: {
      kH(t, e);
      break;
    }
    case w.SELECT: {
      DH(t, e);
      break;
    }
    case w.OPTION:
    case w.OPTGROUP: {
      MH(t, e);
      break;
    }
    case w.NOEMBED:
    case w.NOFRAMES: {
      aE(t, e);
      break;
    }
    case w.FRAMESET: {
      cH(t, e);
      break;
    }
    case w.TEXTAREA: {
      SH(t, e);
      break;
    }
    case w.NOSCRIPT: {
      t.options.scriptingEnabled ? aE(t, e) : oE(t, e);
      break;
    }
    case w.PLAINTEXT: {
      gH(t, e);
      break;
    }
    case w.COL:
    case w.TH:
    case w.TD:
    case w.TR:
    case w.HEAD:
    case w.FRAME:
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD:
    case w.CAPTION:
    case w.COLGROUP:
      break;
    default:
      oE(t, e);
  }
}
function RH(t, e) {
  if (t.openElements.hasInScope(w.BODY) && (t.insertionMode = Ae.AFTER_BODY, t.options.sourceCodeLocationInfo)) {
    const n = t.openElements.tryPeekProperlyNestedBodyElement();
    n && t._setEndLocation(n, e);
  }
}
function BH(t, e) {
  t.openElements.hasInScope(w.BODY) && (t.insertionMode = Ae.AFTER_BODY, jI(t, e));
}
function FH(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n));
}
function UH(t) {
  const e = t.openElements.tmplCount > 0, { formElement: n } = t;
  e || (t.formElement = null), (n || e) && t.openElements.hasInScope(w.FORM) && (t.openElements.generateImpliedEndTags(), e ? t.openElements.popUntilTagNamePopped(w.FORM) : n && t.openElements.remove(n));
}
function $H(t) {
  t.openElements.hasInButtonScope(w.P) || t._insertFakeElement(De.P, w.P), t._closePElement();
}
function HH(t) {
  t.openElements.hasInListItemScope(w.LI) && (t.openElements.generateImpliedEndTagsWithExclusion(w.LI), t.openElements.popUntilTagNamePopped(w.LI));
}
function jH(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilTagNamePopped(n));
}
function zH(t) {
  t.openElements.hasNumberedHeaderInScope() && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilNumberedHeaderPopped());
}
function qH(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker());
}
function VH(t) {
  t._reconstructActiveFormattingElements(), t._insertFakeElement(De.BR, w.BR), t.openElements.pop(), t.framesetOk = !1;
}
function NI(t, e) {
  const n = e.tagName, r = e.tagID;
  for (let i = t.openElements.stackTop; i > 0; i--) {
    const s = t.openElements.items[i], a = t.openElements.tagIDs[i];
    if (r === a && (r !== w.UNKNOWN || t.treeAdapter.getTagName(s) === n)) {
      t.openElements.generateImpliedEndTagsWithExclusion(r), t.openElements.stackTop >= i && t.openElements.shortenToLength(i);
      break;
    }
    if (t._isSpecialElement(s, a))
      break;
  }
}
function Z0(t, e) {
  switch (e.tagID) {
    case w.A:
    case w.B:
    case w.I:
    case w.S:
    case w.U:
    case w.EM:
    case w.TT:
    case w.BIG:
    case w.CODE:
    case w.FONT:
    case w.NOBR:
    case w.SMALL:
    case w.STRIKE:
    case w.STRONG: {
      wv(t, e);
      break;
    }
    case w.P: {
      $H(t);
      break;
    }
    case w.DL:
    case w.UL:
    case w.OL:
    case w.DIR:
    case w.DIV:
    case w.NAV:
    case w.PRE:
    case w.MAIN:
    case w.MENU:
    case w.ASIDE:
    case w.BUTTON:
    case w.CENTER:
    case w.FIGURE:
    case w.FOOTER:
    case w.HEADER:
    case w.HGROUP:
    case w.DIALOG:
    case w.ADDRESS:
    case w.ARTICLE:
    case w.DETAILS:
    case w.SEARCH:
    case w.SECTION:
    case w.SUMMARY:
    case w.LISTING:
    case w.FIELDSET:
    case w.BLOCKQUOTE:
    case w.FIGCAPTION: {
      FH(t, e);
      break;
    }
    case w.LI: {
      HH(t);
      break;
    }
    case w.DD:
    case w.DT: {
      jH(t, e);
      break;
    }
    case w.H1:
    case w.H2:
    case w.H3:
    case w.H4:
    case w.H5:
    case w.H6: {
      zH(t);
      break;
    }
    case w.BR: {
      VH(t);
      break;
    }
    case w.BODY: {
      RH(t, e);
      break;
    }
    case w.HTML: {
      BH(t, e);
      break;
    }
    case w.FORM: {
      UH(t);
      break;
    }
    case w.APPLET:
    case w.OBJECT:
    case w.MARQUEE: {
      qH(t, e);
      break;
    }
    case w.TEMPLATE: {
      Ku(t, e);
      break;
    }
    default:
      NI(t, e);
  }
}
function LI(t, e) {
  t.tmplInsertionModeStack.length > 0 ? HI(t, e) : Cv(t, e);
}
function WH(t, e) {
  var n;
  e.tagID === w.SCRIPT && ((n = t.scriptHandler) === null || n === void 0 || n.call(t, t.openElements.current)), t.openElements.pop(), t.insertionMode = t.originalInsertionMode;
}
function QH(t, e) {
  t._err(e, Ue.eofInElementThatCanContainOnlyText), t.openElements.pop(), t.insertionMode = t.originalInsertionMode, t.onEof(e);
}
function iA(t, e) {
  if (t.openElements.currentTagId !== void 0 && SI.has(t.openElements.currentTagId))
    switch (t.pendingCharacterTokens.length = 0, t.hasNonWhitespacePendingCharacterToken = !1, t.originalInsertionMode = t.insertionMode, t.insertionMode = Ae.IN_TABLE_TEXT, e.type) {
      case fn.CHARACTER: {
        RI(t, e);
        break;
      }
      case fn.WHITESPACE_CHARACTER: {
        PI(t, e);
        break;
      }
    }
  else
    mh(t, e);
}
function GH(t, e) {
  t.openElements.clearBackToTableContext(), t.activeFormattingElements.insertMarker(), t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_CAPTION;
}
function YH(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_COLUMN_GROUP;
}
function XH(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(De.COLGROUP, w.COLGROUP), t.insertionMode = Ae.IN_COLUMN_GROUP, Sv(t, e);
}
function KH(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_TABLE_BODY;
}
function ZH(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(De.TBODY, w.TBODY), t.insertionMode = Ae.IN_TABLE_BODY, J0(t, e);
}
function JH(t, e) {
  t.openElements.hasInTableScope(w.TABLE) && (t.openElements.popUntilTagNamePopped(w.TABLE), t._resetInsertionMode(), t._processStartTag(e));
}
function ej(t, e) {
  OI(e) ? t._appendElement(e, Ye.HTML) : mh(t, e), e.ackSelfClosing = !0;
}
function tj(t, e) {
  !t.formElement && t.openElements.tmplCount === 0 && (t._insertElement(e, Ye.HTML), t.formElement = t.openElements.current, t.openElements.pop());
}
function sc(t, e) {
  switch (e.tagID) {
    case w.TD:
    case w.TH:
    case w.TR: {
      ZH(t, e);
      break;
    }
    case w.STYLE:
    case w.SCRIPT:
    case w.TEMPLATE: {
      Fs(t, e);
      break;
    }
    case w.COL: {
      XH(t, e);
      break;
    }
    case w.FORM: {
      tj(t, e);
      break;
    }
    case w.TABLE: {
      JH(t, e);
      break;
    }
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD: {
      KH(t, e);
      break;
    }
    case w.INPUT: {
      ej(t, e);
      break;
    }
    case w.CAPTION: {
      GH(t, e);
      break;
    }
    case w.COLGROUP: {
      YH(t, e);
      break;
    }
    default:
      mh(t, e);
  }
}
function Pf(t, e) {
  switch (e.tagID) {
    case w.TABLE: {
      t.openElements.hasInTableScope(w.TABLE) && (t.openElements.popUntilTagNamePopped(w.TABLE), t._resetInsertionMode());
      break;
    }
    case w.TEMPLATE: {
      Ku(t, e);
      break;
    }
    case w.BODY:
    case w.CAPTION:
    case w.COL:
    case w.COLGROUP:
    case w.HTML:
    case w.TBODY:
    case w.TD:
    case w.TFOOT:
    case w.TH:
    case w.THEAD:
    case w.TR:
      break;
    default:
      mh(t, e);
  }
}
function mh(t, e) {
  const n = t.fosterParentingEnabled;
  t.fosterParentingEnabled = !0, K0(t, e), t.fosterParentingEnabled = n;
}
function PI(t, e) {
  t.pendingCharacterTokens.push(e);
}
function RI(t, e) {
  t.pendingCharacterTokens.push(e), t.hasNonWhitespacePendingCharacterToken = !0;
}
function _d(t, e) {
  let n = 0;
  if (t.hasNonWhitespacePendingCharacterToken)
    for (; n < t.pendingCharacterTokens.length; n++)
      mh(t, t.pendingCharacterTokens[n]);
  else
    for (; n < t.pendingCharacterTokens.length; n++)
      t._insertCharacters(t.pendingCharacterTokens[n]);
  t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
const BI = /* @__PURE__ */ new Set([w.CAPTION, w.COL, w.COLGROUP, w.TBODY, w.TD, w.TFOOT, w.TH, w.THEAD, w.TR]);
function nj(t, e) {
  const n = e.tagID;
  BI.has(n) ? t.openElements.hasInTableScope(w.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(w.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = Ae.IN_TABLE, sc(t, e)) : ri(t, e);
}
function rj(t, e) {
  const n = e.tagID;
  switch (n) {
    case w.CAPTION:
    case w.TABLE: {
      t.openElements.hasInTableScope(w.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(w.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = Ae.IN_TABLE, n === w.TABLE && Pf(t, e));
      break;
    }
    case w.BODY:
    case w.COL:
    case w.COLGROUP:
    case w.HTML:
    case w.TBODY:
    case w.TD:
    case w.TFOOT:
    case w.TH:
    case w.THEAD:
    case w.TR:
      break;
    default:
      Z0(t, e);
  }
}
function Sv(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.COL: {
      t._appendElement(e, Ye.HTML), e.ackSelfClosing = !0;
      break;
    }
    case w.TEMPLATE: {
      Fs(t, e);
      break;
    }
    default:
      Vm(t, e);
  }
}
function ij(t, e) {
  switch (e.tagID) {
    case w.COLGROUP: {
      t.openElements.currentTagId === w.COLGROUP && (t.openElements.pop(), t.insertionMode = Ae.IN_TABLE);
      break;
    }
    case w.TEMPLATE: {
      Ku(t, e);
      break;
    }
    case w.COL:
      break;
    default:
      Vm(t, e);
  }
}
function Vm(t, e) {
  t.openElements.currentTagId === w.COLGROUP && (t.openElements.pop(), t.insertionMode = Ae.IN_TABLE, t._processToken(e));
}
function J0(t, e) {
  switch (e.tagID) {
    case w.TR: {
      t.openElements.clearBackToTableBodyContext(), t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_ROW;
      break;
    }
    case w.TH:
    case w.TD: {
      t.openElements.clearBackToTableBodyContext(), t._insertFakeElement(De.TR, w.TR), t.insertionMode = Ae.IN_ROW, eg(t, e);
      break;
    }
    case w.CAPTION:
    case w.COL:
    case w.COLGROUP:
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = Ae.IN_TABLE, sc(t, e));
      break;
    }
    default:
      sc(t, e);
  }
}
function db(t, e) {
  const n = e.tagID;
  switch (e.tagID) {
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD: {
      t.openElements.hasInTableScope(n) && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = Ae.IN_TABLE);
      break;
    }
    case w.TABLE: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = Ae.IN_TABLE, Pf(t, e));
      break;
    }
    case w.BODY:
    case w.CAPTION:
    case w.COL:
    case w.COLGROUP:
    case w.HTML:
    case w.TD:
    case w.TH:
    case w.TR:
      break;
    default:
      Pf(t, e);
  }
}
function eg(t, e) {
  switch (e.tagID) {
    case w.TH:
    case w.TD: {
      t.openElements.clearBackToTableRowContext(), t._insertElement(e, Ye.HTML), t.insertionMode = Ae.IN_CELL, t.activeFormattingElements.insertMarker();
      break;
    }
    case w.CAPTION:
    case w.COL:
    case w.COLGROUP:
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD:
    case w.TR: {
      t.openElements.hasInTableScope(w.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Ae.IN_TABLE_BODY, J0(t, e));
      break;
    }
    default:
      sc(t, e);
  }
}
function FI(t, e) {
  switch (e.tagID) {
    case w.TR: {
      t.openElements.hasInTableScope(w.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Ae.IN_TABLE_BODY);
      break;
    }
    case w.TABLE: {
      t.openElements.hasInTableScope(w.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Ae.IN_TABLE_BODY, db(t, e));
      break;
    }
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD: {
      (t.openElements.hasInTableScope(e.tagID) || t.openElements.hasInTableScope(w.TR)) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = Ae.IN_TABLE_BODY, db(t, e));
      break;
    }
    case w.BODY:
    case w.CAPTION:
    case w.COL:
    case w.COLGROUP:
    case w.HTML:
    case w.TD:
    case w.TH:
      break;
    default:
      Pf(t, e);
  }
}
function sj(t, e) {
  const n = e.tagID;
  BI.has(n) ? (t.openElements.hasInTableScope(w.TD) || t.openElements.hasInTableScope(w.TH)) && (t._closeTableCell(), eg(t, e)) : ri(t, e);
}
function aj(t, e) {
  const n = e.tagID;
  switch (n) {
    case w.TD:
    case w.TH: {
      t.openElements.hasInTableScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = Ae.IN_ROW);
      break;
    }
    case w.TABLE:
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD:
    case w.TR: {
      t.openElements.hasInTableScope(n) && (t._closeTableCell(), FI(t, e));
      break;
    }
    case w.BODY:
    case w.CAPTION:
    case w.COL:
    case w.COLGROUP:
    case w.HTML:
      break;
    default:
      Z0(t, e);
  }
}
function UI(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.OPTION: {
      t.openElements.currentTagId === w.OPTION && t.openElements.pop(), t._insertElement(e, Ye.HTML);
      break;
    }
    case w.OPTGROUP: {
      t.openElements.currentTagId === w.OPTION && t.openElements.pop(), t.openElements.currentTagId === w.OPTGROUP && t.openElements.pop(), t._insertElement(e, Ye.HTML);
      break;
    }
    case w.HR: {
      t.openElements.currentTagId === w.OPTION && t.openElements.pop(), t.openElements.currentTagId === w.OPTGROUP && t.openElements.pop(), t._appendElement(e, Ye.HTML), e.ackSelfClosing = !0;
      break;
    }
    case w.INPUT:
    case w.KEYGEN:
    case w.TEXTAREA:
    case w.SELECT: {
      t.openElements.hasInSelectScope(w.SELECT) && (t.openElements.popUntilTagNamePopped(w.SELECT), t._resetInsertionMode(), e.tagID !== w.SELECT && t._processStartTag(e));
      break;
    }
    case w.SCRIPT:
    case w.TEMPLATE: {
      Fs(t, e);
      break;
    }
  }
}
function $I(t, e) {
  switch (e.tagID) {
    case w.OPTGROUP: {
      t.openElements.stackTop > 0 && t.openElements.currentTagId === w.OPTION && t.openElements.tagIDs[t.openElements.stackTop - 1] === w.OPTGROUP && t.openElements.pop(), t.openElements.currentTagId === w.OPTGROUP && t.openElements.pop();
      break;
    }
    case w.OPTION: {
      t.openElements.currentTagId === w.OPTION && t.openElements.pop();
      break;
    }
    case w.SELECT: {
      t.openElements.hasInSelectScope(w.SELECT) && (t.openElements.popUntilTagNamePopped(w.SELECT), t._resetInsertionMode());
      break;
    }
    case w.TEMPLATE: {
      Ku(t, e);
      break;
    }
  }
}
function oj(t, e) {
  const n = e.tagID;
  n === w.CAPTION || n === w.TABLE || n === w.TBODY || n === w.TFOOT || n === w.THEAD || n === w.TR || n === w.TD || n === w.TH ? (t.openElements.popUntilTagNamePopped(w.SELECT), t._resetInsertionMode(), t._processStartTag(e)) : UI(t, e);
}
function uj(t, e) {
  const n = e.tagID;
  n === w.CAPTION || n === w.TABLE || n === w.TBODY || n === w.TFOOT || n === w.THEAD || n === w.TR || n === w.TD || n === w.TH ? t.openElements.hasInTableScope(n) && (t.openElements.popUntilTagNamePopped(w.SELECT), t._resetInsertionMode(), t.onEndTag(e)) : $I(t, e);
}
function lj(t, e) {
  switch (e.tagID) {
    // First, handle tags that can start without a mode change
    case w.BASE:
    case w.BASEFONT:
    case w.BGSOUND:
    case w.LINK:
    case w.META:
    case w.NOFRAMES:
    case w.SCRIPT:
    case w.STYLE:
    case w.TEMPLATE:
    case w.TITLE: {
      Fs(t, e);
      break;
    }
    // Re-process the token in the appropriate mode
    case w.CAPTION:
    case w.COLGROUP:
    case w.TBODY:
    case w.TFOOT:
    case w.THEAD: {
      t.tmplInsertionModeStack[0] = Ae.IN_TABLE, t.insertionMode = Ae.IN_TABLE, sc(t, e);
      break;
    }
    case w.COL: {
      t.tmplInsertionModeStack[0] = Ae.IN_COLUMN_GROUP, t.insertionMode = Ae.IN_COLUMN_GROUP, Sv(t, e);
      break;
    }
    case w.TR: {
      t.tmplInsertionModeStack[0] = Ae.IN_TABLE_BODY, t.insertionMode = Ae.IN_TABLE_BODY, J0(t, e);
      break;
    }
    case w.TD:
    case w.TH: {
      t.tmplInsertionModeStack[0] = Ae.IN_ROW, t.insertionMode = Ae.IN_ROW, eg(t, e);
      break;
    }
    default:
      t.tmplInsertionModeStack[0] = Ae.IN_BODY, t.insertionMode = Ae.IN_BODY, ri(t, e);
  }
}
function cj(t, e) {
  e.tagID === w.TEMPLATE && Ku(t, e);
}
function HI(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.popUntilTagNamePopped(w.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode(), t.onEof(e)) : Cv(t, e);
}
function dj(t, e) {
  e.tagID === w.HTML ? ri(t, e) : Wm(t, e);
}
function jI(t, e) {
  var n;
  if (e.tagID === w.HTML) {
    if (t.fragmentContext || (t.insertionMode = Ae.AFTER_AFTER_BODY), t.options.sourceCodeLocationInfo && t.openElements.tagIDs[0] === w.HTML) {
      t._setEndLocation(t.openElements.items[0], e);
      const r = t.openElements.items[1];
      r && !(!((n = t.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && t._setEndLocation(r, e);
    }
  } else
    Wm(t, e);
}
function Wm(t, e) {
  t.insertionMode = Ae.IN_BODY, K0(t, e);
}
function fj(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.FRAMESET: {
      t._insertElement(e, Ye.HTML);
      break;
    }
    case w.FRAME: {
      t._appendElement(e, Ye.HTML), e.ackSelfClosing = !0;
      break;
    }
    case w.NOFRAMES: {
      Fs(t, e);
      break;
    }
  }
}
function hj(t, e) {
  e.tagID === w.FRAMESET && !t.openElements.isRootHtmlElementCurrent() && (t.openElements.pop(), !t.fragmentContext && t.openElements.currentTagId !== w.FRAMESET && (t.insertionMode = Ae.AFTER_FRAMESET));
}
function pj(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.NOFRAMES: {
      Fs(t, e);
      break;
    }
  }
}
function mj(t, e) {
  e.tagID === w.HTML && (t.insertionMode = Ae.AFTER_AFTER_FRAMESET);
}
function gj(t, e) {
  e.tagID === w.HTML ? ri(t, e) : nm(t, e);
}
function nm(t, e) {
  t.insertionMode = Ae.IN_BODY, K0(t, e);
}
function Aj(t, e) {
  switch (e.tagID) {
    case w.HTML: {
      ri(t, e);
      break;
    }
    case w.NOFRAMES: {
      Fs(t, e);
      break;
    }
  }
}
function bj(t, e) {
  e.chars = Gn, t._insertCharacters(e);
}
function yj(t, e) {
  t._insertCharacters(e), t.framesetOk = !1;
}
function zI(t) {
  for (; t.treeAdapter.getNamespaceURI(t.openElements.current) !== Ye.HTML && t.openElements.currentTagId !== void 0 && !t._isIntegrationPoint(t.openElements.currentTagId, t.openElements.current); )
    t.openElements.pop();
}
function vj(t, e) {
  if (P$(e))
    zI(t), t._startTagOutsideForeignContent(e);
  else {
    const n = t._getAdjustedCurrentElement(), r = t.treeAdapter.getNamespaceURI(n);
    r === Ye.MATHML ? wI(e) : r === Ye.SVG && (R$(e), CI(e)), xv(e), e.selfClosing ? t._appendElement(e, r) : t._insertElement(e, r), e.ackSelfClosing = !0;
  }
}
function Tj(t, e) {
  if (e.tagID === w.P || e.tagID === w.BR) {
    zI(t), t._endTagOutsideForeignContent(e);
    return;
  }
  for (let n = t.openElements.stackTop; n > 0; n--) {
    const r = t.openElements.items[n];
    if (t.treeAdapter.getNamespaceURI(r) === Ye.HTML) {
      t._endTagOutsideForeignContent(e);
      break;
    }
    const i = t.treeAdapter.getTagName(r);
    if (i.toLowerCase() === e.tagName) {
      e.tagName = i, t.openElements.shortenToLength(n);
      break;
    }
  }
}
function qI(t, e) {
  return function(r) {
    let i, s = 0, a = "";
    for (; i = t.exec(r); )
      s !== i.index && (a += r.substring(s, i.index)), a += e.get(i[0].charCodeAt(0)), s = i.index + 1;
    return a + r.substring(s);
  };
}
const _j = /* @__PURE__ */ qI(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
])), Ej = /* @__PURE__ */ qI(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
])), xj = /* @__PURE__ */ new Set([
  De.AREA,
  De.BASE,
  De.BASEFONT,
  De.BGSOUND,
  De.BR,
  De.COL,
  De.EMBED,
  De.FRAME,
  De.HR,
  De.IMG,
  De.INPUT,
  De.KEYGEN,
  De.LINK,
  De.META,
  De.PARAM,
  De.SOURCE,
  De.TRACK,
  De.WBR
]);
function wj(t, e) {
  return e.treeAdapter.isElementNode(t) && e.treeAdapter.getNamespaceURI(t) === Ye.HTML && xj.has(e.treeAdapter.getTagName(t));
}
const Cj = { treeAdapter: Ia, scriptingEnabled: !0 };
function Sj(t, e) {
  const n = { ...Cj, ...e };
  return VI(t, n);
}
function Ij(t, e) {
  let n = "";
  const r = e.treeAdapter.isElementNode(t) && e.treeAdapter.getTagName(t) === De.TEMPLATE && e.treeAdapter.getNamespaceURI(t) === Ye.HTML ? e.treeAdapter.getTemplateContent(t) : t, i = e.treeAdapter.getChildNodes(r);
  if (i)
    for (const s of i)
      n += VI(s, e);
  return n;
}
function VI(t, e) {
  return e.treeAdapter.isElementNode(t) ? kj(t, e) : e.treeAdapter.isTextNode(t) ? Mj(t, e) : e.treeAdapter.isCommentNode(t) ? Oj(t, e) : e.treeAdapter.isDocumentTypeNode(t) ? Nj(t, e) : "";
}
function kj(t, e) {
  const n = e.treeAdapter.getTagName(t);
  return `<${n}${Dj(t, e)}>${wj(t, e) ? "" : `${Ij(t, e)}</${n}>`}`;
}
function Dj(t, { treeAdapter: e }) {
  let n = "";
  for (const r of e.getAttrList(t)) {
    if (n += " ", r.namespace)
      switch (r.namespace) {
        case Ye.XML: {
          n += `xml:${r.name}`;
          break;
        }
        case Ye.XMLNS: {
          r.name !== "xmlns" && (n += "xmlns:"), n += r.name;
          break;
        }
        case Ye.XLINK: {
          n += `xlink:${r.name}`;
          break;
        }
        default:
          n += `${r.prefix}:${r.name}`;
      }
    else
      n += r.name;
    n += `="${_j(r.value)}"`;
  }
  return n;
}
function Mj(t, e) {
  const { treeAdapter: n } = e, r = n.getTextNodeContent(t), i = n.getParentNode(t), s = i && n.isElementNode(i) && n.getTagName(i);
  return s && n.getNamespaceURI(i) === Ye.HTML && l$(s, e.scriptingEnabled) ? r : Ej(r);
}
function Oj(t, { treeAdapter: e }) {
  return `<!--${e.getCommentNodeContent(t)}-->`;
}
function Nj(t, { treeAdapter: e }) {
  return `<!DOCTYPE ${e.getDocumentTypeNodeName(t)}>`;
}
function Lj(t, e) {
  return II.parse(t, e);
}
function Pj(t, e, n) {
  typeof t == "string" && (n = e, e = t, t = null);
  const r = II.getFragmentParser(t, n);
  return r.tokenizer.write(e, !0), r.getFragment();
}
function uE(t) {
  const e = t.includes('"') ? "'" : '"';
  return e + t + e;
}
function Rj(t, e, n) {
  let r = "!DOCTYPE ";
  return t && (r += t), e ? r += ` PUBLIC ${uE(e)}` : n && (r += " SYSTEM"), n && (r += ` ${uE(n)}`), r;
}
const po = {
  // Re-exports from domhandler
  isCommentNode: V0,
  isElementNode: Lt,
  isTextNode: sa,
  //Node construction
  createDocument() {
    const t = new Ru([]);
    return t["x-mode"] = zi.NO_QUIRKS, t;
  },
  createDocumentFragment() {
    return new Ru([]);
  },
  createElement(t, e, n) {
    const r = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ Object.create(null);
    for (let o = 0; o < n.length; o++) {
      const u = n[o].name;
      r[u] = n[o].value, i[u] = n[o].namespace, s[u] = n[o].prefix;
    }
    const a = new cv(t, r, []);
    return a.namespace = e, a["x-attribsNamespace"] = i, a["x-attribsPrefix"] = s, a;
  },
  createCommentNode(t) {
    return new ov(t);
  },
  createTextNode(t) {
    return new Df(t);
  },
  //Tree mutation
  appendChild(t, e) {
    const n = t.children[t.children.length - 1];
    n && (n.next = e, e.prev = n), t.children.push(e), e.parent = t;
  },
  insertBefore(t, e, n) {
    const r = t.children.indexOf(n), { prev: i } = n;
    i && (i.next = e, e.prev = i), n.prev = e, e.next = n, t.children.splice(r, 0, e), e.parent = t;
  },
  setTemplateContent(t, e) {
    po.appendChild(t, e);
  },
  getTemplateContent(t) {
    return t.children[0];
  },
  setDocumentType(t, e, n, r) {
    const i = Rj(e, n, r);
    let s = t.children.find((a) => eb(a) && a.name === "!doctype");
    s ? s.data = i ?? null : (s = new uv("!doctype", i), po.appendChild(t, s)), s["x-name"] = e, s["x-publicId"] = n, s["x-systemId"] = r;
  },
  setDocumentMode(t, e) {
    t["x-mode"] = e;
  },
  getDocumentMode(t) {
    return t["x-mode"];
  },
  detachNode(t) {
    if (t.parent) {
      const e = t.parent.children.indexOf(t), { prev: n, next: r } = t;
      t.prev = null, t.next = null, n && (n.next = r), r && (r.prev = n), t.parent.children.splice(e, 1), t.parent = null;
    }
  },
  insertText(t, e) {
    const n = t.children[t.children.length - 1];
    n && sa(n) ? n.data += e : po.appendChild(t, po.createTextNode(e));
  },
  insertTextBefore(t, e, n) {
    const r = t.children[t.children.indexOf(n) - 1];
    r && sa(r) ? r.data += e : po.insertBefore(t, po.createTextNode(e), n);
  },
  adoptAttributes(t, e) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n].name;
      t.attribs[r] === void 0 && (t.attribs[r] = e[n].value, t["x-attribsNamespace"][r] = e[n].namespace, t["x-attribsPrefix"][r] = e[n].prefix);
    }
  },
  //Tree traversing
  getFirstChild(t) {
    return t.children[0];
  },
  getChildNodes(t) {
    return t.children;
  },
  getParentNode(t) {
    return t.parent;
  },
  getAttrList(t) {
    return t.attributes;
  },
  //Node data
  getTagName(t) {
    return t.name;
  },
  getNamespaceURI(t) {
    return t.namespace;
  },
  getTextNodeContent(t) {
    return t.data;
  },
  getCommentNodeContent(t) {
    return t.data;
  },
  getDocumentTypeNodeName(t) {
    var e;
    return (e = t["x-name"]) !== null && e !== void 0 ? e : "";
  },
  getDocumentTypeNodePublicId(t) {
    var e;
    return (e = t["x-publicId"]) !== null && e !== void 0 ? e : "";
  },
  getDocumentTypeNodeSystemId(t) {
    var e;
    return (e = t["x-systemId"]) !== null && e !== void 0 ? e : "";
  },
  //Node types
  isDocumentTypeNode(t) {
    return eb(t) && t.name === "!doctype";
  },
  // Source code location
  setNodeSourceCodeLocation(t, e) {
    e && (t.startIndex = e.startOffset, t.endIndex = e.endOffset), t.sourceCodeLocation = e;
  },
  getNodeSourceCodeLocation(t) {
    return t.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(t, e) {
    e.endOffset != null && (t.endIndex = e.endOffset), t.sourceCodeLocation = {
      ...t.sourceCodeLocation,
      ...e
    };
  }
};
function Bj(t, e, n, r) {
  var i;
  return (i = e.treeAdapter) !== null && i !== void 0 || (e.treeAdapter = po), e.scriptingEnabled !== !1 && (e.scriptingEnabled = !0), n ? Lj(t, e) : Pj(r, t, e);
}
const Fj = { treeAdapter: po };
function Uj(t) {
  const e = "length" in t ? t : [t];
  for (let r = 0; r < e.length; r += 1) {
    const i = e[r];
    Lo(i) && Array.prototype.splice.call(e, r, 1, ...i.children);
  }
  let n = "";
  for (let r = 0; r < e.length; r += 1) {
    const i = e[r];
    n += Sj(i, Fj);
  }
  return n;
}
const $j = vU((t, e, n, r) => e._useHtmlParser2 ? QB(t, e) : Bj(t, e, n, r)), Hj = JU($j, (t, e) => e._useHtmlParser2 ? W0(t, e) : Uj(t));
var rm = { exports: {} };
/*!
 * Autolinker.js
 * v4.1.5
 *
 * Copyright(c) 2025 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT License
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
var jj = rm.exports, lE;
function zj() {
  return lE || (lE = 1, function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(jj, function() {
      var n = function(h, F) {
        return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(q, le) {
          q.__proto__ = le;
        } || function(q, le) {
          for (var Le in le) Object.prototype.hasOwnProperty.call(le, Le) && (q[Le] = le[Le]);
        }, n(h, F);
      };
      function r(h, F) {
        if (typeof F != "function" && F !== null)
          throw new TypeError("Class extends value " + String(F) + " is not a constructor or null");
        n(h, F);
        function q() {
          this.constructor = h;
        }
        h.prototype = F === null ? Object.create(F) : (q.prototype = F.prototype, new q());
      }
      var i = function() {
        return i = Object.assign || function(F) {
          for (var q, le = 1, Le = arguments.length; le < Le; le++) {
            q = arguments[le];
            for (var st in q) Object.prototype.hasOwnProperty.call(q, st) && (F[st] = q[st]);
          }
          return F;
        }, i.apply(this, arguments);
      };
      function s(h, F) {
        var q = typeof Symbol == "function" && h[Symbol.iterator];
        if (!q) return h;
        var le = q.call(h), Le, st = [], Je;
        try {
          for (; (F === void 0 || F-- > 0) && !(Le = le.next()).done; ) st.push(Le.value);
        } catch (Lr) {
          Je = { error: Lr };
        } finally {
          try {
            Le && !Le.done && (q = le.return) && q.call(le);
          } finally {
            if (Je) throw Je.error;
          }
        }
        return st;
      }
      function a(h, F, q) {
        if (arguments.length === 2) for (var le = 0, Le = F.length, st; le < Le; le++)
          (st || !(le in F)) && (st || (st = Array.prototype.slice.call(F, 0, le)), st[le] = F[le]);
        return h.concat(st || Array.prototype.slice.call(F));
      }
      typeof SuppressedError == "function" && SuppressedError;
      var o = "4.1.5", u = Object.prototype.hasOwnProperty;
      function c(h) {
        return typeof h == "boolean";
      }
      function d(h, F, q) {
        var le;
        return h.length > F && (q == null ? (q = "&hellip;", le = 3) : le = q.length, h = h.substring(0, F - le) + q), h;
      }
      function l(h, F) {
        for (var q = h.length - 1; q >= 0; q--)
          F(h[q]) === !0 && h.splice(q, 1);
      }
      function f(h) {
        throw new Error("Unhandled case for value: '".concat(h, "'"));
      }
      var p = /\s+/, m = (
        /** @class */
        function() {
          function h(F) {
            F === void 0 && (F = {}), this.tagName = "", this.attrs = {}, this.innerHTML = "", this.tagName = F.tagName || "", this.attrs = F.attrs || {}, this.innerHTML = F.innerHtml || F.innerHTML || "";
          }
          return h.prototype.setTagName = function(F) {
            return this.tagName = F, this;
          }, h.prototype.getTagName = function() {
            return this.tagName;
          }, h.prototype.setAttr = function(F, q) {
            var le = this.getAttrs();
            return le[F] = q, this;
          }, h.prototype.getAttr = function(F) {
            return this.getAttrs()[F];
          }, h.prototype.setAttrs = function(F) {
            return Object.assign(this.getAttrs(), F), this;
          }, h.prototype.getAttrs = function() {
            return this.attrs;
          }, h.prototype.setClass = function(F) {
            return this.setAttr("class", F);
          }, h.prototype.addClass = function(F) {
            for (var q = this.getClass(), le = q ? q.split(p) : [], Le = F.split(p), st; st = Le.shift(); )
              le.indexOf(st) === -1 && le.push(st);
            return this.getAttrs().class = le.join(" "), this;
          }, h.prototype.removeClass = function(F) {
            for (var q = this.getClass(), le = q ? q.split(p) : [], Le = F.split(p), st; le.length && (st = Le.shift()); ) {
              var Je = le.indexOf(st);
              Je !== -1 && le.splice(Je, 1);
            }
            return this.getAttrs().class = le.join(" "), this;
          }, h.prototype.getClass = function() {
            return this.getAttrs().class || "";
          }, h.prototype.hasClass = function(F) {
            return (" " + this.getClass() + " ").indexOf(" " + F + " ") !== -1;
          }, h.prototype.setInnerHTML = function(F) {
            return this.innerHTML = F, this;
          }, h.prototype.setInnerHtml = function(F) {
            return this.setInnerHTML(F);
          }, h.prototype.getInnerHTML = function() {
            return this.innerHTML || "";
          }, h.prototype.getInnerHtml = function() {
            return this.getInnerHTML();
          }, h.prototype.toAnchorString = function() {
            var F = this.getTagName(), q = this.buildAttrsStr();
            return q = q ? " " + q : "", ["<", F, q, ">", this.getInnerHtml(), "</", F, ">"].join("");
          }, h.prototype.buildAttrsStr = function() {
            var F = this.getAttrs(), q = [];
            for (var le in F)
              u.call(F, le) && q.push(le + '="' + F[le] + '"');
            return q.join(" ");
          }, h;
        }()
      );
      function g(h, F, q) {
        var le, Le;
        if (q == null ? (q = "&hellip;", Le = 3, le = 8) : (Le = q.length, le = q.length), h.length <= F)
          return h;
        var st = F - Le, Je = y(h);
        if (Je.query) {
          var Lr = Je.query.match(/^(.*?)(?=(\?|#))(.*?)$/i);
          Lr && (Je.query = Je.query.substr(0, Lr[1].length), h = b(Je));
        }
        if (h.length <= F || (Je.host && (Je.host = Je.host.replace(/^www\./, ""), h = b(Je)), h.length <= F))
          return h;
        var Tn = "";
        if (Je.host && (Tn += Je.host), Tn.length >= st)
          return Je.host.length === F ? (Je.host.substr(0, F - Le) + q).substr(0, st + le) : E(Tn, st, q).substr(0, st + le);
        var $r = "";
        if (Je.path && ($r += "/" + Je.path), Je.query && ($r += "?" + Je.query), $r)
          if ((Tn + $r).length >= st) {
            if ((Tn + $r).length == F)
              return (Tn + $r).substr(0, F);
            var Ta = st - Tn.length;
            return (Tn + E($r, Ta, q)).substr(0, st + le);
          } else
            Tn += $r;
        if (Je.fragment) {
          var _r = "#" + Je.fragment;
          if ((Tn + _r).length >= st) {
            if ((Tn + _r).length == F)
              return (Tn + _r).substr(0, F);
            var un = st - Tn.length;
            return (Tn + E(_r, un, q)).substr(0, st + le);
          } else
            Tn += _r;
        }
        if (Je.scheme && Je.host) {
          var bs = Je.scheme + "://";
          if ((Tn + bs).length < st)
            return (bs + Tn).substr(0, F);
        }
        if (Tn.length <= F)
          return Tn;
        var Xi = "";
        return st > 0 && (Xi = Tn.substr(-1 * Math.floor(st / 2))), (Tn.substr(0, Math.ceil(st / 2)) + q + Xi).substr(0, st + le);
      }
      function y(h) {
        var F = {}, q = h, le = q.match(/^([a-z]+):\/\//i);
        return le && (F.scheme = le[1], q = q.slice(le[0].length)), le = q.match(/^(.*?)(?=(\?|#|\/|$))/i), le && (F.host = le[1], q = q.slice(le[0].length)), le = q.match(/^\/(.*?)(?=(\?|#|$))/i), le && (F.path = le[1], q = q.slice(le[0].length)), le = q.match(/^\?(.*?)(?=(#|$))/i), le && (F.query = le[1], q = q.slice(le[0].length)), le = q.match(/^#(.*?)$/i), le && (F.fragment = le[1]), F;
      }
      function b(h) {
        var F = "";
        return h.scheme && h.host && (F += h.scheme + "://"), h.host && (F += h.host), h.path && (F += "/" + h.path), h.query && (F += "?" + h.query), h.fragment && (F += "#" + h.fragment), F;
      }
      function E(h, F, q) {
        var le = F / 2, Le = Math.ceil(le), st = -1 * Math.floor(le), Je = "";
        return st < 0 && (Je = h.substr(st)), h.substr(0, Le) + q + Je;
      }
      function v(h, F, q) {
        if (h.length <= F)
          return h;
        var le, Le;
        q == null ? (q = "&hellip;", le = 8, Le = 3) : (le = q.length, Le = q.length);
        var st = F - Le, Je = "";
        return st > 0 && (Je = h.substr(-1 * Math.floor(st / 2))), (h.substr(0, Math.ceil(st / 2)) + q + Je).substr(0, st + le);
      }
      function _(h, F, q) {
        return d(h, F, q);
      }
      var D = (
        /** @class */
        function() {
          function h(F) {
            F === void 0 && (F = {}), this.newWindow = !1, this.truncate = {}, this.className = "", this.newWindow = F.newWindow || !1, this.truncate = F.truncate || {}, this.className = F.className || "";
          }
          return h.prototype.build = function(F) {
            return new m({
              tagName: "a",
              attrs: this.createAttrs(F),
              innerHtml: this.processAnchorText(F.getAnchorText())
            });
          }, h.prototype.createAttrs = function(F) {
            var q = {
              href: F.getAnchorHref()
              // we'll always have the `href` attribute
            }, le = this.createCssClass(F);
            return le && (q.class = le), this.newWindow && (q.target = "_blank", q.rel = "noopener noreferrer"), this.truncate.length && this.truncate.length < F.getAnchorText().length && (q.title = F.getAnchorHref()), q;
          }, h.prototype.createCssClass = function(F) {
            var q = this.className;
            if (q) {
              for (var le = [q], Le = F.getCssClassSuffixes(), st = 0, Je = Le.length; st < Je; st++)
                le.push(q + "-" + Le[st]);
              return le.join(" ");
            } else
              return "";
          }, h.prototype.processAnchorText = function(F) {
            return F = this.doTruncate(F), F;
          }, h.prototype.doTruncate = function(F) {
            var q = this.truncate;
            if (!q.length)
              return F;
            var le = q.length, Le = q.location;
            return Le === "smart" ? g(F, le) : Le === "middle" ? v(F, le) : _(F, le);
          }, h;
        }()
      ), S = (
        /** @class */
        function() {
          function h(F) {
            this._ = null, this.matchedText = "", this.offset = 0, this.tagBuilder = F.tagBuilder, this.matchedText = F.matchedText, this.offset = F.offset;
          }
          return h.prototype.getMatchedText = function() {
            return this.matchedText;
          }, h.prototype.setOffset = function(F) {
            this.offset = F;
          }, h.prototype.getOffset = function() {
            return this.offset;
          }, h.prototype.getCssClassSuffixes = function() {
            return [this.type];
          }, h.prototype.buildTag = function() {
            return this.tagBuilder.build(this);
          }, h;
        }()
      );
      function M(h) {
        return h >= 0 && h <= 31 || h == 127;
      }
      function O(h) {
        return h >= 65 && h <= 90 || h >= 97 && h <= 122;
      }
      function T(h) {
        return h >= 48 && h <= 57;
      }
      function N(h) {
        return h == 34 || h == 39;
      }
      function H(h) {
        return h < 8232 ? h < 160 ? h >= 9 && h <= 13 || h == 32 : h < 5760 ? h == 160 : h == 5760 || h >= 8192 && h <= 8202 : h < 8287 ? h >= 8232 && h <= 8233 || h == 8239 : h < 12288 ? h == 8287 : h == 12288 || h == 65279;
      }
      function $(h) {
        return h < 4800 ? h < 2949 ? h < 2451 ? h < 1425 ? h < 768 ? h < 192 ? h < 169 ? h < 65 ? h >= 48 && h <= 57 : h >= 65 && h <= 90 || h >= 97 && h <= 122 : h < 181 ? h >= 169 && h <= 170 || h == 174 : h == 181 || h == 186 : h < 710 ? h < 216 ? h >= 192 && h <= 214 : h >= 216 && h <= 246 || h >= 248 && h <= 705 : h < 748 ? h >= 710 && h <= 721 || h >= 736 && h <= 740 : h == 748 || h == 750 : h < 910 ? h < 895 ? h < 886 ? h >= 768 && h <= 884 : h >= 886 && h <= 887 || h >= 890 && h <= 893 : h < 904 ? h == 895 || h == 902 : h >= 904 && h <= 906 || h == 908 : h < 1155 ? h < 931 ? h >= 910 && h <= 929 : h >= 931 && h <= 1013 || h >= 1015 && h <= 1153 : h < 1369 ? h >= 1155 && h <= 1327 || h >= 1329 && h <= 1366 : h == 1369 || h >= 1377 && h <= 1415 : h < 1808 ? h < 1552 ? h < 1476 ? h < 1471 ? h >= 1425 && h <= 1469 : h == 1471 || h >= 1473 && h <= 1474 : h < 1488 ? h >= 1476 && h <= 1477 || h == 1479 : h >= 1488 && h <= 1514 || h >= 1520 && h <= 1522 : h < 1749 ? h < 1568 ? h >= 1552 && h <= 1562 : h >= 1568 && h <= 1641 || h >= 1646 && h <= 1747 : h < 1770 ? h >= 1749 && h <= 1756 || h >= 1759 && h <= 1768 : h >= 1770 && h <= 1788 || h == 1791 : h < 2230 ? h < 2042 ? h < 1869 ? h >= 1808 && h <= 1866 : h >= 1869 && h <= 1969 || h >= 1984 && h <= 2037 : h < 2112 ? h == 2042 || h >= 2048 && h <= 2093 : h >= 2112 && h <= 2139 || h >= 2208 && h <= 2228 : h < 2406 ? h < 2260 ? h >= 2230 && h <= 2237 : h >= 2260 && h <= 2273 || h >= 2275 && h <= 2403 : h < 2437 ? h >= 2406 && h <= 2415 || h >= 2417 && h <= 2435 : h >= 2437 && h <= 2444 || h >= 2447 && h <= 2448 : h < 2693 ? h < 2579 ? h < 2519 ? h < 2486 ? h < 2474 ? h >= 2451 && h <= 2472 : h >= 2474 && h <= 2480 || h == 2482 : h < 2503 ? h >= 2486 && h <= 2489 || h >= 2492 && h <= 2500 : h >= 2503 && h <= 2504 || h >= 2507 && h <= 2510 : h < 2534 ? h < 2524 ? h == 2519 : h >= 2524 && h <= 2525 || h >= 2527 && h <= 2531 : h < 2565 ? h >= 2534 && h <= 2545 || h >= 2561 && h <= 2563 : h >= 2565 && h <= 2570 || h >= 2575 && h <= 2576 : h < 2631 ? h < 2613 ? h < 2602 ? h >= 2579 && h <= 2600 : h >= 2602 && h <= 2608 || h >= 2610 && h <= 2611 : h < 2620 ? h >= 2613 && h <= 2614 || h >= 2616 && h <= 2617 : h == 2620 || h >= 2622 && h <= 2626 : h < 2649 ? h < 2635 ? h >= 2631 && h <= 2632 : h >= 2635 && h <= 2637 || h == 2641 : h < 2662 ? h >= 2649 && h <= 2652 || h == 2654 : h >= 2662 && h <= 2677 || h >= 2689 && h <= 2691 : h < 2821 ? h < 2759 ? h < 2730 ? h < 2703 ? h >= 2693 && h <= 2701 : h >= 2703 && h <= 2705 || h >= 2707 && h <= 2728 : h < 2741 ? h >= 2730 && h <= 2736 || h >= 2738 && h <= 2739 : h >= 2741 && h <= 2745 || h >= 2748 && h <= 2757 : h < 2784 ? h < 2763 ? h >= 2759 && h <= 2761 : h >= 2763 && h <= 2765 || h == 2768 : h < 2809 ? h >= 2784 && h <= 2787 || h >= 2790 && h <= 2799 : h == 2809 || h >= 2817 && h <= 2819 : h < 2887 ? h < 2858 ? h < 2831 ? h >= 2821 && h <= 2828 : h >= 2831 && h <= 2832 || h >= 2835 && h <= 2856 : h < 2869 ? h >= 2858 && h <= 2864 || h >= 2866 && h <= 2867 : h >= 2869 && h <= 2873 || h >= 2876 && h <= 2884 : h < 2911 ? h < 2902 ? h >= 2887 && h <= 2888 || h >= 2891 && h <= 2893 : h >= 2902 && h <= 2903 || h >= 2908 && h <= 2909 : h < 2929 ? h >= 2911 && h <= 2915 || h >= 2918 && h <= 2927 : h == 2929 || h >= 2946 && h <= 2947 : h < 3517 ? h < 3205 ? h < 3046 ? h < 2984 ? h < 2969 ? h < 2958 ? h >= 2949 && h <= 2954 : h >= 2958 && h <= 2960 || h >= 2962 && h <= 2965 : h < 2974 ? h >= 2969 && h <= 2970 || h == 2972 : h >= 2974 && h <= 2975 || h >= 2979 && h <= 2980 : h < 3014 ? h < 2990 ? h >= 2984 && h <= 2986 : h >= 2990 && h <= 3001 || h >= 3006 && h <= 3010 : h < 3024 ? h >= 3014 && h <= 3016 || h >= 3018 && h <= 3021 : h == 3024 || h == 3031 : h < 3142 ? h < 3086 ? h < 3072 ? h >= 3046 && h <= 3055 : h >= 3072 && h <= 3075 || h >= 3077 && h <= 3084 : h < 3114 ? h >= 3086 && h <= 3088 || h >= 3090 && h <= 3112 : h >= 3114 && h <= 3129 || h >= 3133 && h <= 3140 : h < 3160 ? h < 3146 ? h >= 3142 && h <= 3144 : h >= 3146 && h <= 3149 || h >= 3157 && h <= 3158 : h < 3174 ? h >= 3160 && h <= 3162 || h >= 3168 && h <= 3171 : h >= 3174 && h <= 3183 || h >= 3200 && h <= 3203 : h < 3333 ? h < 3274 ? h < 3242 ? h < 3214 ? h >= 3205 && h <= 3212 : h >= 3214 && h <= 3216 || h >= 3218 && h <= 3240 : h < 3260 ? h >= 3242 && h <= 3251 || h >= 3253 && h <= 3257 : h >= 3260 && h <= 3268 || h >= 3270 && h <= 3272 : h < 3296 ? h < 3285 ? h >= 3274 && h <= 3277 : h >= 3285 && h <= 3286 || h == 3294 : h < 3313 ? h >= 3296 && h <= 3299 || h >= 3302 && h <= 3311 : h >= 3313 && h <= 3314 || h >= 3329 && h <= 3331 : h < 3423 ? h < 3389 ? h < 3342 ? h >= 3333 && h <= 3340 : h >= 3342 && h <= 3344 || h >= 3346 && h <= 3386 : h < 3402 ? h >= 3389 && h <= 3396 || h >= 3398 && h <= 3400 : h >= 3402 && h <= 3406 || h >= 3412 && h <= 3415 : h < 3458 ? h < 3430 ? h >= 3423 && h <= 3427 : h >= 3430 && h <= 3439 || h >= 3450 && h <= 3455 : h < 3482 ? h >= 3458 && h <= 3459 || h >= 3461 && h <= 3478 : h >= 3482 && h <= 3505 || h >= 3507 && h <= 3515 : h < 3804 ? h < 3722 ? h < 3570 ? h < 3535 ? h < 3520 ? h == 3517 : h >= 3520 && h <= 3526 || h == 3530 : h < 3544 ? h >= 3535 && h <= 3540 || h == 3542 : h >= 3544 && h <= 3551 || h >= 3558 && h <= 3567 : h < 3664 ? h < 3585 ? h >= 3570 && h <= 3571 : h >= 3585 && h <= 3642 || h >= 3648 && h <= 3662 : h < 3716 ? h >= 3664 && h <= 3673 || h >= 3713 && h <= 3714 : h == 3716 || h >= 3719 && h <= 3720 : h < 3754 ? h < 3737 ? h < 3725 ? h == 3722 : h == 3725 || h >= 3732 && h <= 3735 : h < 3749 ? h >= 3737 && h <= 3743 || h >= 3745 && h <= 3747 : h == 3749 || h == 3751 : h < 3776 ? h < 3757 ? h >= 3754 && h <= 3755 : h >= 3757 && h <= 3769 || h >= 3771 && h <= 3773 : h < 3784 ? h >= 3776 && h <= 3780 || h == 3782 : h >= 3784 && h <= 3789 || h >= 3792 && h <= 3801 : h < 4176 ? h < 3902 ? h < 3872 ? h < 3840 ? h >= 3804 && h <= 3807 : h == 3840 || h >= 3864 && h <= 3865 : h < 3895 ? h >= 3872 && h <= 3881 || h == 3893 : h == 3895 || h == 3897 : h < 3974 ? h < 3913 ? h >= 3902 && h <= 3911 : h >= 3913 && h <= 3948 || h >= 3953 && h <= 3972 : h < 4038 ? h >= 3974 && h <= 3991 || h >= 3993 && h <= 4028 : h == 4038 || h >= 4096 && h <= 4169 : h < 4688 ? h < 4301 ? h < 4256 ? h >= 4176 && h <= 4253 : h >= 4256 && h <= 4293 || h == 4295 : h < 4348 ? h == 4301 || h >= 4304 && h <= 4346 : h >= 4348 && h <= 4680 || h >= 4682 && h <= 4685 : h < 4746 ? h < 4698 ? h >= 4688 && h <= 4694 || h == 4696 : h >= 4698 && h <= 4701 || h >= 4704 && h <= 4744 : h < 4786 ? h >= 4746 && h <= 4749 || h >= 4752 && h <= 4784 : h >= 4786 && h <= 4789 || h >= 4792 && h <= 4798 : h < 11035 ? h < 7416 ? h < 6176 ? h < 5873 ? h < 4992 ? h < 4824 ? h < 4802 ? h == 4800 : h >= 4802 && h <= 4805 || h >= 4808 && h <= 4822 : h < 4888 ? h >= 4824 && h <= 4880 || h >= 4882 && h <= 4885 : h >= 4888 && h <= 4954 || h >= 4957 && h <= 4959 : h < 5121 ? h < 5024 ? h >= 4992 && h <= 5007 : h >= 5024 && h <= 5109 || h >= 5112 && h <= 5117 : h < 5761 ? h >= 5121 && h <= 5740 || h >= 5743 && h <= 5759 : h >= 5761 && h <= 5786 || h >= 5792 && h <= 5866 : h < 6002 ? h < 5920 ? h < 5888 ? h >= 5873 && h <= 5880 : h >= 5888 && h <= 5900 || h >= 5902 && h <= 5908 : h < 5984 ? h >= 5920 && h <= 5940 || h >= 5952 && h <= 5971 : h >= 5984 && h <= 5996 || h >= 5998 && h <= 6e3 : h < 6108 ? h < 6016 ? h >= 6002 && h <= 6003 : h >= 6016 && h <= 6099 || h == 6103 : h < 6155 ? h >= 6108 && h <= 6109 || h >= 6112 && h <= 6121 : h >= 6155 && h <= 6157 || h >= 6160 && h <= 6169 : h < 6783 ? h < 6512 ? h < 6400 ? h < 6272 ? h >= 6176 && h <= 6263 : h >= 6272 && h <= 6314 || h >= 6320 && h <= 6389 : h < 6448 ? h >= 6400 && h <= 6430 || h >= 6432 && h <= 6443 : h >= 6448 && h <= 6459 || h >= 6470 && h <= 6509 : h < 6608 ? h < 6528 ? h >= 6512 && h <= 6516 : h >= 6528 && h <= 6571 || h >= 6576 && h <= 6601 : h < 6688 ? h >= 6608 && h <= 6617 || h >= 6656 && h <= 6683 : h >= 6688 && h <= 6750 || h >= 6752 && h <= 6780 : h < 7040 ? h < 6832 ? h < 6800 ? h >= 6783 && h <= 6793 : h >= 6800 && h <= 6809 || h == 6823 : h < 6992 ? h >= 6832 && h <= 6846 || h >= 6912 && h <= 6987 : h >= 6992 && h <= 7001 || h >= 7019 && h <= 7027 : h < 7245 ? h < 7168 ? h >= 7040 && h <= 7155 : h >= 7168 && h <= 7223 || h >= 7232 && h <= 7241 : h < 7376 ? h >= 7245 && h <= 7293 || h >= 7296 && h <= 7304 : h >= 7376 && h <= 7378 || h >= 7380 && h <= 7414 : h < 8450 ? h < 8130 ? h < 8025 ? h < 7960 ? h < 7424 ? h >= 7416 && h <= 7417 : h >= 7424 && h <= 7669 || h >= 7675 && h <= 7957 : h < 8008 ? h >= 7960 && h <= 7965 || h >= 7968 && h <= 8005 : h >= 8008 && h <= 8013 || h >= 8016 && h <= 8023 : h < 8031 ? h < 8027 ? h == 8025 : h == 8027 || h == 8029 : h < 8118 ? h >= 8031 && h <= 8061 || h >= 8064 && h <= 8116 : h >= 8118 && h <= 8124 || h == 8126 : h < 8205 ? h < 8150 ? h < 8134 ? h >= 8130 && h <= 8132 : h >= 8134 && h <= 8140 || h >= 8144 && h <= 8147 : h < 8178 ? h >= 8150 && h <= 8155 || h >= 8160 && h <= 8172 : h >= 8178 && h <= 8180 || h >= 8182 && h <= 8188 : h < 8305 ? h < 8252 ? h == 8205 : h == 8252 || h == 8265 : h < 8336 ? h == 8305 || h == 8319 : h >= 8336 && h <= 8348 || h >= 8400 && h <= 8432 : h < 8579 ? h < 8486 ? h < 8469 ? h < 8455 ? h == 8450 : h == 8455 || h >= 8458 && h <= 8467 : h < 8482 ? h == 8469 || h >= 8473 && h <= 8477 : h == 8482 || h == 8484 : h < 8495 ? h < 8488 ? h == 8486 : h == 8488 || h >= 8490 && h <= 8493 : h < 8517 ? h >= 8495 && h <= 8505 || h >= 8508 && h <= 8511 : h >= 8517 && h <= 8521 || h == 8526 : h < 9410 ? h < 9e3 ? h < 8592 ? h >= 8579 && h <= 8580 : h >= 8592 && h <= 8703 || h >= 8986 && h <= 8987 : h < 9193 ? h == 9e3 || h == 9167 : h >= 9193 && h <= 9203 || h >= 9208 && h <= 9210 : h < 9723 ? h < 9654 ? h == 9410 || h >= 9642 && h <= 9643 : h == 9654 || h == 9664 : h < 10548 ? h >= 9723 && h <= 9726 || h >= 9728 && h <= 10175 : h >= 10548 && h <= 10549 || h >= 11013 && h <= 11015 : h < 43259 ? h < 12445 ? h < 11688 ? h < 11520 ? h < 11264 ? h < 11088 ? h >= 11035 && h <= 11036 : h == 11088 || h == 11093 : h < 11360 ? h >= 11264 && h <= 11310 || h >= 11312 && h <= 11358 : h >= 11360 && h <= 11492 || h >= 11499 && h <= 11507 : h < 11568 ? h < 11559 ? h >= 11520 && h <= 11557 : h == 11559 || h == 11565 : h < 11647 ? h >= 11568 && h <= 11623 || h == 11631 : h >= 11647 && h <= 11670 || h >= 11680 && h <= 11686 : h < 11744 ? h < 11712 ? h < 11696 ? h >= 11688 && h <= 11694 : h >= 11696 && h <= 11702 || h >= 11704 && h <= 11710 : h < 11728 ? h >= 11712 && h <= 11718 || h >= 11720 && h <= 11726 : h >= 11728 && h <= 11734 || h >= 11736 && h <= 11742 : h < 12330 ? h < 11823 ? h >= 11744 && h <= 11775 : h == 11823 || h >= 12293 && h <= 12294 : h < 12353 ? h >= 12330 && h <= 12341 || h >= 12347 && h <= 12349 : h >= 12353 && h <= 12438 || h >= 12441 && h <= 12442 : h < 42512 ? h < 12951 ? h < 12549 ? h < 12449 ? h >= 12445 && h <= 12447 : h >= 12449 && h <= 12538 || h >= 12540 && h <= 12543 : h < 12704 ? h >= 12549 && h <= 12589 || h >= 12593 && h <= 12686 : h >= 12704 && h <= 12730 || h >= 12784 && h <= 12799 : h < 19968 ? h < 12953 ? h == 12951 : h == 12953 || h >= 13312 && h <= 19893 : h < 42192 ? h >= 19968 && h <= 40917 || h >= 40960 && h <= 42124 : h >= 42192 && h <= 42237 || h >= 42240 && h <= 42508 : h < 42891 ? h < 42623 ? h < 42560 ? h >= 42512 && h <= 42539 : h >= 42560 && h <= 42610 || h >= 42612 && h <= 42621 : h < 42775 ? h >= 42623 && h <= 42725 || h >= 42736 && h <= 42737 : h >= 42775 && h <= 42783 || h >= 42786 && h <= 42888 : h < 43072 ? h < 42928 ? h >= 42891 && h <= 42926 : h >= 42928 && h <= 42935 || h >= 42999 && h <= 43047 : h < 43216 ? h >= 43072 && h <= 43123 || h >= 43136 && h <= 43205 : h >= 43216 && h <= 43225 || h >= 43232 && h <= 43255 : h < 55243 ? h < 43744 ? h < 43488 ? h < 43312 ? h < 43261 ? h == 43259 : h == 43261 || h >= 43264 && h <= 43309 : h < 43392 ? h >= 43312 && h <= 43347 || h >= 43360 && h <= 43388 : h >= 43392 && h <= 43456 || h >= 43471 && h <= 43481 : h < 43600 ? h < 43520 ? h >= 43488 && h <= 43518 : h >= 43520 && h <= 43574 || h >= 43584 && h <= 43597 : h < 43642 ? h >= 43600 && h <= 43609 || h >= 43616 && h <= 43638 : h >= 43642 && h <= 43714 || h >= 43739 && h <= 43741 : h < 43824 ? h < 43785 ? h < 43762 ? h >= 43744 && h <= 43759 : h >= 43762 && h <= 43766 || h >= 43777 && h <= 43782 : h < 43808 ? h >= 43785 && h <= 43790 || h >= 43793 && h <= 43798 : h >= 43808 && h <= 43814 || h >= 43816 && h <= 43822 : h < 44012 ? h < 43868 ? h >= 43824 && h <= 43866 : h >= 43868 && h <= 43877 || h >= 43888 && h <= 44010 : h < 44032 ? h >= 44012 && h <= 44013 || h >= 44016 && h <= 44025 : h >= 44032 && h <= 55203 || h >= 55216 && h <= 55238 : h < 64848 ? h < 64298 ? h < 64112 ? h < 55296 ? h >= 55243 && h <= 55291 : h >= 55296 && h <= 57343 || h >= 63744 && h <= 64109 : h < 64275 ? h >= 64112 && h <= 64217 || h >= 64256 && h <= 64262 : h >= 64275 && h <= 64279 || h >= 64285 && h <= 64296 : h < 64320 ? h < 64312 ? h >= 64298 && h <= 64310 : h >= 64312 && h <= 64316 || h == 64318 : h < 64326 ? h >= 64320 && h <= 64321 || h >= 64323 && h <= 64324 : h >= 64326 && h <= 64433 || h >= 64467 && h <= 64829 : h < 65296 ? h < 65024 ? h < 64914 ? h >= 64848 && h <= 64911 : h >= 64914 && h <= 64967 || h >= 65008 && h <= 65019 : h < 65136 ? h >= 65024 && h <= 65039 || h >= 65056 && h <= 65071 : h >= 65136 && h <= 65140 || h >= 65142 && h <= 65276 : h < 65474 ? h < 65345 ? h >= 65296 && h <= 65305 || h >= 65313 && h <= 65338 : h >= 65345 && h <= 65370 || h >= 65382 && h <= 65470 : h < 65490 ? h >= 65474 && h <= 65479 || h >= 65482 && h <= 65487 : h >= 65490 && h <= 65495 || h >= 65498 && h <= 65500;
      }
      function j(h) {
        return h < 47 ? h < 42 ? h == 33 || h >= 35 && h <= 39 : h >= 42 && h <= 43 || h == 45 : h < 63 ? h == 47 || h == 61 : h < 94 ? h == 63 : h >= 94 && h <= 96 || h >= 123 && h <= 126;
      }
      function U(h) {
        return h < 91 ? h < 47 ? h >= 35 && h <= 43 || h == 45 : h < 61 ? h == 47 : h == 61 || h == 64 : h < 95 ? h == 91 || h == 93 : h < 123 ? h == 95 : h >= 123 && h <= 126 || h == 10003;
      }
      function V(h) {
        return h < 58 ? h < 44 ? h == 33 : h == 44 || h == 46 : h < 63 ? h >= 58 && h <= 59 : h == 63 || h == 94;
      }
      function B(h) {
        return h < 91 ? h == 40 : h == 91 || h == 123;
      }
      function R(h) {
        return h < 93 ? h == 41 : h == 93 || h == 125;
      }
      var K = /^(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|travelersinsurance|vermögensberatung|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbah1a3hjkrd|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermögensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--mgbcpq6gpa1a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbc0a9azcg|xn--nqv7fs00ema|americanfamily|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--h2breg3eve|xn--jlq480n2rg|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|xn--rvc1e0am3e|international|lifeinsurance|wolterskluwer|xn--cckwcxetd|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--h2brj9c8c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|scholarships|versicherung|xn--3e0b707e|xn--45br5cyl|xn--4dbrk0ce|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbgu82a|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--3bst00m|xn--3ds443g|xn--3hcrj9c|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--mgbbh1a|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--otu796d|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b|சிங்கப்பூர்|accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nextdirect|properties|protection|prudential|realestate|republican|restaurant|schaeffler|tatamotors|technology|university|vlaanderen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--q7ce6a|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|furniture|goldpoint|hisamitsu|homedepot|homegoods|homesense|institute|insurance|kuokgroup|landrover|lifestyle|marketing|marshalls|melbourne|microsoft|panasonic|richardli|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--ngbrx|xn--nqv7f|xn--p1acf|xn--qxa6a|xn--tckwe|xn--vhquv|yodobashi|موريتانيا|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|builders|business|capetown|catering|catholic|cipriani|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|mckinsey|memorial|merckmsd|mortgage|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|softbank|software|stcgroup|supplies|training|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama|السعودية|abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|banamex|bauhaus|bestbuy|booking|brother|capital|caravan|careers|channel|charity|chintai|citadel|clubmed|college|cologne|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|grocery|guitars|hamburg|hangout|hitachi|holiday|hosting|hotmail|hyundai|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lanxess|lasalle|latrobe|leclerc|limited|lincoln|markets|monster|netbank|netflix|network|neustar|okinawa|organic|origins|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|singles|staples|storage|support|surgery|systems|temasek|theater|theatre|tickets|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|yamaxun|youtube|zuerich|католик|البحرين|الجزائر|العليان|پاکستان|كاثوليك|இந்தியா|abbott|abbvie|africa|agency|airbus|airtel|alipay|alsace|alstom|amazon|anquan|aramco|author|bayern|beauty|berlin|bharti|bostik|boston|broker|camera|career|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hotels|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kindle|kosher|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|monash|mormon|moscow|museum|nagoya|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|pictet|quebec|racing|realty|reisen|repair|report|review|rogers|ryukyu|safety|sakura|sanofi|school|schule|search|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|walter|webcam|xihuan|yachts|yandex|zappos|москва|онлайн|ابوظبي|ارامكو|الاردن|المغرب|امارات|فلسطين|مليسيا|भारतम्|இலங்கை|ファッション|actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|bosch|build|canon|cards|chase|cheap|cisco|citic|click|cloud|coach|codes|crown|cymru|dance|deals|delta|drive|dubai|earth|edeka|email|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|irish|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|loans|locus|lotte|lotto|mango|media|miami|money|movie|music|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|rugby|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|sport|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo|ישראל|ایران|بازار|بھارت|سودان|سورية|همراه|भारोत|संगठन|বাংলা|భారత్|ഭാരതം|嘉里大酒店|aarp|able|aero|akdn|ally|amex|arab|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|dvag|erni|fage|fail|fans|farm|fast|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kids|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|read|reit|rent|rest|rich|room|rsvp|ruhr|safe|sale|sarl|save|saxo|scot|seat|seek|sexy|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone|дети|сайт|بارت|بيتك|ڀارت|تونس|شبكة|عراق|عمان|موقع|भारत|ভারত|ভাৰত|ਭਾਰਤ|ભારત|ଭାରତ|ಭಾರತ|ලංකා|アマゾン|グーグル|クラウド|ポイント|组织机构|電訊盈科|香格里拉|aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|ceo|cfa|cfd|com|cpa|crs|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gay|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|ibm|ice|icu|ifm|inc|ing|ink|int|ist|itv|jcb|jio|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|llc|llp|lol|lpl|ltd|man|map|mba|med|men|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|one|ong|onl|ooo|org|ott|ovh|pay|pet|phd|pid|pin|pnc|pro|pru|pub|pwc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|scb|sew|sex|sfr|ski|sky|soy|spa|srl|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip|бел|ком|қаз|мкд|мон|орг|рус|срб|укр|հայ|קום|عرب|قطر|كوم|مصر|कॉम|नेट|คอม|ไทย|ລາວ|ストア|セール|みんな|中文网|亚马逊|天主教|我爱你|新加坡|淡马锡|飞利浦|ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|ελ|ευ|бг|ею|рф|გე|닷넷|닷컴|삼성|한국|コム|世界|中信|中国|中國|企业|佛山|信息|健康|八卦|公司|公益|台湾|台灣|商城|商店|商标|嘉里|在线|大拿|娱乐|家電|广东|微博|慈善|手机|招聘|政务|政府|新闻|时尚|書籍|机构|游戏|澳門|点看|移动|网址|网店|网站|网络|联通|谷歌|购物|通販|集团|食品|餐厅|香港)$/, Q = /https?:\/\//i, P = new RegExp("^" + Q.source, "i"), I = /^(javascript|vbscript):/i, G = /^[A-Za-z][-.+A-Za-z0-9]*:(\/\/)?([^:/]*)/, te = /^(?:\/\/)?([^/#?:]+)/, ee = O;
      function Z(h) {
        return O(h) || T(h) || h === 43 || // '+'
        h === 45 || // '-'
        h === 46;
      }
      var ye = $;
      function he(h) {
        return h === 95 || ye(h);
      }
      function Ee(h) {
        return $(h) || U(h) || V(h);
      }
      function be(h) {
        return h === 47 || // '/'
        h === 63 || // '?'
        h === 35;
      }
      function ve(h) {
        return K.test(h.toLowerCase());
      }
      function Ce(h) {
        if (I.test(h))
          return !1;
        var F = h.match(G);
        if (!F)
          return !1;
        var q = !!F[1], le = F[2];
        return q ? !0 : !(le.indexOf(".") === -1 || !/[A-Za-z]/.test(le));
      }
      function Ne(h) {
        var F = h.match(te);
        if (!F)
          return !1;
        var q = F[0], le = q.split(".");
        if (le.length < 2)
          return !1;
        var Le = le[le.length - 1];
        return !!ve(Le);
      }
      var qe = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/, $e = /[:/?#]/;
      function Xe(h) {
        var F = h.split($e, 1)[0];
        return qe.test(F);
      }
      var at = /^(https?:\/\/)?(?:www\.)?/i, Ie = /^\/\//, ne = (
        /** @class */
        function(h) {
          r(F, h);
          function F(q) {
            var le = h.call(this, q) || this;
            return le.type = "url", le.url = "", le.urlMatchType = "scheme", le.protocolRelativeMatch = !1, le.stripPrefix = {
              scheme: !0,
              www: !0
            }, le.stripTrailingSlash = !0, le.decodePercentEncoding = !0, le.protocolPrepended = !1, le.urlMatchType = q.urlMatchType, le.url = q.url, le.protocolRelativeMatch = q.protocolRelativeMatch, le.stripPrefix = q.stripPrefix, le.stripTrailingSlash = q.stripTrailingSlash, le.decodePercentEncoding = q.decodePercentEncoding, le;
          }
          return F.prototype.getType = function() {
            return "url";
          }, F.prototype.getUrlMatchType = function() {
            return this.urlMatchType;
          }, F.prototype.getUrl = function() {
            var q = this.url;
            return !this.protocolRelativeMatch && this.urlMatchType !== "scheme" && !this.protocolPrepended && (q = this.url = "http://" + q, this.protocolPrepended = !0), q;
          }, F.prototype.getAnchorHref = function() {
            var q = this.getUrl();
            return q.replace(/&amp;/g, "&");
          }, F.prototype.getAnchorText = function() {
            var q = this.getMatchedText();
            return this.protocolRelativeMatch && (q = Te(q)), this.stripPrefix.scheme && (q = ue(q)), this.stripPrefix.www && (q = ie(q)), this.stripTrailingSlash && (q = je(q)), this.decodePercentEncoding && (q = We(q)), q;
          }, F;
        }(S)
      );
      function ue(h) {
        return h.replace(P, "");
      }
      function ie(h) {
        return h.includes("www.") ? h.replace(at, "$1") : h;
      }
      function Te(h) {
        return h.replace(Ie, "");
      }
      function je(h) {
        return h.charAt(h.length - 1) === "/" && (h = h.slice(0, -1)), h;
      }
      function We(h) {
        var F = h.replace(/%(?:22|26|27|3C|3E)/gi, function(q) {
          return q === "%22" ? "&quot;" : q === "%26" ? "&amp;" : q === "%27" ? "&#39;" : q === "%3C" || q === "%3c" ? "&lt;" : "&gt;";
        });
        if (F.includes("%"))
          try {
            return decodeURIComponent(F);
          } catch {
          }
        return F;
      }
      var Qe = /^mailto:/i, xe = $;
      function Be(h) {
        return xe(h) || j(h);
      }
      function At(h) {
        var F = h.split(".").pop();
        return ve(F);
      }
      var xt = (
        /** @class */
        function(h) {
          r(F, h);
          function F(q) {
            var le = h.call(this, q) || this;
            return le.type = "email", le.email = "", le.email = q.email, le;
          }
          return F.prototype.getType = function() {
            return "email";
          }, F.prototype.getEmail = function() {
            return this.email;
          }, F.prototype.getAnchorHref = function() {
            return "mailto:" + this.email;
          }, F.prototype.getAnchorText = function() {
            return this.email;
          }, F;
        }(S)
      );
      function Rt(h) {
        return h === 95 || $(h);
      }
      function Xt(h) {
        return h.length <= 140;
      }
      var jt = [
        "twitter",
        "facebook",
        "instagram",
        "tiktok",
        "youtube"
      ], Tt = (
        /** @class */
        function(h) {
          r(F, h);
          function F(q) {
            var le = h.call(this, q) || this;
            return le.type = "hashtag", le.serviceName = "twitter", le.hashtag = "", le.serviceName = q.serviceName, le.hashtag = q.hashtag, le;
          }
          return F.prototype.getType = function() {
            return "hashtag";
          }, F.prototype.getServiceName = function() {
            return this.serviceName;
          }, F.prototype.getHashtag = function() {
            return this.hashtag;
          }, F.prototype.getAnchorHref = function() {
            var q = this.serviceName, le = this.hashtag;
            switch (q) {
              case "twitter":
                return "https://twitter.com/hashtag/" + le;
              case "facebook":
                return "https://www.facebook.com/hashtag/" + le;
              case "instagram":
                return "https://instagram.com/explore/tags/" + le;
              case "tiktok":
                return "https://www.tiktok.com/tag/" + le;
              case "youtube":
                return "https://youtube.com/hashtag/" + le;
              /* istanbul ignore next */
              default:
                f(q);
            }
          }, F.prototype.getAnchorText = function() {
            return "#" + this.hashtag;
          }, F.prototype.getCssClassSuffixes = function() {
            var q = h.prototype.getCssClassSuffixes.call(this), le = this.getServiceName();
            return le && q.push(le), q;
          }, F;
        }(S)
      ), bn = {
        twitter: /^@\w{1,15}$/,
        instagram: /^@[_\w]{1,30}$/,
        soundcloud: /^@[-a-z0-9_]{3,25}$/,
        // TikTok usernames are 1-24 characters containing letters, numbers, underscores
        // and periods, but cannot end in a period: https://support.tiktok.com/en/getting-started/setting-up-your-profile/changing-your-username
        tiktok: /^@[.\w]{1,23}[\w]$/,
        // Youtube usernames are 3-30 characters containing letters, numbers, underscores,
        // dashes, or latin middle dots ('·').
        // https://support.google.com/youtube/answer/11585688?hl=en&co=GENIE.Platform%3DAndroid#tns
        youtube: /^@[-.·\w]{3,30}$/,
        imkit: /^@[-_.·\w]{2,37}$/
      };
      function Ve(h) {
        return h === 45 || // '-'
        h === 46 || // '.'
        h === 95 || // '_'
        O(h) || T(h);
      }
      function ut(h, F) {
        var q = bn[F];
        return q.test(h);
      }
      var _t = [
        "twitter",
        "instagram",
        "soundcloud",
        "tiktok",
        "youtube",
        "imkit"
      ], zt = (
        /** @class */
        function(h) {
          r(F, h);
          function F(q) {
            var le = h.call(this, q) || this;
            return le.type = "mention", le.serviceName = "twitter", le.mention = "", le.mention = q.mention, le.serviceName = q.serviceName, le;
          }
          return F.prototype.getType = function() {
            return "mention";
          }, F.prototype.getMention = function() {
            return this.mention;
          }, F.prototype.getServiceName = function() {
            return this.serviceName;
          }, F.prototype.getAnchorHref = function() {
            switch (this.serviceName) {
              case "twitter":
                return "https://twitter.com/" + this.mention;
              case "instagram":
                return "https://instagram.com/" + this.mention;
              case "soundcloud":
                return "https://soundcloud.com/" + this.mention;
              case "tiktok":
                return "https://www.tiktok.com/@" + this.mention;
              case "youtube":
                return "https://youtube.com/@" + this.mention;
              case "imkit":
                return "https://imkit.io/" + this.mention;
              /* istanbul ignore next */
              default:
                f(this.serviceName);
            }
          }, F.prototype.getAnchorText = function() {
            return "@" + this.mention;
          }, F.prototype.getCssClassSuffixes = function() {
            var q = h.prototype.getCssClassSuffixes.call(this), le = this.getServiceName();
            return le && q.push(le), q;
          }, F;
        }(S)
      ), wn = /[-. ()]/, Hn = /(?:(?:(?:(\+)?\d{1,3}[-. ]?)?\(?\d{3}\)?[-. ]?\d{3}[-. ]?\d{4})|(?:(\+)(?:9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-. ]?(?:\d[-. ]?){6,12}\d+))([,;]+[0-9]+#?)*/, jn = /(0([1-9]-?[1-9]\d{3}|[1-9]{2}-?\d{3}|[1-9]{2}\d{1}-?\d{2}|[1-9]{2}\d{2}-?\d{1})-?\d{4}|0[789]0-?\d{4}-?\d{4}|050-?\d{4}-?\d{4})/, Y = new RegExp("^".concat(Hn.source, "|").concat(jn.source, "$"));
      function J(h) {
        return h === 45 || // '-'
        h === 46 || // '.'
        h === 32;
      }
      function me(h) {
        return h === 44 || // ','
        h === 59;
      }
      function Oe(h) {
        var F = h.charAt(0) === "+" || wn.test(h);
        return F && Y.test(h);
      }
      var rt = (
        /** @class */
        function(h) {
          r(F, h);
          function F(q) {
            var le = h.call(this, q) || this;
            return le.type = "phone", le.number = "", le.plusSign = !1, le.number = q.number, le.plusSign = q.plusSign, le;
          }
          return F.prototype.getType = function() {
            return "phone";
          }, F.prototype.getPhoneNumber = function() {
            return this.number;
          }, F.prototype.getNumber = function() {
            return this.getPhoneNumber();
          }, F.prototype.getAnchorHref = function() {
            return "tel:" + (this.plusSign ? "+" : "") + this.number;
          }, F.prototype.getAnchorText = function() {
            return this.matchedText;
          }, F;
        }(S)
      ), ht = (
        /** @class */
        function() {
          function h(F, q) {
            this.charIdx = 0, this.matches = [], this._stateMachines = [], this.schemeUrlMachinesCount = 0, this.text = F, this.tagBuilder = q.tagBuilder, this.stripPrefix = q.stripPrefix, this.stripTrailingSlash = q.stripTrailingSlash, this.decodePercentEncoding = q.decodePercentEncoding, this.hashtagServiceName = q.hashtagServiceName, this.mentionServiceName = q.mentionServiceName;
          }
          return Object.defineProperty(h.prototype, "stateMachines", {
            get: function() {
              return this._stateMachines;
            },
            enumerable: !1,
            configurable: !0
          }), h.prototype.addMachine = function(F) {
            this._stateMachines.push(F), ud(F) && this.schemeUrlMachinesCount++;
          }, h.prototype.removeMachine = function(F) {
            this._stateMachines = this._stateMachines.filter(function(q) {
              return q !== F;
            }), ud(F) && this.schemeUrlMachinesCount--;
          }, h.prototype.hasSchemeUrlMachine = function() {
            return this.schemeUrlMachinesCount > 0;
          }, h;
        }()
      );
      function qt(h, F) {
        for (var q = new ht(h, F); q.charIdx < q.text.length; q.charIdx++) {
          var le = h.charAt(q.charIdx), Le = h.charCodeAt(q.charIdx);
          if (q.stateMachines.length === 0)
            Bt(q, le, Le);
          else {
            for (var st = q.stateMachines.length - 1; st >= 0; st--) {
              var Je = q.stateMachines[st];
              switch (Je.state) {
                // Protocol-relative URL states
                case 11:
                  On(q, Je, Le);
                  break;
                case 12:
                  $t(q, Je, Le);
                  break;
                case 0:
                  mr(q, Je, Le);
                  break;
                case 1:
                  wr(q, Je, Le);
                  break;
                case 2:
                  gn(q, Je, Le);
                  break;
                case 3:
                  Kn(q, Je, Le);
                  break;
                case 4:
                  Rn(q, Je, le, Le);
                  break;
                case 5:
                  ur(q, Je, Le);
                  break;
                case 6:
                  Or(q, Je, le, Le);
                  break;
                case 7:
                  Nn(q, Je, le, Le);
                  break;
                case 13:
                  Nr(q, Je, Le);
                  break;
                case 14:
                  ii(q, Je, Le);
                  break;
                case 8:
                  rn(q, Je, Le);
                  break;
                case 9:
                  s1(q, Je, Le);
                  break;
                case 10:
                  il(q, Je, Le);
                  break;
                // Email States
                case 15:
                  sl(q, Je, le, Le);
                  break;
                case 16:
                  a1(q, Je, le, Le);
                  break;
                case 17:
                  ya(q, Je, le, Le);
                  break;
                case 18:
                  Bn(q, Je, le, Le);
                  break;
                case 19:
                  Fh(q, Je, le, Le);
                  break;
                case 20:
                  al(q, Je, Le);
                  break;
                case 21:
                  o1(q, Je, Le);
                  break;
                case 22:
                  va(q, Je, Le);
                  break;
                case 23:
                  u1(q, Je, Le);
                  break;
                case 24:
                  Uh(q, Je, Le);
                  break;
                case 25:
                  id(q, Je, Le);
                  break;
                case 26:
                  sd(q, Je, Le);
                  break;
                case 27:
                  $h(q, Je, Le);
                  break;
                // Hashtag states
                case 28:
                  l1(q, Je, Le);
                  break;
                case 29:
                  c1(q, Je, Le);
                  break;
                // Mention states
                case 30:
                  ol(q, Je, Le);
                  break;
                case 31:
                  ul(q, Je, Le);
                  break;
                // Phone number states
                case 32:
                  jo(q, Je, le, Le);
                  break;
                case 33:
                  zo(q, Je, Le);
                  break;
                case 34:
                  qo(q, Je, Le);
                  break;
                case 35:
                  Vo(q, Je, Le);
                  break;
                case 36:
                  d1(q, Je, le, Le);
                  break;
                case 37:
                  Hh(q, Je, le, Le);
                  break;
                case 38:
                  jh(q, Je, le, Le);
                  break;
                case 39:
                  f1(q, Je, le, Le);
                  break;
                case 40:
                  h1(q, Je, Le);
                  break;
                case 41:
                  zs(q, Je, Le);
                  break;
                /* istanbul ignore next */
                default:
                  f(Je.state);
              }
            }
            if (!q.hasSchemeUrlMachine() && q.charIdx > 0 && ee(Le)) {
              var Lr = q.text.charCodeAt(q.charIdx - 1);
              ee(Lr) || q.addMachine(Ur(
                q.charIdx,
                0
                /* State.SchemeChar */
              ));
            }
          }
        }
        for (var Tn = q.stateMachines.length - 1; Tn >= 0; Tn--)
          q.stateMachines.forEach(function($r) {
            return Sn(q, $r);
          });
        return q.matches;
      }
      function Bt(h, F, q) {
        var le = h.charIdx;
        if (q === 35)
          h.addMachine(dl(
            le,
            28
            /* State.HashtagHashChar */
          ));
        else if (q === 64)
          h.addMachine(Xa(
            le,
            30
            /* State.MentionAtChar */
          ));
        else if (q === 47)
          h.addMachine(od(
            le,
            11
            /* State.ProtocolRelativeSlash1 */
          ));
        else if (q === 43)
          h.addMachine(Qo(
            le,
            37
            /* State.PhoneNumberPlus */
          ));
        else if (q === 40)
          h.addMachine(Qo(
            le,
            32
            /* State.PhoneNumberOpenParen */
          ));
        else {
          if (T(q) && (h.addMachine(Qo(
            le,
            38
            /* State.PhoneNumberDigit */
          )), h.addMachine(cl(
            le,
            13
            /* State.IpV4Digit */
          ))), xe(q)) {
            var Le = F.toLowerCase() === "m" ? 15 : 22;
            h.addMachine(Wo(le, Le));
          }
          ee(q) && h.addMachine(Ur(
            le,
            0
            /* State.SchemeChar */
          )), $(q) && h.addMachine(od(
            le,
            5
            /* State.DomainLabelChar */
          ));
        }
      }
      function mr(h, F, q) {
        q === 58 ? F.state = 2 : q === 45 ? F.state = 1 : Z(q) || h.removeMachine(F);
      }
      function wr(h, F, q) {
        var le = h.charIdx;
        q === 45 || (q === 47 ? (h.removeMachine(F), h.addMachine(od(
          le,
          11
          /* State.ProtocolRelativeSlash1 */
        ))) : Z(q) ? F.state = 0 : h.removeMachine(F));
      }
      function gn(h, F, q) {
        var le = h.charIdx;
        q === 47 ? F.state = 3 : q === 46 ? h.removeMachine(F) : ye(q) ? (F.state = 5, ee(q) && h.addMachine(Ur(
          le,
          0
          /* State.SchemeChar */
        ))) : h.removeMachine(F);
      }
      function Kn(h, F, q) {
        q === 47 ? F.state = 4 : Ee(q) ? (F.state = 10, F.acceptStateReached = !0) : Sn(h, F);
      }
      function Rn(h, F, q, le) {
        le === 47 ? (F.state = 10, F.acceptStateReached = !0) : ye(le) ? (F.state = 5, F.acceptStateReached = !0) : h.removeMachine(F);
      }
      function On(h, F, q) {
        q === 47 ? F.state = 12 : h.removeMachine(F);
      }
      function $t(h, F, q) {
        ye(q) ? F.state = 5 : h.removeMachine(F);
      }
      function ur(h, F, q) {
        q === 46 ? F.state = 7 : q === 45 ? F.state = 6 : q === 58 ? F.state = 8 : be(q) ? F.state = 10 : he(q) || Sn(h, F);
      }
      function Or(h, F, q, le) {
        le === 45 || (le === 46 ? Sn(h, F) : ye(le) ? F.state = 5 : Sn(h, F));
      }
      function Nn(h, F, q, le) {
        le === 46 ? Sn(h, F) : ye(le) ? (F.state = 5, F.acceptStateReached = !0) : Sn(h, F);
      }
      function Nr(h, F, q) {
        q === 46 ? F.state = 14 : q === 58 ? F.state = 8 : T(q) || (be(q) ? F.state = 10 : $(q) ? h.removeMachine(F) : Sn(h, F));
      }
      function ii(h, F, q) {
        T(q) ? (F.octetsEncountered++, F.octetsEncountered === 4 && (F.acceptStateReached = !0), F.state = 13) : Sn(h, F);
      }
      function rn(h, F, q) {
        T(q) ? F.state = 9 : Sn(h, F);
      }
      function s1(h, F, q) {
        T(q) || (be(q) ? F.state = 10 : Sn(h, F));
      }
      function il(h, F, q) {
        Ee(q) || Sn(h, F);
      }
      function sl(h, F, q, le) {
        q.toLowerCase() === "a" ? F.state = 16 : va(h, F, le);
      }
      function a1(h, F, q, le) {
        q.toLowerCase() === "i" ? F.state = 17 : va(h, F, le);
      }
      function ya(h, F, q, le) {
        q.toLowerCase() === "l" ? F.state = 18 : va(h, F, le);
      }
      function Bn(h, F, q, le) {
        q.toLowerCase() === "t" ? F.state = 19 : va(h, F, le);
      }
      function Fh(h, F, q, le) {
        q.toLowerCase() === "o" ? F.state = 20 : va(h, F, le);
      }
      function al(h, F, q) {
        q === 58 ? F.state = 21 : va(h, F, q);
      }
      function o1(h, F, q) {
        Be(q) ? F.state = 22 : h.removeMachine(F);
      }
      function va(h, F, q) {
        q === 46 ? F.state = 23 : q === 64 ? F.state = 24 : Be(q) ? F.state = 22 : h.removeMachine(F);
      }
      function u1(h, F, q) {
        q === 46 || q === 64 ? h.removeMachine(F) : Be(q) ? F.state = 22 : h.removeMachine(F);
      }
      function Uh(h, F, q) {
        ye(q) ? F.state = 25 : h.removeMachine(F);
      }
      function id(h, F, q) {
        q === 46 ? F.state = 27 : q === 45 ? F.state = 26 : he(q) || Sn(h, F);
      }
      function sd(h, F, q) {
        q === 45 || q === 46 ? Sn(h, F) : he(q) ? F.state = 25 : Sn(h, F);
      }
      function $h(h, F, q) {
        q === 46 || q === 45 ? Sn(h, F) : ye(q) ? (F.state = 25, F.acceptStateReached = !0) : Sn(h, F);
      }
      function l1(h, F, q) {
        Rt(q) ? (F.state = 29, F.acceptStateReached = !0) : h.removeMachine(F);
      }
      function c1(h, F, q) {
        Rt(q) || Sn(h, F);
      }
      function ol(h, F, q) {
        Ve(q) ? (F.state = 31, F.acceptStateReached = !0) : h.removeMachine(F);
      }
      function ul(h, F, q) {
        Ve(q) || ($(q) ? h.removeMachine(F) : Sn(h, F));
      }
      function Hh(h, F, q, le) {
        T(le) ? F.state = 38 : (h.removeMachine(F), Bt(h, q, le));
      }
      function jo(h, F, q, le) {
        T(le) ? F.state = 33 : h.removeMachine(F), Bt(h, q, le);
      }
      function zo(h, F, q) {
        T(q) ? F.state = 34 : h.removeMachine(F);
      }
      function qo(h, F, q) {
        T(q) ? F.state = 35 : h.removeMachine(F);
      }
      function Vo(h, F, q) {
        q === 41 ? F.state = 36 : h.removeMachine(F);
      }
      function d1(h, F, q, le) {
        T(le) ? F.state = 38 : J(le) ? F.state = 39 : h.removeMachine(F);
      }
      function jh(h, F, q, le) {
        var Le = h.charIdx;
        F.acceptStateReached = !0, me(le) ? F.state = 40 : le === 35 ? F.state = 41 : T(le) || (le === 40 ? F.state = 32 : J(le) ? F.state = 39 : (Sn(h, F), ee(le) && h.addMachine(Ur(
          Le,
          0
          /* State.SchemeChar */
        ))));
      }
      function f1(h, F, q, le) {
        T(le) ? F.state = 38 : le === 40 ? F.state = 32 : (Sn(h, F), Bt(h, q, le));
      }
      function h1(h, F, q) {
        me(q) || (q === 35 ? F.state = 41 : T(q) ? F.state = 38 : Sn(h, F));
      }
      function zs(h, F, q) {
        me(q) ? F.state = 40 : T(q) ? h.removeMachine(F) : Sn(h, F);
      }
      function Sn(h, F) {
        var q = h.matches, le = h.text, Le = h.charIdx, st = h.tagBuilder, Je = h.stripPrefix, Lr = h.stripTrailingSlash, Tn = h.decodePercentEncoding, $r = h.hashtagServiceName, Ta = h.mentionServiceName;
        if (h.removeMachine(F), !!F.acceptStateReached) {
          var _r = F.startIdx, un = le.slice(F.startIdx, Le);
          switch (un = ad(un), F.type) {
            case 0: {
              var bs = le.charCodeAt(F.startIdx - 1);
              if (bs === 64)
                return;
              switch (F.matchType) {
                case 0: {
                  var Xi = Q.exec(un);
                  if (Xi && (_r = _r + Xi.index, un = un.slice(Xi.index)), !Ce(un))
                    return;
                  break;
                }
                case 1: {
                  if (!Ne(un))
                    return;
                  break;
                }
                case 2: {
                  if (!Xe(un))
                    return;
                  break;
                }
                /* istanbul ignore next */
                default:
                  f(F);
              }
              q.push(new ne({
                tagBuilder: st,
                matchedText: un,
                offset: _r,
                urlMatchType: p1(F.matchType),
                url: un,
                protocolRelativeMatch: un.slice(0, 2) === "//",
                // TODO: Do these settings need to be passed to the match,
                // or should we handle them here in UrlMatcher?
                stripPrefix: Je,
                stripTrailingSlash: Lr,
                decodePercentEncoding: Tn
              }));
              break;
            }
            case 1: {
              At(un) && q.push(new xt({
                tagBuilder: st,
                matchedText: un,
                offset: _r,
                email: un.replace(Qe, "")
              }));
              break;
            }
            case 2: {
              Xt(un) && q.push(new Tt({
                tagBuilder: st,
                matchedText: un,
                offset: _r,
                serviceName: $r,
                hashtag: un.slice(1)
              }));
              break;
            }
            case 3: {
              ut(un, Ta) && q.push(new zt({
                tagBuilder: st,
                matchedText: un,
                offset: _r,
                serviceName: Ta,
                mention: un.slice(1)
                // strip off the '@' character at the beginning
              }));
              break;
            }
            case 4: {
              if (un = un.replace(/ +$/g, ""), Oe(un)) {
                var gl = un.replace(/[^0-9,;#]/g, "");
                q.push(new rt({
                  tagBuilder: st,
                  matchedText: un,
                  offset: _r,
                  number: gl,
                  plusSign: un.charAt(0) === "+"
                }));
              }
              break;
            }
            /* istanbul ignore next */
            default:
              f(F);
          }
        }
      }
      function p1(h) {
        switch (h) {
          case 0:
            return "scheme";
          case 1:
            return "tld";
          case 2:
            return "ipV4";
          /* istanbul ignore next */
          default:
            f(h);
        }
      }
      var ll = {
        ")": "(",
        "}": "{",
        "]": "["
      };
      function ad(h) {
        for (var F = {
          "(": 0,
          "{": 0,
          "[": 0
        }, q = 0; q < h.length; q++) {
          var le = h.charAt(q), Le = h.charCodeAt(q);
          B(Le) ? F[le]++ : R(Le) && F[ll[le]]--;
        }
        for (var st = h.length - 1; st >= 0; ) {
          var le = h.charAt(st), Le = h.charCodeAt(st);
          if (R(Le)) {
            var Je = ll[le];
            if (F[Je] < 0)
              F[Je]++, st--;
            else
              break;
          } else if (V(Le))
            st--;
          else
            break;
        }
        return h.slice(0, st + 1);
      }
      function Ur(h, F) {
        return {
          type: 0,
          startIdx: h,
          state: F,
          acceptStateReached: !1,
          matchType: 0
        };
      }
      function od(h, F) {
        return {
          type: 0,
          startIdx: h,
          state: F,
          acceptStateReached: !1,
          matchType: 1
        };
      }
      function cl(h, F) {
        return {
          type: 0,
          startIdx: h,
          state: F,
          acceptStateReached: !1,
          matchType: 2,
          octetsEncountered: 1
          // starts at 1 because we create this machine when encountering the first octet
        };
      }
      function Wo(h, F) {
        return {
          type: 1,
          startIdx: h,
          state: F,
          acceptStateReached: !1
        };
      }
      function dl(h, F) {
        return {
          type: 2,
          startIdx: h,
          state: F,
          acceptStateReached: !1
        };
      }
      function Xa(h, F) {
        return {
          type: 3,
          startIdx: h,
          state: F,
          acceptStateReached: !1
        };
      }
      function Qo(h, F) {
        return {
          type: 4,
          startIdx: h,
          state: F,
          acceptStateReached: !1
        };
      }
      function ud(h) {
        return h.type === 0 && h.matchType === 0;
      }
      var gi = (
        /** @class */
        /* @__PURE__ */ function() {
          function h(F) {
            F === void 0 && (F = {}), this.idx = F.idx !== void 0 ? F.idx : -1, this.type = F.type || "tag", this.name = F.name || "", this.isOpening = !!F.isOpening, this.isClosing = !!F.isClosing;
          }
          return h;
        }()
      ), ld = new gi(), m1 = (
        /** @class */
        /* @__PURE__ */ function() {
          function h(F, q) {
            this.charIdx = 0, this.state = 0, this.currentDataIdx = 0, this.currentTag = ld, this.html = F, this.callbacks = q;
          }
          return h;
        }()
      );
      function g1(h, F) {
        for (var q = new m1(h, F), le = h.length; q.charIdx < le; ) {
          var Le = h.charAt(q.charIdx), st = h.charCodeAt(q.charIdx);
          switch (q.state) {
            case 0:
              fl(q, Le);
              break;
            case 1:
              zh(q, Le, st);
              break;
            case 2:
              qh(q, Le, st);
              break;
            case 3:
              A1(q, Le, st);
              break;
            case 4:
              b1(q, Le, st);
              break;
            case 5:
              Vh(q, Le, st);
              break;
            case 6:
              y1(q, Le, st);
              break;
            case 7:
              hl(q, Le, st);
              break;
            case 8:
              pl(q, Le);
              break;
            case 9:
              Wh(q, Le);
              break;
            case 10:
              v1(q, Le, st);
              break;
            case 11:
              T1(q, Le, st);
              break;
            case 12:
              Qh(q, Le);
              break;
            case 13:
              Gh(q);
              break;
            case 14:
              _1(q, Le);
              break;
            case 15:
              Yh(q, Le);
              break;
            case 16:
              E1(q, Le);
              break;
            case 17:
              x1(q, Le);
              break;
            case 18:
              w1(q, Le);
              break;
            case 19:
              C1(q, Le);
              break;
            case 20:
              S1(q, Le);
              break;
            /* istanbul ignore next */
            default:
              f(q.state);
          }
          q.charIdx++;
        }
        q.currentDataIdx < q.charIdx && Xh(q);
      }
      function fl(h, F) {
        F === "<" && bi(h);
      }
      function zh(h, F, q) {
        F === "!" ? h.state = 13 : F === "/" ? (h.state = 2, h.currentTag = new gi(i(i({}, h.currentTag), { isClosing: !0 }))) : F === "<" ? bi(h) : O(q) ? (h.state = 3, h.currentTag = new gi(i(i({}, h.currentTag), { isOpening: !0 }))) : (h.state = 0, h.currentTag = ld);
      }
      function A1(h, F, q) {
        H(q) ? (h.currentTag = new gi(i(i({}, h.currentTag), { name: Ka(h) })), h.state = 4) : F === "<" ? bi(h) : F === "/" ? (h.currentTag = new gi(i(i({}, h.currentTag), { name: Ka(h) })), h.state = 12) : F === ">" ? (h.currentTag = new gi(i(i({}, h.currentTag), { name: Ka(h) })), Yi(h)) : !O(q) && !T(q) && F !== ":" && Ai(h);
      }
      function qh(h, F, q) {
        F === ">" ? Ai(h) : O(q) ? h.state = 3 : Ai(h);
      }
      function b1(h, F, q) {
        H(q) || (F === "/" ? h.state = 12 : F === ">" ? Yi(h) : F === "<" ? bi(h) : F === "=" || N(q) || M(q) ? Ai(h) : h.state = 5);
      }
      function Vh(h, F, q) {
        H(q) ? h.state = 6 : F === "/" ? h.state = 12 : F === "=" ? h.state = 7 : F === ">" ? Yi(h) : F === "<" ? bi(h) : N(q) && Ai(h);
      }
      function y1(h, F, q) {
        H(q) || (F === "/" ? h.state = 12 : F === "=" ? h.state = 7 : F === ">" ? Yi(h) : F === "<" ? bi(h) : N(q) ? Ai(h) : h.state = 5);
      }
      function hl(h, F, q) {
        H(q) || (F === '"' ? h.state = 8 : F === "'" ? h.state = 9 : /[>=`]/.test(F) ? Ai(h) : F === "<" ? bi(h) : h.state = 10);
      }
      function pl(h, F) {
        F === '"' && (h.state = 11);
      }
      function Wh(h, F) {
        F === "'" && (h.state = 11);
      }
      function v1(h, F, q) {
        H(q) ? h.state = 4 : F === ">" ? Yi(h) : F === "<" && bi(h);
      }
      function T1(h, F, q) {
        H(q) ? h.state = 4 : F === "/" ? h.state = 12 : F === ">" ? Yi(h) : F === "<" ? bi(h) : (h.state = 4, I1(h));
      }
      function Qh(h, F) {
        F === ">" ? (h.currentTag = new gi(i(i({}, h.currentTag), { isClosing: !0 })), Yi(h)) : Ai(h);
      }
      function Gh(h) {
        var F = h.html, q = h.charIdx;
        F.slice(q, q + 2) === "--" ? (h.charIdx++, h.currentTag = new gi(i(i({}, h.currentTag), { type: "comment" })), h.state = 14) : F.slice(q, q + 7).toUpperCase() === "DOCTYPE" ? (h.charIdx += 6, h.currentTag = new gi(i(i({}, h.currentTag), { type: "doctype" })), h.state = 20) : Ai(h);
      }
      function _1(h, F) {
        F === "-" ? h.state = 15 : F === ">" ? Ai(h) : h.state = 16;
      }
      function Yh(h, F) {
        F === "-" ? h.state = 18 : F === ">" ? Ai(h) : h.state = 16;
      }
      function E1(h, F) {
        F === "-" && (h.state = 17);
      }
      function x1(h, F) {
        F === "-" ? h.state = 18 : h.state = 16;
      }
      function w1(h, F) {
        F === ">" ? Yi(h) : F === "!" ? h.state = 19 : F === "-" || (h.state = 16);
      }
      function C1(h, F) {
        F === "-" ? h.state = 17 : F === ">" ? Yi(h) : h.state = 16;
      }
      function S1(h, F) {
        F === ">" ? Yi(h) : F === "<" && bi(h);
      }
      function Ai(h) {
        h.state = 0, h.currentTag = ld;
      }
      function bi(h) {
        h.state = 1, h.currentTag = new gi({ idx: h.charIdx });
      }
      function Yi(h) {
        var F = h.html.slice(h.currentDataIdx, h.currentTag.idx);
        F && h.callbacks.onText(F, h.currentDataIdx);
        var q = h.currentTag;
        q.type === "comment" ? h.callbacks.onComment(q.idx) : q.type === "doctype" ? h.callbacks.onDoctype(q.idx) : (q.isOpening && h.callbacks.onOpenTag(q.name, q.idx), q.isClosing && h.callbacks.onCloseTag(q.name, q.idx)), Ai(h), h.currentDataIdx = h.charIdx + 1;
      }
      function Xh(h) {
        var F = h.html.slice(h.currentDataIdx, h.charIdx);
        h.callbacks.onText(F, h.currentDataIdx), h.currentDataIdx = h.charIdx + 1;
      }
      function Ka(h) {
        var F = h.currentTag.idx + (h.currentTag.isClosing ? 2 : 1);
        return h.html.slice(F, h.charIdx).toLowerCase();
      }
      function I1(h) {
        h.charIdx--;
      }
      var k1 = (
        /** @class */
        function() {
          function h(F) {
            F === void 0 && (F = {}), this.version = h.version, this.urls = {}, this.email = !0, this.phone = !0, this.hashtag = !1, this.mention = !1, this.newWindow = !0, this.stripPrefix = {
              scheme: !0,
              www: !0
            }, this.stripTrailingSlash = !0, this.decodePercentEncoding = !0, this.truncate = {
              length: 0,
              location: "end"
            }, this.className = "", this.replaceFn = null, this.context = void 0, this.sanitizeHtml = !1, this.tagBuilder = null, this.urls = D1(F.urls), this.email = c(F.email) ? F.email : this.email, this.phone = c(F.phone) ? F.phone : this.phone, this.hashtag = F.hashtag || this.hashtag, this.mention = F.mention || this.mention, this.newWindow = c(F.newWindow) ? F.newWindow : this.newWindow, this.stripPrefix = M1(F.stripPrefix), this.stripTrailingSlash = c(F.stripTrailingSlash) ? F.stripTrailingSlash : this.stripTrailingSlash, this.decodePercentEncoding = c(F.decodePercentEncoding) ? F.decodePercentEncoding : this.decodePercentEncoding, this.sanitizeHtml = F.sanitizeHtml || !1;
            var q = this.mention;
            if (q !== !1 && _t.indexOf(q) === -1)
              throw new Error("invalid `mention` cfg '".concat(q, "' - see docs"));
            var le = this.hashtag;
            if (le !== !1 && jt.indexOf(le) === -1)
              throw new Error("invalid `hashtag` cfg '".concat(le, "' - see docs"));
            this.truncate = O1(F.truncate), this.className = F.className || this.className, this.replaceFn = F.replaceFn || this.replaceFn, this.context = F.context || this;
          }
          return h.link = function(F, q) {
            var le = new h(q);
            return le.link(F);
          }, h.parse = function(F, q) {
            var le = new h(q);
            return le.parse(F);
          }, h.prototype.parse = function(F) {
            var q = this, le = ["a", "style", "script"], Le = 0, st = [];
            return g1(F, {
              onOpenTag: function(Je) {
                le.indexOf(Je) >= 0 && Le++;
              },
              onText: function(Je, Lr) {
                if (Le === 0) {
                  var Tn = /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi, $r = Je.split(Tn), Ta = Lr;
                  $r.forEach(function(_r, un) {
                    if (un % 2 === 0) {
                      var bs = q.parseText(_r, Ta);
                      st.push.apply(st, a([], s(bs), !1));
                    }
                    Ta += _r.length;
                  });
                }
              },
              onCloseTag: function(Je) {
                le.indexOf(Je) >= 0 && (Le = Math.max(Le - 1, 0));
              },
              onComment: function() {
              },
              // no need to process comment nodes
              onDoctype: function() {
              }
              // no need to process doctype nodes
            }), st = this.compactMatches(st), st = this.removeUnwantedMatches(st), st;
          }, h.prototype.compactMatches = function(F) {
            F.sort(ml);
            for (var q = 0; q < F.length - 1; ) {
              var le = F[q], Le = le.getOffset(), st = le.getMatchedText().length;
              if (q + 1 < F.length && F[q + 1].getOffset() === Le) {
                var Je = F[q + 1].getMatchedText().length > st ? q : q + 1;
                F.splice(Je, 1);
                continue;
              }
              q++;
            }
            return F;
          }, h.prototype.removeUnwantedMatches = function(F) {
            return this.hashtag || l(F, function(q) {
              return q.getType() === "hashtag";
            }), this.email || l(F, function(q) {
              return q.getType() === "email";
            }), this.phone || l(F, function(q) {
              return q.getType() === "phone";
            }), this.mention || l(F, function(q) {
              return q.getType() === "mention";
            }), this.urls.schemeMatches || l(F, function(q) {
              return q.getType() === "url" && q.getUrlMatchType() === "scheme";
            }), this.urls.tldMatches || l(F, function(q) {
              return q.getType() === "url" && q.getUrlMatchType() === "tld";
            }), this.urls.ipV4Matches || l(F, function(q) {
              return q.getType() === "url" && q.getUrlMatchType() === "ipV4";
            }), F;
          }, h.prototype.parseText = function(F, q) {
            q = q || 0;
            for (var le = qt(F, {
              tagBuilder: this.getTagBuilder(),
              stripPrefix: this.stripPrefix,
              stripTrailingSlash: this.stripTrailingSlash,
              decodePercentEncoding: this.decodePercentEncoding,
              hashtagServiceName: this.hashtag,
              mentionServiceName: this.mention || "twitter"
            }), Le = 0, st = le.length; Le < st; Le++)
              le[Le].setOffset(q + le[Le].getOffset());
            return le;
          }, h.prototype.link = function(F) {
            if (!F)
              return "";
            this.sanitizeHtml && (F = F.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
            for (var q = this.parse(F), le = new Array(q.length * 2 + 1), Le = 0, st = 0, Je = q.length; st < Je; st++) {
              var Lr = q[st];
              le.push(F.substring(Le, Lr.getOffset())), le.push(this.createMatchReturnVal(Lr)), Le = Lr.getOffset() + Lr.getMatchedText().length;
            }
            return le.push(F.substring(Le)), le.join("");
          }, h.prototype.createMatchReturnVal = function(F) {
            var q;
            if (this.replaceFn && (q = this.replaceFn.call(this.context, F)), typeof q == "string")
              return q;
            if (q === !1)
              return F.getMatchedText();
            if (q instanceof m)
              return q.toAnchorString();
            var le = F.buildTag();
            return le.toAnchorString();
          }, h.prototype.getTagBuilder = function() {
            var F = this.tagBuilder;
            return F || (F = this.tagBuilder = new D({
              newWindow: this.newWindow,
              truncate: this.truncate,
              className: this.className
            })), F;
          }, h.version = o, h;
        }()
      );
      function D1(h) {
        return h == null && (h = !0), c(h) ? { schemeMatches: h, tldMatches: h, ipV4Matches: h } : {
          schemeMatches: c(h.schemeMatches) ? h.schemeMatches : !0,
          tldMatches: c(h.tldMatches) ? h.tldMatches : !0,
          ipV4Matches: c(h.ipV4Matches) ? h.ipV4Matches : !0
        };
      }
      function M1(h) {
        return h == null && (h = !0), c(h) ? { scheme: h, www: h } : {
          scheme: c(h.scheme) ? h.scheme : !0,
          www: c(h.www) ? h.www : !0
        };
      }
      function O1(h) {
        return typeof h == "number" ? { length: h, location: "end" } : i({ length: Number.POSITIVE_INFINITY, location: "end" }, h);
      }
      function ml(h, F) {
        return h.getOffset() - F.getOffset();
      }
      return k1;
    });
  }(rm)), rm.exports;
}
var qj = zj();
const Vj = /* @__PURE__ */ Fr(qj);
class Ma {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e) {
    Ke(this, "id");
    Ke(this, "nickname");
    Ke(this, "avatarUrl");
    Ke(this, "country");
    Ke(this, "city");
    Ke(this, "clientType");
    Ke(this, "memberIds");
    const {
      _id: n,
      nickname: r,
      avatarUrl: i,
      country: s,
      city: a,
      clientType: o,
      members: u
    } = e;
    this.id = n, this.nickname = r ?? n, this.avatarUrl = i, this.country = s ?? null, this.city = a ?? null, this.clientType = o ?? null, this.memberIds = {}, u == null || u.forEach((c) => {
      this.memberIds[c._id] = !0;
    });
  }
}
var im = { exports: {} }, Wj = im.exports, cE;
function Qj() {
  return cE || (cE = 1, function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(Wj, function() {
      var n = 1e3, r = 6e4, i = 36e5, s = "millisecond", a = "second", o = "minute", u = "hour", c = "day", d = "week", l = "month", f = "quarter", p = "year", m = "date", g = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, E = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(U) {
        var V = ["th", "st", "nd", "rd"], B = U % 100;
        return "[" + U + (V[(B - 20) % 10] || V[B] || V[0]) + "]";
      } }, v = function(U, V, B) {
        var R = String(U);
        return !R || R.length >= V ? U : "" + Array(V + 1 - R.length).join(B) + U;
      }, _ = { s: v, z: function(U) {
        var V = -U.utcOffset(), B = Math.abs(V), R = Math.floor(B / 60), K = B % 60;
        return (V <= 0 ? "+" : "-") + v(R, 2, "0") + ":" + v(K, 2, "0");
      }, m: function U(V, B) {
        if (V.date() < B.date()) return -U(B, V);
        var R = 12 * (B.year() - V.year()) + (B.month() - V.month()), K = V.clone().add(R, l), Q = B - K < 0, P = V.clone().add(R + (Q ? -1 : 1), l);
        return +(-(R + (B - K) / (Q ? K - P : P - K)) || 0);
      }, a: function(U) {
        return U < 0 ? Math.ceil(U) || 0 : Math.floor(U);
      }, p: function(U) {
        return { M: l, y: p, w: d, d: c, D: m, h: u, m: o, s: a, ms: s, Q: f }[U] || String(U || "").toLowerCase().replace(/s$/, "");
      }, u: function(U) {
        return U === void 0;
      } }, D = "en", S = {};
      S[D] = E;
      var M = "$isDayjsObject", O = function(U) {
        return U instanceof $ || !(!U || !U[M]);
      }, T = function U(V, B, R) {
        var K;
        if (!V) return D;
        if (typeof V == "string") {
          var Q = V.toLowerCase();
          S[Q] && (K = Q), B && (S[Q] = B, K = Q);
          var P = V.split("-");
          if (!K && P.length > 1) return U(P[0]);
        } else {
          var I = V.name;
          S[I] = V, K = I;
        }
        return !R && K && (D = K), K || !R && D;
      }, N = function(U, V) {
        if (O(U)) return U.clone();
        var B = typeof V == "object" ? V : {};
        return B.date = U, B.args = arguments, new $(B);
      }, H = _;
      H.l = T, H.i = O, H.w = function(U, V) {
        return N(U, { locale: V.$L, utc: V.$u, x: V.$x, $offset: V.$offset });
      };
      var $ = function() {
        function U(B) {
          this.$L = T(B.locale, null, !0), this.parse(B), this.$x = this.$x || B.x || {}, this[M] = !0;
        }
        var V = U.prototype;
        return V.parse = function(B) {
          this.$d = function(R) {
            var K = R.date, Q = R.utc;
            if (K === null) return /* @__PURE__ */ new Date(NaN);
            if (H.u(K)) return /* @__PURE__ */ new Date();
            if (K instanceof Date) return new Date(K);
            if (typeof K == "string" && !/Z$/i.test(K)) {
              var P = K.match(y);
              if (P) {
                var I = P[2] - 1 || 0, G = (P[7] || "0").substring(0, 3);
                return Q ? new Date(Date.UTC(P[1], I, P[3] || 1, P[4] || 0, P[5] || 0, P[6] || 0, G)) : new Date(P[1], I, P[3] || 1, P[4] || 0, P[5] || 0, P[6] || 0, G);
              }
            }
            return new Date(K);
          }(B), this.init();
        }, V.init = function() {
          var B = this.$d;
          this.$y = B.getFullYear(), this.$M = B.getMonth(), this.$D = B.getDate(), this.$W = B.getDay(), this.$H = B.getHours(), this.$m = B.getMinutes(), this.$s = B.getSeconds(), this.$ms = B.getMilliseconds();
        }, V.$utils = function() {
          return H;
        }, V.isValid = function() {
          return this.$d.toString() !== g;
        }, V.isSame = function(B, R) {
          var K = N(B);
          return this.startOf(R) <= K && K <= this.endOf(R);
        }, V.isAfter = function(B, R) {
          return N(B) < this.startOf(R);
        }, V.isBefore = function(B, R) {
          return this.endOf(R) < N(B);
        }, V.$g = function(B, R, K) {
          return H.u(B) ? this[R] : this.set(K, B);
        }, V.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, V.valueOf = function() {
          return this.$d.getTime();
        }, V.startOf = function(B, R) {
          var K = this, Q = !!H.u(R) || R, P = H.p(B), I = function(be, ve) {
            var Ce = H.w(K.$u ? Date.UTC(K.$y, ve, be) : new Date(K.$y, ve, be), K);
            return Q ? Ce : Ce.endOf(c);
          }, G = function(be, ve) {
            return H.w(K.toDate()[be].apply(K.toDate("s"), (Q ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ve)), K);
          }, te = this.$W, ee = this.$M, Z = this.$D, ye = "set" + (this.$u ? "UTC" : "");
          switch (P) {
            case p:
              return Q ? I(1, 0) : I(31, 11);
            case l:
              return Q ? I(1, ee) : I(0, ee + 1);
            case d:
              var he = this.$locale().weekStart || 0, Ee = (te < he ? te + 7 : te) - he;
              return I(Q ? Z - Ee : Z + (6 - Ee), ee);
            case c:
            case m:
              return G(ye + "Hours", 0);
            case u:
              return G(ye + "Minutes", 1);
            case o:
              return G(ye + "Seconds", 2);
            case a:
              return G(ye + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, V.endOf = function(B) {
          return this.startOf(B, !1);
        }, V.$set = function(B, R) {
          var K, Q = H.p(B), P = "set" + (this.$u ? "UTC" : ""), I = (K = {}, K[c] = P + "Date", K[m] = P + "Date", K[l] = P + "Month", K[p] = P + "FullYear", K[u] = P + "Hours", K[o] = P + "Minutes", K[a] = P + "Seconds", K[s] = P + "Milliseconds", K)[Q], G = Q === c ? this.$D + (R - this.$W) : R;
          if (Q === l || Q === p) {
            var te = this.clone().set(m, 1);
            te.$d[I](G), te.init(), this.$d = te.set(m, Math.min(this.$D, te.daysInMonth())).$d;
          } else I && this.$d[I](G);
          return this.init(), this;
        }, V.set = function(B, R) {
          return this.clone().$set(B, R);
        }, V.get = function(B) {
          return this[H.p(B)]();
        }, V.add = function(B, R) {
          var K, Q = this;
          B = Number(B);
          var P = H.p(R), I = function(ee) {
            var Z = N(Q);
            return H.w(Z.date(Z.date() + Math.round(ee * B)), Q);
          };
          if (P === l) return this.set(l, this.$M + B);
          if (P === p) return this.set(p, this.$y + B);
          if (P === c) return I(1);
          if (P === d) return I(7);
          var G = (K = {}, K[o] = r, K[u] = i, K[a] = n, K)[P] || 1, te = this.$d.getTime() + B * G;
          return H.w(te, this);
        }, V.subtract = function(B, R) {
          return this.add(-1 * B, R);
        }, V.format = function(B) {
          var R = this, K = this.$locale();
          if (!this.isValid()) return K.invalidDate || g;
          var Q = B || "YYYY-MM-DDTHH:mm:ssZ", P = H.z(this), I = this.$H, G = this.$m, te = this.$M, ee = K.weekdays, Z = K.months, ye = K.meridiem, he = function(ve, Ce, Ne, qe) {
            return ve && (ve[Ce] || ve(R, Q)) || Ne[Ce].slice(0, qe);
          }, Ee = function(ve) {
            return H.s(I % 12 || 12, ve, "0");
          }, be = ye || function(ve, Ce, Ne) {
            var qe = ve < 12 ? "AM" : "PM";
            return Ne ? qe.toLowerCase() : qe;
          };
          return Q.replace(b, function(ve, Ce) {
            return Ce || function(Ne) {
              switch (Ne) {
                case "YY":
                  return String(R.$y).slice(-2);
                case "YYYY":
                  return H.s(R.$y, 4, "0");
                case "M":
                  return te + 1;
                case "MM":
                  return H.s(te + 1, 2, "0");
                case "MMM":
                  return he(K.monthsShort, te, Z, 3);
                case "MMMM":
                  return he(Z, te);
                case "D":
                  return R.$D;
                case "DD":
                  return H.s(R.$D, 2, "0");
                case "d":
                  return String(R.$W);
                case "dd":
                  return he(K.weekdaysMin, R.$W, ee, 2);
                case "ddd":
                  return he(K.weekdaysShort, R.$W, ee, 3);
                case "dddd":
                  return ee[R.$W];
                case "H":
                  return String(I);
                case "HH":
                  return H.s(I, 2, "0");
                case "h":
                  return Ee(1);
                case "hh":
                  return Ee(2);
                case "a":
                  return be(I, G, !0);
                case "A":
                  return be(I, G, !1);
                case "m":
                  return String(G);
                case "mm":
                  return H.s(G, 2, "0");
                case "s":
                  return String(R.$s);
                case "ss":
                  return H.s(R.$s, 2, "0");
                case "SSS":
                  return H.s(R.$ms, 3, "0");
                case "Z":
                  return P;
              }
              return null;
            }(ve) || P.replace(":", "");
          });
        }, V.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, V.diff = function(B, R, K) {
          var Q, P = this, I = H.p(R), G = N(B), te = (G.utcOffset() - this.utcOffset()) * r, ee = this - G, Z = function() {
            return H.m(P, G);
          };
          switch (I) {
            case p:
              Q = Z() / 12;
              break;
            case l:
              Q = Z();
              break;
            case f:
              Q = Z() / 3;
              break;
            case d:
              Q = (ee - te) / 6048e5;
              break;
            case c:
              Q = (ee - te) / 864e5;
              break;
            case u:
              Q = ee / i;
              break;
            case o:
              Q = ee / r;
              break;
            case a:
              Q = ee / n;
              break;
            default:
              Q = ee;
          }
          return K ? Q : H.a(Q);
        }, V.daysInMonth = function() {
          return this.endOf(l).$D;
        }, V.$locale = function() {
          return S[this.$L];
        }, V.locale = function(B, R) {
          if (!B) return this.$L;
          var K = this.clone(), Q = T(B, R, !0);
          return Q && (K.$L = Q), K;
        }, V.clone = function() {
          return H.w(this.$d, this);
        }, V.toDate = function() {
          return new Date(this.valueOf());
        }, V.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, V.toISOString = function() {
          return this.$d.toISOString();
        }, V.toString = function() {
          return this.$d.toUTCString();
        }, U;
      }(), j = $.prototype;
      return N.prototype = j, [["$ms", s], ["$s", a], ["$m", o], ["$H", u], ["$W", c], ["$M", l], ["$y", p], ["$D", m]].forEach(function(U) {
        j[U[1]] = function(V) {
          return this.$g(V, U[0], U[1]);
        };
      }), N.extend = function(U, V) {
        return U.$i || (U(V, $, N), U.$i = !0), N;
      }, N.locale = T, N.isDayjs = O, N.unix = function(U) {
        return N(1e3 * U);
      }, N.en = S[D], N.Ls = S, N.p = {}, N;
    });
  }(im)), im.exports;
}
var Gj = Qj();
const Wn = /* @__PURE__ */ Fr(Gj);
/*!
  * shared v11.1.7
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const Os = typeof window < "u";
let qi, Fu;
if (process.env.NODE_ENV !== "production") {
  const t = Os && window.performance;
  t && t.mark && t.measure && t.clearMarks && // @ts-ignore browser compat
  t.clearMeasures && (qi = (e) => {
    t.mark(e);
  }, Fu = (e, n, r) => {
    t.measure(e, n, r), t.clearMarks(n), t.clearMarks(r);
  });
}
const Yj = /\{([0-9a-zA-Z]+)\}/g;
function tg(t, ...e) {
  return e.length === 1 && an(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(Yj, (n, r) => e.hasOwnProperty(r) ? e[r] : "");
}
const ba = (t, e = !1) => e ? Symbol.for(t) : Symbol(t), Xj = (t, e, n) => Kj({ l: t, k: e, s: n }), Kj = (t) => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), yr = (t) => typeof t == "number" && isFinite(t), Zj = (t) => Iv(t) === "[object Date]", ac = (t) => Iv(t) === "[object RegExp]", ng = (t) => en(t) && Object.keys(t).length === 0, xr = Object.assign, Jj = Object.create, Mn = (t = null) => Jj(t);
let dE;
const fu = () => dE || (dE = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : Mn());
function fE(t) {
  return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const ez = Object.prototype.hasOwnProperty;
function Is(t, e) {
  return ez.call(t, e);
}
const Zn = Array.isArray, Pn = (t) => typeof t == "function", mt = (t) => typeof t == "string", hn = (t) => typeof t == "boolean", an = (t) => t !== null && typeof t == "object", tz = (t) => an(t) && Pn(t.then) && Pn(t.catch), WI = Object.prototype.toString, Iv = (t) => WI.call(t), en = (t) => Iv(t) === "[object Object]", nz = (t) => t == null ? "" : Zn(t) || en(t) && t.toString === WI ? JSON.stringify(t, null, 2) : String(t);
function kv(t, e = "") {
  return t.reduce((n, r, i) => i === 0 ? n + r : n + e + r, "");
}
const hE = 2;
function rz(t, e = 0, n = t.length) {
  const r = t.split(/\r?\n/);
  let i = 0;
  const s = [];
  for (let a = 0; a < r.length; a++)
    if (i += r[a].length + 1, i >= e) {
      for (let o = a - hE; o <= a + hE || n > i; o++) {
        if (o < 0 || o >= r.length)
          continue;
        const u = o + 1;
        s.push(`${u}${" ".repeat(3 - String(u).length)}|  ${r[o]}`);
        const c = r[o].length;
        if (o === a) {
          const d = e - (i - c) + 1, l = Math.max(1, n > i ? c - d : n - e);
          s.push("   |  " + " ".repeat(d) + "^".repeat(l));
        } else if (o > a) {
          if (n > i) {
            const d = Math.max(Math.min(n - i, c), 1);
            s.push("   |  " + "^".repeat(d));
          }
          i += c + 1;
        }
      }
      break;
    }
  return s.join(`
`);
}
function Ro(t, e) {
  typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack));
}
const pE = {};
function Dv(t) {
  pE[t] || (pE[t] = !0, Ro(t));
}
function Mv() {
  const t = /* @__PURE__ */ new Map();
  return {
    events: t,
    on(n, r) {
      const i = t.get(n);
      i && i.push(r) || t.set(n, [r]);
    },
    off(n, r) {
      const i = t.get(n);
      i && i.splice(i.indexOf(r) >>> 0, 1);
    },
    emit(n, r) {
      (t.get(n) || []).slice().map((i) => i(r)), (t.get("*") || []).slice().map((i) => i(n, r));
    }
  };
}
const fp = (t) => !an(t) || Zn(t);
function sm(t, e) {
  if (fp(t) || fp(e))
    throw new Error("Invalid value");
  const n = [{ src: t, des: e }];
  for (; n.length; ) {
    const { src: r, des: i } = n.pop();
    Object.keys(r).forEach((s) => {
      s !== "__proto__" && (an(r[s]) && !an(i[s]) && (i[s] = Array.isArray(r[s]) ? [] : Mn()), fp(i[s]) || fp(r[s]) ? i[s] = r[s] : n.push({ src: r[s], des: i[s] }));
    });
  }
}
/*!
  * message-compiler v11.1.7
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function iz(t, e, n) {
  return { line: t, column: e, offset: n };
}
function fb(t, e, n) {
  return { start: t, end: e };
}
const Pt = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16
}, sz = 17, az = {
  // tokenizer error messages
  [Pt.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [Pt.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [Pt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [Pt.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [Pt.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [Pt.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [Pt.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [Pt.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [Pt.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [Pt.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [Pt.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [Pt.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [Pt.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [Pt.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [Pt.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [Pt.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function Pc(t, e, n = {}) {
  const { domain: r, messages: i, args: s } = n, a = process.env.NODE_ENV !== "production" ? tg((i || az)[t] || "", ...s || []) : t, o = new SyntaxError(String(a));
  return o.code = t, e && (o.location = e), o.domain = r, o;
}
function oz(t) {
  throw t;
}
const uz = /<\/?[\w\s="/.':;#-\/]+>/, lz = (t) => uz.test(t), Ea = " ", cz = "\r", li = `
`, dz = "\u2028", fz = "\u2029";
function hz(t) {
  const e = t;
  let n = 0, r = 1, i = 1, s = 0;
  const a = (M) => e[M] === cz && e[M + 1] === li, o = (M) => e[M] === li, u = (M) => e[M] === fz, c = (M) => e[M] === dz, d = (M) => a(M) || o(M) || u(M) || c(M), l = () => n, f = () => r, p = () => i, m = () => s, g = (M) => a(M) || u(M) || c(M) ? li : e[M], y = () => g(n), b = () => g(n + s);
  function E() {
    return s = 0, d(n) && (r++, i = 0), a(n) && n++, n++, i++, e[n];
  }
  function v() {
    return a(n + s) && s++, s++, e[n + s];
  }
  function _() {
    n = 0, r = 1, i = 1, s = 0;
  }
  function D(M = 0) {
    s = M;
  }
  function S() {
    const M = n + s;
    for (; M !== n; )
      E();
    s = 0;
  }
  return {
    index: l,
    line: f,
    column: p,
    peekOffset: m,
    charAt: g,
    currentChar: y,
    currentPeek: b,
    next: E,
    peek: v,
    reset: _,
    resetPeek: D,
    skipToPeek: S
  };
}
const eo = void 0, pz = ".", mE = "'", mz = "tokenizer";
function gz(t, e = {}) {
  const n = e.location !== !1, r = hz(t), i = () => r.index(), s = () => iz(r.line(), r.column(), r.index()), a = s(), o = i(), u = {
    currentType: 13,
    offset: o,
    startLoc: a,
    endLoc: a,
    lastType: 13,
    lastOffset: o,
    lastStartLoc: a,
    lastEndLoc: a,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, c = () => u, { onError: d } = e;
  function l(ne, ue, ie, ...Te) {
    const je = c();
    if (ue.column += ie, ue.offset += ie, d) {
      const We = n ? fb(je.startLoc, ue) : null, Qe = Pc(ne, We, {
        domain: mz,
        args: Te
      });
      d(Qe);
    }
  }
  function f(ne, ue, ie) {
    ne.endLoc = s(), ne.currentType = ue;
    const Te = { type: ue };
    return n && (Te.loc = fb(ne.startLoc, ne.endLoc)), ie != null && (Te.value = ie), Te;
  }
  const p = (ne) => f(
    ne,
    13
    /* TokenTypes.EOF */
  );
  function m(ne, ue) {
    return ne.currentChar() === ue ? (ne.next(), ue) : (l(Pt.EXPECTED_TOKEN, s(), 0, ue), "");
  }
  function g(ne) {
    let ue = "";
    for (; ne.currentPeek() === Ea || ne.currentPeek() === li; )
      ue += ne.currentPeek(), ne.peek();
    return ue;
  }
  function y(ne) {
    const ue = g(ne);
    return ne.skipToPeek(), ue;
  }
  function b(ne) {
    if (ne === eo)
      return !1;
    const ue = ne.charCodeAt(0);
    return ue >= 97 && ue <= 122 || // a-z
    ue >= 65 && ue <= 90 || // A-Z
    ue === 95;
  }
  function E(ne) {
    if (ne === eo)
      return !1;
    const ue = ne.charCodeAt(0);
    return ue >= 48 && ue <= 57;
  }
  function v(ne, ue) {
    const { currentType: ie } = ue;
    if (ie !== 2)
      return !1;
    g(ne);
    const Te = b(ne.currentPeek());
    return ne.resetPeek(), Te;
  }
  function _(ne, ue) {
    const { currentType: ie } = ue;
    if (ie !== 2)
      return !1;
    g(ne);
    const Te = ne.currentPeek() === "-" ? ne.peek() : ne.currentPeek(), je = E(Te);
    return ne.resetPeek(), je;
  }
  function D(ne, ue) {
    const { currentType: ie } = ue;
    if (ie !== 2)
      return !1;
    g(ne);
    const Te = ne.currentPeek() === mE;
    return ne.resetPeek(), Te;
  }
  function S(ne, ue) {
    const { currentType: ie } = ue;
    if (ie !== 7)
      return !1;
    g(ne);
    const Te = ne.currentPeek() === ".";
    return ne.resetPeek(), Te;
  }
  function M(ne, ue) {
    const { currentType: ie } = ue;
    if (ie !== 8)
      return !1;
    g(ne);
    const Te = b(ne.currentPeek());
    return ne.resetPeek(), Te;
  }
  function O(ne, ue) {
    const { currentType: ie } = ue;
    if (!(ie === 7 || ie === 11))
      return !1;
    g(ne);
    const Te = ne.currentPeek() === ":";
    return ne.resetPeek(), Te;
  }
  function T(ne, ue) {
    const { currentType: ie } = ue;
    if (ie !== 9)
      return !1;
    const Te = () => {
      const We = ne.currentPeek();
      return We === "{" ? b(ne.peek()) : We === "@" || We === "|" || We === ":" || We === "." || We === Ea || !We ? !1 : We === li ? (ne.peek(), Te()) : H(ne, !1);
    }, je = Te();
    return ne.resetPeek(), je;
  }
  function N(ne) {
    g(ne);
    const ue = ne.currentPeek() === "|";
    return ne.resetPeek(), ue;
  }
  function H(ne, ue = !0) {
    const ie = (je = !1, We = "") => {
      const Qe = ne.currentPeek();
      return Qe === "{" || Qe === "@" || !Qe ? je : Qe === "|" ? !(We === Ea || We === li) : Qe === Ea ? (ne.peek(), ie(!0, Ea)) : Qe === li ? (ne.peek(), ie(!0, li)) : !0;
    }, Te = ie();
    return ue && ne.resetPeek(), Te;
  }
  function $(ne, ue) {
    const ie = ne.currentChar();
    return ie === eo ? eo : ue(ie) ? (ne.next(), ie) : null;
  }
  function j(ne) {
    const ue = ne.charCodeAt(0);
    return ue >= 97 && ue <= 122 || // a-z
    ue >= 65 && ue <= 90 || // A-Z
    ue >= 48 && ue <= 57 || // 0-9
    ue === 95 || // _
    ue === 36;
  }
  function U(ne) {
    return $(ne, j);
  }
  function V(ne) {
    const ue = ne.charCodeAt(0);
    return ue >= 97 && ue <= 122 || // a-z
    ue >= 65 && ue <= 90 || // A-Z
    ue >= 48 && ue <= 57 || // 0-9
    ue === 95 || // _
    ue === 36 || // $
    ue === 45;
  }
  function B(ne) {
    return $(ne, V);
  }
  function R(ne) {
    const ue = ne.charCodeAt(0);
    return ue >= 48 && ue <= 57;
  }
  function K(ne) {
    return $(ne, R);
  }
  function Q(ne) {
    const ue = ne.charCodeAt(0);
    return ue >= 48 && ue <= 57 || // 0-9
    ue >= 65 && ue <= 70 || // A-F
    ue >= 97 && ue <= 102;
  }
  function P(ne) {
    return $(ne, Q);
  }
  function I(ne) {
    let ue = "", ie = "";
    for (; ue = K(ne); )
      ie += ue;
    return ie;
  }
  function G(ne) {
    let ue = "";
    for (; ; ) {
      const ie = ne.currentChar();
      if (ie === "{" || ie === "}" || ie === "@" || ie === "|" || !ie)
        break;
      if (ie === Ea || ie === li)
        if (H(ne))
          ue += ie, ne.next();
        else {
          if (N(ne))
            break;
          ue += ie, ne.next();
        }
      else
        ue += ie, ne.next();
    }
    return ue;
  }
  function te(ne) {
    y(ne);
    let ue = "", ie = "";
    for (; ue = B(ne); )
      ie += ue;
    return ne.currentChar() === eo && l(Pt.UNTERMINATED_CLOSING_BRACE, s(), 0), ie;
  }
  function ee(ne) {
    y(ne);
    let ue = "";
    return ne.currentChar() === "-" ? (ne.next(), ue += `-${I(ne)}`) : ue += I(ne), ne.currentChar() === eo && l(Pt.UNTERMINATED_CLOSING_BRACE, s(), 0), ue;
  }
  function Z(ne) {
    return ne !== mE && ne !== li;
  }
  function ye(ne) {
    y(ne), m(ne, "'");
    let ue = "", ie = "";
    for (; ue = $(ne, Z); )
      ue === "\\" ? ie += he(ne) : ie += ue;
    const Te = ne.currentChar();
    return Te === li || Te === eo ? (l(Pt.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0), Te === li && (ne.next(), m(ne, "'")), ie) : (m(ne, "'"), ie);
  }
  function he(ne) {
    const ue = ne.currentChar();
    switch (ue) {
      case "\\":
      case "'":
        return ne.next(), `\\${ue}`;
      case "u":
        return Ee(ne, ue, 4);
      case "U":
        return Ee(ne, ue, 6);
      default:
        return l(Pt.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, ue), "";
    }
  }
  function Ee(ne, ue, ie) {
    m(ne, ue);
    let Te = "";
    for (let je = 0; je < ie; je++) {
      const We = P(ne);
      if (!We) {
        l(Pt.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${ue}${Te}${ne.currentChar()}`);
        break;
      }
      Te += We;
    }
    return `\\${ue}${Te}`;
  }
  function be(ne) {
    return ne !== "{" && ne !== "}" && ne !== Ea && ne !== li;
  }
  function ve(ne) {
    y(ne);
    let ue = "", ie = "";
    for (; ue = $(ne, be); )
      ie += ue;
    return ie;
  }
  function Ce(ne) {
    let ue = "", ie = "";
    for (; ue = U(ne); )
      ie += ue;
    return ie;
  }
  function Ne(ne) {
    const ue = (ie) => {
      const Te = ne.currentChar();
      return Te === "{" || Te === "@" || Te === "|" || Te === "(" || Te === ")" || !Te || Te === Ea ? ie : (ie += Te, ne.next(), ue(ie));
    };
    return ue("");
  }
  function qe(ne) {
    y(ne);
    const ue = m(
      ne,
      "|"
      /* TokenChars.Pipe */
    );
    return y(ne), ue;
  }
  function $e(ne, ue) {
    let ie = null;
    switch (ne.currentChar()) {
      case "{":
        return ue.braceNest >= 1 && l(Pt.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0), ne.next(), ie = f(
          ue,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), y(ne), ue.braceNest++, ie;
      case "}":
        return ue.braceNest > 0 && ue.currentType === 2 && l(Pt.EMPTY_PLACEHOLDER, s(), 0), ne.next(), ie = f(
          ue,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), ue.braceNest--, ue.braceNest > 0 && y(ne), ue.inLinked && ue.braceNest === 0 && (ue.inLinked = !1), ie;
      case "@":
        return ue.braceNest > 0 && l(Pt.UNTERMINATED_CLOSING_BRACE, s(), 0), ie = Xe(ne, ue) || p(ue), ue.braceNest = 0, ie;
      default: {
        let je = !0, We = !0, Qe = !0;
        if (N(ne))
          return ue.braceNest > 0 && l(Pt.UNTERMINATED_CLOSING_BRACE, s(), 0), ie = f(ue, 1, qe(ne)), ue.braceNest = 0, ue.inLinked = !1, ie;
        if (ue.braceNest > 0 && (ue.currentType === 4 || ue.currentType === 5 || ue.currentType === 6))
          return l(Pt.UNTERMINATED_CLOSING_BRACE, s(), 0), ue.braceNest = 0, at(ne, ue);
        if (je = v(ne, ue))
          return ie = f(ue, 4, te(ne)), y(ne), ie;
        if (We = _(ne, ue))
          return ie = f(ue, 5, ee(ne)), y(ne), ie;
        if (Qe = D(ne, ue))
          return ie = f(ue, 6, ye(ne)), y(ne), ie;
        if (!je && !We && !Qe)
          return ie = f(ue, 12, ve(ne)), l(Pt.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, ie.value), y(ne), ie;
        break;
      }
    }
    return ie;
  }
  function Xe(ne, ue) {
    const { currentType: ie } = ue;
    let Te = null;
    const je = ne.currentChar();
    switch ((ie === 7 || ie === 8 || ie === 11 || ie === 9) && (je === li || je === Ea) && l(Pt.INVALID_LINKED_FORMAT, s(), 0), je) {
      case "@":
        return ne.next(), Te = f(
          ue,
          7,
          "@"
          /* TokenChars.LinkedAlias */
        ), ue.inLinked = !0, Te;
      case ".":
        return y(ne), ne.next(), f(
          ue,
          8,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return y(ne), ne.next(), f(
          ue,
          9,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return N(ne) ? (Te = f(ue, 1, qe(ne)), ue.braceNest = 0, ue.inLinked = !1, Te) : S(ne, ue) || O(ne, ue) ? (y(ne), Xe(ne, ue)) : M(ne, ue) ? (y(ne), f(ue, 11, Ce(ne))) : T(ne, ue) ? (y(ne), je === "{" ? $e(ne, ue) || Te : f(ue, 10, Ne(ne))) : (ie === 7 && l(Pt.INVALID_LINKED_FORMAT, s(), 0), ue.braceNest = 0, ue.inLinked = !1, at(ne, ue));
    }
  }
  function at(ne, ue) {
    let ie = {
      type: 13
      /* TokenTypes.EOF */
    };
    if (ue.braceNest > 0)
      return $e(ne, ue) || p(ue);
    if (ue.inLinked)
      return Xe(ne, ue) || p(ue);
    switch (ne.currentChar()) {
      case "{":
        return $e(ne, ue) || p(ue);
      case "}":
        return l(Pt.UNBALANCED_CLOSING_BRACE, s(), 0), ne.next(), f(
          ue,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return Xe(ne, ue) || p(ue);
      default: {
        if (N(ne))
          return ie = f(ue, 1, qe(ne)), ue.braceNest = 0, ue.inLinked = !1, ie;
        if (H(ne))
          return f(ue, 0, G(ne));
        break;
      }
    }
    return ie;
  }
  function Ie() {
    const { currentType: ne, offset: ue, startLoc: ie, endLoc: Te } = u;
    return u.lastType = ne, u.lastOffset = ue, u.lastStartLoc = ie, u.lastEndLoc = Te, u.offset = i(), u.startLoc = s(), r.currentChar() === eo ? f(
      u,
      13
      /* TokenTypes.EOF */
    ) : at(r, u);
  }
  return {
    nextToken: Ie,
    currentOffset: i,
    currentPosition: s,
    context: c
  };
}
const Az = "parser", bz = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function yz(t, e, n) {
  switch (t) {
    case "\\\\":
      return "\\";
    // eslint-disable-next-line no-useless-escape
    case "\\'":
      return "'";
    default: {
      const r = parseInt(e || n, 16);
      return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "�";
    }
  }
}
function vz(t = {}) {
  const e = t.location !== !1, { onError: n } = t;
  function r(b, E, v, _, ...D) {
    const S = b.currentPosition();
    if (S.offset += _, S.column += _, n) {
      const M = e ? fb(v, S) : null, O = Pc(E, M, {
        domain: Az,
        args: D
      });
      n(O);
    }
  }
  function i(b, E, v) {
    const _ = { type: b };
    return e && (_.start = E, _.end = E, _.loc = { start: v, end: v }), _;
  }
  function s(b, E, v, _) {
    e && (b.end = E, b.loc && (b.loc.end = v));
  }
  function a(b, E) {
    const v = b.context(), _ = i(3, v.offset, v.startLoc);
    return _.value = E, s(_, b.currentOffset(), b.currentPosition()), _;
  }
  function o(b, E) {
    const v = b.context(), { lastOffset: _, lastStartLoc: D } = v, S = i(5, _, D);
    return S.index = parseInt(E, 10), b.nextToken(), s(S, b.currentOffset(), b.currentPosition()), S;
  }
  function u(b, E) {
    const v = b.context(), { lastOffset: _, lastStartLoc: D } = v, S = i(4, _, D);
    return S.key = E, b.nextToken(), s(S, b.currentOffset(), b.currentPosition()), S;
  }
  function c(b, E) {
    const v = b.context(), { lastOffset: _, lastStartLoc: D } = v, S = i(9, _, D);
    return S.value = E.replace(bz, yz), b.nextToken(), s(S, b.currentOffset(), b.currentPosition()), S;
  }
  function d(b) {
    const E = b.nextToken(), v = b.context(), { lastOffset: _, lastStartLoc: D } = v, S = i(8, _, D);
    return E.type !== 11 ? (r(b, Pt.UNEXPECTED_EMPTY_LINKED_MODIFIER, v.lastStartLoc, 0), S.value = "", s(S, _, D), {
      nextConsumeToken: E,
      node: S
    }) : (E.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Vs(E)), S.value = E.value || "", s(S, b.currentOffset(), b.currentPosition()), {
      node: S
    });
  }
  function l(b, E) {
    const v = b.context(), _ = i(7, v.offset, v.startLoc);
    return _.value = E, s(_, b.currentOffset(), b.currentPosition()), _;
  }
  function f(b) {
    const E = b.context(), v = i(6, E.offset, E.startLoc);
    let _ = b.nextToken();
    if (_.type === 8) {
      const D = d(b);
      v.modifier = D.node, _ = D.nextConsumeToken || b.nextToken();
    }
    switch (_.type !== 9 && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(_)), _ = b.nextToken(), _.type === 2 && (_ = b.nextToken()), _.type) {
      case 10:
        _.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(_)), v.key = l(b, _.value || "");
        break;
      case 4:
        _.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(_)), v.key = u(b, _.value || "");
        break;
      case 5:
        _.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(_)), v.key = o(b, _.value || "");
        break;
      case 6:
        _.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(_)), v.key = c(b, _.value || "");
        break;
      default: {
        r(b, Pt.UNEXPECTED_EMPTY_LINKED_KEY, E.lastStartLoc, 0);
        const D = b.context(), S = i(7, D.offset, D.startLoc);
        return S.value = "", s(S, D.offset, D.startLoc), v.key = S, s(v, D.offset, D.startLoc), {
          nextConsumeToken: _,
          node: v
        };
      }
    }
    return s(v, b.currentOffset(), b.currentPosition()), {
      node: v
    };
  }
  function p(b) {
    const E = b.context(), v = E.currentType === 1 ? b.currentOffset() : E.offset, _ = E.currentType === 1 ? E.endLoc : E.startLoc, D = i(2, v, _);
    D.items = [];
    let S = null;
    do {
      const T = S || b.nextToken();
      switch (S = null, T.type) {
        case 0:
          T.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(T)), D.items.push(a(b, T.value || ""));
          break;
        case 5:
          T.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(T)), D.items.push(o(b, T.value || ""));
          break;
        case 4:
          T.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(T)), D.items.push(u(b, T.value || ""));
          break;
        case 6:
          T.value == null && r(b, Pt.UNEXPECTED_LEXICAL_ANALYSIS, E.lastStartLoc, 0, Vs(T)), D.items.push(c(b, T.value || ""));
          break;
        case 7: {
          const N = f(b);
          D.items.push(N.node), S = N.nextConsumeToken || null;
          break;
        }
      }
    } while (E.currentType !== 13 && E.currentType !== 1);
    const M = E.currentType === 1 ? E.lastOffset : b.currentOffset(), O = E.currentType === 1 ? E.lastEndLoc : b.currentPosition();
    return s(D, M, O), D;
  }
  function m(b, E, v, _) {
    const D = b.context();
    let S = _.items.length === 0;
    const M = i(1, E, v);
    M.cases = [], M.cases.push(_);
    do {
      const O = p(b);
      S || (S = O.items.length === 0), M.cases.push(O);
    } while (D.currentType !== 13);
    return S && r(b, Pt.MUST_HAVE_MESSAGES_IN_PLURAL, v, 0), s(M, b.currentOffset(), b.currentPosition()), M;
  }
  function g(b) {
    const E = b.context(), { offset: v, startLoc: _ } = E, D = p(b);
    return E.currentType === 13 ? D : m(b, v, _, D);
  }
  function y(b) {
    const E = gz(b, xr({}, t)), v = E.context(), _ = i(0, v.offset, v.startLoc);
    return e && _.loc && (_.loc.source = b), _.body = g(E), t.onCacheKey && (_.cacheKey = t.onCacheKey(b)), v.currentType !== 13 && r(E, Pt.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, b[v.offset] || ""), s(_, E.currentOffset(), E.currentPosition()), _;
  }
  return { parse: y };
}
function Vs(t) {
  if (t.type === 13)
    return "EOF";
  const e = (t.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "…" : e;
}
function Tz(t, e = {}) {
  const n = {
    ast: t,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (s) => (n.helpers.add(s), s) };
}
function gE(t, e) {
  for (let n = 0; n < t.length; n++)
    Ov(t[n], e);
}
function Ov(t, e) {
  switch (t.type) {
    case 1:
      gE(t.cases, e), e.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      gE(t.items, e);
      break;
    case 6: {
      Ov(t.key, e), e.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), e.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function _z(t, e = {}) {
  const n = Tz(t);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), t.body && Ov(t.body, n);
  const r = n.context();
  t.helpers = Array.from(r.helpers);
}
function Ez(t) {
  const e = t.body;
  return e.type === 2 ? AE(e) : e.cases.forEach((n) => AE(n)), t;
}
function AE(t) {
  if (t.items.length === 1) {
    const e = t.items[0];
    (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value);
  } else {
    const e = [];
    for (let n = 0; n < t.items.length; n++) {
      const r = t.items[n];
      if (!(r.type === 3 || r.type === 9) || r.value == null)
        break;
      e.push(r.value);
    }
    if (e.length === t.items.length) {
      t.static = kv(e);
      for (let n = 0; n < t.items.length; n++) {
        const r = t.items[n];
        (r.type === 3 || r.type === 9) && delete r.value;
      }
    }
  }
}
const xz = "minifier";
function Ol(t) {
  switch (t.t = t.type, t.type) {
    case 0: {
      const e = t;
      Ol(e.body), e.b = e.body, delete e.body;
      break;
    }
    case 1: {
      const e = t, n = e.cases;
      for (let r = 0; r < n.length; r++)
        Ol(n[r]);
      e.c = n, delete e.cases;
      break;
    }
    case 2: {
      const e = t, n = e.items;
      for (let r = 0; r < n.length; r++)
        Ol(n[r]);
      e.i = n, delete e.items, e.static && (e.s = e.static, delete e.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = t;
      e.value && (e.v = e.value, delete e.value);
      break;
    }
    case 6: {
      const e = t;
      Ol(e.key), e.k = e.key, delete e.key, e.modifier && (Ol(e.modifier), e.m = e.modifier, delete e.modifier);
      break;
    }
    case 5: {
      const e = t;
      e.i = e.index, delete e.index;
      break;
    }
    case 4: {
      const e = t;
      e.k = e.key, delete e.key;
      break;
    }
    default:
      if (process.env.NODE_ENV !== "production")
        throw Pc(Pt.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: xz,
          args: [t.type]
        });
  }
  delete t.type;
}
const wz = "parser";
function Cz(t, e) {
  const { filename: n, breakLineCode: r, needIndent: i } = e, s = e.location !== !1, a = {
    filename: n,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: r,
    needIndent: i,
    indentLevel: 0
  };
  s && t.loc && (a.source = t.loc.source);
  const o = () => a;
  function u(g, y) {
    a.code += g;
  }
  function c(g, y = !0) {
    const b = y ? r : "";
    u(i ? b + "  ".repeat(g) : b);
  }
  function d(g = !0) {
    const y = ++a.indentLevel;
    g && c(y);
  }
  function l(g = !0) {
    const y = --a.indentLevel;
    g && c(y);
  }
  function f() {
    c(a.indentLevel);
  }
  return {
    context: o,
    push: u,
    indent: d,
    deindent: l,
    newline: f,
    helper: (g) => `_${g}`,
    needIndent: () => a.needIndent
  };
}
function Sz(t, e) {
  const { helper: n } = t;
  t.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), oc(t, e.key), e.modifier ? (t.push(", "), oc(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")");
}
function Iz(t, e) {
  const { helper: n, needIndent: r } = t;
  t.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), t.indent(r());
  const i = e.items.length;
  for (let s = 0; s < i && (oc(t, e.items[s]), s !== i - 1); s++)
    t.push(", ");
  t.deindent(r()), t.push("])");
}
function kz(t, e) {
  const { helper: n, needIndent: r } = t;
  if (e.cases.length > 1) {
    t.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), t.indent(r());
    const i = e.cases.length;
    for (let s = 0; s < i && (oc(t, e.cases[s]), s !== i - 1); s++)
      t.push(", ");
    t.deindent(r()), t.push("])");
  }
}
function Dz(t, e) {
  e.body ? oc(t, e.body) : t.push("null");
}
function oc(t, e) {
  const { helper: n } = t;
  switch (e.type) {
    case 0:
      Dz(t, e);
      break;
    case 1:
      kz(t, e);
      break;
    case 2:
      Iz(t, e);
      break;
    case 6:
      Sz(t, e);
      break;
    case 8:
      t.push(JSON.stringify(e.value), e);
      break;
    case 7:
      t.push(JSON.stringify(e.value), e);
      break;
    case 5:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${e.index}))`, e);
      break;
    case 4:
      t.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(e.key)}))`, e);
      break;
    case 9:
      t.push(JSON.stringify(e.value), e);
      break;
    case 3:
      t.push(JSON.stringify(e.value), e);
      break;
    default:
      if (process.env.NODE_ENV !== "production")
        throw Pc(Pt.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: wz,
          args: [e.type]
        });
  }
}
const Mz = (t, e = {}) => {
  const n = mt(e.mode) ? e.mode : "normal", r = mt(e.filename) ? e.filename : "message.intl";
  e.sourceMap;
  const i = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`, s = e.needIndent ? e.needIndent : n !== "arrow", a = t.helpers || [], o = Cz(t, {
    filename: r,
    breakLineCode: i,
    needIndent: s
  });
  o.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), o.indent(s), a.length > 0 && (o.push(`const { ${kv(a.map((d) => `${d}: _${d}`), ", ")} } = ctx`), o.newline()), o.push("return "), oc(o, t), o.deindent(s), o.push("}"), delete t.helpers;
  const { code: u, map: c } = o.context();
  return {
    ast: t,
    code: u,
    map: c ? c.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function Oz(t, e = {}) {
  const n = xr({}, e), r = !!n.jit, i = !!n.minify, s = n.optimize == null ? !0 : n.optimize, o = vz(n).parse(t);
  return r ? (s && Ez(o), i && Ol(o), { ast: o, code: "" }) : (_z(o, n), Mz(o, n));
}
/*!
  * core-base v11.1.7
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function Nz() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (fu().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (fu().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
}
function ss(t) {
  return an(t) && Nv(t) === 0 && (Is(t, "b") || Is(t, "body"));
}
const QI = ["b", "body"];
function Lz(t) {
  return Bo(t, QI);
}
const GI = ["c", "cases"];
function Pz(t) {
  return Bo(t, GI, []);
}
const YI = ["s", "static"];
function Rz(t) {
  return Bo(t, YI);
}
const XI = ["i", "items"];
function Bz(t) {
  return Bo(t, XI, []);
}
const KI = ["t", "type"];
function Nv(t) {
  return Bo(t, KI);
}
const ZI = ["v", "value"];
function hp(t, e) {
  const n = Bo(t, ZI);
  if (n != null)
    return n;
  throw Rf(e);
}
const JI = ["m", "modifier"];
function Fz(t) {
  return Bo(t, JI);
}
const ek = ["k", "key"];
function Uz(t) {
  const e = Bo(t, ek);
  if (e)
    return e;
  throw Rf(
    6
    /* NodeTypes.Linked */
  );
}
function Bo(t, e, n) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (Is(t, i) && t[i] != null)
      return t[i];
  }
  return n;
}
const tk = [
  ...QI,
  ...GI,
  ...YI,
  ...XI,
  ...ek,
  ...JI,
  ...ZI,
  ...KI
];
function Rf(t) {
  return new Error(`unhandled node type: ${t}`);
}
function sA(t) {
  return (n) => $z(n, t);
}
function $z(t, e) {
  const n = Lz(e);
  if (n == null)
    throw Rf(
      0
      /* NodeTypes.Resource */
    );
  if (Nv(n) === 1) {
    const s = Pz(n);
    return t.plural(s.reduce((a, o) => [
      ...a,
      bE(t, o)
    ], []));
  } else
    return bE(t, n);
}
function bE(t, e) {
  const n = Rz(e);
  if (n != null)
    return t.type === "text" ? n : t.normalize([n]);
  {
    const r = Bz(e).reduce((i, s) => [...i, hb(t, s)], []);
    return t.normalize(r);
  }
}
function hb(t, e) {
  const n = Nv(e);
  switch (n) {
    case 3:
      return hp(e, n);
    case 9:
      return hp(e, n);
    case 4: {
      const r = e;
      if (Is(r, "k") && r.k)
        return t.interpolate(t.named(r.k));
      if (Is(r, "key") && r.key)
        return t.interpolate(t.named(r.key));
      throw Rf(n);
    }
    case 5: {
      const r = e;
      if (Is(r, "i") && yr(r.i))
        return t.interpolate(t.list(r.i));
      if (Is(r, "index") && yr(r.index))
        return t.interpolate(t.list(r.index));
      throw Rf(n);
    }
    case 6: {
      const r = e, i = Fz(r), s = Uz(r);
      return t.linked(hb(t, s), i ? hb(t, i) : void 0, t.type);
    }
    case 7:
      return hp(e, n);
    case 8:
      return hp(e, n);
    default:
      throw new Error(`unhandled node on format message part: ${n}`);
  }
}
const Hz = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function jz(t, e) {
  e && lz(t) && Ro(tg(Hz, { source: t }));
}
const zz = (t) => t;
let pp = Mn();
function qz(t, e = {}) {
  let n = !1;
  const r = e.onError || oz;
  return e.onError = (i) => {
    n = !0, r(i);
  }, { ...Oz(t, e), detectError: n };
}
// @__NO_SIDE_EFFECTS__
function Vz(t, e) {
  if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && mt(t)) {
    const n = hn(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && jz(t, n);
    const i = (e.onCacheKey || zz)(t), s = pp[i];
    if (s)
      return s;
    const { ast: a, detectError: o } = qz(t, {
      ...e,
      location: process.env.NODE_ENV !== "production",
      jit: !0
    }), u = sA(a);
    return o ? u : pp[i] = u;
  } else {
    if (process.env.NODE_ENV !== "production" && !ss(t))
      return Ro(`the message that is resolve with key '${e.key}' is not supported for jit compilation`), () => t;
    const n = t.cacheKey;
    if (n) {
      const r = pp[n];
      return r || (pp[n] = sA(t));
    } else
      return sA(t);
  }
}
let Bf = null;
function Wz(t) {
  Bf = t;
}
function Qz(t, e, n) {
  Bf && Bf.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: t,
    version: e,
    meta: n
  });
}
const Gz = /* @__PURE__ */ Yz("function:translate");
function Yz(t) {
  return (e) => Bf && Bf.emit(t, e);
}
const Vr = {
  INVALID_ARGUMENT: sz,
  // 17
  INVALID_DATE_ARGUMENT: 18,
  INVALID_ISO_DATE_ARGUMENT: 19,
  NOT_SUPPORT_NON_STRING_MESSAGE: 20,
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
  NOT_SUPPORT_LOCALE_TYPE: 23
}, Xz = 24;
function La(t) {
  return Pc(t, null, process.env.NODE_ENV !== "production" ? { messages: Kz } : void 0);
}
const Kz = {
  [Vr.INVALID_ARGUMENT]: "Invalid arguments",
  [Vr.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [Vr.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [Vr.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [Vr.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [Vr.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [Vr.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function Lv(t, e) {
  return e.locale != null ? yE(e.locale) : yE(t.locale);
}
let aA;
function yE(t) {
  if (mt(t))
    return t;
  if (Pn(t)) {
    if (t.resolvedOnce && aA != null)
      return aA;
    if (t.constructor.name === "Function") {
      const e = t();
      if (tz(e))
        throw La(Vr.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return aA = e;
    } else
      throw La(Vr.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw La(Vr.NOT_SUPPORT_LOCALE_TYPE);
}
function Zz(t, e, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...Zn(e) ? e : an(e) ? Object.keys(e) : mt(e) ? [e] : [n]
  ])];
}
function nk(t, e, n) {
  const r = mt(n) ? n : Ff, i = t;
  i.__localeChainCache || (i.__localeChainCache = /* @__PURE__ */ new Map());
  let s = i.__localeChainCache.get(r);
  if (!s) {
    s = [];
    let a = [n];
    for (; Zn(a); )
      a = vE(s, a, e);
    const o = Zn(e) || !en(e) ? e : e.default ? e.default : null;
    a = mt(o) ? [o] : o, Zn(a) && vE(s, a, !1), i.__localeChainCache.set(r, s);
  }
  return s;
}
function vE(t, e, n) {
  let r = !0;
  for (let i = 0; i < e.length && hn(r); i++) {
    const s = e[i];
    mt(s) && (r = Jz(t, e[i], n));
  }
  return r;
}
function Jz(t, e, n) {
  let r;
  const i = e.split("-");
  do {
    const s = i.join("-");
    r = eq(t, s, n), i.splice(-1, 1);
  } while (i.length && r === !0);
  return r;
}
function eq(t, e, n) {
  let r = !1;
  if (!t.includes(e) && (r = !0, e)) {
    r = e[e.length - 1] !== "!";
    const i = e.replace(/!/g, "");
    t.push(i), (Zn(n) || en(n)) && n[i] && (r = n[i]);
  }
  return r;
}
const Fo = [];
Fo[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Fo[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Fo[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
Fo[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
Fo[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
Fo[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
Fo[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const tq = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function nq(t) {
  return tq.test(t);
}
function rq(t) {
  const e = t.charCodeAt(0), n = t.charCodeAt(t.length - 1);
  return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t;
}
function iq(t) {
  if (t == null)
    return "o";
  switch (t.charCodeAt(0)) {
    case 91:
    // [
    case 93:
    // ]
    case 46:
    // .
    case 34:
    // "
    case 39:
      return t;
    case 95:
    // _
    case 36:
    // $
    case 45:
      return "i";
    case 9:
    // Tab (HT)
    case 10:
    // Newline (LF)
    case 13:
    // Return (CR)
    case 160:
    // No-break space (NBSP)
    case 65279:
    // Byte Order Mark (BOM)
    case 8232:
    // Line Separator (LS)
    case 8233:
      return "w";
  }
  return "i";
}
function sq(t) {
  const e = t.trim();
  return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : nq(e) ? rq(e) : "*" + e;
}
function aq(t) {
  const e = [];
  let n = -1, r = 0, i = 0, s, a, o, u, c, d, l;
  const f = [];
  f[
    0
    /* Actions.APPEND */
  ] = () => {
    a === void 0 ? a = o : a += o;
  }, f[
    1
    /* Actions.PUSH */
  ] = () => {
    a !== void 0 && (e.push(a), a = void 0);
  }, f[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    f[
      0
      /* Actions.APPEND */
    ](), i++;
  }, f[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (i > 0)
      i--, r = 4, f[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (i = 0, a === void 0 || (a = sq(a), a === !1))
        return !1;
      f[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function p() {
    const m = t[n + 1];
    if (r === 5 && m === "'" || r === 6 && m === '"')
      return n++, o = "\\" + m, f[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; r !== null; )
    if (n++, s = t[n], !(s === "\\" && p())) {
      if (u = iq(s), l = Fo[r], c = l[u] || l.l || 8, c === 8 || (r = c[0], c[1] !== void 0 && (d = f[c[1]], d && (o = s, d() === !1))))
        return;
      if (r === 7)
        return e;
    }
}
const TE = /* @__PURE__ */ new Map();
function oq(t, e) {
  return an(t) ? t[e] : null;
}
function uq(t, e) {
  if (!an(t))
    return null;
  let n = TE.get(e);
  if (n || (n = aq(e), n && TE.set(e, n)), !n)
    return null;
  const r = n.length;
  let i = t, s = 0;
  for (; s < r; ) {
    const a = n[s];
    if (tk.includes(a) && ss(i))
      return null;
    const o = i[a];
    if (o === void 0 || Pn(i))
      return null;
    i = o, s++;
  }
  return i;
}
const Ei = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7
}, lq = 8, cq = {
  [Ei.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [Ei.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [Ei.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [Ei.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [Ei.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [Ei.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [Ei.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function Uu(t, ...e) {
  return tg(cq[t], ...e);
}
const dq = "11.1.7", rg = -1, Ff = "en-US", Qm = "", _E = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
function fq() {
  return {
    upper: (t, e) => e === "text" && mt(t) ? t.toUpperCase() : e === "vnode" && an(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
    lower: (t, e) => e === "text" && mt(t) ? t.toLowerCase() : e === "vnode" && an(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
    capitalize: (t, e) => e === "text" && mt(t) ? _E(t) : e === "vnode" && an(t) && "__v_isVNode" in t ? _E(t.children) : t
  };
}
let rk;
function hq(t) {
  rk = t;
}
let ik;
function pq(t) {
  ik = t;
}
let sk;
function mq(t) {
  sk = t;
}
let ak = null;
const gq = /* @__NO_SIDE_EFFECTS__ */ (t) => {
  ak = t;
}, Aq = /* @__NO_SIDE_EFFECTS__ */ () => ak;
let ok = null;
const EE = (t) => {
  ok = t;
}, bq = () => ok;
let xE = 0;
function yq(t = {}) {
  const e = Pn(t.onWarn) ? t.onWarn : Ro, n = mt(t.version) ? t.version : dq, r = mt(t.locale) || Pn(t.locale) ? t.locale : Ff, i = Pn(r) ? Ff : r, s = Zn(t.fallbackLocale) || en(t.fallbackLocale) || mt(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : i, a = en(t.messages) ? t.messages : oA(i), o = en(t.datetimeFormats) ? t.datetimeFormats : oA(i), u = en(t.numberFormats) ? t.numberFormats : oA(i), c = xr(Mn(), t.modifiers, fq()), d = t.pluralRules || Mn(), l = Pn(t.missing) ? t.missing : null, f = hn(t.missingWarn) || ac(t.missingWarn) ? t.missingWarn : !0, p = hn(t.fallbackWarn) || ac(t.fallbackWarn) ? t.fallbackWarn : !0, m = !!t.fallbackFormat, g = !!t.unresolving, y = Pn(t.postTranslation) ? t.postTranslation : null, b = en(t.processor) ? t.processor : null, E = hn(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, v = !!t.escapeParameter, _ = Pn(t.messageCompiler) ? t.messageCompiler : rk;
  process.env.NODE_ENV !== "production" && Pn(t.messageCompiler) && Dv(Uu(Ei.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const D = Pn(t.messageResolver) ? t.messageResolver : ik || oq, S = Pn(t.localeFallbacker) ? t.localeFallbacker : sk || Zz, M = an(t.fallbackContext) ? t.fallbackContext : void 0, O = t, T = an(O.__datetimeFormatters) ? O.__datetimeFormatters : /* @__PURE__ */ new Map(), N = an(O.__numberFormatters) ? O.__numberFormatters : /* @__PURE__ */ new Map(), H = an(O.__meta) ? O.__meta : {};
  xE++;
  const $ = {
    version: n,
    cid: xE,
    locale: r,
    fallbackLocale: s,
    messages: a,
    modifiers: c,
    pluralRules: d,
    missing: l,
    missingWarn: f,
    fallbackWarn: p,
    fallbackFormat: m,
    unresolving: g,
    postTranslation: y,
    processor: b,
    warnHtmlMessage: E,
    escapeParameter: v,
    messageCompiler: _,
    messageResolver: D,
    localeFallbacker: S,
    fallbackContext: M,
    onWarn: e,
    __meta: H
  };
  return $.datetimeFormats = o, $.numberFormats = u, $.__datetimeFormatters = T, $.__numberFormatters = N, process.env.NODE_ENV !== "production" && ($.__v_emitter = O.__v_emitter != null ? O.__v_emitter : void 0), (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) && Qz($, n, H), $;
}
const oA = (t) => ({ [t]: Mn() });
function ig(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function uk(t, e) {
  return t instanceof RegExp ? t.test(e) : t;
}
function Pv(t, e, n, r, i) {
  const { missing: s, onWarn: a } = t;
  if (process.env.NODE_ENV !== "production") {
    const o = t.__v_emitter;
    o && o.emit("missing", {
      locale: n,
      key: e,
      type: i,
      groupId: `${i}:${e}`
    });
  }
  if (s !== null) {
    const o = s(t, n, e, i);
    return mt(o) ? o : e;
  } else
    return process.env.NODE_ENV !== "production" && uk(r, e) && a(Uu(Ei.NOT_FOUND_KEY, { key: e, locale: n })), e;
}
function Ed(t, e, n) {
  const r = t;
  r.__localeChainCache = /* @__PURE__ */ new Map(), t.localeFallbacker(t, n, e);
}
function lk(t, e) {
  return t === e ? !1 : t.split("-")[0] === e.split("-")[0];
}
function vq(t, e) {
  const n = e.indexOf(t);
  if (n === -1)
    return !1;
  for (let r = n + 1; r < e.length; r++)
    if (lk(t, e[r]))
      return !0;
  return !1;
}
const wE = typeof Intl < "u", ck = {
  dateTimeFormat: wE && typeof Intl.DateTimeFormat < "u",
  numberFormat: wE && typeof Intl.NumberFormat < "u"
};
function CE(t, ...e) {
  const { datetimeFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: a } = t, { __datetimeFormatters: o } = t;
  if (process.env.NODE_ENV !== "production" && !ck.dateTimeFormat)
    return s(Uu(Ei.CANNOT_FORMAT_DATE)), Qm;
  const [u, c, d, l] = pb(...e), f = hn(d.missingWarn) ? d.missingWarn : t.missingWarn, p = hn(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn, m = !!d.part, g = Lv(t, d), y = a(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    i,
    g
  );
  if (!mt(u) || u === "")
    return new Intl.DateTimeFormat(g, l).format(c);
  let b = {}, E, v = null, _ = g, D = null;
  const S = "datetime format";
  for (let T = 0; T < y.length; T++) {
    if (E = D = y[T], process.env.NODE_ENV !== "production" && g !== E && ig(p, u) && s(Uu(Ei.FALLBACK_TO_DATE_FORMAT, {
      key: u,
      target: E
    })), process.env.NODE_ENV !== "production" && g !== E) {
      const N = t.__v_emitter;
      N && N.emit("fallback", {
        type: S,
        key: u,
        from: _,
        to: D,
        groupId: `${S}:${u}`
      });
    }
    if (b = n[E] || {}, v = b[u], en(v))
      break;
    Pv(t, u, E, f, S), _ = D;
  }
  if (!en(v) || !mt(E))
    return r ? rg : u;
  let M = `${E}__${u}`;
  ng(l) || (M = `${M}__${JSON.stringify(l)}`);
  let O = o.get(M);
  return O || (O = new Intl.DateTimeFormat(E, xr({}, v, l)), o.set(M, O)), m ? O.formatToParts(c) : O.format(c);
}
const dk = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function pb(...t) {
  const [e, n, r, i] = t, s = Mn();
  let a = Mn(), o;
  if (mt(e)) {
    const u = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!u)
      throw La(Vr.INVALID_ISO_DATE_ARGUMENT);
    const c = u[3] ? u[3].trim().startsWith("T") ? `${u[1].trim()}${u[3].trim()}` : `${u[1].trim()}T${u[3].trim()}` : u[1].trim();
    o = new Date(c);
    try {
      o.toISOString();
    } catch {
      throw La(Vr.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (Zj(e)) {
    if (isNaN(e.getTime()))
      throw La(Vr.INVALID_DATE_ARGUMENT);
    o = e;
  } else if (yr(e))
    o = e;
  else
    throw La(Vr.INVALID_ARGUMENT);
  return mt(n) ? s.key = n : en(n) && Object.keys(n).forEach((u) => {
    dk.includes(u) ? a[u] = n[u] : s[u] = n[u];
  }), mt(r) ? s.locale = r : en(r) && (a = r), en(i) && (a = i), [s.key || "", o, s, a];
}
function SE(t, e, n) {
  const r = t;
  for (const i in n) {
    const s = `${e}__${i}`;
    r.__datetimeFormatters.has(s) && r.__datetimeFormatters.delete(s);
  }
}
function IE(t, ...e) {
  const { numberFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: a } = t, { __numberFormatters: o } = t;
  if (process.env.NODE_ENV !== "production" && !ck.numberFormat)
    return s(Uu(Ei.CANNOT_FORMAT_NUMBER)), Qm;
  const [u, c, d, l] = mb(...e), f = hn(d.missingWarn) ? d.missingWarn : t.missingWarn, p = hn(d.fallbackWarn) ? d.fallbackWarn : t.fallbackWarn, m = !!d.part, g = Lv(t, d), y = a(
    t,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    i,
    g
  );
  if (!mt(u) || u === "")
    return new Intl.NumberFormat(g, l).format(c);
  let b = {}, E, v = null, _ = g, D = null;
  const S = "number format";
  for (let T = 0; T < y.length; T++) {
    if (E = D = y[T], process.env.NODE_ENV !== "production" && g !== E && ig(p, u) && s(Uu(Ei.FALLBACK_TO_NUMBER_FORMAT, {
      key: u,
      target: E
    })), process.env.NODE_ENV !== "production" && g !== E) {
      const N = t.__v_emitter;
      N && N.emit("fallback", {
        type: S,
        key: u,
        from: _,
        to: D,
        groupId: `${S}:${u}`
      });
    }
    if (b = n[E] || {}, v = b[u], en(v))
      break;
    Pv(t, u, E, f, S), _ = D;
  }
  if (!en(v) || !mt(E))
    return r ? rg : u;
  let M = `${E}__${u}`;
  ng(l) || (M = `${M}__${JSON.stringify(l)}`);
  let O = o.get(M);
  return O || (O = new Intl.NumberFormat(E, xr({}, v, l)), o.set(M, O)), m ? O.formatToParts(c) : O.format(c);
}
const fk = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function mb(...t) {
  const [e, n, r, i] = t, s = Mn();
  let a = Mn();
  if (!yr(e))
    throw La(Vr.INVALID_ARGUMENT);
  const o = e;
  return mt(n) ? s.key = n : en(n) && Object.keys(n).forEach((u) => {
    fk.includes(u) ? a[u] = n[u] : s[u] = n[u];
  }), mt(r) ? s.locale = r : en(r) && (a = r), en(i) && (a = i), [s.key || "", o, s, a];
}
function kE(t, e, n) {
  const r = t;
  for (const i in n) {
    const s = `${e}__${i}`;
    r.__numberFormatters.has(s) && r.__numberFormatters.delete(s);
  }
}
const Tq = (t) => t, _q = (t) => "", Eq = "text", xq = (t) => t.length === 0 ? "" : kv(t), wq = nz;
function DE(t, e) {
  return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0;
}
function Cq(t) {
  const e = yr(t.pluralIndex) ? t.pluralIndex : -1;
  return t.named && (yr(t.named.count) || yr(t.named.n)) ? yr(t.named.count) ? t.named.count : yr(t.named.n) ? t.named.n : e : e;
}
function Sq(t, e) {
  e.count || (e.count = t), e.n || (e.n = t);
}
function Iq(t = {}) {
  const e = t.locale, n = Cq(t), r = an(t.pluralRules) && mt(e) && Pn(t.pluralRules[e]) ? t.pluralRules[e] : DE, i = an(t.pluralRules) && mt(e) && Pn(t.pluralRules[e]) ? DE : void 0, s = (b) => b[r(n, b.length, i)], a = t.list || [], o = (b) => a[b], u = t.named || Mn();
  yr(t.pluralIndex) && Sq(n, u);
  const c = (b) => u[b];
  function d(b, E) {
    const v = Pn(t.messages) ? t.messages(b, !!E) : an(t.messages) ? t.messages[b] : !1;
    return v || (t.parent ? t.parent.message(b) : _q);
  }
  const l = (b) => t.modifiers ? t.modifiers[b] : Tq, f = en(t.processor) && Pn(t.processor.normalize) ? t.processor.normalize : xq, p = en(t.processor) && Pn(t.processor.interpolate) ? t.processor.interpolate : wq, m = en(t.processor) && mt(t.processor.type) ? t.processor.type : Eq, y = {
    list: o,
    named: c,
    plural: s,
    linked: (b, ...E) => {
      const [v, _] = E;
      let D = "text", S = "";
      E.length === 1 ? an(v) ? (S = v.modifier || S, D = v.type || D) : mt(v) && (S = v || S) : E.length === 2 && (mt(v) && (S = v || S), mt(_) && (D = _ || D));
      const M = d(b, !0)(y), O = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        D === "vnode" && Zn(M) && S ? M[0] : M
      );
      return S ? l(S)(O, D) : O;
    },
    message: d,
    type: m,
    interpolate: p,
    normalize: f,
    values: xr(Mn(), a, u)
  };
  return y;
}
const ME = () => "", es = (t) => Pn(t);
function OE(t, ...e) {
  const { fallbackFormat: n, postTranslation: r, unresolving: i, messageCompiler: s, fallbackLocale: a, messages: o } = t, [u, c] = gb(...e), d = hn(c.missingWarn) ? c.missingWarn : t.missingWarn, l = hn(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, f = hn(c.escapeParameter) ? c.escapeParameter : t.escapeParameter, p = !!c.resolvedMessage, m = mt(c.default) || hn(c.default) ? hn(c.default) ? s ? u : () => u : c.default : n ? s ? u : () => u : null, g = n || m != null && (mt(m) || Pn(m)), y = Lv(t, c);
  f && kq(c);
  let [b, E, v] = p ? [
    u,
    y,
    o[y] || Mn()
  ] : hk(t, u, y, a, l, d), _ = b, D = u;
  if (!p && !(mt(_) || ss(_) || es(_)) && g && (_ = m, D = _), !p && (!(mt(_) || ss(_) || es(_)) || !mt(E)))
    return i ? rg : u;
  if (process.env.NODE_ENV !== "production" && mt(_) && t.messageCompiler == null)
    return Ro(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${u}'.`), u;
  let S = !1;
  const M = () => {
    S = !0;
  }, O = es(_) ? _ : pk(t, u, E, _, D, M);
  if (S)
    return _;
  const T = Nq(t, E, v, c), N = Iq(T), H = Dq(t, O, N), $ = r ? r(H, u) : H;
  if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
    const j = {
      timestamp: Date.now(),
      key: mt(u) ? u : es(_) ? _.key : "",
      locale: E || (es(_) ? _.locale : ""),
      format: mt(_) ? _ : es(_) ? _.source : "",
      message: $
    };
    j.meta = xr({}, t.__meta, /* @__PURE__ */ Aq() || {}), Gz(j);
  }
  return $;
}
function kq(t) {
  Zn(t.list) ? t.list = t.list.map((e) => mt(e) ? fE(e) : e) : an(t.named) && Object.keys(t.named).forEach((e) => {
    mt(t.named[e]) && (t.named[e] = fE(t.named[e]));
  });
}
function hk(t, e, n, r, i, s) {
  const { messages: a, onWarn: o, messageResolver: u, localeFallbacker: c } = t, d = c(t, r, n);
  let l = Mn(), f, p = null, m = n, g = null;
  const y = "translate";
  for (let b = 0; b < d.length; b++) {
    if (f = g = d[b], process.env.NODE_ENV !== "production" && n !== f && !lk(n, f) && ig(i, e) && o(Uu(Ei.FALLBACK_TO_TRANSLATE, {
      key: e,
      target: f
    })), process.env.NODE_ENV !== "production" && n !== f) {
      const D = t.__v_emitter;
      D && D.emit("fallback", {
        type: y,
        key: e,
        from: m,
        to: g,
        groupId: `${y}:${e}`
      });
    }
    l = a[f] || Mn();
    let E = null, v, _;
    if (process.env.NODE_ENV !== "production" && Os && (E = window.performance.now(), v = "intlify-message-resolve-start", _ = "intlify-message-resolve-end", qi && qi(v)), (p = u(l, e)) === null && (p = l[e]), process.env.NODE_ENV !== "production" && Os) {
      const D = window.performance.now(), S = t.__v_emitter;
      S && E && p && S.emit("message-resolve", {
        type: "message-resolve",
        key: e,
        message: p,
        time: D - E,
        groupId: `${y}:${e}`
      }), v && _ && qi && Fu && (qi(_), Fu("intlify message resolve", v, _));
    }
    if (mt(p) || ss(p) || es(p))
      break;
    if (!vq(f, d)) {
      const D = Pv(
        t,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        e,
        f,
        s,
        y
      );
      D !== e && (p = D);
    }
    m = g;
  }
  return [p, f, l];
}
function pk(t, e, n, r, i, s) {
  const { messageCompiler: a, warnHtmlMessage: o } = t;
  if (es(r)) {
    const f = r;
    return f.locale = f.locale || n, f.key = f.key || e, f;
  }
  if (a == null) {
    const f = () => r;
    return f.locale = n, f.key = e, f;
  }
  let u = null, c, d;
  process.env.NODE_ENV !== "production" && Os && (u = window.performance.now(), c = "intlify-message-compilation-start", d = "intlify-message-compilation-end", qi && qi(c));
  const l = a(r, Mq(t, n, i, r, o, s));
  if (process.env.NODE_ENV !== "production" && Os) {
    const f = window.performance.now(), p = t.__v_emitter;
    p && u && p.emit("message-compilation", {
      type: "message-compilation",
      message: r,
      time: f - u,
      groupId: `translate:${e}`
    }), c && d && qi && Fu && (qi(d), Fu("intlify message compilation", c, d));
  }
  return l.locale = n, l.key = e, l.source = r, l;
}
function Dq(t, e, n) {
  let r = null, i, s;
  process.env.NODE_ENV !== "production" && Os && (r = window.performance.now(), i = "intlify-message-evaluation-start", s = "intlify-message-evaluation-end", qi && qi(i));
  const a = e(n);
  if (process.env.NODE_ENV !== "production" && Os) {
    const o = window.performance.now(), u = t.__v_emitter;
    u && r && u.emit("message-evaluation", {
      type: "message-evaluation",
      value: a,
      time: o - r,
      groupId: `translate:${e.key}`
    }), i && s && qi && Fu && (qi(s), Fu("intlify message evaluation", i, s));
  }
  return a;
}
function gb(...t) {
  const [e, n, r] = t, i = Mn();
  if (!mt(e) && !yr(e) && !es(e) && !ss(e))
    throw La(Vr.INVALID_ARGUMENT);
  const s = yr(e) ? String(e) : (es(e), e);
  return yr(n) ? i.plural = n : mt(n) ? i.default = n : en(n) && !ng(n) ? i.named = n : Zn(n) && (i.list = n), yr(r) ? i.plural = r : mt(r) ? i.default = r : en(r) && xr(i, r), [s, i];
}
function Mq(t, e, n, r, i, s) {
  return {
    locale: e,
    key: n,
    warnHtmlMessage: i,
    onError: (a) => {
      if (s && s(a), process.env.NODE_ENV !== "production") {
        const o = Oq(r), u = `Message compilation error: ${a.message}`, c = a.location && o && rz(o, a.location.start.offset, a.location.end.offset), d = t.__v_emitter;
        d && o && d.emit("compile-error", {
          message: o,
          error: a.message,
          start: a.location && a.location.start.offset,
          end: a.location && a.location.end.offset,
          groupId: `translate:${n}`
        }), console.error(c ? `${u}
${c}` : u);
      } else
        throw a;
    },
    onCacheKey: (a) => Xj(e, n, a)
  };
}
function Oq(t) {
  if (mt(t))
    return t;
  if (t.loc && t.loc.source)
    return t.loc.source;
}
function Nq(t, e, n, r) {
  const { modifiers: i, pluralRules: s, messageResolver: a, fallbackLocale: o, fallbackWarn: u, missingWarn: c, fallbackContext: d } = t, f = {
    locale: e,
    modifiers: i,
    pluralRules: s,
    messages: (p, m) => {
      let g = a(n, p);
      if (g == null && (d || m)) {
        const [, , y] = hk(
          d || t,
          // NOTE: if has fallbackContext, fallback to root, else if use linked, fallback to local context
          p,
          e,
          o,
          u,
          c
        );
        g = a(y, p);
      }
      if (mt(g) || ss(g)) {
        let y = !1;
        const E = pk(t, p, e, g, p, () => {
          y = !0;
        });
        return y ? ME : E;
      } else return es(g) ? g : ME;
    }
  };
  return t.processor && (f.processor = t.processor), r.list && (f.list = r.list), r.named && (f.named = r.named), yr(r.plural) && (f.pluralIndex = r.plural), f;
}
Nz();
/*!
  * vue-i18n v11.1.7
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const Lq = "11.1.7";
function Pq() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (fu().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (fu().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (fu().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (fu().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const kn = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: Xz,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: 25,
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  // directive module errors
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  // unexpected error
  UNEXPECTED_ERROR: 32,
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34,
  // duplicate `useI18n` calling
  DUPLICATE_USE_I18N_CALLING: 35
};
function hi(t, ...e) {
  return Pc(t, null, process.env.NODE_ENV !== "production" ? { messages: Rq, args: e } : void 0);
}
const Rq = {
  [kn.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [kn.INVALID_ARGUMENT]: "Invalid argument",
  [kn.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [kn.NOT_INSTALLED]: "Need to install with `app.use` function",
  [kn.UNEXPECTED_ERROR]: "Unexpected error",
  [kn.REQUIRED_VALUE]: "Required in value: {0}",
  [kn.INVALID_VALUE]: "Invalid value",
  [kn.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [kn.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [kn.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [kn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly",
  [kn.DUPLICATE_USE_I18N_CALLING]: "Duplicate `useI18n` calling by local scope. Please don't call it on local scope"
}, Ab = /* @__PURE__ */ ba("__translateVNode"), bb = /* @__PURE__ */ ba("__datetimeParts"), yb = /* @__PURE__ */ ba("__numberParts"), $u = /* @__PURE__ */ ba("__enableEmitter"), Uf = /* @__PURE__ */ ba("__disableEmitter"), mk = ba("__setPluralRules"), gk = /* @__PURE__ */ ba("__injectWithOption"), vb = /* @__PURE__ */ ba("__dispose"), Js = {
  FALLBACK_TO_ROOT: lq,
  // 8
  NOT_FOUND_PARENT_SCOPE: 9,
  IGNORE_OBJ_FLATTEN: 10,
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  DEPRECATE_LEGACY_MODE: 11,
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE: 12
}, Bq = {
  [Js.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [Js.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [Js.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  [Js.DEPRECATE_LEGACY_MODE]: `Legacy API mode has been deprecated in v11. Use Composition API mode instead.
About how to use the Composition API mode, see https://vue-i18n.intlify.dev/guide/advanced/composition.html`,
  /**
   * @deprecated will be removed at vue-i18n v12
   */
  [Js.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE]: "'v-t' has been deprecated in v11. Use translate APIs ('t' or '$t') instead."
};
function gh(t, ...e) {
  return tg(Bq[t], ...e);
}
function $f(t) {
  if (!an(t) || ss(t))
    return t;
  for (const e in t)
    if (Is(t, e))
      if (!e.includes("."))
        an(t[e]) && $f(t[e]);
      else {
        const n = e.split("."), r = n.length - 1;
        let i = t, s = !1;
        for (let a = 0; a < r; a++) {
          if (n[a] === "__proto__")
            throw new Error(`unsafe key: ${n[a]}`);
          if (n[a] in i || (i[n[a]] = Mn()), !an(i[n[a]])) {
            process.env.NODE_ENV !== "production" && Ro(gh(Js.IGNORE_OBJ_FLATTEN, {
              key: n[a]
            })), s = !0;
            break;
          }
          i = i[n[a]];
        }
        if (s || (ss(i) ? tk.includes(n[r]) || delete t[e] : (i[n[r]] = t[e], delete t[e])), !ss(i)) {
          const a = i[n[r]];
          an(a) && $f(a);
        }
      }
  return t;
}
function Rv(t, e) {
  const { messages: n, __i18n: r, messageResolver: i, flatJson: s } = e, a = en(n) ? n : Zn(r) ? Mn() : { [t]: Mn() };
  if (Zn(r) && r.forEach((o) => {
    if ("locale" in o && "resource" in o) {
      const { locale: u, resource: c } = o;
      u ? (a[u] = a[u] || Mn(), sm(c, a[u])) : sm(c, a);
    } else
      mt(o) && sm(JSON.parse(o), a);
  }), i == null && s)
    for (const o in a)
      Is(a, o) && $f(a[o]);
  return a;
}
function Ak(t) {
  return t.type;
}
function bk(t, e, n) {
  let r = an(e.messages) ? e.messages : Mn();
  "__i18nGlobal" in n && (r = Rv(t.locale.value, {
    messages: r,
    __i18n: n.__i18nGlobal
  }));
  const i = Object.keys(r);
  i.length && i.forEach((s) => {
    t.mergeLocaleMessage(s, r[s]);
  });
  {
    if (an(e.datetimeFormats)) {
      const s = Object.keys(e.datetimeFormats);
      s.length && s.forEach((a) => {
        t.mergeDateTimeFormat(a, e.datetimeFormats[a]);
      });
    }
    if (an(e.numberFormats)) {
      const s = Object.keys(e.numberFormats);
      s.length && s.forEach((a) => {
        t.mergeNumberFormat(a, e.numberFormats[a]);
      });
    }
  }
}
function NE(t) {
  return et(f7, null, t, 0);
}
const LE = "__INTLIFY_META__", PE = () => [], Fq = () => !1;
let RE = 0;
function BE(t) {
  return (e, n, r, i) => t(n, r, la() || void 0, i);
}
const Uq = /* @__NO_SIDE_EFFECTS__ */ () => {
  const t = la();
  let e = null;
  return t && (e = Ak(t)[LE]) ? { [LE]: e } : null;
};
function Bv(t = {}) {
  const { __root: e, __injectWithOption: n } = t, r = e === void 0, i = t.flatJson, s = Os ? Se : ch;
  let a = hn(t.inheritLocale) ? t.inheritLocale : !0;
  const o = s(
    // prettier-ignore
    e && a ? e.locale.value : mt(t.locale) ? t.locale : Ff
  ), u = s(
    // prettier-ignore
    e && a ? e.fallbackLocale.value : mt(t.fallbackLocale) || Zn(t.fallbackLocale) || en(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : o.value
  ), c = s(Rv(o.value, t)), d = s(en(t.datetimeFormats) ? t.datetimeFormats : { [o.value]: {} }), l = s(en(t.numberFormats) ? t.numberFormats : { [o.value]: {} });
  let f = e ? e.missingWarn : hn(t.missingWarn) || ac(t.missingWarn) ? t.missingWarn : !0, p = e ? e.fallbackWarn : hn(t.fallbackWarn) || ac(t.fallbackWarn) ? t.fallbackWarn : !0, m = e ? e.fallbackRoot : hn(t.fallbackRoot) ? t.fallbackRoot : !0, g = !!t.fallbackFormat, y = Pn(t.missing) ? t.missing : null, b = Pn(t.missing) ? BE(t.missing) : null, E = Pn(t.postTranslation) ? t.postTranslation : null, v = e ? e.warnHtmlMessage : hn(t.warnHtmlMessage) ? t.warnHtmlMessage : !0, _ = !!t.escapeParameter;
  const D = e ? e.modifiers : en(t.modifiers) ? t.modifiers : {};
  let S = t.pluralRules || e && e.pluralRules, M;
  M = (() => {
    r && EE(null);
    const xe = {
      version: Lq,
      locale: o.value,
      fallbackLocale: u.value,
      messages: c.value,
      modifiers: D,
      pluralRules: S,
      missing: b === null ? void 0 : b,
      missingWarn: f,
      fallbackWarn: p,
      fallbackFormat: g,
      unresolving: !0,
      postTranslation: E === null ? void 0 : E,
      warnHtmlMessage: v,
      escapeParameter: _,
      messageResolver: t.messageResolver,
      messageCompiler: t.messageCompiler,
      __meta: { framework: "vue" }
    };
    xe.datetimeFormats = d.value, xe.numberFormats = l.value, xe.__datetimeFormatters = en(M) ? M.__datetimeFormatters : void 0, xe.__numberFormatters = en(M) ? M.__numberFormatters : void 0, process.env.NODE_ENV !== "production" && (xe.__v_emitter = en(M) ? M.__v_emitter : void 0);
    const Be = yq(xe);
    return r && EE(Be), Be;
  })(), Ed(M, o.value, u.value);
  function T() {
    return [
      o.value,
      u.value,
      c.value,
      d.value,
      l.value
    ];
  }
  const N = de({
    get: () => o.value,
    set: (xe) => {
      M.locale = xe, o.value = xe;
    }
  }), H = de({
    get: () => u.value,
    set: (xe) => {
      M.fallbackLocale = xe, u.value = xe, Ed(M, o.value, xe);
    }
  }), $ = de(() => c.value), j = /* @__PURE__ */ de(() => d.value), U = /* @__PURE__ */ de(() => l.value);
  function V() {
    return Pn(E) ? E : null;
  }
  function B(xe) {
    E = xe, M.postTranslation = xe;
  }
  function R() {
    return y;
  }
  function K(xe) {
    xe !== null && (b = BE(xe)), y = xe, M.missing = b;
  }
  function Q(xe, Be) {
    return xe !== "translate" || !Be.resolvedMessage;
  }
  const P = (xe, Be, At, xt, Rt, Xt) => {
    T();
    let jt;
    try {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, r || (M.fallbackContext = e ? bq() : void 0), jt = xe(M);
    } finally {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, r || (M.fallbackContext = void 0);
    }
    if (At !== "translate exists" && // for not `te` (e.g `t`)
    yr(jt) && jt === rg || At === "translate exists" && !jt) {
      const [Tt, bn] = Be();
      if (process.env.NODE_ENV !== "production" && e && mt(Tt) && Q(At, bn) && (m && (ig(p, Tt) || uk(f, Tt)) && Ro(gh(Js.FALLBACK_TO_ROOT, {
        key: Tt,
        type: At
      })), process.env.NODE_ENV !== "production")) {
        const { __v_emitter: Ve } = M;
        Ve && m && Ve.emit("fallback", {
          type: At,
          key: Tt,
          to: "global",
          groupId: `${At}:${Tt}`
        });
      }
      return e && m ? xt(e) : Rt(Tt);
    } else {
      if (Xt(jt))
        return jt;
      throw hi(kn.UNEXPECTED_RETURN_TYPE);
    }
  };
  function I(...xe) {
    return P((Be) => Reflect.apply(OE, null, [Be, ...xe]), () => gb(...xe), "translate", (Be) => Reflect.apply(Be.t, Be, [...xe]), (Be) => Be, (Be) => mt(Be));
  }
  function G(...xe) {
    const [Be, At, xt] = xe;
    if (xt && !an(xt))
      throw hi(kn.INVALID_ARGUMENT);
    return I(Be, At, xr({ resolvedMessage: !0 }, xt || {}));
  }
  function te(...xe) {
    return P((Be) => Reflect.apply(CE, null, [Be, ...xe]), () => pb(...xe), "datetime format", (Be) => Reflect.apply(Be.d, Be, [...xe]), () => Qm, (Be) => mt(Be) || Zn(Be));
  }
  function ee(...xe) {
    return P((Be) => Reflect.apply(IE, null, [Be, ...xe]), () => mb(...xe), "number format", (Be) => Reflect.apply(Be.n, Be, [...xe]), () => Qm, (Be) => mt(Be) || Zn(Be));
  }
  function Z(xe) {
    return xe.map((Be) => mt(Be) || yr(Be) || hn(Be) ? NE(String(Be)) : Be);
  }
  const he = {
    normalize: Z,
    interpolate: (xe) => xe,
    type: "vnode"
  };
  function Ee(...xe) {
    return P((Be) => {
      let At;
      const xt = Be;
      try {
        xt.processor = he, At = Reflect.apply(OE, null, [xt, ...xe]);
      } finally {
        xt.processor = null;
      }
      return At;
    }, () => gb(...xe), "translate", (Be) => Be[Ab](...xe), (Be) => [NE(Be)], (Be) => Zn(Be));
  }
  function be(...xe) {
    return P((Be) => Reflect.apply(IE, null, [Be, ...xe]), () => mb(...xe), "number format", (Be) => Be[yb](...xe), PE, (Be) => mt(Be) || Zn(Be));
  }
  function ve(...xe) {
    return P((Be) => Reflect.apply(CE, null, [Be, ...xe]), () => pb(...xe), "datetime format", (Be) => Be[bb](...xe), PE, (Be) => mt(Be) || Zn(Be));
  }
  function Ce(xe) {
    S = xe, M.pluralRules = S;
  }
  function Ne(xe, Be) {
    return P(() => {
      if (!xe)
        return !1;
      const At = mt(Be) ? Be : o.value, xt = Xe(At), Rt = M.messageResolver(xt, xe);
      return ss(Rt) || es(Rt) || mt(Rt);
    }, () => [xe], "translate exists", (At) => Reflect.apply(At.te, At, [xe, Be]), Fq, (At) => hn(At));
  }
  function qe(xe) {
    let Be = null;
    const At = nk(M, u.value, o.value);
    for (let xt = 0; xt < At.length; xt++) {
      const Rt = c.value[At[xt]] || {}, Xt = M.messageResolver(Rt, xe);
      if (Xt != null) {
        Be = Xt;
        break;
      }
    }
    return Be;
  }
  function $e(xe) {
    const Be = qe(xe);
    return Be ?? (e ? e.tm(xe) || {} : {});
  }
  function Xe(xe) {
    return c.value[xe] || {};
  }
  function at(xe, Be) {
    if (i) {
      const At = { [xe]: Be };
      for (const xt in At)
        Is(At, xt) && $f(At[xt]);
      Be = At[xe];
    }
    c.value[xe] = Be, M.messages = c.value;
  }
  function Ie(xe, Be) {
    c.value[xe] = c.value[xe] || {};
    const At = { [xe]: Be };
    if (i)
      for (const xt in At)
        Is(At, xt) && $f(At[xt]);
    Be = At[xe], sm(Be, c.value[xe]), M.messages = c.value;
  }
  function ne(xe) {
    return d.value[xe] || {};
  }
  function ue(xe, Be) {
    d.value[xe] = Be, M.datetimeFormats = d.value, SE(M, xe, Be);
  }
  function ie(xe, Be) {
    d.value[xe] = xr(d.value[xe] || {}, Be), M.datetimeFormats = d.value, SE(M, xe, Be);
  }
  function Te(xe) {
    return l.value[xe] || {};
  }
  function je(xe, Be) {
    l.value[xe] = Be, M.numberFormats = l.value, kE(M, xe, Be);
  }
  function We(xe, Be) {
    l.value[xe] = xr(l.value[xe] || {}, Be), M.numberFormats = l.value, kE(M, xe, Be);
  }
  RE++, e && Os && (Ct(e.locale, (xe) => {
    a && (o.value = xe, M.locale = xe, Ed(M, o.value, u.value));
  }), Ct(e.fallbackLocale, (xe) => {
    a && (u.value = xe, M.fallbackLocale = xe, Ed(M, o.value, u.value));
  }));
  const Qe = {
    id: RE,
    locale: N,
    fallbackLocale: H,
    get inheritLocale() {
      return a;
    },
    set inheritLocale(xe) {
      a = xe, xe && e && (o.value = e.locale.value, u.value = e.fallbackLocale.value, Ed(M, o.value, u.value));
    },
    get availableLocales() {
      return Object.keys(c.value).sort();
    },
    messages: $,
    get modifiers() {
      return D;
    },
    get pluralRules() {
      return S || {};
    },
    get isGlobal() {
      return r;
    },
    get missingWarn() {
      return f;
    },
    set missingWarn(xe) {
      f = xe, M.missingWarn = f;
    },
    get fallbackWarn() {
      return p;
    },
    set fallbackWarn(xe) {
      p = xe, M.fallbackWarn = p;
    },
    get fallbackRoot() {
      return m;
    },
    set fallbackRoot(xe) {
      m = xe;
    },
    get fallbackFormat() {
      return g;
    },
    set fallbackFormat(xe) {
      g = xe, M.fallbackFormat = g;
    },
    get warnHtmlMessage() {
      return v;
    },
    set warnHtmlMessage(xe) {
      v = xe, M.warnHtmlMessage = xe;
    },
    get escapeParameter() {
      return _;
    },
    set escapeParameter(xe) {
      _ = xe, M.escapeParameter = xe;
    },
    t: I,
    getLocaleMessage: Xe,
    setLocaleMessage: at,
    mergeLocaleMessage: Ie,
    getPostTranslationHandler: V,
    setPostTranslationHandler: B,
    getMissingHandler: R,
    setMissingHandler: K,
    [mk]: Ce
  };
  return Qe.datetimeFormats = j, Qe.numberFormats = U, Qe.rt = G, Qe.te = Ne, Qe.tm = $e, Qe.d = te, Qe.n = ee, Qe.getDateTimeFormat = ne, Qe.setDateTimeFormat = ue, Qe.mergeDateTimeFormat = ie, Qe.getNumberFormat = Te, Qe.setNumberFormat = je, Qe.mergeNumberFormat = We, Qe[gk] = n, Qe[Ab] = Ee, Qe[bb] = ve, Qe[yb] = be, process.env.NODE_ENV !== "production" && (Qe[$u] = (xe) => {
    M.__v_emitter = xe;
  }, Qe[Uf] = () => {
    M.__v_emitter = void 0;
  }), Qe;
}
const yk = "vue-i18n: composer properties", uA = {
  "vue-devtools-plugin-vue-i18n": "Vue I18n DevTools",
  "vue-i18n-resource-inspector": "Vue I18n DevTools",
  "vue-i18n-timeline": "Vue I18n"
}, $q = {
  "vue-i18n-resource-inspector": "Search for scopes ..."
}, Hq = {
  "vue-i18n-timeline": 16764185
};
let Tb;
async function jq(t, e) {
  return new Promise((n, r) => {
    try {
      m6({
        id: "vue-devtools-plugin-vue-i18n",
        label: uA["vue-devtools-plugin-vue-i18n"],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [yk],
        app: t
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (i) => {
        Tb = i, i.on.visitComponentTree(({ componentInstance: a, treeNode: o }) => {
          zq(a, o, e);
        }), i.on.inspectComponent(({ componentInstance: a, instanceData: o }) => {
          a.vnode.el && a.vnode.el.__VUE_I18N__ && o && (e.mode === "legacy" ? a.vnode.el.__VUE_I18N__ !== e.global.__composer && FE(o, a.vnode.el.__VUE_I18N__) : FE(o, a.vnode.el.__VUE_I18N__));
        }), i.addInspector({
          id: "vue-i18n-resource-inspector",
          label: uA["vue-i18n-resource-inspector"],
          icon: "language",
          treeFilterPlaceholder: $q["vue-i18n-resource-inspector"]
        }), i.on.getInspectorTree((a) => {
          a.app === t && a.inspectorId === "vue-i18n-resource-inspector" && Gq(a, e);
        });
        const s = /* @__PURE__ */ new Map();
        i.on.getInspectorState(async (a) => {
          if (a.app === t && a.inspectorId === "vue-i18n-resource-inspector")
            if (i.unhighlightElement(), Xq(a, e), a.nodeId === "global") {
              if (!s.has(a.app)) {
                const [o] = await i.getComponentInstances(a.app);
                s.set(a.app, o);
              }
              i.highlightElement(s.get(a.app));
            } else {
              const o = Yq(a.nodeId, e);
              o && i.highlightElement(o);
            }
        }), i.on.editInspectorState((a) => {
          a.app === t && a.inspectorId === "vue-i18n-resource-inspector" && Zq(a, e);
        }), i.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: uA["vue-i18n-timeline"],
          color: Hq["vue-i18n-timeline"]
        }), n(!0);
      });
    } catch (i) {
      console.error(i), r(!1);
    }
  });
}
function vk(t) {
  return t.type.name || t.type.displayName || t.type.__file || "Anonymous";
}
function zq(t, e, n) {
  const r = n.mode === "composition" ? n.global : n.global.__composer;
  if (t && t.vnode.el && t.vnode.el.__VUE_I18N__ && t.vnode.el.__VUE_I18N__ !== r) {
    const i = {
      label: `i18n (${vk(t)} Scope)`,
      textColor: 0,
      backgroundColor: 16764185
    };
    e.tags.push(i);
  }
}
function FE(t, e) {
  const n = yk;
  t.state.push({
    type: n,
    key: "locale",
    editable: !0,
    value: e.locale.value
  }), t.state.push({
    type: n,
    key: "availableLocales",
    editable: !1,
    value: e.availableLocales
  }), t.state.push({
    type: n,
    key: "fallbackLocale",
    editable: !0,
    value: e.fallbackLocale.value
  }), t.state.push({
    type: n,
    key: "inheritLocale",
    editable: !0,
    value: e.inheritLocale
  }), t.state.push({
    type: n,
    key: "messages",
    editable: !1,
    value: Fv(e.messages.value)
  }), t.state.push({
    type: n,
    key: "datetimeFormats",
    editable: !1,
    value: e.datetimeFormats.value
  }), t.state.push({
    type: n,
    key: "numberFormats",
    editable: !1,
    value: e.numberFormats.value
  });
}
function Fv(t) {
  const e = {};
  return Object.keys(t).forEach((n) => {
    const r = t[n];
    Pn(r) && "source" in r ? e[n] = Qq(r) : ss(r) && r.loc && r.loc.source ? e[n] = r.loc.source : an(r) ? e[n] = Fv(r) : e[n] = r;
  }), e;
}
const qq = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function Vq(t) {
  return t.replace(/[<>"&]/g, Wq);
}
function Wq(t) {
  return qq[t] || t;
}
function Qq(t) {
  return {
    _custom: {
      type: "function",
      display: `<span>ƒ</span> ${t.source ? `("${Vq(t.source)}")` : "(?)"}`
    }
  };
}
function Gq(t, e) {
  t.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const n = e.mode === "composition" ? e.global : e.global.__composer;
  for (const [r, i] of e.__instances) {
    const s = e.mode === "composition" ? i : i.__composer;
    n !== s && t.rootNodes.push({
      id: s.id.toString(),
      label: `${vk(r)} Scope`
    });
  }
}
function Yq(t, e) {
  let n = null;
  if (t !== "global") {
    for (const [r, i] of e.__instances.entries())
      if (i.id.toString() === t) {
        n = r;
        break;
      }
  }
  return n;
}
function Tk(t, e) {
  if (t === "global")
    return e.mode === "composition" ? e.global : e.global.__composer;
  {
    const n = Array.from(e.__instances.values()).find((r) => r.id.toString() === t);
    return n ? e.mode === "composition" ? n : n.__composer : null;
  }
}
function Xq(t, e) {
  const n = Tk(t.nodeId, e);
  return n && (t.state = Kq(n)), null;
}
function Kq(t) {
  const e = {}, n = "Locale related info", r = [
    {
      type: n,
      key: "locale",
      editable: !0,
      value: t.locale.value
    },
    {
      type: n,
      key: "fallbackLocale",
      editable: !0,
      value: t.fallbackLocale.value
    },
    {
      type: n,
      key: "availableLocales",
      editable: !1,
      value: t.availableLocales
    },
    {
      type: n,
      key: "inheritLocale",
      editable: !0,
      value: t.inheritLocale
    }
  ];
  e[n] = r;
  const i = "Locale messages info", s = [
    {
      type: i,
      key: "messages",
      editable: !1,
      value: Fv(t.messages.value)
    }
  ];
  e[i] = s;
  {
    const a = "Datetime formats info", o = [
      {
        type: a,
        key: "datetimeFormats",
        editable: !1,
        value: t.datetimeFormats.value
      }
    ];
    e[a] = o;
    const u = "Datetime formats info", c = [
      {
        type: u,
        key: "numberFormats",
        editable: !1,
        value: t.numberFormats.value
      }
    ];
    e[u] = c;
  }
  return e;
}
function Hf(t, e) {
  if (Tb) {
    let n;
    e && "groupId" in e && (n = e.groupId, delete e.groupId), Tb.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: t,
        groupId: n,
        time: Date.now(),
        meta: {},
        data: e || {},
        logType: t === "compile-error" ? "error" : t === "fallback" || t === "missing" ? "warning" : "default"
      }
    });
  }
}
function Zq(t, e) {
  const n = Tk(t.nodeId, e);
  if (n) {
    const [r] = t.path;
    r === "locale" && mt(t.state.value) ? n.locale.value = t.state.value : r === "fallbackLocale" && (mt(t.state.value) || Zn(t.state.value) || an(t.state.value)) ? n.fallbackLocale.value = t.state.value : r === "inheritLocale" && hn(t.state.value) && (n.inheritLocale = t.state.value);
  }
}
function Jq(t) {
  const e = mt(t.locale) ? t.locale : Ff, n = mt(t.fallbackLocale) || Zn(t.fallbackLocale) || en(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e, r = Pn(t.missing) ? t.missing : void 0, i = hn(t.silentTranslationWarn) || ac(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0, s = hn(t.silentFallbackWarn) || ac(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0, a = hn(t.fallbackRoot) ? t.fallbackRoot : !0, o = !!t.formatFallbackMessages, u = en(t.modifiers) ? t.modifiers : {}, c = t.pluralizationRules, d = Pn(t.postTranslation) ? t.postTranslation : void 0, l = mt(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0, f = !!t.escapeParameterHtml, p = hn(t.sync) ? t.sync : !0;
  let m = t.messages;
  if (en(t.sharedMessages)) {
    const D = t.sharedMessages;
    m = Object.keys(D).reduce((M, O) => {
      const T = M[O] || (M[O] = {});
      return xr(T, D[O]), M;
    }, m || {});
  }
  const { __i18n: g, __root: y, __injectWithOption: b } = t, E = t.datetimeFormats, v = t.numberFormats, _ = t.flatJson;
  return {
    locale: e,
    fallbackLocale: n,
    messages: m,
    flatJson: _,
    datetimeFormats: E,
    numberFormats: v,
    missing: r,
    missingWarn: i,
    fallbackWarn: s,
    fallbackRoot: a,
    fallbackFormat: o,
    modifiers: u,
    pluralRules: c,
    postTranslation: d,
    warnHtmlMessage: l,
    escapeParameter: f,
    messageResolver: t.messageResolver,
    inheritLocale: p,
    __i18n: g,
    __root: y,
    __injectWithOption: b
  };
}
function _b(t = {}) {
  const e = Bv(Jq(t)), { __extender: n } = t, r = {
    // id
    id: e.id,
    // locale
    get locale() {
      return e.locale.value;
    },
    set locale(i) {
      e.locale.value = i;
    },
    // fallbackLocale
    get fallbackLocale() {
      return e.fallbackLocale.value;
    },
    set fallbackLocale(i) {
      e.fallbackLocale.value = i;
    },
    // messages
    get messages() {
      return e.messages.value;
    },
    // datetimeFormats
    get datetimeFormats() {
      return e.datetimeFormats.value;
    },
    // numberFormats
    get numberFormats() {
      return e.numberFormats.value;
    },
    // availableLocales
    get availableLocales() {
      return e.availableLocales;
    },
    // missing
    get missing() {
      return e.getMissingHandler();
    },
    set missing(i) {
      e.setMissingHandler(i);
    },
    // silentTranslationWarn
    get silentTranslationWarn() {
      return hn(e.missingWarn) ? !e.missingWarn : e.missingWarn;
    },
    set silentTranslationWarn(i) {
      e.missingWarn = hn(i) ? !i : i;
    },
    // silentFallbackWarn
    get silentFallbackWarn() {
      return hn(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn;
    },
    set silentFallbackWarn(i) {
      e.fallbackWarn = hn(i) ? !i : i;
    },
    // modifiers
    get modifiers() {
      return e.modifiers;
    },
    // formatFallbackMessages
    get formatFallbackMessages() {
      return e.fallbackFormat;
    },
    set formatFallbackMessages(i) {
      e.fallbackFormat = i;
    },
    // postTranslation
    get postTranslation() {
      return e.getPostTranslationHandler();
    },
    set postTranslation(i) {
      e.setPostTranslationHandler(i);
    },
    // sync
    get sync() {
      return e.inheritLocale;
    },
    set sync(i) {
      e.inheritLocale = i;
    },
    // warnInHtmlMessage
    get warnHtmlInMessage() {
      return e.warnHtmlMessage ? "warn" : "off";
    },
    set warnHtmlInMessage(i) {
      e.warnHtmlMessage = i !== "off";
    },
    // escapeParameterHtml
    get escapeParameterHtml() {
      return e.escapeParameter;
    },
    set escapeParameterHtml(i) {
      e.escapeParameter = i;
    },
    // pluralizationRules
    get pluralizationRules() {
      return e.pluralRules || {};
    },
    // for internal
    __composer: e,
    // t
    t(...i) {
      return Reflect.apply(e.t, e, [...i]);
    },
    // rt
    rt(...i) {
      return Reflect.apply(e.rt, e, [...i]);
    },
    // te
    te(i, s) {
      return e.te(i, s);
    },
    // tm
    tm(i) {
      return e.tm(i);
    },
    // getLocaleMessage
    getLocaleMessage(i) {
      return e.getLocaleMessage(i);
    },
    // setLocaleMessage
    setLocaleMessage(i, s) {
      e.setLocaleMessage(i, s);
    },
    // mergeLocaleMessage
    mergeLocaleMessage(i, s) {
      e.mergeLocaleMessage(i, s);
    },
    // d
    d(...i) {
      return Reflect.apply(e.d, e, [...i]);
    },
    // getDateTimeFormat
    getDateTimeFormat(i) {
      return e.getDateTimeFormat(i);
    },
    // setDateTimeFormat
    setDateTimeFormat(i, s) {
      e.setDateTimeFormat(i, s);
    },
    // mergeDateTimeFormat
    mergeDateTimeFormat(i, s) {
      e.mergeDateTimeFormat(i, s);
    },
    // n
    n(...i) {
      return Reflect.apply(e.n, e, [...i]);
    },
    // getNumberFormat
    getNumberFormat(i) {
      return e.getNumberFormat(i);
    },
    // setNumberFormat
    setNumberFormat(i, s) {
      e.setNumberFormat(i, s);
    },
    // mergeNumberFormat
    mergeNumberFormat(i, s) {
      e.mergeNumberFormat(i, s);
    }
  };
  return r.__extender = n, process.env.NODE_ENV !== "production" && (r.__enableEmitter = (i) => {
    const s = e;
    s[$u] && s[$u](i);
  }, r.__disableEmitter = () => {
    const i = e;
    i[Uf] && i[Uf]();
  }), r;
}
function eV(t, e, n) {
  return {
    beforeCreate() {
      const r = la();
      if (!r)
        throw hi(kn.UNEXPECTED_ERROR);
      const i = this.$options;
      if (i.i18n) {
        const s = i.i18n;
        if (i.__i18n && (s.__i18n = i.__i18n), s.__root = e, this === this.$root)
          this.$i18n = UE(t, s);
        else {
          s.__injectWithOption = !0, s.__extender = n.__vueI18nExtend, this.$i18n = _b(s);
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
      } else if (i.__i18n)
        if (this === this.$root)
          this.$i18n = UE(t, i);
        else {
          this.$i18n = _b({
            __i18n: i.__i18n,
            __injectWithOption: !0,
            __extender: n.__vueI18nExtend,
            __root: e
          });
          const s = this.$i18n;
          s.__extender && (s.__disposer = s.__extender(this.$i18n));
        }
      else
        this.$i18n = t;
      i.__i18nGlobal && bk(e, i, i), this.$t = (...s) => this.$i18n.t(...s), this.$rt = (...s) => this.$i18n.rt(...s), this.$te = (s, a) => this.$i18n.te(s, a), this.$d = (...s) => this.$i18n.d(...s), this.$n = (...s) => this.$i18n.n(...s), this.$tm = (s) => this.$i18n.tm(s), n.__setInstance(r, this.$i18n);
    },
    mounted() {
      if (process.env.NODE_ENV !== "production" && this.$el && this.$i18n) {
        const r = this.$i18n;
        this.$el.__VUE_I18N__ = r.__composer;
        const i = this.__v_emitter = Mv();
        r.__enableEmitter && r.__enableEmitter(i), i.on("*", Hf);
      }
    },
    unmounted() {
      const r = la();
      if (!r)
        throw hi(kn.UNEXPECTED_ERROR);
      const i = this.$i18n;
      process.env.NODE_ENV !== "production" && this.$el && this.$el.__VUE_I18N__ && (this.__v_emitter && (this.__v_emitter.off("*", Hf), delete this.__v_emitter), this.$i18n && (i.__disableEmitter && i.__disableEmitter(), delete this.$el.__VUE_I18N__)), delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), n.__deleteInstance(r), delete this.$i18n;
    }
  };
}
function UE(t, e) {
  t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[mk](e.pluralizationRules || t.pluralizationRules);
  const n = Rv(t.locale, {
    messages: e.messages,
    __i18n: e.__i18n
  });
  return Object.keys(n).forEach((r) => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach((r) => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach((r) => t.mergeNumberFormat(r, e.numberFormats[r])), t;
}
const Uv = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (t) => t === "parent" || t === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function tV({ slots: t }, e) {
  return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, i) => [
    ...r,
    // prettier-ignore
    ...i.type === wt ? i.children : [i]
  ], []) : e.reduce((n, r) => {
    const i = t[r];
    return i && (n[r] = i()), n;
  }, Mn());
}
function _k() {
  return wt;
}
const nV = /* @__PURE__ */ Ze({
  /* eslint-disable */
  name: "i18n-t",
  props: xr({
    keypath: {
      type: String,
      required: !0
    },
    plural: {
      type: [Number, String],
      validator: (t) => yr(t) || !isNaN(t)
    }
  }, Uv),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const { slots: n, attrs: r } = e, i = t.i18n || Ri({
      useScope: t.scope,
      __useComponent: !0
    });
    return () => {
      const s = Object.keys(n).filter((l) => l[0] !== "_"), a = Mn();
      t.locale && (a.locale = t.locale), t.plural !== void 0 && (a.plural = mt(t.plural) ? +t.plural : t.plural);
      const o = tV(e, s), u = i[Ab](t.keypath, o, a), c = xr(Mn(), r), d = mt(t.tag) || an(t.tag) ? t.tag : _k();
      return sn(d, c, u);
    };
  }
}), $E = nV;
function rV(t) {
  return Zn(t) && !mt(t[0]);
}
function Ek(t, e, n, r) {
  const { slots: i, attrs: s } = e;
  return () => {
    const a = { part: !0 };
    let o = Mn();
    t.locale && (a.locale = t.locale), mt(t.format) ? a.key = t.format : an(t.format) && (mt(t.format.key) && (a.key = t.format.key), o = Object.keys(t.format).reduce((f, p) => n.includes(p) ? xr(Mn(), f, { [p]: t.format[p] }) : f, Mn()));
    const u = r(t.value, a, o);
    let c = [a.key];
    Zn(u) ? c = u.map((f, p) => {
      const m = i[f.type], g = m ? m({ [f.type]: f.value, index: p, parts: u }) : [f.value];
      return rV(g) && (g[0].key = `${f.type}-${p}`), g;
    }) : mt(u) && (c = [u]);
    const d = xr(Mn(), s), l = mt(t.tag) || an(t.tag) ? t.tag : _k();
    return sn(l, d, c);
  };
}
const iV = /* @__PURE__ */ Ze({
  /* eslint-disable */
  name: "i18n-n",
  props: xr({
    value: {
      type: Number,
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, Uv),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const n = t.i18n || Ri({
      useScope: t.scope,
      __useComponent: !0
    });
    return Ek(t, e, fk, (...r) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[yb](...r)
    ));
  }
}), HE = iV;
function sV(t, e) {
  const n = t;
  if (t.mode === "composition")
    return n.__getInstance(e) || t.global;
  {
    const r = n.__getInstance(e);
    return r != null ? r.__composer : t.global.__composer;
  }
}
function aV(t) {
  const e = (a) => {
    process.env.NODE_ENV !== "production" && Dv(gh(Js.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE));
    const { instance: o, value: u } = a;
    if (!o || !o.$)
      throw hi(kn.UNEXPECTED_ERROR);
    const c = sV(t, o.$), d = jE(u);
    return [
      Reflect.apply(c.t, c, [...zE(d)]),
      c
    ];
  };
  return {
    created: (a, o) => {
      const [u, c] = e(o);
      Os && t.global === c && (a.__i18nWatcher = Ct(c.locale, () => {
        o.instance && o.instance.$forceUpdate();
      })), a.__composer = c, a.textContent = u;
    },
    unmounted: (a) => {
      Os && a.__i18nWatcher && (a.__i18nWatcher(), a.__i18nWatcher = void 0, delete a.__i18nWatcher), a.__composer && (a.__composer = void 0, delete a.__composer);
    },
    beforeUpdate: (a, { value: o }) => {
      if (a.__composer) {
        const u = a.__composer, c = jE(o);
        a.textContent = Reflect.apply(u.t, u, [
          ...zE(c)
        ]);
      }
    },
    getSSRProps: (a) => {
      const [o] = e(a);
      return { textContent: o };
    }
  };
}
function jE(t) {
  if (mt(t))
    return { path: t };
  if (en(t)) {
    if (!("path" in t))
      throw hi(kn.REQUIRED_VALUE, "path");
    return t;
  } else
    throw hi(kn.INVALID_VALUE);
}
function zE(t) {
  const { path: e, locale: n, args: r, choice: i, plural: s } = t, a = {}, o = r || {};
  return mt(n) && (a.locale = n), yr(i) && (a.plural = i), yr(s) && (a.plural = s), [e, o, a];
}
function oV(t, e, ...n) {
  const r = en(n[0]) ? n[0] : {};
  (hn(r.globalInstall) ? r.globalInstall : !0) && ([$E.name, "I18nT"].forEach((s) => t.component(s, $E)), [HE.name, "I18nN"].forEach((s) => t.component(s, HE)), [VE.name, "I18nD"].forEach((s) => t.component(s, VE))), t.directive("t", aV(e));
}
const uV = /* @__PURE__ */ ba("global-vue-i18n");
function lV(t = {}) {
  const e = __VUE_I18N_LEGACY_API__ && hn(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__;
  process.env.NODE_ENV !== "production" && e && Dv(gh(Js.DEPRECATE_LEGACY_MODE));
  const n = hn(t.globalInjection) ? t.globalInjection : !0, r = /* @__PURE__ */ new Map(), [i, s] = cV(t, e), a = /* @__PURE__ */ ba(process.env.NODE_ENV !== "production" ? "vue-i18n" : "");
  function o(l) {
    return r.get(l) || null;
  }
  function u(l, f) {
    r.set(l, f);
  }
  function c(l) {
    r.delete(l);
  }
  const d = {
    // mode
    get mode() {
      return __VUE_I18N_LEGACY_API__ && e ? "legacy" : "composition";
    },
    // install plugin
    async install(l, ...f) {
      if (process.env.NODE_ENV !== "production" && (l.__VUE_I18N__ = d), l.__VUE_I18N_SYMBOL__ = a, l.provide(l.__VUE_I18N_SYMBOL__, d), en(f[0])) {
        const g = f[0];
        d.__composerExtend = g.__composerExtend, d.__vueI18nExtend = g.__vueI18nExtend;
      }
      let p = null;
      !e && n && (p = bV(l, d.global)), __VUE_I18N_FULL_INSTALL__ && oV(l, d, ...f), __VUE_I18N_LEGACY_API__ && e && l.mixin(eV(s, s.__composer, d));
      const m = l.unmount;
      if (l.unmount = () => {
        p && p(), d.dispose(), m();
      }, process.env.NODE_ENV !== "production") {
        if (!await jq(l, d))
          throw hi(kn.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
        const y = Mv();
        if (e) {
          const b = s;
          b.__enableEmitter && b.__enableEmitter(y);
        } else {
          const b = s;
          b[$u] && b[$u](y);
        }
        y.on("*", Hf);
      }
    },
    // global accessor
    get global() {
      return s;
    },
    dispose() {
      i.stop();
    },
    // @internal
    __instances: r,
    // @internal
    __getInstance: o,
    // @internal
    __setInstance: u,
    // @internal
    __deleteInstance: c
  };
  return d;
}
function Ri(t = {}) {
  const e = la();
  if (e == null)
    throw hi(kn.MUST_BE_CALL_SETUP_TOP);
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw hi(kn.NOT_INSTALLED);
  const n = dV(e), r = hV(n), i = Ak(e), s = fV(t, i);
  if (s === "global")
    return bk(r, t, i), r;
  if (s === "parent") {
    let u = pV(n, e, t.__useComponent);
    return u == null && (process.env.NODE_ENV !== "production" && Ro(gh(Js.NOT_FOUND_PARENT_SCOPE)), u = r), u;
  }
  const a = n;
  let o = a.__getInstance(e);
  if (o == null) {
    const u = xr({}, t);
    "__i18n" in i && (u.__i18n = i.__i18n), r && (u.__root = r), o = Bv(u), a.__composerExtend && (o[vb] = a.__composerExtend(o)), gV(a, e, o), a.__setInstance(e, o);
  } else if (process.env.NODE_ENV !== "production" && s === "local")
    throw hi(kn.DUPLICATE_USE_I18N_CALLING);
  return o;
}
function cV(t, e) {
  const n = XS(), r = __VUE_I18N_LEGACY_API__ && e ? n.run(() => _b(t)) : n.run(() => Bv(t));
  if (r == null)
    throw hi(kn.UNEXPECTED_ERROR);
  return [n, r];
}
function dV(t) {
  const e = pn(t.isCE ? uV : t.appContext.app.__VUE_I18N_SYMBOL__);
  if (!e)
    throw hi(t.isCE ? kn.NOT_INSTALLED_WITH_PROVIDE : kn.UNEXPECTED_ERROR);
  return e;
}
function fV(t, e) {
  return ng(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local";
}
function hV(t) {
  return t.mode === "composition" ? t.global : t.global.__composer;
}
function pV(t, e, n = !1) {
  let r = null;
  const i = e.root;
  let s = mV(e, n);
  for (; s != null; ) {
    const a = t;
    if (t.mode === "composition")
      r = a.__getInstance(s);
    else if (__VUE_I18N_LEGACY_API__) {
      const o = a.__getInstance(s);
      o != null && (r = o.__composer, n && r && !r[gk] && (r = null));
    }
    if (r != null || i === s)
      break;
    s = s.parent;
  }
  return r;
}
function mV(t, e = !1) {
  return t == null ? null : e && t.vnode.ctx || t.parent;
}
function gV(t, e, n) {
  let r = null;
  Tr(() => {
    if (process.env.NODE_ENV !== "production" && e.vnode.el) {
      e.vnode.el.__VUE_I18N__ = n, r = Mv();
      const i = n;
      i[$u] && i[$u](r), r.on("*", Hf);
    }
  }, e), Dc(() => {
    const i = n;
    process.env.NODE_ENV !== "production" && e.vnode.el && e.vnode.el.__VUE_I18N__ && (r && r.off("*", Hf), i[Uf] && i[Uf](), delete e.vnode.el.__VUE_I18N__), t.__deleteInstance(e);
    const s = i[vb];
    s && (s(), delete i[vb]);
  }, e);
}
const AV = [
  "locale",
  "fallbackLocale",
  "availableLocales"
], qE = ["t", "rt", "d", "n", "tm", "te"];
function bV(t, e) {
  const n = /* @__PURE__ */ Object.create(null);
  return AV.forEach((i) => {
    const s = Object.getOwnPropertyDescriptor(e, i);
    if (!s)
      throw hi(kn.UNEXPECTED_ERROR);
    const a = F0(s.value) ? {
      get() {
        return s.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(o) {
        s.value.value = o;
      }
    } : {
      get() {
        return s.get && s.get();
      }
    };
    Object.defineProperty(n, i, a);
  }), t.config.globalProperties.$i18n = n, qE.forEach((i) => {
    const s = Object.getOwnPropertyDescriptor(e, i);
    if (!s || !s.value)
      throw hi(kn.UNEXPECTED_ERROR);
    Object.defineProperty(t.config.globalProperties, `$${i}`, s);
  }), () => {
    delete t.config.globalProperties.$i18n, qE.forEach((i) => {
      delete t.config.globalProperties[`$${i}`];
    });
  };
}
const yV = /* @__PURE__ */ Ze({
  /* eslint-disable */
  name: "i18n-d",
  props: xr({
    value: {
      type: [Number, Date],
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, Uv),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(t, e) {
    const n = t.i18n || Ri({
      useScope: t.scope,
      __useComponent: !0
    });
    return Ek(t, e, dk, (...r) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[bb](...r)
    ));
  }
}), VE = yV;
Pq();
hq(Vz);
pq(uq);
mq(nk);
if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
  const t = fu();
  t.__INTLIFY__ = !0, Wz(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
process.env.NODE_ENV;
const vV = "Schließen", TV = "Bestätigen", _V = "Ordnername", EV = "Ordner erstellen", xV = "Tag", wV = "Tag-Namen eingeben", CV = "Bitte benutzerdefinierte Farbe eingeben, z. B. #02B13F", SV = "Herunterladen", IV = "{0} hat die Nachricht zurückgezogen", kV = "Gelesen", DV = "Anheften", MV = "Lösen", OV = "Keine Mitglieder", NV = "Mitglieder", LV = "Erstellt am", PV = "Aktualisiert am", RV = "Gruppe verlassen", BV = "Text", FV = "Bild", UV = "Video", $V = "Sticker", HV = "Nachricht", jV = "{0} gesendet", zV = "{0} hat Ihnen {1} gesendet", qV = "Hier tippen, um den Link zu öffnen.", VV = "Nachricht eingeben...", WV = "{0} tippt...", QV = "{0} ist dem Chat beigetreten", GV = "{0} hat den Chat verlassen", YV = "{0} hat {1} eingeladen", XV = "{0} hat {1} entfernt", KV = "Sie haben die Nachricht zurückgezogen", ZV = "Dateigröße", JV = "Datei", eW = "Übersetzung", tW = "Suche", nW = "Standort", rW = "Aktuellen Standort senden", iW = "Kein Zugriff auf Standortberechtigung", sW = "Standortinformationen nicht verfügbar", aW = "Standortanfrage abgelaufen", oW = "Adresse nicht verfügbar", uW = "Sprachnachricht", lW = "Kein Zugriff auf Mikrofonberechtigung", cW = "Aus Ordner entfernen", dW = "Ordner bearbeiten", fW = "Zum Ordner hinzufügen", hW = "{n} Chaträume", pW = "Chatraum-Name", mW = "Mitglieder", gW = "Tags", AW = "Ordner", bW = "Eigenschaften", yW = "Massenversand", vW = "Bitte Nachricht eingeben", TW = "In Unterhaltung suchen", _W = "Gestern", EW = "Heute", xW = "Ordner löschen?", wW = "Ausblenden", CW = "Einblenden", SW = "Abbrechen", IW = "Erstellen", kW = "Speichern", DW = "Tag-Namen eingeben", MW = "Tag wirklich löschen?", OW = "Tag bearbeiten", NW = "Farbe wählen", LW = "Tag existiert bereits. Anderen Namen wählen.", PW = "Blockieren", RW = "Entblocken", BW = "Dieser Benutzer wurde blockiert.", FW = "Benachrichtigungen stummschalten", UW = "Benachrichtigungen aktivieren", $W = "Chatraum wirklich löschen?", HW = "Nach dem Löschen des Chatraums können Sie den vorherigen Chatverlauf nicht mehr einsehen. Der Chatraum aus der Perspektive der anderen Person wird nicht beeinträchtigt und sie können Ihnen weiterhin neue Nachrichten senden.", jW = "Unten sind ungelesene Nachrichten", zW = "Wie möchten Sie diese Nachricht löschen?", qW = "Für alle löschen", VW = "Nur für mich löschen", WW = "Nachricht löschen bestätigen?", QW = "Die von Ihnen ausgewählte Nachricht wird aus allen Chaträumen gelöscht. Diese Aktion kann nicht rückgängig gemacht werden.", GW = "Die von Ihnen ausgewählte Nachricht wird nur aus Ihrem Chatraum gelöscht. Die andere Person kann die Nachricht weiterhin im Chatraum sehen. Diese Aktion kann nicht rückgängig gemacht werden.", YW = "Nachrichten", XW = "Gefundene Nachrichten {0}", KW = "Entfernen", ZW = "Möchten Sie {0} wirklich aus der Gruppe entfernen?", JW = "Nach dem Entfernen kann das Mitglied keine Gruppen­nachrichten mehr sehen.", eQ = "Aus der Gruppe ausgehen", tQ = "Die Mitglieder des Tretens scheiterten", nQ = "Der Kick-out-Betrieb kann derzeit nicht abgeschlossen werden. Bitte bestätigen Sie die Netzwerkverbindung oder versuchen Sie es später erneut.", rQ = "Datei zu groß", iQ = "Die ausgewählte Datei überschreitet die maximale erlaubte Größe von {0}. Bitte wählen Sie eine kleinere Datei.", sQ = { Message: { email: { submit: "E-Mail wurde gesendet", placeholder: "E-Mail eingeben" }, phone: { placeholder: "Telefonnummer eingeben", submit: "Telefonnummer wurde gesendet" }, text: { submit: "Text wurde gesendet", placeholder: "Textinhalt eingeben" } } }, aQ = "Bitte korrektes Format eingeben", oQ = "Chatbot", uQ = "Wenn der Chatbot eingeschaltet ist, antwortet er dem Gesprächspartner gemäß Ihren Einstellungen. Wenn der Chatbot ausgeschaltet ist, können Sie in den Modus für persönliche Antworten wechseln.", lQ = "Offline-Push-Benachrichtigungen zulassen", cQ = "Nach der Aktivierung erhalten Sie bei Eingang einer neuen Nachricht Desktop-Benachrichtigungen, auch wenn der Chat nicht geöffnet ist.", dQ = "Diese Einstellung kann unter [Mein Konto > Benachrichtigungseinstellungen] geändert werden.", fQ = "Später fragen", hQ = "Benachrichtigungen zulassen", pQ = "", mQ = "", gQ = "", AQ = "", bQ = "", yQ = "", vQ = "", TQ = "", _Q = "", EQ = "", xQ = "", wQ = "", CQ = "", SQ = "", IQ = "", kQ = "", DQ = "", MQ = "", OQ = "", NQ = "", LQ = "", PQ = "", RQ = "", BQ = "", FQ = "", UQ = "", $Q = "", HQ = "", jQ = "", zQ = "", qQ = "", VQ = {
  close: vV,
  confirm: TV,
  folderName: _V,
  createFolder: EV,
  tag: xV,
  inputTag: wV,
  inputTagPlaceholder: CV,
  download: SV,
  someoneUnsentMessage: IV,
  read: kV,
  pin: DV,
  unpin: MV,
  emptyChat: OV,
  members: NV,
  createdAt: LV,
  updatedAt: PV,
  leaveGroup: RV,
  text: BV,
  image: FV,
  video: UV,
  sticker: $V,
  message: HV,
  youSent: jV,
  someoneSent: zV,
  tapOpen: qV,
  TypeMessage: VV,
  isTyping: WV,
  someoneJoinedTheChat: QV,
  someoneLeftTheChat: GV,
  someoneInvited: YV,
  someoneKicked: XV,
  youUnsentMessage: KV,
  fileSize: ZV,
  file: JV,
  translation: eW,
  search: tW,
  location: nW,
  sendCurrentLocation: rW,
  noAccessLocationPermission: iW,
  locationInfoUnavailable: sW,
  requestLocationTimeout: aW,
  addressUnavailable: oW,
  audio: uW,
  noAccessMicrophonePermission: lW,
  removeFromFolder: cW,
  editFolder: dW,
  addToFolder: fW,
  numberOfChatroom: hW,
  roomName: pW,
  roomMember: mW,
  roomPrefTags: gW,
  roomPrefFolder: AW,
  roomTags: bW,
  massTexting: yW,
  inputMessage: vW,
  searchInConversation: TW,
  yesterday: _W,
  today: EW,
  confirmToDeleteFolder: xW,
  hide: wW,
  unhide: CW,
  delete: "Löschen",
  cancel: SW,
  create: IW,
  save: kW,
  createTag: DW,
  confirmDeleteTag: MW,
  editTag: OW,
  chooseColor: NW,
  duplicateTagName: LW,
  block: PW,
  unblock: RW,
  textareaBlockedHint: BW,
  mute: FW,
  unmute: UW,
  chatroomDeleteConfirmationTitle: $W,
  chatroomDeleteConfirmationMessage: HW,
  unreadMessages: jW,
  deleteMessageConfirmation: zW,
  deleteForEveryone: qW,
  deleteForMe: VW,
  confirmDeleteMessage: WW,
  deleteForEveryoneWarning: QW,
  deleteForMeWarning: GW,
  messages: YW,
  foundMessages: XW,
  moveOut: KW,
  kickOutConfirmTitle: ZW,
  kickOutConfirmTip: JW,
  kickOutGroup: eQ,
  kickOutErrorTitle: tQ,
  kickOutErrorDesc: nQ,
  fileSizeLimitTitle: rQ,
  fileSizeLimitMessage: iQ,
  "online-status-online": "Aktiv",
  "online-status-offline": "Abwesend",
  Request: sQ,
  emailFromatError: aQ,
  chatbotSwitch: oQ,
  chatbotSwitchDescription: uQ,
  allowOfflineNotifications: lQ,
  notificationPermissionDescription: cQ,
  notificationSettingsPath: dQ,
  askLater: fQ,
  allowNotifications: hQ,
  you: pQ,
  submit: mQ,
  status: gQ,
  currency: AQ,
  paymentCollectionTitle: bQ,
  paymentCollectionNotSet: yQ,
  paymentCollectionNotSetDescription: vQ,
  paymentGoToSetting: TQ,
  paymentSendRequestMessage: _Q,
  paymentMethods: EQ,
  paymentSupportedMethods: xQ,
  paymentRequestMessage: wQ,
  paymentInputMessageOptional: CQ,
  paymentRequestedFrom: SQ,
  paymentViewDetails: IQ,
  paymentRequestDetail: kQ,
  paymentDetail: DQ,
  paymentRequestTime: MQ,
  paymentCompleted: OQ,
  paymentFlowPaid: NQ,
  paymentFlowUnpaid: LQ,
  paymentFlowRefund: PQ,
  paymentFlowAuthorizationError: RQ,
  paymentRequestedFromYou: BQ,
  paymentGoToPay: FQ,
  paymentFailed: UQ,
  paymentFailedDescription: $Q,
  paymentPaidTo: HQ,
  paymentSendPaymentRequestMessageEmpty: jQ,
  paymentSendPaymentRequestMessage: zQ,
  paymentSendPaymentMessage: qQ
}, WQ = "Close", QQ = "Confirm", GQ = "Folder Name", YQ = "Create Folder", XQ = "Tag", KQ = "Input Tag", ZQ = "Input Tag Color #02B13F", JQ = "Download", eG = "{0} unsent a message", tG = "Read", nG = "Pin", rG = "Unpin", iG = "Empty Chat", sG = "Members", aG = "Created At", oG = "Updated At", uG = "Leave Group", lG = "Text", cG = "Image", dG = "Video", fG = "Sticker", hG = "Message", pG = "{0} sent", mG = "{0} sent a {1}", gG = "Tap here to open the link.", AG = "Type a message...", bG = "{0} is typing...", yG = "{0} joined the chat", vG = "{0} left the chat", TG = "{0} invited {1}", _G = "{0} kicked {1}", EG = "You unsent a message", xG = "File size", wG = "File", CG = "Translation", SG = "Search", IG = "Location", kG = "Send Current Location", DG = "No access location permission.", MG = "The request to get location timed out.", OG = "The address is unavailable.", NG = "Audio Message", LG = "No access microphone permission.", PG = "Remove from folder", RG = "Edit Folder", BG = "Add to Folder", FG = "{n} Chatrooms", UG = "Room Name", $G = "Member", HG = "Tag", jG = "Folder", zG = "Attribute", qG = "Mass Texting", VG = "Input Message", WG = "Search in Conversation", QG = "Yesterday", GG = "Today", YG = "Confirm Delete Folder", XG = "Hide", KG = "Unhide", ZG = "Cancel", JG = "Create", eY = "Save", tY = "Enter tag name", nY = "Confirm Delete Tag?", rY = "Edit Tag", iY = "Choose Color", sY = "Tag already exists. Try another name.", aY = "Block", oY = "Unblock", uY = "This user has been blocked", lY = "Mute", cY = "Unmute", dY = "Are you sure you want to delete this chatroom?", fY = "After deleting this chatroom, you will not be able to view the chat history in the chatroom. For the other user in the chatroom, their chat history will not be affected, and they can still send you new messages.", hY = "Below are unread messages", pY = "How do you want to delete this message?", mY = "Delete for everyone", gY = "Delete for me only", AY = "Confirm Delete Message?", bY = "The message you selected will be deleted from all chatrooms. This action cannot be undone.", yY = "The message you selected will be deleted from your chatroom. The other user will still be able to see the message in the chatroom. This action cannot be undone.", vY = "Messages", TY = "Found {0} messages", _Y = "Remove", EY = "Are you sure you want to remove {0} from the group?", xY = "Once removed, the member will no longer be able to view group messages.", wY = "Kick out of the group", CY = "Kicking out members failed", SY = "The kick-out operation cannot be completed at present. Please confirm the network connection or try again later.", IY = "File too large", kY = "The selected file exceeds the maximum allowed size of {0}. Please choose a smaller file.", DY = { Message: { email: { submit: "Email is sent", placeholder: "Enter your email" }, phone: { placeholder: "Enter your phone number", submit: "Phone number is sent" }, text: { submit: "Text is sent", placeholder: "Enter text content" } } }, MY = "Please enter correct format", OY = "Chatbot", NY = "Turn on the chatbot, the chatbot will respond to the other party according to the flow you set. Turn off the chatbot, you can enter the real person reply mode.", LY = "Allow offline push notifications", PY = "After enabling, when a new message arrives, you will receive desktop notifications even if the chat is not open.", RY = "This setting can be modified in [My Account > Notification Settings].", BY = "Ask Later", FY = "Allow Notifications", UY = "You", $Y = "Submit", HY = "Status", jY = "Currency", zY = "Payment Collection", qY = "Payment method not set", VY = "You haven't set up a payment method yet. Please go to [My Account > Chatroom Payment Settings] to complete the setup and start sending payment requests.", WY = "Go to Settings", QY = "Send Payment Request Message", GY = "Payment Methods", YY = "Supported Payment Methods", XY = "Payment Request Message", KY = "Enter message (optional)", ZY = "Requested payment from {0}", JY = "View Details", eX = "Request Details", tX = "Payment Details", nX = "Request Time", rX = "{0} has completed the payment", iX = "Paid", sX = "Unpaid", aX = "Refunded", oX = "Authorization Error", uX = "{0} requested payment from you", lX = "Go to Pay", cX = "Payment Failed", dX = "Please check your account and try again.", fX = "Paid to ${0}", hX = "None", pX = "{0} sent a payment request", mX = "{0} sent a payment", gX = {
  close: WQ,
  confirm: QQ,
  folderName: GQ,
  createFolder: YQ,
  tag: XQ,
  inputTag: KQ,
  inputTagPlaceholder: ZQ,
  download: JQ,
  someoneUnsentMessage: eG,
  read: tG,
  pin: nG,
  unpin: rG,
  emptyChat: iG,
  members: sG,
  createdAt: aG,
  updatedAt: oG,
  leaveGroup: uG,
  text: lG,
  image: cG,
  video: dG,
  sticker: fG,
  message: hG,
  youSent: pG,
  someoneSent: mG,
  tapOpen: gG,
  TypeMessage: AG,
  isTyping: bG,
  someoneJoinedTheChat: yG,
  someoneLeftTheChat: vG,
  someoneInvited: TG,
  someoneKicked: _G,
  youUnsentMessage: EG,
  fileSize: xG,
  file: wG,
  translation: CG,
  search: SG,
  location: IG,
  sendCurrentLocation: kG,
  noAccessLocationPermission: DG,
  "locationInfoUnavailable.": "Location information is unavailable.",
  requestLocationTimeout: MG,
  addressUnavailable: OG,
  audio: NG,
  noAccessMicrophonePermission: LG,
  removeFromFolder: PG,
  editFolder: RG,
  addToFolder: BG,
  numberOfChatroom: FG,
  "no-chatroom": "No chatroom",
  roomName: UG,
  roomMember: $G,
  roomPrefTags: HG,
  roomPrefFolder: jG,
  roomTags: zG,
  massTexting: qG,
  inputMessage: VG,
  searchInConversation: WG,
  yesterday: QG,
  today: GG,
  confirmToDeleteFolder: YG,
  hide: XG,
  unhide: KG,
  delete: "Delete",
  cancel: ZG,
  create: JG,
  save: eY,
  createTag: tY,
  confirmDeleteTag: nY,
  editTag: rY,
  chooseColor: iY,
  duplicateTagName: sY,
  block: aY,
  unblock: oY,
  textareaBlockedHint: uY,
  mute: lY,
  unmute: cY,
  chatroomDeleteConfirmationTitle: dY,
  chatroomDeleteConfirmationMessage: fY,
  unreadMessages: hY,
  deleteMessageConfirmation: pY,
  deleteForEveryone: mY,
  deleteForMe: gY,
  confirmDeleteMessage: AY,
  deleteForEveryoneWarning: bY,
  deleteForMeWarning: yY,
  messages: vY,
  foundMessages: TY,
  moveOut: _Y,
  kickOutConfirmTitle: EY,
  kickOutConfirmTip: xY,
  kickOutGroup: wY,
  kickOutErrorTitle: CY,
  kickOutErrorDesc: SY,
  fileSizeLimitTitle: IY,
  fileSizeLimitMessage: kY,
  "online-status-online": "Active",
  "online-status-offline": "Away",
  Request: DY,
  emailFromatError: MY,
  chatbotSwitch: OY,
  chatbotSwitchDescription: NY,
  allowOfflineNotifications: LY,
  notificationPermissionDescription: PY,
  notificationSettingsPath: RY,
  askLater: BY,
  allowNotifications: FY,
  you: UY,
  submit: $Y,
  status: HY,
  currency: jY,
  paymentCollectionTitle: zY,
  paymentCollectionNotSet: qY,
  paymentCollectionNotSetDescription: VY,
  paymentGoToSetting: WY,
  paymentSendRequestMessage: QY,
  paymentMethods: GY,
  paymentSupportedMethods: YY,
  paymentRequestMessage: XY,
  paymentInputMessageOptional: KY,
  paymentRequestedFrom: ZY,
  paymentViewDetails: JY,
  paymentRequestDetail: eX,
  paymentDetail: tX,
  paymentRequestTime: nX,
  paymentCompleted: rX,
  paymentFlowPaid: iX,
  paymentFlowUnpaid: sX,
  paymentFlowRefund: aX,
  paymentFlowAuthorizationError: oX,
  paymentRequestedFromYou: uX,
  paymentGoToPay: lX,
  paymentFailed: cX,
  paymentFailedDescription: dX,
  paymentPaidTo: fX,
  paymentSendPaymentRequestMessageEmpty: hX,
  paymentSendPaymentRequestMessage: pX,
  paymentSendPaymentMessage: mX
}, AX = "Cerrar", bX = "Confirmar", yX = "Nombre de la carpeta", vX = "Crear carpeta", TX = "Etiqueta", _X = "Ingresar nombre de etiqueta", EX = "Por favor ingrese un color personalizado como #02B13F", xX = "Descargar", wX = "{0} ha retirado un mensaje", CX = "Leído", SX = "Fijar", IX = "Desfijar", kX = "No hay miembros", DX = "Miembros", MX = "Creado el", OX = "Actualizado el", NX = "Salir del grupo", LX = "Texto", PX = "Imagen", RX = "Video", BX = "Sticker", FX = "Mensaje", UX = "{0} enviado", $X = "{0} te ha enviado {1}", HX = "Toca aquí para abrir este enlace.", jX = "Escribe un mensaje...", zX = "{0} está escribiendo...", qX = "{0} se unió al chat", VX = "{0} abandonó el chat", WX = "{0} invitó a {1}", QX = "{0} expulsó a {1}", GX = "Has retirado un mensaje", YX = "Tamaño del archivo", XX = "Archivo", KX = "Traducción", ZX = "Buscar", JX = "Ubicación", eK = "Enviar ubicación actual", tK = "Sin permiso de acceso a la ubicación", nK = "Tiempo de espera para solicitud de ubicación", rK = "Dirección no disponible", iK = "Mensaje de voz", sK = "Sin permiso de acceso al micrófono", aK = "Eliminar de la carpeta", oK = "Editar carpeta", uK = "Añadir a carpeta", lK = "{n} salas de chat", cK = "Nombre de la sala", dK = "Miembro", fK = "Etiquetas", hK = "Carpeta", pK = "Atributos", mK = "Mensaje masivo", gK = "Por favor, ingresa el contenido del mensaje", AK = "Buscar en la conversación", bK = "Ayer", yK = "Hoy", vK = "¿Eliminar carpeta?", TK = "Ocultar", _K = "Mostrar", EK = "Cancelar", xK = "Crear", wK = "Guardar", CK = "Ingresar nombre de etiqueta", SK = "¿Confirmar eliminación de etiqueta?", IK = "Editar etiqueta", kK = "Elegir color", DK = "Etiqueta ya existe. Usa otro nombre.", MK = "Bloquear", OK = "Desbloquear", NK = "Este usuario ha sido bloqueado.", LK = "Silenciar notificaciones", PK = "Activar notificaciones", RK = "¿Confirmar eliminación de la sala de chat?", BK = "Después de eliminar la sala de chat, no podrás ver el historial de chat anterior. La sala de chat desde la perspectiva de la otra persona no se verá afectada y aún podrán enviarte nuevos mensajes.", FK = "Mensajes no leídos a continuación", UK = "¿Cómo deseas eliminar este mensaje?", $K = "Eliminar para todos", HK = "Eliminar solo para mí", jK = "¿Confirmar eliminación del mensaje?", zK = "El mensaje que seleccionaste se eliminará de todas las salas de chat. Esta acción no se puede deshacer.", qK = "El mensaje que seleccionaste solo se eliminará de tu sala de chat. La otra persona aún podrá ver el mensaje en la sala de chat. Esta acción no se puede deshacer.", VK = "Mensajes", WK = "Mensajes encontrados {0}", QK = "Echar", GK = "¿Estás seguro de que deseas expulsar a {0} del grupo?", YK = "Una vez expulsado, el miembro no podrá ver los mensajes del grupo.", XK = "Compilarse del grupo", KK = "Patear a los miembros falló", ZK = "La operación de inicio no se puede completar en la actualidad. Confirme la conexión de red o vuelva a intentarlo más tarde.", JK = "Archivo demasiado grande", eZ = "El archivo seleccionado excede el tamaño máximo permitido de {0}. Por favor, elija un archivo más pequeño.", tZ = { Message: { email: { submit: "Correo electrónico enviado", placeholder: "Introduce tu correo electrónico" }, phone: { placeholder: "Introduce tu número de teléfono", submit: "Número de teléfono enviado" }, text: { submit: "Texto enviado", placeholder: "Introduce el contenido del texto" } } }, nZ = "Por favor, introduce el formato correcto", rZ = "Chatbot", iZ = "Al activar el chatbot, este responderá a la otra parte según el flujo que hayas configurado. Al desactivar el chatbot, podrás entrar en el modo de respuesta de persona real.", sZ = "Permitir notificaciones push sin conexión", aZ = "Después de habilitar, cuando llegue un mensaje nuevo, recibirás notificaciones de escritorio incluso si el chat no está abierto.", oZ = "Esta configuración se puede modificar en [Mi cuenta > Configuración de notificaciones].", uZ = "Preguntar más tarde", lZ = "Permitir notificaciones", cZ = "Tú", dZ = "Enviar", fZ = "Estado", hZ = "Moneda", pZ = "Cobro de pagos", mZ = "Método de pago no configurado", gZ = "Aún no has configurado un método de pago. Ve a [Mi cuenta > Configuración de pagos del chat] para completar la configuración y empezar a enviar solicitudes de pago.", AZ = "Ir a configuración", bZ = "Enviar mensaje de solicitud de pago", yZ = "Métodos de pago", vZ = "Métodos de pago compatibles", TZ = "Mensaje de solicitud de pago", _Z = "Ingrese mensaje (opcional)", EZ = "Solicitó pago de {0}", xZ = "Ver detalles", wZ = "Detalles de la solicitud", CZ = "Detalles del pago", SZ = "Hora de la solicitud", IZ = "{0} ha completado el pago", kZ = "Pagado", DZ = "Sin pagar", MZ = "Reembolsado", OZ = "Error de autorización", NZ = "{0} te solicitó un pago", LZ = "Ir a pagar", PZ = "Pago fallido", RZ = "Por favor, verifica tu cuenta e inténtalo de nuevo.", BZ = "Pagado a {0}", FZ = "Ninguno", UZ = "{0} envió una solicitud de pago", $Z = "{0} envió un pago", HZ = {
  close: AX,
  confirm: bX,
  folderName: yX,
  createFolder: vX,
  tag: TX,
  inputTag: _X,
  inputTagPlaceholder: EX,
  download: xX,
  someoneUnsentMessage: wX,
  read: CX,
  pin: SX,
  unpin: IX,
  emptyChat: kX,
  members: DX,
  createdAt: MX,
  updatedAt: OX,
  leaveGroup: NX,
  text: LX,
  image: PX,
  video: RX,
  sticker: BX,
  message: FX,
  youSent: UX,
  someoneSent: $X,
  tapOpen: HX,
  TypeMessage: jX,
  isTyping: zX,
  someoneJoinedTheChat: qX,
  someoneLeftTheChat: VX,
  someoneInvited: WX,
  someoneKicked: QX,
  youUnsentMessage: GX,
  fileSize: YX,
  file: XX,
  translation: KX,
  search: ZX,
  location: JX,
  sendCurrentLocation: eK,
  noAccessLocationPermission: tK,
  "locationInfoUnavailable.": "Información de ubicación no disponible",
  requestLocationTimeout: nK,
  addressUnavailable: rK,
  audio: iK,
  noAccessMicrophonePermission: sK,
  removeFromFolder: aK,
  editFolder: oK,
  addToFolder: uK,
  numberOfChatroom: lK,
  roomName: cK,
  roomMember: dK,
  roomPrefTags: fK,
  roomPrefFolder: hK,
  roomTags: pK,
  massTexting: mK,
  inputMessage: gK,
  searchInConversation: AK,
  yesterday: bK,
  today: yK,
  confirmToDeleteFolder: vK,
  hide: TK,
  unhide: _K,
  delete: "Eliminar",
  cancel: EK,
  create: xK,
  save: wK,
  createTag: CK,
  confirmDeleteTag: SK,
  editTag: IK,
  chooseColor: kK,
  duplicateTagName: DK,
  block: MK,
  unblock: OK,
  textareaBlockedHint: NK,
  mute: LK,
  unmute: PK,
  chatroomDeleteConfirmationTitle: RK,
  chatroomDeleteConfirmationMessage: BK,
  unreadMessages: FK,
  deleteMessageConfirmation: UK,
  deleteForEveryone: $K,
  deleteForMe: HK,
  confirmDeleteMessage: jK,
  deleteForEveryoneWarning: zK,
  deleteForMeWarning: qK,
  messages: VK,
  foundMessages: WK,
  moveOut: QK,
  kickOutConfirmTitle: GK,
  kickOutConfirmTip: YK,
  kickOutGroup: XK,
  kickOutErrorTitle: KK,
  kickOutErrorDesc: ZK,
  fileSizeLimitTitle: JK,
  fileSizeLimitMessage: eZ,
  "online-status-online": "Activo",
  "online-status-offline": "Ausente",
  Request: tZ,
  emailFromatError: nZ,
  chatbotSwitch: rZ,
  chatbotSwitchDescription: iZ,
  allowOfflineNotifications: sZ,
  notificationPermissionDescription: aZ,
  notificationSettingsPath: oZ,
  askLater: uZ,
  allowNotifications: lZ,
  you: cZ,
  submit: dZ,
  status: fZ,
  currency: hZ,
  paymentCollectionTitle: pZ,
  paymentCollectionNotSet: mZ,
  paymentCollectionNotSetDescription: gZ,
  paymentGoToSetting: AZ,
  paymentSendRequestMessage: bZ,
  paymentMethods: yZ,
  paymentSupportedMethods: vZ,
  paymentRequestMessage: TZ,
  paymentInputMessageOptional: _Z,
  paymentRequestedFrom: EZ,
  paymentViewDetails: xZ,
  paymentRequestDetail: wZ,
  paymentDetail: CZ,
  paymentRequestTime: SZ,
  paymentCompleted: IZ,
  paymentFlowPaid: kZ,
  paymentFlowUnpaid: DZ,
  paymentFlowRefund: MZ,
  paymentFlowAuthorizationError: OZ,
  paymentRequestedFromYou: NZ,
  paymentGoToPay: LZ,
  paymentFailed: PZ,
  paymentFailedDescription: RZ,
  paymentPaidTo: BZ,
  paymentSendPaymentRequestMessageEmpty: FZ,
  paymentSendPaymentRequestMessage: UZ,
  paymentSendPaymentMessage: $Z
}, jZ = "Fermer", zZ = "Confirmer", qZ = "Nom du dossier", VZ = "Créer un dossier", WZ = "Étiquette", QZ = "Saisir le nom de l'étiquette", GZ = "Veuillez saisir une couleur personnalisée comme #02B13F", YZ = "Télécharger", XZ = "{0} a retiré un message", KZ = "Lu", ZZ = "Épingler", JZ = "Désépingler", eJ = "Pas de membres", tJ = "Membres", nJ = "Créé le", rJ = "Mis à jour le", iJ = "Quitter le groupe", sJ = "Texte", aJ = "Image", oJ = "Vidéo", uJ = "Autocollant", lJ = "Message", cJ = "{0} envoyé", dJ = "{0} vous a envoyé {1}", fJ = "Appuyez ici pour ouvrir ce lien.", hJ = "Écrivez un message...", pJ = "{0} est en train d'écrire...", mJ = "{0} a rejoint le chat", gJ = "{0} a quitté le chat", AJ = "{0} a invité {1}", bJ = "{0} a expulsé {1}", yJ = "Vous avez retiré un message", vJ = "Taille du fichier", TJ = "Fichier", _J = "Traduction", EJ = "Rechercher", xJ = "Localisation", wJ = "Envoyer la position actuelle", CJ = "Pas d'autorisation d'accès à la localisation", SJ = "Délai d'attente de la demande de localisation dépassé", IJ = "Adresse non disponible", kJ = "Message vocal", DJ = "Pas d'autorisation d'accès au microphone", MJ = "Retirer du dossier", OJ = "Modifier le dossier", NJ = "Ajouter au dossier", LJ = "{n} salons de discussion", PJ = "Nom du salon", RJ = "Membre", BJ = "Étiquettes", FJ = "Dossier", UJ = "Attributs", $J = "Message de masse", HJ = "Veuillez saisir le contenu du message", jJ = "Rechercher dans la conversation", zJ = "Hier", qJ = "Aujourd'hui", VJ = "Supprimer le dossier ?", WJ = "Masquer", QJ = "Afficher", GJ = "Annuler", YJ = "Créer", XJ = "Enregistrer", KJ = "Saisir le nom de l'étiquette", ZJ = "Confirmer la suppression de l'étiquette ?", JJ = "Modifier l'étiquette", eee = "Choisir une couleur", tee = "Étiquette existante. Choisissez un autre nom.", nee = "Bloquer", ree = "Débloquer", iee = "Cet utilisateur a été bloqué.", see = "Désactiver les notifications", aee = "Activer les notifications", oee = "Confirmer la suppression du salon de discussion ?", uee = "Après avoir supprimé le salon de discussion, vous ne pourrez plus consulter l'historique des conversations précédentes. Le salon de discussion du point de vue de l'autre personne ne sera pas affecté et elle pourra toujours vous envoyer de nouveaux messages.", lee = "Ci-dessous les messages non lus", cee = "Comment souhaitez-vous supprimer ce message ?", dee = "Supprimer pour tout le monde", fee = "Supprimer uniquement pour moi", hee = "Confirmer la suppression du message ?", pee = "Le message que vous avez sélectionné sera supprimé de tous les salons de discussion. Cette action ne peut pas être annulée.", mee = "Le message que vous avez sélectionné sera supprimé uniquement de votre salon de discussion. L'autre personne pourra toujours voir le message dans le salon de discussion. Cette action ne peut pas être annulée.", gee = "Messages", Aee = "Messages trouvés {0}", bee = "Retirer", yee = "Êtes-vous sûr de vouloir retirer {0} du groupe ?", vee = "Une fois retiré, le membre ne pourra plus voir les messages du groupe.", Tee = "Sortir du groupe", _ee = "Les membres ont échoué", Eee = "L'opération de lancement ne peut pas être achevée à l'heure actuelle. Veuillez confirmer la connexion réseau ou réessayer plus tard.", xee = "Fichier trop grand", wee = "Le fichier sélectionné dépasse la taille maximale autorisée de {0}. Veuillez choisir un fichier plus petit.", Cee = { Message: { email: { submit: "E-mail envoyé", placeholder: "Entrez votre e-mail" }, phone: { placeholder: "Entrez votre numéro de téléphone", submit: "Numéro de téléphone envoyé" }, text: { submit: "Texte envoyé", placeholder: "Entrez le contenu du texte" } } }, See = "Veuillez entrer un format correct", Iee = "Chatbot", kee = "Activez le chatbot, il répondra à l'autre partie selon le flux que vous avez défini. Désactivez le chatbot pour passer en mode de réponse humaine.", Dee = "Autoriser les notifications push hors ligne", Mee = "Après activation, lorsqu'un nouveau message arrive, vous recevrez des notifications sur le bureau même si le chat n'est pas ouvert.", Oee = "Ce paramètre peut être modifié dans [Mon compte > Paramètres de notification].", Nee = "Demander plus tard", Lee = "Autoriser les notifications", Pee = "Vous", Ree = "Soumettre", Bee = "Statut", Fee = "Devise", Uee = "Collecte de paiement", $ee = "Mode de paiement non défini", Hee = "Vous n'avez pas encore configuré de mode de paiement. Veuillez aller dans [Mon compte > Paramètres de paiement de chat] pour terminer la configuration et commencer à envoyer des demandes de paiement.", jee = "Aller aux paramètres", zee = "Envoyer un message de demande de paiement", qee = "Modes de paiement", Vee = "Modes de paiement pris en charge", Wee = "Message de demande de paiement", Qee = "Saisir le message (facultatif)", Gee = "Demande de paiement envoyée à {0}", Yee = "Voir les détails", Xee = "Détails de la demande", Kee = "Détails du paiement", Zee = "Heure de la demande", Jee = "{0} a terminé le paiement", ete = "Payé", tte = "Non payé", nte = "Remboursé", rte = "Erreur d'autorisation", ite = "{0} vous a demandé un paiement", ste = "Aller payer", ate = "Paiement échoué", ote = "Veuillez vérifier votre compte et réessayer.", ute = "Payé à {0}", lte = "Aucun", cte = "{0} a envoyé une demande de paiement", dte = "{0} a envoyé un paiement", fte = {
  close: jZ,
  confirm: zZ,
  folderName: qZ,
  createFolder: VZ,
  tag: WZ,
  inputTag: QZ,
  inputTagPlaceholder: GZ,
  download: YZ,
  someoneUnsentMessage: XZ,
  read: KZ,
  pin: ZZ,
  unpin: JZ,
  emptyChat: eJ,
  members: tJ,
  createdAt: nJ,
  updatedAt: rJ,
  leaveGroup: iJ,
  text: sJ,
  image: aJ,
  video: oJ,
  sticker: uJ,
  message: lJ,
  youSent: cJ,
  someoneSent: dJ,
  tapOpen: fJ,
  TypeMessage: hJ,
  isTyping: pJ,
  someoneJoinedTheChat: mJ,
  someoneLeftTheChat: gJ,
  someoneInvited: AJ,
  someoneKicked: bJ,
  youUnsentMessage: yJ,
  fileSize: vJ,
  file: TJ,
  translation: _J,
  search: EJ,
  location: xJ,
  sendCurrentLocation: wJ,
  noAccessLocationPermission: CJ,
  "locationInfoUnavailable.": "Informations de localisation non disponibles",
  requestLocationTimeout: SJ,
  addressUnavailable: IJ,
  audio: kJ,
  noAccessMicrophonePermission: DJ,
  removeFromFolder: MJ,
  editFolder: OJ,
  addToFolder: NJ,
  numberOfChatroom: LJ,
  roomName: PJ,
  roomMember: RJ,
  roomPrefTags: BJ,
  roomPrefFolder: FJ,
  roomTags: UJ,
  massTexting: $J,
  inputMessage: HJ,
  searchInConversation: jJ,
  yesterday: zJ,
  today: qJ,
  confirmToDeleteFolder: VJ,
  hide: WJ,
  unhide: QJ,
  delete: "Supprimer",
  cancel: GJ,
  create: YJ,
  save: XJ,
  createTag: KJ,
  confirmDeleteTag: ZJ,
  editTag: JJ,
  chooseColor: eee,
  duplicateTagName: tee,
  block: nee,
  unblock: ree,
  textareaBlockedHint: iee,
  mute: see,
  unmute: aee,
  chatroomDeleteConfirmationTitle: oee,
  chatroomDeleteConfirmationMessage: uee,
  unreadMessages: lee,
  deleteMessageConfirmation: cee,
  deleteForEveryone: dee,
  deleteForMe: fee,
  confirmDeleteMessage: hee,
  deleteForEveryoneWarning: pee,
  deleteForMeWarning: mee,
  messages: gee,
  foundMessages: Aee,
  moveOut: bee,
  kickOutConfirmTitle: yee,
  kickOutConfirmTip: vee,
  kickOutGroup: Tee,
  kickOutErrorTitle: _ee,
  kickOutErrorDesc: Eee,
  fileSizeLimitTitle: xee,
  fileSizeLimitMessage: wee,
  "online-status-online": "En ligne",
  "online-status-offline": "Hors ligne",
  Request: Cee,
  emailFromatError: See,
  chatbotSwitch: Iee,
  chatbotSwitchDescription: kee,
  allowOfflineNotifications: Dee,
  notificationPermissionDescription: Mee,
  notificationSettingsPath: Oee,
  askLater: Nee,
  allowNotifications: Lee,
  you: Pee,
  submit: Ree,
  status: Bee,
  currency: Fee,
  paymentCollectionTitle: Uee,
  paymentCollectionNotSet: $ee,
  paymentCollectionNotSetDescription: Hee,
  paymentGoToSetting: jee,
  paymentSendRequestMessage: zee,
  paymentMethods: qee,
  paymentSupportedMethods: Vee,
  paymentRequestMessage: Wee,
  paymentInputMessageOptional: Qee,
  paymentRequestedFrom: Gee,
  paymentViewDetails: Yee,
  paymentRequestDetail: Xee,
  paymentDetail: Kee,
  paymentRequestTime: Zee,
  paymentCompleted: Jee,
  paymentFlowPaid: ete,
  paymentFlowUnpaid: tte,
  paymentFlowRefund: nte,
  paymentFlowAuthorizationError: rte,
  paymentRequestedFromYou: ite,
  paymentGoToPay: ste,
  paymentFailed: ate,
  paymentFailedDescription: ote,
  paymentPaidTo: ute,
  paymentSendPaymentRequestMessageEmpty: lte,
  paymentSendPaymentRequestMessage: cte,
  paymentSendPaymentMessage: dte
}, hte = "閉じる", pte = "確認", mte = "フォルダ名", gte = "フォルダを作成", Ate = "タグ", bte = "タグを入力", yte = "カスタムカラーを入力してください（例：#02B13F）", vte = "ダウンロード", Tte = "{0}がメッセージを取り消しました", _te = "既読", Ete = "ピン留め", xte = "ピン留めを解除", wte = "チャットが空です", Cte = "メンバー", Ste = "作成日", Ite = "更新日", kte = "グループを退出", Dte = "テキスト", Mte = "画像", Ote = "ビデオ", Nte = "スティッカー", Lte = "メッセージ", Pte = "{0}が送信しました", Rte = "{0}が{1}を送信しました", Bte = "リンクを開くにはこちらをタップしてください。", Fte = "メッセージを入力...", Ute = "{0}が入力中...", $te = "{0}がチャットに参加しました", Hte = "{0}がチャットを退出しました", jte = "{0}が{1}を招待しました", zte = "{0}が{1}をキックしました", qte = "あなたはメッセージを取り消しました", Vte = "ファイルサイズ", Wte = "ファイル", Qte = "翻訳", Gte = "検索", Yte = "位置", Xte = "現在の位置を送信", Kte = "位置情報のアクセス許可がありません。", Zte = "位置情報のリクエストがタイムアウトしました。", Jte = "アドレスが利用できません。", ene = "オーディオメッセージ", tne = "マイクのアクセス許可がありません。", nne = "フォルダから削除", rne = "フォルダを編集", ine = "フォルダに追加", sne = "{n}のチャットルーム", ane = "チャットルーム名", one = "メンバー", une = "タグ", lne = "フォルダ", cne = "属性", dne = "一斉送信", fne = "メッセージを入力", hne = "チャット内を検索", pne = "昨日", mne = "今日", gne = "フォルダを削除しますか？", Ane = "非表示", bne = "非表示を解除", yne = "キャンセル", vne = "作成", Tne = "保存", _ne = "タグ名を入力してください", Ene = "タグを削除してよろしいですか？", xne = "タグを編集", wne = "色を選択", Cne = "このタグは既にあります。他の名前にしてください。", Sne = "ブロック", Ine = "ブロック解除​", kne = "このユーザーはブロックされました。", Dne = "通知をミュート", Mne = "通知をオンにする", One = "チャットルームの削除を確認？", Nne = "チャットルームを削除すると、過去のチャット履歴を見ることができなくなります。相手の視点からのチャットルームは影響を受けず、引き続き新しいメッセージを送信することができます。", Lne = "以下は未読メッセージです", Pne = "このメッセージをどのように削除しますか？", Rne = "全員に対して削除", Bne = "自分だけに対して削除", Fne = "メッセージの削除を確認しますか？", Une = "選択したメッセージはすべてのチャットルームから削除されます。この操作は元に戻せません。", $ne = "選択したメッセージはあなたのチャットルームからのみ削除されます。相手はチャットルームでメッセージを見ることができます。この操作は元に戻せません。", Hne = "メッセージ", jne = "見つかったメッセージ {0} 件", zne = "削除する", qne = "{0} をグループから削除してもよろしいですか？", Vne = "メンバーが削除されると、グループメッセージを閲覧できなくなります。", Wne = "グループからキックアウト", Qne = "メンバーを蹴るには失敗しました", Gne = "現在、キックアウト操作は完了できません。ネットワーク接続を確認するか、後で再試行してください。", Yne = "ファイルが大きすぎます", Xne = "選択したファイルは、{0} の最大許容サイズを超えています。より小さいファイルを選択してください。", Kne = { Message: { email: { submit: "メールが送信されます", placeholder: "メールアドレスを入力する" }, phone: { placeholder: "電話番号を入力する", submit: "電話番号が送信されます" }, text: { submit: "テキストが送信される", placeholder: "テキストの内容を入力してください" } } }, Zne = "正しい形式を入力してください", Jne = "チャットボット", ere = "チャットボットをオンにすると、チャットボットが設定したフローに従って他のパーティーに応答します。チャットボットをオフにすると、実際の人間の返信モードに入ることができます。", tre = "オフラインプッシュ通知を許可する", nre = "有効にすると、チャットが開いていなくても、新しいメッセージが到着したときにデスクトップ通知を受け取ります。", rre = "この設定は[マイアカウント > 通知設定]で変更できます。", ire = "後で聞く", sre = "通知を許可", are = "あなた", ore = "送信", ure = "ステータス", lre = "通貨", cre = "支払い回収", dre = "支払い方法が設定されていません", fre = "まだ支払い方法を設定していません。【マイアカウント > チャットルーム支払い設定】に移動して設定を完了し、支払いリクエストの送信を開始してください。", hre = "設定に移動", pre = "支払いリクエストメッセージを送信", mre = "支払い方法", gre = "対応している支払い方法", Are = "支払いリクエストメッセージ", bre = "メッセージを入力（任意）", yre = "{0} に支払いを請求しました", vre = "詳細を見る", Tre = "リクエスト詳細", _re = "支払い詳細", Ere = "リクエスト時刻", xre = "{0} が支払いを完了しました", wre = "支払い済み", Cre = "未払い", Sre = "返金済み", Ire = "認証エラー", kre = "{0} があなたに支払いを請求しました", Dre = "支払いに移動", Mre = "支払い失敗", Ore = "アカウントを確認して、もう一度お試しください。", Nre = "{0} に支払い完了", Lre = "なし", Pre = "{0} が支払いリクエストを送信しました", Rre = "{0} が支払いを送信しました", Bre = {
  close: hte,
  confirm: pte,
  folderName: mte,
  createFolder: gte,
  tag: Ate,
  inputTag: bte,
  inputTagPlaceholder: yte,
  download: vte,
  someoneUnsentMessage: Tte,
  read: _te,
  pin: Ete,
  unpin: xte,
  emptyChat: wte,
  members: Cte,
  createdAt: Ste,
  updatedAt: Ite,
  leaveGroup: kte,
  text: Dte,
  image: Mte,
  video: Ote,
  sticker: Nte,
  message: Lte,
  youSent: Pte,
  someoneSent: Rte,
  tapOpen: Bte,
  TypeMessage: Fte,
  isTyping: Ute,
  someoneJoinedTheChat: $te,
  someoneLeftTheChat: Hte,
  someoneInvited: jte,
  someoneKicked: zte,
  youUnsentMessage: qte,
  fileSize: Vte,
  file: Wte,
  translation: Qte,
  search: Gte,
  location: Yte,
  sendCurrentLocation: Xte,
  noAccessLocationPermission: Kte,
  "locationInfoUnavailable.": "位置情報を取得できません。",
  requestLocationTimeout: Zte,
  addressUnavailable: Jte,
  audio: ene,
  noAccessMicrophonePermission: tne,
  removeFromFolder: nne,
  editFolder: rne,
  addToFolder: ine,
  numberOfChatroom: sne,
  "no-chatroom": "チャットルームがありません",
  roomName: ane,
  roomMember: one,
  roomPrefTags: une,
  roomPrefFolder: lne,
  roomTags: cne,
  massTexting: dne,
  inputMessage: fne,
  searchInConversation: hne,
  yesterday: pne,
  today: mne,
  confirmToDeleteFolder: gne,
  hide: Ane,
  unhide: bne,
  delete: "削除",
  cancel: yne,
  create: vne,
  save: Tne,
  createTag: _ne,
  confirmDeleteTag: Ene,
  editTag: xne,
  chooseColor: wne,
  duplicateTagName: Cne,
  block: Sne,
  unblock: Ine,
  textareaBlockedHint: kne,
  mute: Dne,
  unmute: Mne,
  chatroomDeleteConfirmationTitle: One,
  chatroomDeleteConfirmationMessage: Nne,
  unreadMessages: Lne,
  deleteMessageConfirmation: Pne,
  deleteForEveryone: Rne,
  deleteForMe: Bne,
  confirmDeleteMessage: Fne,
  deleteForEveryoneWarning: Une,
  deleteForMeWarning: $ne,
  messages: Hne,
  foundMessages: jne,
  moveOut: zne,
  kickOutConfirmTitle: qne,
  kickOutConfirmTip: Vne,
  kickOutGroup: Wne,
  kickOutErrorTitle: Qne,
  kickOutErrorDesc: Gne,
  fileSizeLimitTitle: Yne,
  fileSizeLimitMessage: Xne,
  "online-status-online": "アクティブ",
  "online-status-offline": "ないオンライン",
  Request: Kne,
  emailFromatError: Zne,
  chatbotSwitch: Jne,
  chatbotSwitchDescription: ere,
  allowOfflineNotifications: tre,
  notificationPermissionDescription: nre,
  notificationSettingsPath: rre,
  askLater: ire,
  allowNotifications: sre,
  you: are,
  submit: ore,
  status: ure,
  currency: lre,
  paymentCollectionTitle: cre,
  paymentCollectionNotSet: dre,
  paymentCollectionNotSetDescription: fre,
  paymentGoToSetting: hre,
  paymentSendRequestMessage: pre,
  paymentMethods: mre,
  paymentSupportedMethods: gre,
  paymentRequestMessage: Are,
  paymentInputMessageOptional: bre,
  paymentRequestedFrom: yre,
  paymentViewDetails: vre,
  paymentRequestDetail: Tre,
  paymentDetail: _re,
  paymentRequestTime: Ere,
  paymentCompleted: xre,
  paymentFlowPaid: wre,
  paymentFlowUnpaid: Cre,
  paymentFlowRefund: Sre,
  paymentFlowAuthorizationError: Ire,
  paymentRequestedFromYou: kre,
  paymentGoToPay: Dre,
  paymentFailed: Mre,
  paymentFailedDescription: Ore,
  paymentPaidTo: Nre,
  paymentSendPaymentRequestMessageEmpty: Lre,
  paymentSendPaymentRequestMessage: Pre,
  paymentSendPaymentMessage: Rre
}, Fre = "닫기", Ure = "확인", $re = "폴더 이름", Hre = "폴더 만들기", jre = "태그", zre = "태그 이름 입력", qre = "#02B13F와 같은 사용자 지정 색상을 입력하세요", Vre = "다운로드", Wre = "{0}님이 메시지를 삭제했습니다", Qre = "읽음", Gre = "고정", Yre = "고정 해제", Xre = "멤버 없음", Kre = "멤버", Zre = "생성 시간", Jre = "업데이트 시간", eie = "그룹 나가기", tie = "텍스트", nie = "이미지", rie = "비디오", iie = "스티커", sie = "메시지", aie = "{0} 보냄", oie = "{0}님이 {1}을(를) 보냈습니다", uie = "이 링크를 열려면 여기를 탭하세요.", lie = "메시지 입력...", cie = "{0}님이 입력 중...", die = "{0}님이 채팅에 참여했습니다", fie = "{0}님이 채팅방을 나갔습니다", hie = "{0}님이 {1}님을 초대했습니다", pie = "{0}님이 {1}님을 강제 퇴장시켰습니다", mie = "메시지를 삭제했습니다", gie = "파일 크기", Aie = "파일", bie = "번역", yie = "검색", vie = "위치", Tie = "현재 위치 보내기", _ie = "위치 접근 권한 없음", Eie = "위치 요청 시간 초과", xie = "주소를 사용할 수 없음", wie = "음성 메시지", Cie = "마이크 접근 권한 없음", Sie = "폴더에서 제거", Iie = "폴더 편집", kie = "폴더에 추가", Die = "채팅방 {n}개", Mie = "방 이름", Oie = "멤버", Nie = "태그", Lie = "폴더", Pie = "속성", Rie = "대량 메시지", Bie = "메시지 내용을 입력하세요", Fie = "대화에서 검색", Uie = "어제", $ie = "오늘", Hie = "폴더를 삭제하시겠습니까?", jie = "숨기기", zie = "숨기기 취소", qie = "취소", Vie = "만들기", Wie = "저장", Qie = "태그 이름 입력", Gie = "태그를 삭제하시겠습니까?", Yie = "태그 편집", Xie = "색상 선택", Kie = "이미 존재하는 태그입니다. 다른 이름을 입력하세요.", Zie = "차단", Jie = "차단 해제", ese = "이 사용자는 차단되었습니다.", tse = "알림 끄기", nse = "알림 켜기", rse = "채팅방을 삭제하시겠습니까?", ise = "채팅방을 삭제하면 이전 채팅 기록을 볼 수 없게 됩니다. 상대방 시점에서의 채팅방은 영향을 받지 않으며 여전히 새 메시지를 보낼 수 있습니다.", sse = "아래는 읽지 않은 메시지입니다", ase = "이 메시지를 어떻게 삭제하시겠습니까?", ose = "모두에게 삭제", use = "나만 삭제", lse = "메시지를 삭제하시겠습니까?", cse = "선택한 메시지가 모든 채팅방에서 삭제됩니다. 이 작업은 취소할 수 없습니다.", dse = "선택한 메시지가 내 채팅방에서만 삭제됩니다. 상대방은 여전히 채팅방에서 메시지를 볼 수 있습니다. 이 작업은 취소할 수 없습니다.", fse = "메시지", hse = "찾은 메시지 {0}개", pse = "내보내기", mse = "{0}님을 그룹에서 내보내시겠습니까?", gse = "내보낸 후에는 해당 사용자가 그룹 메시지를 더 이상 볼 수 없습니다.", Ase = "그룹에서 쫓아냅니다", bse = "퇴장 멤버가 실패했습니다", yse = "킥아웃 작업은 현재 완료 될 수 없습니다. 네트워크 연결을 확인하거나 나중에 다시 시도하십시오.", vse = "파일이 너무 큽니다", Tse = "선택한 파일이 {0}의 최대 허용 크기를 초과했습니다. 더 작은 파일을 선택하세요.", _se = { Message: { email: { submit: "이메일이 전송되었습니다", placeholder: "이메일 입력" }, phone: { placeholder: "전화번호 입력", submit: "전화번호가 전송되었습니다" }, text: { submit: "텍스트가 전송되었습니다", placeholder: "텍스트 내용 입력" } } }, Ese = "올바른 형식을 입력해 주세요", xse = "챗봇", wse = "챗봇을 켜면 설정한 흐름에 따라 상대방에게 응답합니다. 챗봇을 끄면 실제 사람이 응답하는 모드로 전환됩니다.", Cse = "오프라인 푸시 알림 허용", Sse = "활성화하면 새 메시지가 도착했을 때 채팅이 열려 있지 않아도 데스크톱 알림을 받습니다.", Ise = "이 설정은 [내 계정 > 알림 설정]에서 수정할 수 있습니다.", kse = "나중에 묻기", Dse = "알림 허용", Mse = "당신", Ose = "제출", Nse = "상태", Lse = "통화", Pse = "결제 수금", Rse = "결제 방법이 설정되지 않음", Bse = "아직 결제 방법을 설정하지 않으셨습니다. [내 계정 > 채팅방 결제 설정]으로 이동하여 설정을 완료하고 결제 요청 보내기를 시작하세요.", Fse = "설정으로 이동", Use = "결제 요청 메시지 보내기", $se = "결제 방법", Hse = "지원되는 결제 방법", jse = "결제 요청 메시지", zse = "메시지 입력 (선택사항)", qse = "{0}에게 결제를 요청했습니다", Vse = "세부 정보 보기", Wse = "요청 세부 정보", Qse = "결제 세부 정보", Gse = "요청 시간", Yse = "{0}이(가) 결제를 완료했습니다", Xse = "결제 완료", Kse = "미결제", Zse = "환불됨", Jse = "인증 오류", eae = "{0}이(가) 당신에게 결제를 요청했습니다", tae = "결제하러 가기", nae = "결제 실패", rae = "계정을 확인하고 다시 시도해 주세요.", iae = "{0}에게 결제 완료", sae = "없음", aae = "{0}이(가) 결제 요청을 보냈습니다", oae = "{0}이(가) 결제를 보냈습니다", uae = {
  close: Fre,
  confirm: Ure,
  folderName: $re,
  createFolder: Hre,
  tag: jre,
  inputTag: zre,
  inputTagPlaceholder: qre,
  download: Vre,
  someoneUnsentMessage: Wre,
  read: Qre,
  pin: Gre,
  unpin: Yre,
  emptyChat: Xre,
  members: Kre,
  createdAt: Zre,
  updatedAt: Jre,
  leaveGroup: eie,
  text: tie,
  image: nie,
  video: rie,
  sticker: iie,
  message: sie,
  youSent: aie,
  someoneSent: oie,
  tapOpen: uie,
  TypeMessage: lie,
  isTyping: cie,
  someoneJoinedTheChat: die,
  someoneLeftTheChat: fie,
  someoneInvited: hie,
  someoneKicked: pie,
  youUnsentMessage: mie,
  fileSize: gie,
  file: Aie,
  translation: bie,
  search: yie,
  location: vie,
  sendCurrentLocation: Tie,
  noAccessLocationPermission: _ie,
  "locationInfoUnavailable.": "위치 정보를 사용할 수 없습니다",
  requestLocationTimeout: Eie,
  addressUnavailable: xie,
  audio: wie,
  noAccessMicrophonePermission: Cie,
  removeFromFolder: Sie,
  editFolder: Iie,
  addToFolder: kie,
  numberOfChatroom: Die,
  roomName: Mie,
  roomMember: Oie,
  roomPrefTags: Nie,
  roomPrefFolder: Lie,
  roomTags: Pie,
  massTexting: Rie,
  inputMessage: Bie,
  searchInConversation: Fie,
  yesterday: Uie,
  today: $ie,
  confirmToDeleteFolder: Hie,
  hide: jie,
  unhide: zie,
  delete: "삭제",
  cancel: qie,
  create: Vie,
  save: Wie,
  createTag: Qie,
  confirmDeleteTag: Gie,
  editTag: Yie,
  chooseColor: Xie,
  duplicateTagName: Kie,
  block: Zie,
  unblock: Jie,
  textareaBlockedHint: ese,
  mute: tse,
  unmute: nse,
  chatroomDeleteConfirmationTitle: rse,
  chatroomDeleteConfirmationMessage: ise,
  unreadMessages: sse,
  deleteMessageConfirmation: ase,
  deleteForEveryone: ose,
  deleteForMe: use,
  confirmDeleteMessage: lse,
  deleteForEveryoneWarning: cse,
  deleteForMeWarning: dse,
  messages: fse,
  foundMessages: hse,
  moveOut: pse,
  kickOutConfirmTitle: mse,
  kickOutConfirmTip: gse,
  kickOutGroup: Ase,
  kickOutErrorTitle: bse,
  kickOutErrorDesc: yse,
  fileSizeLimitTitle: vse,
  fileSizeLimitMessage: Tse,
  "online-status-online": "온라인",
  "online-status-offline": "오프라인",
  Request: _se,
  emailFromatError: Ese,
  chatbotSwitch: xse,
  chatbotSwitchDescription: wse,
  allowOfflineNotifications: Cse,
  notificationPermissionDescription: Sse,
  notificationSettingsPath: Ise,
  askLater: kse,
  allowNotifications: Dse,
  you: Mse,
  submit: Ose,
  status: Nse,
  currency: Lse,
  paymentCollectionTitle: Pse,
  paymentCollectionNotSet: Rse,
  paymentCollectionNotSetDescription: Bse,
  paymentGoToSetting: Fse,
  paymentSendRequestMessage: Use,
  paymentMethods: $se,
  paymentSupportedMethods: Hse,
  paymentRequestMessage: jse,
  paymentInputMessageOptional: zse,
  paymentRequestedFrom: qse,
  paymentViewDetails: Vse,
  paymentRequestDetail: Wse,
  paymentDetail: Qse,
  paymentRequestTime: Gse,
  paymentCompleted: Yse,
  paymentFlowPaid: Xse,
  paymentFlowUnpaid: Kse,
  paymentFlowRefund: Zse,
  paymentFlowAuthorizationError: Jse,
  paymentRequestedFromYou: eae,
  paymentGoToPay: tae,
  paymentFailed: nae,
  paymentFailedDescription: rae,
  paymentPaidTo: iae,
  paymentSendPaymentRequestMessageEmpty: sae,
  paymentSendPaymentRequestMessage: aae,
  paymentSendPaymentMessage: oae
}, lae = "Fechar", cae = "Confirmar", dae = "Nome da pasta", fae = "Criar pasta", hae = "Etiqueta", pae = "Inserir nome da etiqueta", mae = "Por favor, insira uma cor personalizada como #02B13F", gae = "Descarregar", Aae = "{0} retirou uma mensagem", bae = "Lido", yae = "Fixar", vae = "Desafixar", Tae = "Sem membros", _ae = "Membros", Eae = "Criado em", xae = "Atualizado em", wae = "Sair do grupo", Cae = "Texto", Sae = "Imagem", Iae = "Vídeo", kae = "Autocolante", Dae = "Mensagem", Mae = "{0} enviado", Oae = "{0} enviou-lhe {1}", Nae = "Toque aqui para abrir este link.", Lae = "Escreva uma mensagem...", Pae = "{0} está a escrever...", Rae = "{0} entrou no chat", Bae = "{0} saiu do chat", Fae = "{0} convidou {1}", Uae = "{0} expulsou {1}", $ae = "Retirou uma mensagem", Hae = "Tamanho do ficheiro", jae = "Ficheiro", zae = "Tradução", qae = "Pesquisar", Vae = "Localização", Wae = "Enviar localização atual", Qae = "Sem permissão de acesso à localização", Gae = "Tempo esgotado para pedido de localização", Yae = "Endereço indisponível", Xae = "Mensagem de voz", Kae = "Sem permissão de acesso ao microfone", Zae = "Remover da pasta", Jae = "Editar pasta", eoe = "Adicionar à pasta", toe = "{n} salas de chat", noe = "Nome da sala", roe = "Membro", ioe = "Etiquetas", soe = "Pasta", aoe = "Atributos", ooe = "Mensagem em massa", uoe = "Por favor, insira o conteúdo da mensagem", loe = "Pesquisar na conversa", coe = "Ontem", doe = "Hoje", foe = "Eliminar pasta?", hoe = "Ocultar", poe = "Mostrar", moe = "Cancelar", goe = "Criar", Aoe = "Guardar", boe = "Inserir nome da etiqueta", yoe = "Confirmar eliminação da etiqueta?", voe = "Editar etiqueta", Toe = "Escolher cor", _oe = "Tag existente. Use outro nome.", Eoe = "Bloquear", xoe = "Desbloquear", woe = "Este utilizador foi bloqueado.", Coe = "Silenciar notificações", Soe = "Ativar notificações", Ioe = "Confirmar eliminação da sala de chat?", koe = "Depois de apagar a sala de chat, não poderá mais ver o histórico de chat anterior. A sala de chat da perspectiva da outra pessoa não será afetada e ainda poderão enviar-lhe novas mensagens.", Doe = "Abaixo estão mensagens não lidas", Moe = "Como deseja apagar esta mensagem?", Ooe = "Apagar para todos", Noe = "Apagar apenas para mim", Loe = "Confirmar a eliminação da mensagem?", Poe = "A mensagem que selecionou será apagada de todas as salas de chat. Esta ação não pode ser desfeita.", Roe = "A mensagem que selecionou será apagada apenas da sua sala de chat. A outra pessoa ainda poderá ver a mensagem na sala de chat. Esta ação não pode ser desfeita.", Boe = "Mensagem", Foe = "Encontrado {0} mensagens", Uoe = "Remover", $oe = "Tem certeza de que deseja remover {0} do grupo?", Hoe = "Após a remoção, o membro não poderá mais ver as mensagens do grupo.", joe = "Chutar do grupo", zoe = "Os membros do chutes falharam", qoe = "A operação de chute não pode ser concluída no momento. Confirme a conexão de rede ou tente novamente mais tarde.", Voe = "Ficheiro demasiado grande", Woe = "O ficheiro selecionado excede o tamanho máximo permitido de {0}. Por favor, escolha um ficheiro mais pequeno.", Qoe = { Message: { email: { submit: "Email enviado", placeholder: "Introduza o seu email" }, phone: { placeholder: "Introduza o seu número de telefone", submit: "Número de telefone enviado" }, text: { submit: "Texto enviado", placeholder: "Introduza o conteúdo do texto" } } }, Goe = "Por favor, introduza o formato correto", Yoe = "Chatbot", Xoe = "Ative o chatbot, e este responderá à outra parte de acordo com o fluxo que definiu. Desative o chatbot para entrar no modo de resposta humana.", Koe = "Permitir notificações push offline", Zoe = "Após ativar, quando uma nova mensagem chegar, você receberá notificações na área de trabalho mesmo que o chat não esteja aberto.", Joe = "Esta configuração pode ser modificada em [Minha Conta > Configurações de Notificação].", eue = "Perguntar Mais Tarde", tue = "Permitir Notificações", nue = "Você", rue = "Enviar", iue = "Status", sue = "Moeda", aue = "Cobrança de pagamento", oue = "Forma de pagamento não configurada", uue = "Você ainda não configurou uma forma de pagamento. Vá para [Minha conta > Configurações de pagamento do chat] para concluir a configuração e começar a enviar solicitações de pagamento.", lue = "Ir para configurações", cue = "Enviar mensagem de solicitação de pagamento", due = "Formas de pagamento", fue = "Formas de pagamento suportadas", hue = "Mensagem de solicitação de pagamento", pue = "Digite a mensagem (opcional)", mue = "Solicitou pagamento de {0}", gue = "Ver detalhes", Aue = "Detalhes da solicitação", bue = "Detalhes do pagamento", yue = "Hora da solicitação", vue = "{0} completou o pagamento", Tue = "Pago", _ue = "Não pago", Eue = "Reembolsado", xue = "Erro de autorização", wue = "{0} solicitou pagamento de você", Cue = "Ir para pagar", Sue = "Pagamento falhou", Iue = "Por favor, verifique sua conta e tente novamente.", kue = "Pago para {0}", Due = "Nenhuma", Mue = "{0} enviou uma solicitação de pagamento", Oue = "{0} enviou um pagamento", Nue = {
  close: lae,
  confirm: cae,
  folderName: dae,
  createFolder: fae,
  tag: hae,
  inputTag: pae,
  inputTagPlaceholder: mae,
  download: gae,
  someoneUnsentMessage: Aae,
  read: bae,
  pin: yae,
  unpin: vae,
  emptyChat: Tae,
  members: _ae,
  createdAt: Eae,
  updatedAt: xae,
  leaveGroup: wae,
  text: Cae,
  image: Sae,
  video: Iae,
  sticker: kae,
  message: Dae,
  youSent: Mae,
  someoneSent: Oae,
  tapOpen: Nae,
  TypeMessage: Lae,
  isTyping: Pae,
  someoneJoinedTheChat: Rae,
  someoneLeftTheChat: Bae,
  someoneInvited: Fae,
  someoneKicked: Uae,
  youUnsentMessage: $ae,
  fileSize: Hae,
  file: jae,
  translation: zae,
  search: qae,
  location: Vae,
  sendCurrentLocation: Wae,
  noAccessLocationPermission: Qae,
  "locationInfoUnavailable.": "Informação de localização indisponível",
  requestLocationTimeout: Gae,
  addressUnavailable: Yae,
  audio: Xae,
  noAccessMicrophonePermission: Kae,
  removeFromFolder: Zae,
  editFolder: Jae,
  addToFolder: eoe,
  numberOfChatroom: toe,
  roomName: noe,
  roomMember: roe,
  roomPrefTags: ioe,
  roomPrefFolder: soe,
  roomTags: aoe,
  massTexting: ooe,
  inputMessage: uoe,
  searchInConversation: loe,
  yesterday: coe,
  today: doe,
  confirmToDeleteFolder: foe,
  hide: hoe,
  unhide: poe,
  delete: "Eliminar",
  cancel: moe,
  create: goe,
  save: Aoe,
  createTag: boe,
  confirmDeleteTag: yoe,
  editTag: voe,
  chooseColor: Toe,
  duplicateTagName: _oe,
  block: Eoe,
  unblock: xoe,
  textareaBlockedHint: woe,
  mute: Coe,
  unmute: Soe,
  chatroomDeleteConfirmationTitle: Ioe,
  chatroomDeleteConfirmationMessage: koe,
  unreadMessages: Doe,
  deleteMessageConfirmation: Moe,
  deleteForEveryone: Ooe,
  deleteForMe: Noe,
  confirmDeleteMessage: Loe,
  deleteForEveryoneWarning: Poe,
  deleteForMeWarning: Roe,
  messages: Boe,
  foundMessages: Foe,
  moveOut: Uoe,
  kickOutConfirmTitle: $oe,
  kickOutConfirmTip: Hoe,
  kickOutGroup: joe,
  kickOutErrorTitle: zoe,
  kickOutErrorDesc: qoe,
  fileSizeLimitTitle: Voe,
  fileSizeLimitMessage: Woe,
  "online-status-online": "Ativo",
  "online-status-offline": "Ausente",
  Request: Qoe,
  emailFromatError: Goe,
  chatbotSwitch: Yoe,
  chatbotSwitchDescription: Xoe,
  allowOfflineNotifications: Koe,
  notificationPermissionDescription: Zoe,
  notificationSettingsPath: Joe,
  askLater: eue,
  allowNotifications: tue,
  you: nue,
  submit: rue,
  status: iue,
  currency: sue,
  paymentCollectionTitle: aue,
  paymentCollectionNotSet: oue,
  paymentCollectionNotSetDescription: uue,
  paymentGoToSetting: lue,
  paymentSendRequestMessage: cue,
  paymentMethods: due,
  paymentSupportedMethods: fue,
  paymentRequestMessage: hue,
  paymentInputMessageOptional: pue,
  paymentRequestedFrom: mue,
  paymentViewDetails: gue,
  paymentRequestDetail: Aue,
  paymentDetail: bue,
  paymentRequestTime: yue,
  paymentCompleted: vue,
  paymentFlowPaid: Tue,
  paymentFlowUnpaid: _ue,
  paymentFlowRefund: Eue,
  paymentFlowAuthorizationError: xue,
  paymentRequestedFromYou: wue,
  paymentGoToPay: Cue,
  paymentFailed: Sue,
  paymentFailedDescription: Iue,
  paymentPaidTo: kue,
  paymentSendPaymentRequestMessageEmpty: Due,
  paymentSendPaymentRequestMessage: Mue,
  paymentSendPaymentMessage: Oue
}, Lue = "Închide", Pue = "Confirmă", Rue = "Nume dosar", Bue = "Creare dosar", Fue = "Etichetă", Uue = "Introduceți numele etichetei", $ue = "Vă rugăm să introduceți o culoare personalizată ca #02B13F", Hue = "Descarcă", jue = "{0} a retras un mesaj", zue = "Citit", que = "Fixează", Vue = "Anulează fixarea", Wue = "Nu există membri", Que = "Membri", Gue = "Creat la", Yue = "Actualizat la", Xue = "Părăsește grupul", Kue = "Text", Zue = "Imagine", Jue = "Video", ele = "Autocolant", tle = "Mesaj", nle = "{0} trimis", rle = "{0} v-a trimis {1}", ile = "Atingeți aici pentru a deschide acest link.", sle = "Scrieți un mesaj...", ale = "{0} scrie...", ole = "{0} s-a alăturat conversației", ule = "{0} a părăsit conversația", lle = "{0} l-a invitat pe {1}", cle = "{0} l-a eliminat pe {1}", dle = "Ați retras un mesaj", fle = "Dimensiune fișier", hle = "Fișier", ple = "Traducere", mle = "Caută", gle = "Locație", Ale = "Trimite locația curentă", ble = "Fără permisiune de acces la locație", yle = "Timpul pentru solicitarea locației a expirat", vle = "Adresa nu este disponibilă", Tle = "Mesaj vocal", _le = "Fără permisiune de acces la microfon", Ele = "Elimină din dosar", xle = "Editează dosar", wle = "Adaugă la dosar", Cle = "{n} camere de chat", Sle = "Nume cameră", Ile = "Membru", kle = "Etichete", Dle = "Dosar", Mle = "Atribute", Ole = "Mesaj în masă", Nle = "Vă rugăm să introduceți conținutul mesajului", Lle = "Caută în conversație", Ple = "Ieri", Rle = "Astăzi", Ble = "Ștergeți dosarul?", Fle = "Ascunde", Ule = "Afișează", $le = "Anulează", Hle = "Crează", jle = "Salvează", zle = "Introduceți numele etichetei", qle = "Confirmați ștergerea etichetei?", Vle = "Editează eticheta", Wle = "Alegeți culoarea", Qle = "Eticheta există deja. Folosiți alt nume.", Gle = "Blochează", Yle = "Deblochează", Xle = "Acest utilizator a fost blocat.", Kle = "Dezactivează notificările", Zle = "Activează notificările", Jle = "Confirmați ștergerea camerei de chat?", ece = "După ștergerea camerei de chat, nu veți mai putea vizualiza istoricul conversațiilor anterioare. Camera de chat din perspectiva celeilalte persoane nu va fi afectată și aceasta va putea în continuare să vă trimită mesaje noi.", tce = "Mai jos sunt mesajele necitite", nce = "Cum doriți să ștergeți acest mesaj?", rce = "Șterge pentru toată lumea", ice = "Șterge doar pentru mine", sce = "Confirmați ștergerea mesajului?", ace = "Mesajul selectat va fi șters din toate camerele de chat. Această acțiune nu poate fi anulată.", oce = "Mesajul selectat va fi șters doar din camera dvs. de chat. Cealaltă persoană va putea în continuare să vadă mesajul în camera de chat. Această acțiune nu poate fi anulată.", uce = "Mesaj", lce = "A fost găsit {0} mesaj", cce = "Elimină", dce = "Sigur doriți să îl eliminați pe {0} din grup?", fce = "Odată eliminat, membrul nu va mai putea vedea mesajele din grup.", hce = "Da afară din grup", pce = "Introducerea membrilor nu a reușit", mce = "Operația de declanșare nu poate fi finalizată în prezent. Vă rugăm să confirmați conexiunea de rețea sau să încercați din nou mai târziu.", gce = "Fișier prea mare", Ace = "Fișierul selectat depășește dimensiunea maximă permisă de {0}. Vă rugăm să alegeți un fișier mai mic.", bce = { Message: { email: { submit: "E-mail trimis", placeholder: "Introduceți e-mailul" }, phone: { placeholder: "Introduceți numărul de telefon", submit: "Număr de telefon trimis" }, text: { submit: "Text trimis", placeholder: "Introduceți conținutul text" } } }, yce = "Vă rugăm să introduceți formatul corect", vce = "Chatbot", Tce = "Când chatbot-ul este pornit, acesta va răspunde celeilalte părți conform fluxului pe care l-ați setat. Când chatbot-ul este oprit, puteți intra în modul de răspuns personal.", _ce = "Permiteți notificările push offline", Ece = "După activare, când sosește un mesaj nou, veți primi notificări pe desktop chiar dacă chatul nu este deschis.", xce = "Această setare poate fi modificată în [Contul meu > Setări de notificare].", wce = "Întreabă mai târziu", Cce = "Permiteți notificările", Sce = "Tu", Ice = "Trimite", kce = "Status", Dce = "Monedă", Mce = "Colectarea plăților", Oce = "Metoda de plată nu este setată", Nce = "Nu ați setat încă o metodă de plată. Vă rugăm să mergeți la [Contul meu > Setări plată cameră chat] pentru a finaliza configurarea și a începe să trimiteți cereri de plată.", Lce = "Mergi la setări", Pce = "Trimite mesaj de cerere de plată", Rce = "Metode de plată", Bce = "Metode de plată acceptate", Fce = "Mesaj cerere de plată", Uce = "Introduceți mesaj (opțional)", $ce = "A solicitat plată de la {0}", Hce = "Vezi detalii", jce = "Detalii cerere", zce = "Detalii plată", qce = "Timpul cererii", Vce = "{0} a finalizat plata", Wce = "Plătit", Qce = "Neplătit", Gce = "Rambursat", Yce = "Eroare de autorizare", Xce = "{0} a solicitat plată de la tine", Kce = "Mergi să plătești", Zce = "Plată eșuată", Jce = "Vă rugăm să verificați contul și să încercați din nou.", ede = "Plătit către {0}", tde = "Niciuna", nde = "{0} a trimis o cerere de plată", rde = "{0} a trimis o plată", ide = {
  close: Lue,
  confirm: Pue,
  folderName: Rue,
  createFolder: Bue,
  tag: Fue,
  inputTag: Uue,
  inputTagPlaceholder: $ue,
  download: Hue,
  someoneUnsentMessage: jue,
  read: zue,
  pin: que,
  unpin: Vue,
  emptyChat: Wue,
  members: Que,
  createdAt: Gue,
  updatedAt: Yue,
  leaveGroup: Xue,
  text: Kue,
  image: Zue,
  video: Jue,
  sticker: ele,
  message: tle,
  youSent: nle,
  someoneSent: rle,
  tapOpen: ile,
  TypeMessage: sle,
  isTyping: ale,
  someoneJoinedTheChat: ole,
  someoneLeftTheChat: ule,
  someoneInvited: lle,
  someoneKicked: cle,
  youUnsentMessage: dle,
  fileSize: fle,
  file: hle,
  translation: ple,
  search: mle,
  location: gle,
  sendCurrentLocation: Ale,
  noAccessLocationPermission: ble,
  "locationInfoUnavailable.": "Informațiile despre locație nu sunt disponibile",
  requestLocationTimeout: yle,
  addressUnavailable: vle,
  audio: Tle,
  noAccessMicrophonePermission: _le,
  removeFromFolder: Ele,
  editFolder: xle,
  addToFolder: wle,
  numberOfChatroom: Cle,
  roomName: Sle,
  roomMember: Ile,
  roomPrefTags: kle,
  roomPrefFolder: Dle,
  roomTags: Mle,
  massTexting: Ole,
  inputMessage: Nle,
  searchInConversation: Lle,
  yesterday: Ple,
  today: Rle,
  confirmToDeleteFolder: Ble,
  hide: Fle,
  unhide: Ule,
  delete: "Șterge",
  cancel: $le,
  create: Hle,
  save: jle,
  createTag: zle,
  confirmDeleteTag: qle,
  editTag: Vle,
  chooseColor: Wle,
  duplicateTagName: Qle,
  block: Gle,
  unblock: Yle,
  textareaBlockedHint: Xle,
  mute: Kle,
  unmute: Zle,
  chatroomDeleteConfirmationTitle: Jle,
  chatroomDeleteConfirmationMessage: ece,
  unreadMessages: tce,
  deleteMessageConfirmation: nce,
  deleteForEveryone: rce,
  deleteForMe: ice,
  confirmDeleteMessage: sce,
  deleteForEveryoneWarning: ace,
  deleteForMeWarning: oce,
  messages: uce,
  foundMessages: lce,
  moveOut: cce,
  kickOutConfirmTitle: dce,
  kickOutConfirmTip: fce,
  kickOutGroup: hce,
  kickOutErrorTitle: pce,
  kickOutErrorDesc: mce,
  fileSizeLimitTitle: gce,
  fileSizeLimitMessage: Ace,
  "online-status-online": "Activ",
  "online-status-offline": "Inactiv",
  Request: bce,
  emailFromatError: yce,
  chatbotSwitch: vce,
  chatbotSwitchDescription: Tce,
  allowOfflineNotifications: _ce,
  notificationPermissionDescription: Ece,
  notificationSettingsPath: xce,
  askLater: wce,
  allowNotifications: Cce,
  you: Sce,
  submit: Ice,
  status: kce,
  currency: Dce,
  paymentCollectionTitle: Mce,
  paymentCollectionNotSet: Oce,
  paymentCollectionNotSetDescription: Nce,
  paymentGoToSetting: Lce,
  paymentSendRequestMessage: Pce,
  paymentMethods: Rce,
  paymentSupportedMethods: Bce,
  paymentRequestMessage: Fce,
  paymentInputMessageOptional: Uce,
  paymentRequestedFrom: $ce,
  paymentViewDetails: Hce,
  paymentRequestDetail: jce,
  paymentDetail: zce,
  paymentRequestTime: qce,
  paymentCompleted: Vce,
  paymentFlowPaid: Wce,
  paymentFlowUnpaid: Qce,
  paymentFlowRefund: Gce,
  paymentFlowAuthorizationError: Yce,
  paymentRequestedFromYou: Xce,
  paymentGoToPay: Kce,
  paymentFailed: Zce,
  paymentFailedDescription: Jce,
  paymentPaidTo: ede,
  paymentSendPaymentRequestMessageEmpty: tde,
  paymentSendPaymentRequestMessage: nde,
  paymentSendPaymentMessage: rde
}, sde = "ปิด", ade = "ยืนยัน", ode = "ชื่อโฟลเดอร์", ude = "สร้างโฟลเดอร์", lde = "แท็ก", cde = "ป้อนชื่อแท็ก", dde = "กรุณาป้อนสีที่กำหนดเอง เช่น #02B13F", fde = "ดาวน์โหลด", hde = "{0} ได้ถอนข้อความ", pde = "อ่านแล้ว", mde = "ปักหมุด", gde = "ถอนหมุด", Ade = "ไม่มีสมาชิก", bde = "สมาชิก", yde = "สร้างเมื่อ", vde = "อัปเดตเมื่อ", Tde = "ออกจากกลุ่ม", _de = "ข้อความ", Ede = "รูปภาพ", xde = "วิดีโอ", wde = "สติกเกอร์", Cde = "ข้อความ", Sde = "ส่ง{0}แล้ว", Ide = "{0}ได้ส่ง{1}ถึงคุณ", kde = "แตะที่นี่เพื่อเปิดลิงก์นี้", Dde = "พิมพ์ข้อความ...", Mde = "{0} กำลังพิมพ์...", Ode = "{0}เข้าร่วมการแชท", Nde = "{0}ออกจากการแชท", Lde = "{0}เชิญ{1}", Pde = "{0}เตะ{1}ออก", Rde = "คุณได้ถอนข้อความ", Bde = "ขนาดไฟล์", Fde = "ไฟล์", Ude = "การแปล", $de = "ค้นหา", Hde = "ตำแหน่ง", jde = "ส่งตำแหน่งปัจจุบัน", zde = "ไม่มีสิทธิ์เข้าถึงตำแหน่ง", qde = "การขอตำแหน่งหมดเวลา", Vde = "ที่อยู่ไม่พร้อมใช้งาน", Wde = "ข้อความเสียง", Qde = "ไม่มีสิทธิ์เข้าถึงไมโครโฟน", Gde = "นำออกจากโฟลเดอร์", Yde = "แก้ไขโฟลเดอร์", Xde = "เพิ่มลงในโฟลเดอร์", Kde = "ห้องแชท {n} ห้อง", Zde = "ชื่อห้อง", Jde = "สมาชิก", efe = "แท็ก", tfe = "โฟลเดอร์", nfe = "คุณลักษณะ", rfe = "ส่งข้อความหมู่", ife = "กรุณาป้อนเนื้อหาข้อความ", sfe = "ค้นหาในการสนทนา", afe = "เมื่อวาน", ofe = "วันนี้", ufe = "ลบโฟลเดอร์?", lfe = "ซ่อน", cfe = "ยกเลิกการซ่อน", dfe = "ยกเลิก", ffe = "สร้าง", hfe = "บันทึก", pfe = "ป้อนชื่อแท็ก", mfe = "ยืนยันการลบแท็ก?", gfe = "แก้ไขแท็ก", Afe = "เลือกสี", bfe = "แท็กนี้มีอยู่แล้ว ใช้ชื่ออื่น", yfe = "บล็อก", vfe = "ยกเลิกการบล็อก", Tfe = "ผู้ใช้นี้ถูกบล็อกแล้ว", _fe = "ปิดการแจ้งเตือน", Efe = "เปิดการแจ้งเตือน", xfe = "ยืนยันการลบห้องแชท?", wfe = "หลังจากลบห้องแชทแล้ว คุณจะไม่สามารถดูประวัติการแชทก่อนหน้านี้ได้ ห้องแชทจากมุมมองของอีกฝ่ายจะไม่ได้รับผลกระทบและพวกเขายังคงสามารถส่งข้อความใหม่ถึงคุณได้", Cfe = "ด้านล่างนี้คือข้อความที่ยังไม่ได้อ่าน", Sfe = "คุณต้องการลบข้อความนี้อย่างไร?", Ife = "ลบสำหรับทุกคน", kfe = "ลบสำหรับฉันเท่านั้น", Dfe = "ยืนยันการลบข้อความ?", Mfe = "ข้อความที่คุณเลือกจะถูกลบออกจากห้องแชททั้งหมด การกระทำนี้ไม่สามารถเรียกคืนได้", Ofe = "ข้อความที่คุณเลือกจะถูกลบออกจากห้องแชทของคุณ อีกฝ่ายจะยังคงสามารถเห็นข้อความในห้องแชทได้ การกระทำนี้ไม่สามารถเรียกคืนได้", Nfe = "ข้อความ", Lfe = "พบ {0} ข้อความ", Pfe = "ลบออก", Rfe = "คุณแน่ใจหรือไม่ว่าต้องการลบ {0} ออกจากกลุ่ม", Bfe = "เมื่อถูกลบออก สมาชิกจะไม่สามารถดูข้อความในกลุ่มได้อีก", Ffe = "เตะออกจากกลุ่ม", Ufe = "การเตะสมาชิกล้มเหลว", $fe = "การดำเนินการเตะออกไม่สามารถเสร็จสิ้นได้ในปัจจุบัน โปรดยืนยันการเชื่อมต่อเครือข่ายหรือลองอีกครั้งในภายหลัง", Hfe = "ไฟล์ใหญ่เกินไป", jfe = "ไฟล์ที่เลือกมีขนาดเกินขีดจำกัดสูงสุดที่อนุญาต {0} กรุณาเลือกไฟล์ที่เล็กกว่า", zfe = { Message: { email: { submit: "ส่งอีเมลแล้ว", placeholder: "ป้อนอีเมลของคุณ" }, phone: { placeholder: "ป้อนหมายเลขโทรศัพท์ของคุณ", submit: "ส่งหมายเลขโทรศัพท์แล้ว" }, text: { submit: "ส่งข้อความแล้ว", placeholder: "ป้อนข้อความ" } } }, qfe = "กรุณาป้อนรูปแบบที่ถูกต้อง", Vfe = "สวิตช์บอทแชท", Wfe = "เปิดบอทแชท บอทจะตอบสนองอีกฝ่ายตามขั้นตอนที่คุณตั้งไว้ ปิดบอทแชท คุณสามารถเข้าสู่โหมดตอบกลับด้วยบุคคลจริง", Qfe = "อนุญาตการแจ้งเตือนแบบพุชออฟไลน์", Gfe = "หลังจากเปิดใช้งาน เมื่อมีข้อความใหม่เข้ามา คุณจะได้รับการแจ้งเตือนบนเดสก์ท็อปแม้ว่าแชทจะไม่ได้เปิดอยู่ก็ตาม", Yfe = "การตั้งค่านี้สามารถแก้ไขได้ใน [บัญชีของฉัน > การตั้งค่าการแจ้งเตือน]", Xfe = "ถามทีหลัง", Kfe = "อนุญาตการแจ้งเตือน", Zfe = "คุณ", Jfe = "ส่ง", ehe = "สถานะ", the = "สกุลเงิน", nhe = "การเก็บเงิน", rhe = "ยังไม่ได้ตั้งค่าวิธีการชำระเงิน", ihe = "คุณยังไม่ได้ตั้งค่าวิธีการชำระเงิน กรุณาไปที่ [บัญชีของฉัน > การตั้งค่าการชำระเงินในห้องแชท] เพื่อทำการตั้งค่าให้เสร็จสิ้นและเริ่มส่งคำขอชำระเงิน", she = "ไปที่การตั้งค่า", ahe = "ส่งข้อความขอชำระเงิน", ohe = "วิธีการชำระเงิน", uhe = "วิธีการชำระเงินที่รองรับ", lhe = "ข้อความขอชำระเงิน", che = "กรอกข้อความ (ไม่บังคับ)", dhe = "ได้ขอชำระเงินจาก {0}", fhe = "ดูรายละเอียด", hhe = "รายละเอียดคำขอ", phe = "รายละเอียดการชำระเงิน", mhe = "เวลาที่ขอ", ghe = "{0} ได้ชำระเงินเสร็จสิ้นแล้ว", Ahe = "ชำระแล้ว", bhe = "ยังไม่ชำระ", yhe = "คืนเงินแล้ว", vhe = "ข้อผิดพลาดในการอนุญาต", The = "{0} ได้ขอชำระเงินจากคุณ", _he = "ไปชำระเงิน", Ehe = "การชำระเงินล้มเหลว", xhe = "กรุณาตรวจสอบบัญชีของคุณและลองใหม่อีกครั้ง", whe = "ชำระเงินให้ {0}", Che = "ไม่มี", She = "{0} ส่งคำขอชำระเงิน", Ihe = "{0} ส่งการชำระเงิน", khe = {
  close: sde,
  confirm: ade,
  folderName: ode,
  createFolder: ude,
  tag: lde,
  inputTag: cde,
  inputTagPlaceholder: dde,
  download: fde,
  someoneUnsentMessage: hde,
  read: pde,
  pin: mde,
  unpin: gde,
  emptyChat: Ade,
  members: bde,
  createdAt: yde,
  updatedAt: vde,
  leaveGroup: Tde,
  text: _de,
  image: Ede,
  video: xde,
  sticker: wde,
  message: Cde,
  youSent: Sde,
  someoneSent: Ide,
  tapOpen: kde,
  TypeMessage: Dde,
  isTyping: Mde,
  someoneJoinedTheChat: Ode,
  someoneLeftTheChat: Nde,
  someoneInvited: Lde,
  someoneKicked: Pde,
  youUnsentMessage: Rde,
  fileSize: Bde,
  file: Fde,
  translation: Ude,
  search: $de,
  location: Hde,
  sendCurrentLocation: jde,
  noAccessLocationPermission: zde,
  "locationInfoUnavailable.": "ข้อมูลตำแหน่งไม่พร้อมใช้งาน",
  requestLocationTimeout: qde,
  addressUnavailable: Vde,
  audio: Wde,
  noAccessMicrophonePermission: Qde,
  removeFromFolder: Gde,
  editFolder: Yde,
  addToFolder: Xde,
  numberOfChatroom: Kde,
  roomName: Zde,
  roomMember: Jde,
  roomPrefTags: efe,
  roomPrefFolder: tfe,
  roomTags: nfe,
  massTexting: rfe,
  inputMessage: ife,
  searchInConversation: sfe,
  yesterday: afe,
  today: ofe,
  confirmToDeleteFolder: ufe,
  hide: lfe,
  unhide: cfe,
  delete: "ลบ",
  cancel: dfe,
  create: ffe,
  save: hfe,
  createTag: pfe,
  confirmDeleteTag: mfe,
  editTag: gfe,
  chooseColor: Afe,
  duplicateTagName: bfe,
  block: yfe,
  unblock: vfe,
  textareaBlockedHint: Tfe,
  mute: _fe,
  unmute: Efe,
  chatroomDeleteConfirmationTitle: xfe,
  chatroomDeleteConfirmationMessage: wfe,
  unreadMessages: Cfe,
  deleteMessageConfirmation: Sfe,
  deleteForEveryone: Ife,
  deleteForMe: kfe,
  confirmDeleteMessage: Dfe,
  deleteForEveryoneWarning: Mfe,
  deleteForMeWarning: Ofe,
  messages: Nfe,
  foundMessages: Lfe,
  moveOut: Pfe,
  kickOutConfirmTitle: Rfe,
  kickOutConfirmTip: Bfe,
  kickOutGroup: Ffe,
  kickOutErrorTitle: Ufe,
  kickOutErrorDesc: $fe,
  fileSizeLimitTitle: Hfe,
  fileSizeLimitMessage: jfe,
  "online-status-online": "ออนไลน์",
  "online-status-offline": "ออฟไลน์",
  Request: zfe,
  emailFromatError: qfe,
  chatbotSwitch: Vfe,
  chatbotSwitchDescription: Wfe,
  allowOfflineNotifications: Qfe,
  notificationPermissionDescription: Gfe,
  notificationSettingsPath: Yfe,
  askLater: Xfe,
  allowNotifications: Kfe,
  you: Zfe,
  submit: Jfe,
  status: ehe,
  currency: the,
  paymentCollectionTitle: nhe,
  paymentCollectionNotSet: rhe,
  paymentCollectionNotSetDescription: ihe,
  paymentGoToSetting: she,
  paymentSendRequestMessage: ahe,
  paymentMethods: ohe,
  paymentSupportedMethods: uhe,
  paymentRequestMessage: lhe,
  paymentInputMessageOptional: che,
  paymentRequestedFrom: dhe,
  paymentViewDetails: fhe,
  paymentRequestDetail: hhe,
  paymentDetail: phe,
  paymentRequestTime: mhe,
  paymentCompleted: ghe,
  paymentFlowPaid: Ahe,
  paymentFlowUnpaid: bhe,
  paymentFlowRefund: yhe,
  paymentFlowAuthorizationError: vhe,
  paymentRequestedFromYou: The,
  paymentGoToPay: _he,
  paymentFailed: Ehe,
  paymentFailedDescription: xhe,
  paymentPaidTo: whe,
  paymentSendPaymentRequestMessageEmpty: Che,
  paymentSendPaymentRequestMessage: She,
  paymentSendPaymentMessage: Ihe
}, Dhe = "Đóng", Mhe = "Xác nhận", Ohe = "Tên thư mục", Nhe = "Tạo thư mục", Lhe = "Thẻ", Phe = "Nhập tên thẻ", Rhe = "Vui lòng nhập màu tùy chỉnh như #02B13F", Bhe = "Tải xuống", Fhe = "{0} đã thu hồi một tin nhắn", Uhe = "Đã đọc", $he = "Ghim", Hhe = "Bỏ ghim", jhe = "Không có thành viên", zhe = "Thành viên", qhe = "Được tạo lúc", Vhe = "Được cập nhật lúc", Whe = "Rời nhóm", Qhe = "Văn bản", Ghe = "Hình ảnh", Yhe = "Video", Xhe = "Nhãn dán", Khe = "Tin nhắn", Zhe = "{0} đã gửi", Jhe = "{0} đã gửi cho bạn {1}", epe = "Nhấn vào đây để mở liên kết này.", tpe = "Nhập tin nhắn...", npe = "{0} đang nhập...", rpe = "{0} đã tham gia cuộc trò chuyện", ipe = "{0} đã rời cuộc trò chuyện", spe = "{0} đã mời {1}", ape = "{0} đã đuổi {1}", ope = "Bạn đã thu hồi một tin nhắn", upe = "Kích thước tệp", lpe = "Tệp", cpe = "Dịch", dpe = "Tìm kiếm", fpe = "Vị trí", hpe = "Gửi vị trí hiện tại", ppe = "Không có quyền truy cập vị trí", mpe = "Yêu cầu vị trí đã hết thời gian", gpe = "Địa chỉ không khả dụng", Ape = "Tin nhắn thoại", bpe = "Không có quyền truy cập micrô", ype = "Xóa khỏi thư mục", vpe = "Chỉnh sửa thư mục", Tpe = "Thêm vào thư mục", _pe = "{n} phòng trò chuyện", Epe = "Tên phòng", xpe = "Thành viên", wpe = "Thẻ", Cpe = "Thư mục", Spe = "Thuộc tính", Ipe = "Nhắn tin hàng loạt", kpe = "Vui lòng nhập nội dung tin nhắn", Dpe = "Tìm kiếm trong cuộc trò chuyện", Mpe = "Hôm qua", Ope = "Hôm nay", Npe = "Xóa thư mục?", Lpe = "Ẩn", Ppe = "Hiện", Rpe = "Hủy", Bpe = "Tạo", Fpe = "Lưu", Upe = "Nhập tên thẻ", $pe = "Xác nhận xóa thẻ?", Hpe = "Chỉnh sửa thẻ", jpe = "Chọn màu", zpe = "Thẻ đã tồn tại. Dùng tên khác.", qpe = "Chặn", Vpe = "Bỏ chặn", Wpe = "Người dùng này đã bị chặn.", Qpe = "Tắt thông báo", Gpe = "Bật thông báo", Ype = "Xác nhận xóa phòng trò chuyện?", Xpe = "Sau khi xóa phòng trò chuyện, bạn sẽ không thể xem lịch sử trò chuyện trước đó. Phòng trò chuyện từ góc nhìn của người kia sẽ không bị ảnh hưởng và họ vẫn có thể gửi tin nhắn mới cho bạn.", Kpe = "Dưới đây là tin nhắn chưa đọc", Zpe = "Bạn muốn xóa tin nhắn này như thế nào?", Jpe = "Xóa cho tất cả mọi người", eme = "Chỉ xóa cho tôi", tme = "Xác nhận xóa tin nhắn?", nme = "Tin nhắn bạn đã chọn sẽ bị xóa khỏi tất cả các phòng trò chuyện. Hành động này không thể hoàn tác.", rme = "Tin nhắn bạn đã chọn sẽ chỉ bị xóa khỏi phòng trò chuyện của bạn. Người kia vẫn có thể thấy tin nhắn trong phòng trò chuyện. Hành động này không thể hoàn tác.", ime = "Tin nhắn", sme = "Tìm thấy {0} tin nhắn", ame = "Bạn có chắc muốn xóa {0} khỏi nhóm không?", ome = "Sau khi bị xóa, thành viên sẽ không thể xem tin nhắn nhóm nữa.", ume = "Xóa", lme = "Đá ra khỏi nhóm", cme = "Khởi động các thành viên không thành công", dme = "Các hoạt động kick-out không thể được hoàn thành hiện tại. Vui lòng xác nhận kết nối mạng hoặc thử lại sau.", fme = "Tệp quá lớn", hme = "Tệp bạn chọn vượt quá kích thước tối đa cho phép {0}. Vui lòng chọn tệp nhỏ hơn.", pme = { Message: { email: { submit: "Email đã được gửi", placeholder: "Nhập email của bạn" }, phone: { placeholder: "Nhập số điện thoại của bạn", submit: "Số điện thoại đã được gửi" }, text: { submit: "Văn bản đã được gửi", placeholder: "Nhập nội dung văn bản" } } }, mme = "Vui lòng nhập đúng định dạng", gme = "Bot trò chuyện", Ame = "Bật bot trò chuyện, bot sẽ phản hồi người khác theo quy trình bạn đã thiết lập. Tắt bot trò chuyện, bạn có thể vào chế độ phản hồi của người thật.", bme = "Cho phép thông báo đẩy ngoại tuyến", yme = "Sau khi bật, khi có tin nhắn mới đến, bạn sẽ nhận được thông báo trên màn hình ngay cả khi cuộc trò chuyện không mở.", vme = "Cài đặt này có thể được sửa đổi trong [Tài khoản của tôi > Cài đặt thông báo].", Tme = "Hỏi sau", _me = "Cho phép thông báo", Eme = "Bạn", xme = "Gửi", wme = "Trạng thái", Cme = "Tiền tệ", Sme = "Thu tiền", Ime = "Chưa thiết lập phương thức thanh toán", kme = "Bạn chưa thiết lập phương thức thanh toán. Vui lòng vào [Tài khoản của tôi > Cài đặt thanh toán phòng chat] để hoàn tất thiết lập và bắt đầu gửi yêu cầu thanh toán.", Dme = "Đi tới cài đặt", Mme = "Gửi tin nhắn yêu cầu thanh toán", Ome = "Phương thức thanh toán", Nme = "Phương thức thanh toán được hỗ trợ", Lme = "Tin nhắn yêu cầu thanh toán", Pme = "Nhập tin nhắn (tùy chọn)", Rme = "Đã yêu cầu thanh toán từ {0}", Bme = "Xem chi tiết", Fme = "Chi tiết yêu cầu", Ume = "Chi tiết thanh toán", $me = "Thời gian yêu cầu", Hme = "{0} đã hoàn thành thanh toán", jme = "Đã thanh toán", zme = "Chưa thanh toán", qme = "Đã hoàn tiền", Vme = "Lỗi ủy quyền", Wme = "{0} đã yêu cầu thanh toán từ bạn", Qme = "Đi thanh toán", Gme = "Thanh toán thất bại", Yme = "Vui lòng kiểm tra tài khoản và thử lại.", Xme = "Đã thanh toán cho {0}", Kme = "Không có", Zme = "{0} đã gửi yêu cầu thanh toán", Jme = "{0} đã gửi thanh toán", e0e = {
  close: Dhe,
  confirm: Mhe,
  folderName: Ohe,
  createFolder: Nhe,
  tag: Lhe,
  inputTag: Phe,
  inputTagPlaceholder: Rhe,
  download: Bhe,
  someoneUnsentMessage: Fhe,
  read: Uhe,
  pin: $he,
  unpin: Hhe,
  emptyChat: jhe,
  members: zhe,
  createdAt: qhe,
  updatedAt: Vhe,
  leaveGroup: Whe,
  text: Qhe,
  image: Ghe,
  video: Yhe,
  sticker: Xhe,
  message: Khe,
  youSent: Zhe,
  someoneSent: Jhe,
  tapOpen: epe,
  TypeMessage: tpe,
  isTyping: npe,
  someoneJoinedTheChat: rpe,
  someoneLeftTheChat: ipe,
  someoneInvited: spe,
  someoneKicked: ape,
  youUnsentMessage: ope,
  fileSize: upe,
  file: lpe,
  translation: cpe,
  search: dpe,
  location: fpe,
  sendCurrentLocation: hpe,
  noAccessLocationPermission: ppe,
  "locationInfoUnavailable.": "Thông tin vị trí không khả dụng",
  requestLocationTimeout: mpe,
  addressUnavailable: gpe,
  audio: Ape,
  noAccessMicrophonePermission: bpe,
  removeFromFolder: ype,
  editFolder: vpe,
  addToFolder: Tpe,
  numberOfChatroom: _pe,
  roomName: Epe,
  roomMember: xpe,
  roomPrefTags: wpe,
  roomPrefFolder: Cpe,
  roomTags: Spe,
  massTexting: Ipe,
  inputMessage: kpe,
  searchInConversation: Dpe,
  yesterday: Mpe,
  today: Ope,
  confirmToDeleteFolder: Npe,
  hide: Lpe,
  unhide: Ppe,
  delete: "Xóa",
  cancel: Rpe,
  create: Bpe,
  save: Fpe,
  createTag: Upe,
  confirmDeleteTag: $pe,
  editTag: Hpe,
  chooseColor: jpe,
  duplicateTagName: zpe,
  block: qpe,
  unblock: Vpe,
  textareaBlockedHint: Wpe,
  mute: Qpe,
  unmute: Gpe,
  chatroomDeleteConfirmationTitle: Ype,
  chatroomDeleteConfirmationMessage: Xpe,
  unreadMessages: Kpe,
  deleteMessageConfirmation: Zpe,
  deleteForEveryone: Jpe,
  deleteForMe: eme,
  confirmDeleteMessage: tme,
  deleteForEveryoneWarning: nme,
  deleteForMeWarning: rme,
  messages: ime,
  foundMessages: sme,
  kickOutConfirmTitle: ame,
  kickOutConfirmTip: ome,
  moveOut: ume,
  kickOutGroup: lme,
  kickOutErrorTitle: cme,
  kickOutErrorDesc: dme,
  fileSizeLimitTitle: fme,
  fileSizeLimitMessage: hme,
  "online-status-online": "Đang hoạt động",
  "online-status-offline": "Không hoạt động",
  Request: pme,
  emailFromatError: mme,
  chatbotSwitch: gme,
  chatbotSwitchDescription: Ame,
  allowOfflineNotifications: bme,
  notificationPermissionDescription: yme,
  notificationSettingsPath: vme,
  askLater: Tme,
  allowNotifications: _me,
  you: Eme,
  submit: xme,
  status: wme,
  currency: Cme,
  paymentCollectionTitle: Sme,
  paymentCollectionNotSet: Ime,
  paymentCollectionNotSetDescription: kme,
  paymentGoToSetting: Dme,
  paymentSendRequestMessage: Mme,
  paymentMethods: Ome,
  paymentSupportedMethods: Nme,
  paymentRequestMessage: Lme,
  paymentInputMessageOptional: Pme,
  paymentRequestedFrom: Rme,
  paymentViewDetails: Bme,
  paymentRequestDetail: Fme,
  paymentDetail: Ume,
  paymentRequestTime: $me,
  paymentCompleted: Hme,
  paymentFlowPaid: jme,
  paymentFlowUnpaid: zme,
  paymentFlowRefund: qme,
  paymentFlowAuthorizationError: Vme,
  paymentRequestedFromYou: Wme,
  paymentGoToPay: Qme,
  paymentFailed: Gme,
  paymentFailedDescription: Yme,
  paymentPaidTo: Xme,
  paymentSendPaymentRequestMessageEmpty: Kme,
  paymentSendPaymentRequestMessage: Zme,
  paymentSendPaymentMessage: Jme
}, t0e = "关闭", n0e = "确认", r0e = "资料夹名称", i0e = "建立资料夹", s0e = "标签", a0e = "输入标签名称", o0e = "请输入自订色彩例如 #02B13F", u0e = "下载", l0e = "{0} 已收回讯息", c0e = "已读", d0e = "置顶", f0e = "取消置顶", h0e = "没有成员", p0e = "成员", m0e = "创建时间", g0e = "更新时间", A0e = "退出群组", b0e = "文字", y0e = "图片", v0e = "影片", T0e = "贴图", _0e = "讯息", E0e = "{0}已传送", x0e = "{0}向您传送了{1}", w0e = "点选此处以开启此连结。", C0e = "输入讯息...", S0e = "{0} 正在输入...", I0e = "{0}加入聊天", k0e = "{0}离开聊天", D0e = "{0}邀请{1}加入", M0e = "{0}将{1}踢出", O0e = "您已收回讯息", N0e = "档案大小", L0e = "档案", P0e = "翻译", R0e = "搜寻", B0e = "位置", F0e = "传送目前位置", U0e = "无存取位置权限", $0e = "请求位置逾时", H0e = "无法取得地址", j0e = "语音讯息", z0e = "无存取麦克风权限", q0e = "从资料夹中移除", V0e = "编辑资料夹", W0e = "新增至资料夹", Q0e = "{n} 个聊天室", G0e = "聊天室名称", Y0e = "成员", X0e = "标签", K0e = "资料夹", Z0e = "属性", J0e = "群发讯息", ege = "请输入讯息内容", tge = "搜寻对话", nge = "昨天", rge = "今天", ige = "删除资料夹？", sge = "隐藏", age = "取消隐藏", oge = "取消", uge = "建立", lge = "储存", cge = "输入标签名称", dge = "确认删除标签?", fge = "编辑标签", hge = "选择颜色", pge = "标签已存在，请换个名称", mge = "封锁", gge = "解封锁", Age = "此用户已被封锁。", bge = "关闭通知", yge = "开启通知", vge = "确认要删除聊天室吗？", Tge = "删除聊天室后，您将无法再查看此聊天室过去的聊天记录。对方视角下的聊天室将不受任何影响，且还是可以发送新消息给您。", _ge = "以下为尚未阅读的消息", Ege = "您想如何删除消息？", xge = "为所有人删除", wge = "只为自己删除", Cge = "确认要删除这条消息吗？", Sge = "您选择的消息会从所有人的聊天室中删除。此操作无法恢复。", Ige = "您选择的消息只会从您的聊天室删除，对方还是可以在聊天室内看到消息。此操作无法恢复。", kge = "消息", Dge = "找到 {0} 条消息", Mge = "踢出", Oge = "确定要将 {0} 移出群组吗？", Nge = "成员被移出后，将无法再查看群组消息。", Lge = "踢出群组", Pge = "踢出成员失败", Rge = "目前无法完成踢出操作，请确认网路连线或稍后再试。", Bge = "文件过大", Fge = "所选文件超过 {0} 的大小限制。请选择较小的文件。", Uge = { Message: { email: { submit: "已送出Email", placeholder: "输入信箱" }, phone: { placeholder: "输入手机号码", submit: "已送出手机号码" }, text: { submit: "已送出文字回复", placeholder: "输入文字回复" } } }, $ge = "请输入正确格式", Hge = "聊天机器人开关", jge = "开启聊天机器人，机器人会依照您设定的流程回应对方。关闭机器人，可以进入真人回复模式", zge = "允许离线推送通知", qge = "允许后，当有新讯息传来时，即使聊天室页面未开启，你也会收到桌面推送通知。", Vge = "这个设置可以在【我的帐号 > 讯息通知设置】中修改。", Wge = "稍后再说", Qge = "允许通知", Gge = "您", Yge = "提交", Xge = "状态", Kge = "货币", Zge = "收款", Jge = "未设置付款方式", e1e = "您尚未设置付款方式。请前往【我的账户 > 聊天室付款设置】完成设置并开始发送付款请求。", t1e = "前往设置", n1e = "发送付款请求消息", r1e = "付款方式", i1e = "支持的付款方式", s1e = "付款请求消息", a1e = "输入消息（可选）", o1e = "已向 {0} 请求付款", u1e = "查看详情", l1e = "请求详情", c1e = "付款详情", d1e = "请求时间", f1e = "{0} 已完成付款", h1e = "已付款", p1e = "未付款", m1e = "已退款", g1e = "授权错误", A1e = "{0} 向您请求付款", b1e = "前往付款", y1e = "付款失败", v1e = "请检查您的账户并重试。", T1e = "已付款至 {0}", _1e = "无", E1e = "{0} 发送了付款请求", x1e = "{0} 发送了付款", w1e = {
  close: t0e,
  confirm: n0e,
  folderName: r0e,
  createFolder: i0e,
  tag: s0e,
  inputTag: a0e,
  inputTagPlaceholder: o0e,
  download: u0e,
  someoneUnsentMessage: l0e,
  read: c0e,
  pin: d0e,
  unpin: f0e,
  emptyChat: h0e,
  members: p0e,
  createdAt: m0e,
  updatedAt: g0e,
  leaveGroup: A0e,
  text: b0e,
  image: y0e,
  video: v0e,
  sticker: T0e,
  message: _0e,
  youSent: E0e,
  someoneSent: x0e,
  tapOpen: w0e,
  TypeMessage: C0e,
  isTyping: S0e,
  someoneJoinedTheChat: I0e,
  someoneLeftTheChat: k0e,
  someoneInvited: D0e,
  someoneKicked: M0e,
  youUnsentMessage: O0e,
  fileSize: N0e,
  file: L0e,
  translation: P0e,
  search: R0e,
  location: B0e,
  sendCurrentLocation: F0e,
  noAccessLocationPermission: U0e,
  "locationInfoUnavailable.": "无法取得位置资讯",
  requestLocationTimeout: $0e,
  addressUnavailable: H0e,
  audio: j0e,
  noAccessMicrophonePermission: z0e,
  removeFromFolder: q0e,
  editFolder: V0e,
  addToFolder: W0e,
  numberOfChatroom: Q0e,
  roomName: G0e,
  roomMember: Y0e,
  roomPrefTags: X0e,
  roomPrefFolder: K0e,
  roomTags: Z0e,
  massTexting: J0e,
  inputMessage: ege,
  searchInConversation: tge,
  yesterday: nge,
  today: rge,
  confirmToDeleteFolder: ige,
  hide: sge,
  unhide: age,
  delete: "删除",
  cancel: oge,
  create: uge,
  save: lge,
  createTag: cge,
  confirmDeleteTag: dge,
  editTag: fge,
  chooseColor: hge,
  duplicateTagName: pge,
  block: mge,
  unblock: gge,
  textareaBlockedHint: Age,
  mute: bge,
  unmute: yge,
  chatroomDeleteConfirmationTitle: vge,
  chatroomDeleteConfirmationMessage: Tge,
  unreadMessages: _ge,
  deleteMessageConfirmation: Ege,
  deleteForEveryone: xge,
  deleteForMe: wge,
  confirmDeleteMessage: Cge,
  deleteForEveryoneWarning: Sge,
  deleteForMeWarning: Ige,
  messages: kge,
  foundMessages: Dge,
  moveOut: Mge,
  kickOutConfirmTitle: Oge,
  kickOutConfirmTip: Nge,
  kickOutGroup: Lge,
  kickOutErrorTitle: Pge,
  kickOutErrorDesc: Rge,
  fileSizeLimitTitle: Bge,
  fileSizeLimitMessage: Fge,
  "online-status-online": "上线中",
  "online-status-offline": "离线中",
  Request: Uge,
  emailFromatError: $ge,
  chatbotSwitch: Hge,
  chatbotSwitchDescription: jge,
  allowOfflineNotifications: zge,
  notificationPermissionDescription: qge,
  notificationSettingsPath: Vge,
  askLater: Wge,
  allowNotifications: Qge,
  you: Gge,
  submit: Yge,
  status: Xge,
  currency: Kge,
  paymentCollectionTitle: Zge,
  paymentCollectionNotSet: Jge,
  paymentCollectionNotSetDescription: e1e,
  paymentGoToSetting: t1e,
  paymentSendRequestMessage: n1e,
  paymentMethods: r1e,
  paymentSupportedMethods: i1e,
  paymentRequestMessage: s1e,
  paymentInputMessageOptional: a1e,
  paymentRequestedFrom: o1e,
  paymentViewDetails: u1e,
  paymentRequestDetail: l1e,
  paymentDetail: c1e,
  paymentRequestTime: d1e,
  paymentCompleted: f1e,
  paymentFlowPaid: h1e,
  paymentFlowUnpaid: p1e,
  paymentFlowRefund: m1e,
  paymentFlowAuthorizationError: g1e,
  paymentRequestedFromYou: A1e,
  paymentGoToPay: b1e,
  paymentFailed: y1e,
  paymentFailedDescription: v1e,
  paymentPaidTo: T1e,
  paymentSendPaymentRequestMessageEmpty: _1e,
  paymentSendPaymentRequestMessage: E1e,
  paymentSendPaymentMessage: x1e
}, C1e = "關閉", S1e = "確認", I1e = "資料夾名稱", k1e = "建立資料夾", D1e = "標籤", M1e = "輸入標籤名稱", O1e = "請輸入自訂色彩例如 #02B13F", N1e = "下載", L1e = "{0} 已收回訊息", P1e = "已讀", R1e = "置頂", B1e = "取消置頂", F1e = "沒有成員", U1e = "成員", $1e = "創建時間", H1e = "更新時間", j1e = "退出群組", z1e = "文字", q1e = "圖片", V1e = "影片", W1e = "貼圖", Q1e = "訊息", G1e = "{0}已傳送", Y1e = "{0}向您傳送了{1}", X1e = "點選此處以開啟此連結。", K1e = "輸入訊息...", Z1e = "{0} 正在輸入...", J1e = "{0}加入聊天", eAe = "{0}離開聊天", tAe = "{0}邀請{1}加入", nAe = "{0}將{1}踢出", rAe = "您已收回訊息", iAe = "檔案大小", sAe = "檔案", aAe = "翻譯", oAe = "搜尋", uAe = "位置", lAe = "傳送目前位置", cAe = "無存取位置權限", dAe = "請求位置逾時", fAe = "無法取得地址", hAe = "語音訊息", pAe = "無存取麥克風權限", mAe = "從資料夾中移除", gAe = "編輯資料夾", AAe = "新增至資料夾", bAe = "{n} 個聊天室", yAe = "聊天室名稱", vAe = "成員", TAe = "標籤", _Ae = "資料夾", EAe = "屬性", xAe = "群發訊息", wAe = "請輸入訊息內容", CAe = "搜尋對話", SAe = "昨天", IAe = "今天", kAe = "刪除資料夾？", DAe = "隱藏", MAe = "取消隱藏", OAe = "取消", NAe = "建立", LAe = "儲存", PAe = "輸入標籤名稱", RAe = "確認刪除標籤?", BAe = "編輯標籤", FAe = "選擇顏色", UAe = "此標籤已存在，請改用其他名稱", $Ae = "封鎖", HAe = "解封鎖", jAe = "此用戶已被封鎖。", zAe = "關閉通知", qAe = "開啟通知", VAe = "確認要刪除聊天室嗎？", WAe = "刪除聊天室後，您將無法再檢視此聊天室過去的聊天記錄。對方視角下的聊天室將不受任何影響，且還是可以傳新訊息給您。", QAe = "以下為尚未閱讀的訊息", GAe = "您想如何刪除訊息？", YAe = "為所有人刪除", XAe = "只為自己刪除", KAe = "確認要刪除這則訊息嗎？", ZAe = "您選擇的訊息會從所有人的聊天室中刪除。此操作無法復原。", JAe = "您選擇的訊息只會從您的聊天室刪除，對方還是可以在聊天室內看到訊息。此操作無法復原。", e2e = "訊息", t2e = "找到 {0} 則訊息", n2e = "移出", r2e = "確定要將 {0} 踢出群組嗎？", i2e = "成員被移出後，將無法再查看群組訊息。", s2e = "踢出群組", a2e = "踢出成員失敗", o2e = "目前無法完成踢出操作，請確認網路連線或稍後再試。", u2e = "檔案過大", l2e = "所選檔案超過 {0} 的大小限制。請選擇較小的檔案。", c2e = { Message: { email: { submit: "已送出Email", placeholder: "輸入信箱" }, phone: { placeholder: "輸入手機號碼", submit: "已送出手機號碼" }, text: { submit: "已送出文字回覆", placeholder: "輸入文字回覆" } } }, d2e = "請輸入正確格式", f2e = "聊天機器人開關", h2e = "開啟聊天機器人，機器人會依照您設定的流程回應對方。關閉機器人，可以進入真人回覆模式", p2e = "允許離線推播通知", m2e = "允許後，當有新訊息傳來時，即使聊天室頁面未開啟，你也會收到桌面推播通知。", g2e = "這個設定可以在【我的帳號 > 訊息通知設定】中修改。", A2e = "稍後再說", b2e = "允許通知", y2e = "您", v2e = "送出", T2e = "狀態", _2e = "幣別", E2e = "收款", x2e = "尚未設定收款方式", w2e = "您尚未設定任何收款方式，請前往【我的帳號 > 聊天室金流設定】完成設定後，即可發送收款訊息給對方。", C2e = "前往設定", S2e = "傳送請求付款訊息", I2e = "付款方式", k2e = "支援的付款方式", D2e = "請款訊息", M2e = "輸入訊息（選填）", O2e = "已向 {0} 請款", N2e = "查看詳情", L2e = "請款詳細", P2e = "付款詳細", R2e = "請款時間", B2e = "{0} 已支付款項", F2e = "已付款", U2e = "未付款", $2e = "退款", H2e = "授權錯誤", j2e = "{0} 向您請款", z2e = "前往付款", q2e = "付款失敗", V2e = "請確認您的帳戶並重新付款。", W2e = "已支付給 ${0}", Q2e = "無", G2e = "{0}傳送了請款訊息", Y2e = "{0}傳送了付款訊息", X2e = {
  close: C1e,
  confirm: S1e,
  folderName: I1e,
  createFolder: k1e,
  tag: D1e,
  inputTag: M1e,
  inputTagPlaceholder: O1e,
  download: N1e,
  someoneUnsentMessage: L1e,
  read: P1e,
  pin: R1e,
  unpin: B1e,
  emptyChat: F1e,
  members: U1e,
  createdAt: $1e,
  updatedAt: H1e,
  leaveGroup: j1e,
  text: z1e,
  image: q1e,
  video: V1e,
  sticker: W1e,
  message: Q1e,
  youSent: G1e,
  someoneSent: Y1e,
  tapOpen: X1e,
  TypeMessage: K1e,
  isTyping: Z1e,
  someoneJoinedTheChat: J1e,
  someoneLeftTheChat: eAe,
  someoneInvited: tAe,
  someoneKicked: nAe,
  youUnsentMessage: rAe,
  fileSize: iAe,
  file: sAe,
  translation: aAe,
  search: oAe,
  location: uAe,
  sendCurrentLocation: lAe,
  noAccessLocationPermission: cAe,
  "locationInfoUnavailable.": "無法取得位置資訊",
  requestLocationTimeout: dAe,
  addressUnavailable: fAe,
  audio: hAe,
  noAccessMicrophonePermission: pAe,
  removeFromFolder: mAe,
  editFolder: gAe,
  addToFolder: AAe,
  numberOfChatroom: bAe,
  "no-chatroom": "沒有聊天室",
  roomName: yAe,
  roomMember: vAe,
  roomPrefTags: TAe,
  roomPrefFolder: _Ae,
  roomTags: EAe,
  massTexting: xAe,
  inputMessage: wAe,
  searchInConversation: CAe,
  yesterday: SAe,
  today: IAe,
  confirmToDeleteFolder: kAe,
  hide: DAe,
  unhide: MAe,
  delete: "刪除",
  cancel: OAe,
  create: NAe,
  save: LAe,
  createTag: PAe,
  confirmDeleteTag: RAe,
  editTag: BAe,
  chooseColor: FAe,
  duplicateTagName: UAe,
  block: $Ae,
  unblock: HAe,
  textareaBlockedHint: jAe,
  mute: zAe,
  unmute: qAe,
  chatroomDeleteConfirmationTitle: VAe,
  chatroomDeleteConfirmationMessage: WAe,
  unreadMessages: QAe,
  deleteMessageConfirmation: GAe,
  deleteForEveryone: YAe,
  deleteForMe: XAe,
  confirmDeleteMessage: KAe,
  deleteForEveryoneWarning: ZAe,
  deleteForMeWarning: JAe,
  messages: e2e,
  foundMessages: t2e,
  moveOut: n2e,
  kickOutConfirmTitle: r2e,
  kickOutConfirmTip: i2e,
  kickOutGroup: s2e,
  kickOutErrorTitle: a2e,
  kickOutErrorDesc: o2e,
  fileSizeLimitTitle: u2e,
  fileSizeLimitMessage: l2e,
  "online-status-online": "上線中",
  "online-status-offline": "離線中",
  Request: c2e,
  emailFromatError: d2e,
  chatbotSwitch: f2e,
  chatbotSwitchDescription: h2e,
  allowOfflineNotifications: p2e,
  notificationPermissionDescription: m2e,
  notificationSettingsPath: g2e,
  askLater: A2e,
  allowNotifications: b2e,
  you: y2e,
  submit: v2e,
  status: T2e,
  currency: _2e,
  paymentCollectionTitle: E2e,
  paymentCollectionNotSet: x2e,
  paymentCollectionNotSetDescription: w2e,
  paymentGoToSetting: C2e,
  paymentSendRequestMessage: S2e,
  paymentMethods: I2e,
  paymentSupportedMethods: k2e,
  paymentRequestMessage: D2e,
  paymentInputMessageOptional: M2e,
  paymentRequestedFrom: O2e,
  paymentViewDetails: N2e,
  paymentRequestDetail: L2e,
  paymentDetail: P2e,
  paymentRequestTime: R2e,
  paymentCompleted: B2e,
  paymentFlowPaid: F2e,
  paymentFlowUnpaid: U2e,
  paymentFlowRefund: $2e,
  paymentFlowAuthorizationError: H2e,
  paymentRequestedFromYou: j2e,
  paymentGoToPay: z2e,
  paymentFailed: q2e,
  paymentFailedDescription: V2e,
  paymentPaidTo: W2e,
  paymentSendPaymentRequestMessageEmpty: Q2e,
  paymentSendPaymentRequestMessage: G2e,
  paymentSendPaymentMessage: Y2e
}, WE = {
  "de-DE": VQ,
  "en-US": gX,
  "es-ES": HZ,
  "fr-FR": fte,
  "ja-JP": Bre,
  "ko-KR": uae,
  "pt-PT": Nue,
  "ro-RO": ide,
  "th-TH": khe,
  "vi-VN": e0e,
  "zh-CN": w1e,
  "zh-TW": X2e
}, zr = lV({
  legacy: !1,
  locale: typeof navigator < "u" && navigator.language in WE ? navigator.language : "en-US",
  messages: WE
});
var mp = { exports: {} }, gp = { exports: {} }, QE;
function $v() {
  return QE || (QE = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = n;
    function n(r) {
      if (r == null) throw new TypeError("Expected a string but received a ".concat(r));
      if (r.constructor.name !== "String") throw new TypeError("Expected a string but received a ".concat(r.constructor.name));
    }
    t.exports = e.default, t.exports.default = e.default;
  }(gp, gp.exports)), gp.exports;
}
var Ap = { exports: {} }, GE;
function K2e() {
  return GE || (GE = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = r;
    function n(i) {
      return Object.prototype.toString.call(i) === "[object RegExp]";
    }
    function r(i, s) {
      for (var a = 0; a < s.length; a++) {
        var o = s[a];
        if (i === o || n(o) && o.test(i))
          return !0;
      }
      return !1;
    }
    t.exports = e.default, t.exports.default = e.default;
  }(Ap, Ap.exports)), Ap.exports;
}
var bp = { exports: {} }, YE;
function Z2e() {
  return YE || (YE = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = void 0;
    var n = function(i, s) {
      return i.indexOf(s) !== -1;
    };
    e.default = n, t.exports = e.default, t.exports.default = e.default;
  }(bp, bp.exports)), bp.exports;
}
var yp = { exports: {} }, vp = { exports: {} }, XE;
function xk() {
  return XE || (XE = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = n;
    function n() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
      for (var s in i)
        typeof r[s] > "u" && (r[s] = i[s]);
      return r;
    }
    t.exports = e.default, t.exports.default = e.default;
  }(vp, vp.exports)), vp.exports;
}
var KE;
function J2e() {
  return KE || (KE = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = a;
    var n = i(/* @__PURE__ */ $v()), r = i(/* @__PURE__ */ xk());
    function i(o) {
      return o && o.__esModule ? o : { default: o };
    }
    var s = {
      require_tld: !0,
      allow_underscores: !1,
      allow_trailing_dot: !1,
      allow_numeric_tld: !1,
      allow_wildcard: !1,
      ignore_max_length: !1
    };
    function a(o, u) {
      (0, n.default)(o), u = (0, r.default)(u, s), u.allow_trailing_dot && o[o.length - 1] === "." && (o = o.substring(0, o.length - 1)), u.allow_wildcard === !0 && o.indexOf("*.") === 0 && (o = o.substring(2));
      var c = o.split("."), d = c[c.length - 1];
      return u.require_tld && (c.length < 2 || !u.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(d) || /\s/.test(d)) || !u.allow_numeric_tld && /^\d+$/.test(d) ? !1 : c.every(function(l) {
        return !(l.length > 63 && !u.ignore_max_length || !/^[a-z_\u00a1-\uffff0-9-]+$/i.test(l) || /[\uff01-\uff5e]/.test(l) || /^-|-$/.test(l) || !u.allow_underscores && /_/.test(l));
      });
    }
    t.exports = e.default, t.exports.default = e.default;
  }(yp, yp.exports)), yp.exports;
}
var Tp = { exports: {} }, ZE;
function ebe() {
  return ZE || (ZE = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = d;
    var n = r(/* @__PURE__ */ $v());
    function r(l) {
      return l && l.__esModule ? l : { default: l };
    }
    function i(l) {
      "@babel/helpers - typeof";
      return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
        return typeof f;
      } : function(f) {
        return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
      }, i(l);
    }
    var s = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])", a = "(".concat(s, "[.]){3}").concat(s), o = new RegExp("^".concat(a, "$")), u = "(?:[0-9a-fA-F]{1,4})", c = new RegExp("^(" + "(?:".concat(u, ":){7}(?:").concat(u, "|:)|") + "(?:".concat(u, ":){6}(?:").concat(a, "|:").concat(u, "|:)|") + "(?:".concat(u, ":){5}(?::").concat(a, "|(:").concat(u, "){1,2}|:)|") + "(?:".concat(u, ":){4}(?:(:").concat(u, "){0,1}:").concat(a, "|(:").concat(u, "){1,3}|:)|") + "(?:".concat(u, ":){3}(?:(:").concat(u, "){0,2}:").concat(a, "|(:").concat(u, "){1,4}|:)|") + "(?:".concat(u, ":){2}(?:(:").concat(u, "){0,3}:").concat(a, "|(:").concat(u, "){1,5}|:)|") + "(?:".concat(u, ":){1}(?:(:").concat(u, "){0,4}:").concat(a, "|(:").concat(u, "){1,6}|:)|") + "(?::((?::".concat(u, "){0,5}:").concat(a, "|(?::").concat(u, "){1,7}|:))") + ")(%[0-9a-zA-Z.]{1,})?$");
    function d(l) {
      var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, n.default)(l);
      var p = (i(f) === "object" ? f.version : arguments[1]) || "";
      return p ? p.toString() === "4" ? o.test(l) : p.toString() === "6" ? c.test(l) : !1 : d(l, {
        version: 4
      }) || d(l, {
        version: 6
      });
    }
    t.exports = e.default, t.exports.default = e.default;
  }(Tp, Tp.exports)), Tp.exports;
}
var JE;
function tbe() {
  return JE || (JE = 1, function(t, e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.default = b;
    var n = u(/* @__PURE__ */ $v()), r = u(/* @__PURE__ */ K2e()), i = u(/* @__PURE__ */ Z2e()), s = u(/* @__PURE__ */ J2e()), a = u(/* @__PURE__ */ ebe()), o = u(/* @__PURE__ */ xk());
    function u(E) {
      return E && E.__esModule ? E : { default: E };
    }
    function c(E, v) {
      return m(E) || p(E, v) || l(E, v) || d();
    }
    function d() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function l(E, v) {
      if (E) {
        if (typeof E == "string") return f(E, v);
        var _ = {}.toString.call(E).slice(8, -1);
        return _ === "Object" && E.constructor && (_ = E.constructor.name), _ === "Map" || _ === "Set" ? Array.from(E) : _ === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_) ? f(E, v) : void 0;
      }
    }
    function f(E, v) {
      (v == null || v > E.length) && (v = E.length);
      for (var _ = 0, D = Array(v); _ < v; _++) D[_] = E[_];
      return D;
    }
    function p(E, v) {
      var _ = E == null ? null : typeof Symbol < "u" && E[Symbol.iterator] || E["@@iterator"];
      if (_ != null) {
        var D, S, M, O, T = [], N = !0, H = !1;
        try {
          if (M = (_ = _.call(E)).next, v !== 0) for (; !(N = (D = M.call(_)).done) && (T.push(D.value), T.length !== v); N = !0) ;
        } catch ($) {
          H = !0, S = $;
        } finally {
          try {
            if (!N && _.return != null && (O = _.return(), Object(O) !== O)) return;
          } finally {
            if (H) throw S;
          }
        }
        return T;
      }
    }
    function m(E) {
      if (Array.isArray(E)) return E;
    }
    var g = {
      protocols: ["http", "https", "ftp"],
      require_tld: !0,
      require_protocol: !1,
      require_host: !0,
      require_port: !1,
      require_valid_protocol: !0,
      allow_underscores: !1,
      allow_trailing_dot: !1,
      allow_protocol_relative_urls: !1,
      allow_fragments: !0,
      allow_query_components: !0,
      validate_length: !0,
      max_allowed_length: 2084
    }, y = /^\[([^\]]+)\](?::([0-9]+))?$/;
    function b(E, v) {
      if ((0, n.default)(E), !E || /[\s<>]/.test(E) || E.indexOf("mailto:") === 0 || (v = (0, o.default)(v, g), v.validate_length && E.length > v.max_allowed_length) || !v.allow_fragments && (0, i.default)(E, "#") || !v.allow_query_components && ((0, i.default)(E, "?") || (0, i.default)(E, "&")))
        return !1;
      var _, D, S, M, O, T, N, H;
      if (N = E.split("#"), E = N.shift(), N = E.split("?"), E = N.shift(), N = E.split("://"), N.length > 1) {
        if (_ = N.shift().toLowerCase(), v.require_valid_protocol && v.protocols.indexOf(_) === -1)
          return !1;
      } else {
        if (v.require_protocol)
          return !1;
        if (E.slice(0, 2) === "//") {
          if (!v.allow_protocol_relative_urls)
            return !1;
          N[0] = E.slice(2);
        }
      }
      if (E = N.join("://"), E === "")
        return !1;
      if (N = E.split("/"), E = N.shift(), E === "" && !v.require_host)
        return !0;
      if (N = E.split("@"), N.length > 1) {
        if (v.disallow_auth || N[0] === "" || (D = N.shift(), D.indexOf(":") >= 0 && D.split(":").length > 2))
          return !1;
        var $ = D.split(":"), j = c($, 2), U = j[0], V = j[1];
        if (U === "" && V === "")
          return !1;
      }
      M = N.join("@"), T = null, H = null;
      var B = M.match(y);
      if (B ? (S = "", H = B[1], T = B[2] || null) : (N = M.split(":"), S = N.shift(), N.length && (T = N.join(":"))), T !== null && T.length > 0) {
        if (O = parseInt(T, 10), !/^[0-9]+$/.test(T) || O <= 0 || O > 65535)
          return !1;
      } else if (v.require_port)
        return !1;
      return v.host_whitelist ? (0, r.default)(S, v.host_whitelist) : S === "" && !v.require_host ? !0 : !(!(0, a.default)(S) && !(0, s.default)(S, v) && (!H || !(0, a.default)(H, 6)) || (S = S || H, v.host_blacklist && (0, r.default)(S, v.host_blacklist)));
    }
    t.exports = e.default, t.exports.default = e.default;
  }(mp, mp.exports)), mp.exports;
}
var nbe = /* @__PURE__ */ tbe();
const rbe = /* @__PURE__ */ Fr(nbe), da = /* @__PURE__ */ Object.create(null);
da.open = "0";
da.close = "1";
da.ping = "2";
da.pong = "3";
da.message = "4";
da.upgrade = "5";
da.noop = "6";
const am = /* @__PURE__ */ Object.create(null);
Object.keys(da).forEach((t) => {
  am[da[t]] = t;
});
const Eb = { type: "error", data: "parser error" }, wk = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Ck = typeof ArrayBuffer == "function", Sk = (t) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer, Hv = ({ type: t, data: e }, n, r) => wk && e instanceof Blob ? n ? r(e) : e4(e, r) : Ck && (e instanceof ArrayBuffer || Sk(e)) ? n ? r(e) : e4(new Blob([e]), r) : r(da[t] + (e || "")), e4 = (t, e) => {
  const n = new FileReader();
  return n.onload = function() {
    const r = n.result.split(",")[1];
    e("b" + (r || ""));
  }, n.readAsDataURL(t);
};
function t4(t) {
  return t instanceof Uint8Array ? t : t instanceof ArrayBuffer ? new Uint8Array(t) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
}
let lA;
function ibe(t, e) {
  if (wk && t.data instanceof Blob)
    return t.data.arrayBuffer().then(t4).then(e);
  if (Ck && (t.data instanceof ArrayBuffer || Sk(t.data)))
    return e(t4(t.data));
  Hv(t, !1, (n) => {
    lA || (lA = new TextEncoder()), e(lA.encode(n));
  });
}
const n4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Wd = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let t = 0; t < n4.length; t++)
  Wd[n4.charCodeAt(t)] = t;
const sbe = (t) => {
  let e = t.length * 0.75, n = t.length, r, i = 0, s, a, o, u;
  t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--);
  const c = new ArrayBuffer(e), d = new Uint8Array(c);
  for (r = 0; r < n; r += 4)
    s = Wd[t.charCodeAt(r)], a = Wd[t.charCodeAt(r + 1)], o = Wd[t.charCodeAt(r + 2)], u = Wd[t.charCodeAt(r + 3)], d[i++] = s << 2 | a >> 4, d[i++] = (a & 15) << 4 | o >> 2, d[i++] = (o & 3) << 6 | u & 63;
  return c;
}, abe = typeof ArrayBuffer == "function", jv = (t, e) => {
  if (typeof t != "string")
    return {
      type: "message",
      data: Ik(t, e)
    };
  const n = t.charAt(0);
  return n === "b" ? {
    type: "message",
    data: obe(t.substring(1), e)
  } : am[n] ? t.length > 1 ? {
    type: am[n],
    data: t.substring(1)
  } : {
    type: am[n]
  } : Eb;
}, obe = (t, e) => {
  if (abe) {
    const n = sbe(t);
    return Ik(n, e);
  } else
    return { base64: !0, data: t };
}, Ik = (t, e) => {
  switch (e) {
    case "blob":
      return t instanceof Blob ? t : new Blob([t]);
    case "arraybuffer":
    default:
      return t instanceof ArrayBuffer ? t : t.buffer;
  }
}, kk = "", ube = (t, e) => {
  const n = t.length, r = new Array(n);
  let i = 0;
  t.forEach((s, a) => {
    Hv(s, !1, (o) => {
      r[a] = o, ++i === n && e(r.join(kk));
    });
  });
}, lbe = (t, e) => {
  const n = t.split(kk), r = [];
  for (let i = 0; i < n.length; i++) {
    const s = jv(n[i], e);
    if (r.push(s), s.type === "error")
      break;
  }
  return r;
};
function cbe() {
  return new TransformStream({
    transform(t, e) {
      ibe(t, (n) => {
        const r = n.length;
        let i;
        if (r < 126)
          i = new Uint8Array(1), new DataView(i.buffer).setUint8(0, r);
        else if (r < 65536) {
          i = new Uint8Array(3);
          const s = new DataView(i.buffer);
          s.setUint8(0, 126), s.setUint16(1, r);
        } else {
          i = new Uint8Array(9);
          const s = new DataView(i.buffer);
          s.setUint8(0, 127), s.setBigUint64(1, BigInt(r));
        }
        t.data && typeof t.data != "string" && (i[0] |= 128), e.enqueue(i), e.enqueue(n);
      });
    }
  });
}
let cA;
function _p(t) {
  return t.reduce((e, n) => e + n.length, 0);
}
function Ep(t, e) {
  if (t[0].length === e)
    return t.shift();
  const n = new Uint8Array(e);
  let r = 0;
  for (let i = 0; i < e; i++)
    n[i] = t[0][r++], r === t[0].length && (t.shift(), r = 0);
  return t.length && r < t[0].length && (t[0] = t[0].slice(r)), n;
}
function dbe(t, e) {
  cA || (cA = new TextDecoder());
  const n = [];
  let r = 0, i = -1, s = !1;
  return new TransformStream({
    transform(a, o) {
      for (n.push(a); ; ) {
        if (r === 0) {
          if (_p(n) < 1)
            break;
          const u = Ep(n, 1);
          s = (u[0] & 128) === 128, i = u[0] & 127, i < 126 ? r = 3 : i === 126 ? r = 1 : r = 2;
        } else if (r === 1) {
          if (_p(n) < 2)
            break;
          const u = Ep(n, 2);
          i = new DataView(u.buffer, u.byteOffset, u.length).getUint16(0), r = 3;
        } else if (r === 2) {
          if (_p(n) < 8)
            break;
          const u = Ep(n, 8), c = new DataView(u.buffer, u.byteOffset, u.length), d = c.getUint32(0);
          if (d > Math.pow(2, 21) - 1) {
            o.enqueue(Eb);
            break;
          }
          i = d * Math.pow(2, 32) + c.getUint32(4), r = 3;
        } else {
          if (_p(n) < i)
            break;
          const u = Ep(n, i);
          o.enqueue(jv(s ? u : cA.decode(u), e)), r = 0;
        }
        if (i === 0 || i > t) {
          o.enqueue(Eb);
          break;
        }
      }
    }
  });
}
const Dk = 4;
function vr(t) {
  if (t) return fbe(t);
}
function fbe(t) {
  for (var e in vr.prototype)
    t[e] = vr.prototype[e];
  return t;
}
vr.prototype.on = vr.prototype.addEventListener = function(t, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this;
};
vr.prototype.once = function(t, e) {
  function n() {
    this.off(t, n), e.apply(this, arguments);
  }
  return n.fn = e, this.on(t, n), this;
};
vr.prototype.off = vr.prototype.removeListener = vr.prototype.removeAllListeners = vr.prototype.removeEventListener = function(t, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var n = this._callbacks["$" + t];
  if (!n) return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + t], this;
  for (var r, i = 0; i < n.length; i++)
    if (r = n[i], r === e || r.fn === e) {
      n.splice(i, 1);
      break;
    }
  return n.length === 0 && delete this._callbacks["$" + t], this;
};
vr.prototype.emit = function(t) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), n = this._callbacks["$" + t], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  if (n) {
    n = n.slice(0);
    for (var r = 0, i = n.length; r < i; ++r)
      n[r].apply(this, e);
  }
  return this;
};
vr.prototype.emitReserved = vr.prototype.emit;
vr.prototype.listeners = function(t) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [];
};
vr.prototype.hasListeners = function(t) {
  return !!this.listeners(t).length;
};
const sg = typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, n) => n(e, 0), ts = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), hbe = "arraybuffer";
function Mk(t, ...e) {
  return e.reduce((n, r) => (t.hasOwnProperty(r) && (n[r] = t[r]), n), {});
}
const pbe = ts.setTimeout, mbe = ts.clearTimeout;
function ag(t, e) {
  e.useNativeTimers ? (t.setTimeoutFn = pbe.bind(ts), t.clearTimeoutFn = mbe.bind(ts)) : (t.setTimeoutFn = ts.setTimeout.bind(ts), t.clearTimeoutFn = ts.clearTimeout.bind(ts));
}
const gbe = 1.33;
function Abe(t) {
  return typeof t == "string" ? bbe(t) : Math.ceil((t.byteLength || t.size) * gbe);
}
function bbe(t) {
  let e = 0, n = 0;
  for (let r = 0, i = t.length; r < i; r++)
    e = t.charCodeAt(r), e < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++, n += 4);
  return n;
}
function Ok() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function ybe(t) {
  let e = "";
  for (let n in t)
    t.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n]));
  return e;
}
function vbe(t) {
  let e = {}, n = t.split("&");
  for (let r = 0, i = n.length; r < i; r++) {
    let s = n[r].split("=");
    e[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
  }
  return e;
}
class Tbe extends Error {
  constructor(e, n, r) {
    super(e), this.description = n, this.context = r, this.type = "TransportError";
  }
}
class zv extends vr {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(e) {
    super(), this.writable = !1, ag(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(e, n, r) {
    return super.emitReserved("error", new Tbe(e, n, r)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(e) {
    const n = jv(e, this.socket.binaryType);
    this.onPacket(n);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(e) {
  }
  createUri(e, n = {}) {
    return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(n);
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e) {
    const n = ybe(e);
    return n.length ? "?" + n : "";
  }
}
class _be extends zv {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(e) {
    this.readyState = "pausing";
    const n = () => {
      this.readyState = "paused", e();
    };
    if (this._polling || !this.writable) {
      let r = 0;
      this._polling && (r++, this.once("pollComplete", function() {
        --r || n();
      })), this.writable || (r++, this.once("drain", function() {
        --r || n();
      }));
    } else
      n();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(e) {
    const n = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    lbe(e, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(e) {
    this.writable = !1, ube(e, (n) => {
      this.doWrite(n, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "https" : "http", n = this.query || {};
    return this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = Ok()), !this.supportsBinary && !n.sid && (n.b64 = 1), this.createUri(e, n);
  }
}
let Nk = !1;
try {
  Nk = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Ebe = Nk;
function xbe() {
}
class wbe extends _be {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(e) {
    if (super(e), typeof location < "u") {
      const n = location.protocol === "https:";
      let r = location.port;
      r || (r = n ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || r !== e.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(e, n) {
    const r = this.request({
      method: "POST",
      data: e
    });
    r.on("success", n), r.on("error", (i, s) => {
      this.onError("xhr post error", i, s);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (n, r) => {
      this.onError("xhr poll error", n, r);
    }), this.pollXhr = e;
  }
}
let ql = class om extends vr {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(e, n, r) {
    super(), this.createRequest = e, ag(this, r), this._opts = r, this._method = r.method || "GET", this._uri = n, this._data = r.data !== void 0 ? r.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var e;
    const n = Mk(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    n.xdomain = !!this._opts.xd;
    const r = this._xhr = this.createRequest(n);
    try {
      r.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
          for (let i in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(i) && r.setRequestHeader(i, this._opts.extraHeaders[i]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(r), "withCredentials" in r && (r.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (r.timeout = this._opts.requestTimeout), r.onreadystatechange = () => {
        var i;
        r.readyState === 3 && ((i = this._opts.cookieJar) === null || i === void 0 || i.parseCookies(
          // @ts-ignore
          r.getResponseHeader("set-cookie")
        )), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof r.status == "number" ? r.status : 0);
        }, 0));
      }, r.send(this._data);
    } catch (i) {
      this.setTimeoutFn(() => {
        this._onError(i);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = om.requestsCount++, om.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(e) {
    this.emitReserved("error", e, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(e) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = xbe, e)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete om.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const e = this._xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
ql.requestsCount = 0;
ql.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", r4);
  else if (typeof addEventListener == "function") {
    const t = "onpagehide" in ts ? "pagehide" : "unload";
    addEventListener(t, r4, !1);
  }
}
function r4() {
  for (let t in ql.requests)
    ql.requests.hasOwnProperty(t) && ql.requests[t].abort();
}
const Cbe = function() {
  const t = Lk({
    xdomain: !1
  });
  return t && t.responseType !== null;
}();
let Sbe = class extends wbe {
  constructor(e) {
    super(e);
    const n = e && e.forceBase64;
    this.supportsBinary = Cbe && !n;
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd }, this.opts), new ql(Lk, this.uri(), e);
  }
};
function Lk(t) {
  const e = t.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || Ebe))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new ts[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const Pk = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Ibe extends zv {
  get name() {
    return "websocket";
  }
  doOpen() {
    const e = this.uri(), n = this.opts.protocols, r = Pk ? {} : Mk(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(e, n, r);
    } catch (i) {
      return this.emitReserved("error", i);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = !1;
    for (let n = 0; n < e.length; n++) {
      const r = e[n], i = n === e.length - 1;
      Hv(r, this.supportsBinary, (s) => {
        try {
          this.doWrite(r, s);
        } catch {
        }
        i && sg(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e = this.opts.secure ? "wss" : "ws", n = this.query || {};
    return this.opts.timestampRequests && (n[this.opts.timestampParam] = Ok()), this.supportsBinary || (n.b64 = 1), this.createUri(e, n);
  }
}
const dA = ts.WebSocket || ts.MozWebSocket;
class kbe extends Ibe {
  createSocket(e, n, r) {
    return Pk ? new dA(e, n, r) : n ? new dA(e, n) : new dA(e);
  }
  doWrite(e, n) {
    this.ws.send(n);
  }
}
class Dbe extends zv {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (e) {
      return this.emitReserved("error", e);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((e) => {
      this.onError("webtransport error", e);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((e) => {
        const n = dbe(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = e.readable.pipeThrough(n).getReader(), i = cbe();
        i.readable.pipeTo(e.writable), this._writer = i.writable.getWriter();
        const s = () => {
          r.read().then(({ done: o, value: u }) => {
            o || (this.onPacket(u), s());
          }).catch((o) => {
          });
        };
        s();
        const a = { type: "open" };
        this.query.sid && (a.data = `{"sid":"${this.query.sid}"}`), this._writer.write(a).then(() => this.onOpen());
      });
    });
  }
  write(e) {
    this.writable = !1;
    for (let n = 0; n < e.length; n++) {
      const r = e[n], i = n === e.length - 1;
      this._writer.write(r).then(() => {
        i && sg(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this._transport) === null || e === void 0 || e.close();
  }
}
const Mbe = {
  websocket: kbe,
  webtransport: Dbe,
  polling: Sbe
}, Obe = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, Nbe = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function xb(t) {
  if (t.length > 8e3)
    throw "URI too long";
  const e = t, n = t.indexOf("["), r = t.indexOf("]");
  n != -1 && r != -1 && (t = t.substring(0, n) + t.substring(n, r).replace(/:/g, ";") + t.substring(r, t.length));
  let i = Obe.exec(t || ""), s = {}, a = 14;
  for (; a--; )
    s[Nbe[a]] = i[a] || "";
  return n != -1 && r != -1 && (s.source = e, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = Lbe(s, s.path), s.queryKey = Pbe(s, s.query), s;
}
function Lbe(t, e) {
  const n = /\/{2,9}/g, r = e.replace(n, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function Pbe(t, e) {
  const n = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, i, s) {
    i && (n[i] = s);
  }), n;
}
const wb = typeof addEventListener == "function" && typeof removeEventListener == "function", um = [];
wb && addEventListener("offline", () => {
  um.forEach((t) => t());
}, !1);
class xo extends vr {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(e, n) {
    if (super(), this.binaryType = hbe, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && typeof e == "object" && (n = e, e = null), e) {
      const r = xb(e);
      n.hostname = r.host, n.secure = r.protocol === "https" || r.protocol === "wss", n.port = r.port, r.query && (n.query = r.query);
    } else n.host && (n.hostname = xb(n.host).host);
    ag(this, n), this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, n.transports.forEach((r) => {
      const i = r.prototype.name;
      this.transports.push(i), this._transportsByName[i] = r;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = vbe(this.opts.query)), wb && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, um.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(e) {
    const n = Object.assign({}, this.opts.query);
    n.EIO = Dk, n.transport = e, this.id && (n.sid = this.id);
    const r = Object.assign({}, this.opts, {
      query: n,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[e]);
    return new this._transportsByName[e](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const e = this.opts.rememberUpgrade && xo.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const n = this.createTransport(e);
    n.open(), this.setTransport(n);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (n) => this._onClose("transport close", n));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", xo.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const n = new Error("server error");
          n.code = e.data, this._onError(n);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const e = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this._getWritablePackets();
      this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let n = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const i = this.writeBuffer[r].data;
      if (i && (n += Abe(i)), r > 0 && n > this._maxPayload)
        return this.writeBuffer.slice(0, r);
      n += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const e = Date.now() > this._pingTimeoutTime;
    return e && (this._pingTimeoutTime = 0, sg(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), e;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(e, n, r) {
    return this._sendPacket("message", e, n, r), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(e, n, r) {
    return this._sendPacket("message", e, n, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(e, n, r, i) {
    if (typeof n == "function" && (i = n, n = void 0), typeof r == "function" && (i = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const s = {
      type: e,
      data: n,
      options: r
    };
    this.emitReserved("packetCreate", s), this.writeBuffer.push(s), i && this.once("flush", i), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const e = () => {
      this._onClose("forced close"), this.transport.close();
    }, n = () => {
      this.off("upgrade", n), this.off("upgradeError", n), e();
    }, r = () => {
      this.once("upgrade", n), this.once("upgradeError", n);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : e();
    }) : this.upgrading ? r() : e()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(e) {
    if (xo.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", e), this._onClose("transport error", e);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(e, n) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), wb && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const r = um.indexOf(this._offlineEventListener);
        r !== -1 && um.splice(r, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", e, n), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
xo.protocol = Dk;
class Rbe extends xo {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let e = 0; e < this._upgrades.length; e++)
        this._probe(this._upgrades[e]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(e) {
    let n = this.createTransport(e), r = !1;
    xo.priorWebsocketSuccess = !1;
    const i = () => {
      r || (n.send([{ type: "ping", data: "probe" }]), n.once("packet", (l) => {
        if (!r)
          if (l.type === "pong" && l.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", n), !n)
              return;
            xo.priorWebsocketSuccess = n.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (d(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = !1, this.flush());
            });
          } else {
            const f = new Error("probe error");
            f.transport = n.name, this.emitReserved("upgradeError", f);
          }
      }));
    };
    function s() {
      r || (r = !0, d(), n.close(), n = null);
    }
    const a = (l) => {
      const f = new Error("probe error: " + l);
      f.transport = n.name, s(), this.emitReserved("upgradeError", f);
    };
    function o() {
      a("transport closed");
    }
    function u() {
      a("socket closed");
    }
    function c(l) {
      n && l.name !== n.name && s();
    }
    const d = () => {
      n.removeListener("open", i), n.removeListener("error", a), n.removeListener("close", o), this.off("close", u), this.off("upgrading", c);
    };
    n.once("open", i), n.once("error", a), n.once("close", o), this.once("close", u), this.once("upgrading", c), this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
      r || n.open();
    }, 200) : n.open();
  }
  onHandshake(e) {
    this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(e) {
    const n = [];
    for (let r = 0; r < e.length; r++)
      ~this.transports.indexOf(e[r]) && n.push(e[r]);
    return n;
  }
}
let Bbe = class extends Rbe {
  constructor(e, n = {}) {
    const r = typeof e == "object" ? e : n;
    (!r.transports || r.transports && typeof r.transports[0] == "string") && (r.transports = (r.transports || ["polling", "websocket", "webtransport"]).map((i) => Mbe[i]).filter((i) => !!i)), super(e, r);
  }
};
function Fbe(t, e = "", n) {
  let r = t;
  n = n || typeof location < "u" && location, t == null && (t = n.protocol + "//" + n.host), typeof t == "string" && (t.charAt(0) === "/" && (t.charAt(1) === "/" ? t = n.protocol + t : t = n.host + t), /^(https?|wss?):\/\//.test(t) || (typeof n < "u" ? t = n.protocol + "//" + t : t = "https://" + t), r = xb(t)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const s = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + s + ":" + r.port + e, r.href = r.protocol + "://" + s + (n && n.port === r.port ? "" : ":" + r.port), r;
}
const Ube = typeof ArrayBuffer == "function", $be = (t) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer, Rk = Object.prototype.toString, Hbe = typeof Blob == "function" || typeof Blob < "u" && Rk.call(Blob) === "[object BlobConstructor]", jbe = typeof File == "function" || typeof File < "u" && Rk.call(File) === "[object FileConstructor]";
function qv(t) {
  return Ube && (t instanceof ArrayBuffer || $be(t)) || Hbe && t instanceof Blob || jbe && t instanceof File;
}
function lm(t, e) {
  if (!t || typeof t != "object")
    return !1;
  if (Array.isArray(t)) {
    for (let n = 0, r = t.length; n < r; n++)
      if (lm(t[n]))
        return !0;
    return !1;
  }
  if (qv(t))
    return !0;
  if (t.toJSON && typeof t.toJSON == "function" && arguments.length === 1)
    return lm(t.toJSON(), !0);
  for (const n in t)
    if (Object.prototype.hasOwnProperty.call(t, n) && lm(t[n]))
      return !0;
  return !1;
}
function zbe(t) {
  const e = [], n = t.data, r = t;
  return r.data = Cb(n, e), r.attachments = e.length, { packet: r, buffers: e };
}
function Cb(t, e) {
  if (!t)
    return t;
  if (qv(t)) {
    const n = { _placeholder: !0, num: e.length };
    return e.push(t), n;
  } else if (Array.isArray(t)) {
    const n = new Array(t.length);
    for (let r = 0; r < t.length; r++)
      n[r] = Cb(t[r], e);
    return n;
  } else if (typeof t == "object" && !(t instanceof Date)) {
    const n = {};
    for (const r in t)
      Object.prototype.hasOwnProperty.call(t, r) && (n[r] = Cb(t[r], e));
    return n;
  }
  return t;
}
function qbe(t, e) {
  return t.data = Sb(t.data, e), delete t.attachments, t;
}
function Sb(t, e) {
  if (!t)
    return t;
  if (t && t._placeholder === !0) {
    if (typeof t.num == "number" && t.num >= 0 && t.num < e.length)
      return e[t.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(t))
    for (let n = 0; n < t.length; n++)
      t[n] = Sb(t[n], e);
  else if (typeof t == "object")
    for (const n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (t[n] = Sb(t[n], e));
  return t;
}
const Vbe = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], Wbe = 5;
var nn;
(function(t) {
  t[t.CONNECT = 0] = "CONNECT", t[t.DISCONNECT = 1] = "DISCONNECT", t[t.EVENT = 2] = "EVENT", t[t.ACK = 3] = "ACK", t[t.CONNECT_ERROR = 4] = "CONNECT_ERROR", t[t.BINARY_EVENT = 5] = "BINARY_EVENT", t[t.BINARY_ACK = 6] = "BINARY_ACK";
})(nn || (nn = {}));
class Qbe {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(e) {
    this.replacer = e;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(e) {
    return (e.type === nn.EVENT || e.type === nn.ACK) && lm(e) ? this.encodeAsBinary({
      type: e.type === nn.EVENT ? nn.BINARY_EVENT : nn.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(e) {
    let n = "" + e.type;
    return (e.type === nn.BINARY_EVENT || e.type === nn.BINARY_ACK) && (n += e.attachments + "-"), e.nsp && e.nsp !== "/" && (n += e.nsp + ","), e.id != null && (n += e.id), e.data != null && (n += JSON.stringify(e.data, this.replacer)), n;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(e) {
    const n = zbe(e), r = this.encodeAsString(n.packet), i = n.buffers;
    return i.unshift(r), i;
  }
}
function i4(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
class Vv extends vr {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(e) {
    super(), this.reviver = e;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(e) {
    let n;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      n = this.decodeString(e);
      const r = n.type === nn.BINARY_EVENT;
      r || n.type === nn.BINARY_ACK ? (n.type = r ? nn.EVENT : nn.ACK, this.reconstructor = new Gbe(n), n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n);
    } else if (qv(e) || e.base64)
      if (this.reconstructor)
        n = this.reconstructor.takeBinaryData(e), n && (this.reconstructor = null, super.emitReserved("decoded", n));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(e) {
    let n = 0;
    const r = {
      type: Number(e.charAt(0))
    };
    if (nn[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === nn.BINARY_EVENT || r.type === nn.BINARY_ACK) {
      const s = n + 1;
      for (; e.charAt(++n) !== "-" && n != e.length; )
        ;
      const a = e.substring(s, n);
      if (a != Number(a) || e.charAt(n) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(a);
    }
    if (e.charAt(n + 1) === "/") {
      const s = n + 1;
      for (; ++n && !(e.charAt(n) === "," || n === e.length); )
        ;
      r.nsp = e.substring(s, n);
    } else
      r.nsp = "/";
    const i = e.charAt(n + 1);
    if (i !== "" && Number(i) == i) {
      const s = n + 1;
      for (; ++n; ) {
        const a = e.charAt(n);
        if (a == null || Number(a) != a) {
          --n;
          break;
        }
        if (n === e.length)
          break;
      }
      r.id = Number(e.substring(s, n + 1));
    }
    if (e.charAt(++n)) {
      const s = this.tryParse(e.substr(n));
      if (Vv.isPayloadValid(r.type, s))
        r.data = s;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, n) {
    switch (e) {
      case nn.CONNECT:
        return i4(n);
      case nn.DISCONNECT:
        return n === void 0;
      case nn.CONNECT_ERROR:
        return typeof n == "string" || i4(n);
      case nn.EVENT:
      case nn.BINARY_EVENT:
        return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && Vbe.indexOf(n[0]) === -1);
      case nn.ACK:
      case nn.BINARY_ACK:
        return Array.isArray(n);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class Gbe {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const n = qbe(this.reconPack, this.buffers);
      return this.finishedReconstruction(), n;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const Ybe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder: Vv,
  Encoder: Qbe,
  get PacketType() {
    return nn;
  },
  protocol: Wbe
}, Symbol.toStringTag, { value: "Module" }));
function Cs(t, e, n) {
  return t.on(e, n), function() {
    t.off(e, n);
  };
}
const Xbe = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Bk extends vr {
  /**
   * `Socket` constructor.
   */
  constructor(e, n, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = n, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      Cs(e, "open", this.onopen.bind(this)),
      Cs(e, "packet", this.onpacket.bind(this)),
      Cs(e, "error", this.onerror.bind(this)),
      Cs(e, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(e, ...n) {
    var r, i, s;
    if (Xbe.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (n.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(n), this;
    const a = {
      type: nn.EVENT,
      data: n
    };
    if (a.options = {}, a.options.compress = this.flags.compress !== !1, typeof n[n.length - 1] == "function") {
      const d = this.ids++, l = n.pop();
      this._registerAckCallback(d, l), a.id = d;
    }
    const o = (i = (r = this.io.engine) === null || r === void 0 ? void 0 : r.transport) === null || i === void 0 ? void 0 : i.writable, u = this.connected && !(!((s = this.io.engine) === null || s === void 0) && s._hasPingExpired());
    return this.flags.volatile && !o || (u ? (this.notifyOutgoingListeners(a), this.packet(a)) : this.sendBuffer.push(a)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(e, n) {
    var r;
    const i = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (i === void 0) {
      this.acks[e] = n;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
      n.call(this, new Error("operation has timed out"));
    }, i), a = (...o) => {
      this.io.clearTimeoutFn(s), n.apply(this, o);
    };
    a.withError = !0, this.acks[e] = a;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(e, ...n) {
    return new Promise((r, i) => {
      const s = (a, o) => a ? i(a) : r(o);
      s.withError = !0, n.push(s), this.emit(e, ...n);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(e) {
    let n;
    typeof e[e.length - 1] == "function" && (n = e.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e.push((i, ...s) => r !== this._queue[0] ? void 0 : (i !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), n && n(i)) : (this._queue.shift(), n && n(null, ...s)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const n = this._queue[0];
    n.pending && !e || (n.pending = !0, n.tryCount++, this.flags = n.flags, this.emit.apply(this, n.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(e) {
    this.packet({
      type: nn.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(e, n) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e, n), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((e) => {
      if (!this.sendBuffer.some((r) => String(r.id) === e)) {
        const r = this.acks[e];
        delete this.acks[e], r.withError && r.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case nn.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case nn.EVENT:
        case nn.BINARY_EVENT:
          this.onevent(e);
          break;
        case nn.ACK:
        case nn.BINARY_ACK:
          this.onack(e);
          break;
        case nn.DISCONNECT:
          this.ondisconnect();
          break;
        case nn.CONNECT_ERROR:
          this.destroy();
          const r = new Error(e.data.message);
          r.data = e.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(e) {
    const n = e.data || [];
    e.id != null && n.push(this.ack(e.id)), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const n = this._anyListeners.slice();
      for (const r of n)
        r.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(e) {
    const n = this;
    let r = !1;
    return function(...i) {
      r || (r = !0, n.packet({
        type: nn.ACK,
        id: e,
        data: i
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(e) {
    const n = this.acks[e.id];
    typeof n == "function" && (delete this.acks[e.id], n.withError && e.data.unshift(null), n.apply(this, e.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(e, n) {
    this.id = e, this.recovered = n && this._pid === n, this._pid = n, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: nn.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(e) {
    return this.flags.compress = e, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const n = this._anyListeners;
      for (let r = 0; r < n.length; r++)
        if (e === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const n = this._anyOutgoingListeners;
      for (let r = 0; r < n.length; r++)
        if (e === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const n = this._anyOutgoingListeners.slice();
      for (const r of n)
        r.apply(this, e.data);
    }
  }
}
function Rc(t) {
  t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0;
}
Rc.prototype.duration = function() {
  var t = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), n = Math.floor(e * this.jitter * t);
    t = (Math.floor(e * 10) & 1) == 0 ? t - n : t + n;
  }
  return Math.min(t, this.max) | 0;
};
Rc.prototype.reset = function() {
  this.attempts = 0;
};
Rc.prototype.setMin = function(t) {
  this.ms = t;
};
Rc.prototype.setMax = function(t) {
  this.max = t;
};
Rc.prototype.setJitter = function(t) {
  this.jitter = t;
};
class Ib extends vr {
  constructor(e, n) {
    var r;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (n = e, e = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, ag(this, n), this.reconnection(n.reconnection !== !1), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Rc({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = e;
    const i = n.parser || Ybe;
    this.encoder = new i.Encoder(), this.decoder = new i.Decoder(), this._autoConnect = n.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var n;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (n = this.backoff) === null || n === void 0 || n.setMin(e), this);
  }
  randomizationFactor(e) {
    var n;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (n = this.backoff) === null || n === void 0 || n.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var n;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (n = this.backoff) === null || n === void 0 || n.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Bbe(this.uri, this.opts);
    const n = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const i = Cs(n, "open", function() {
      r.onopen(), e && e();
    }), s = (o) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", o), e ? e(o) : this.maybeReconnectOnOpen();
    }, a = Cs(n, "error", s);
    if (this._timeout !== !1) {
      const o = this._timeout, u = this.setTimeoutFn(() => {
        i(), s(new Error("timeout")), n.close();
      }, o);
      this.opts.autoUnref && u.unref(), this.subs.push(() => {
        this.clearTimeoutFn(u);
      });
    }
    return this.subs.push(i), this.subs.push(a), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(e) {
    return this.open(e);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(
      Cs(e, "ping", this.onping.bind(this)),
      Cs(e, "data", this.ondata.bind(this)),
      Cs(e, "error", this.onerror.bind(this)),
      Cs(e, "close", this.onclose.bind(this)),
      // @ts-ignore
      Cs(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (n) {
      this.onclose("parse error", n);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(e) {
    sg(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(e) {
    this.emitReserved("error", e);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(e, n) {
    let r = this.nsps[e];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new Bk(this, e, n), this.nsps[e] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(e) {
    const n = Object.keys(this.nsps);
    for (const r of n)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(e) {
    const n = this.encoder.encode(e);
    for (let r = 0; r < n.length; r++)
      this.engine.write(n[r], e.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(e, n) {
    var r;
    this.cleanup(), (r = this.engine) === null || r === void 0 || r.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, n), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const n = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((i) => {
          i ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", i)) : e.onreconnect();
        }));
      }, n);
      this.opts.autoUnref && r.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const xd = {};
function pf(t, e) {
  typeof t == "object" && (e = t, t = void 0), e = e || {};
  const n = Fbe(t, e.path || "/socket.io"), r = n.source, i = n.id, s = n.path, a = xd[i] && s in xd[i].nsps, o = e.forceNew || e["force new connection"] || e.multiplex === !1 || a;
  let u;
  return o ? u = new Ib(r, e) : (xd[i] || (xd[i] = new Ib(r, e)), u = xd[i]), n.query && !e.query && (e.query = n.queryKey), u.socket(n.path, e);
}
Object.assign(pf, {
  Manager: Ib,
  Socket: Bk,
  io: pf,
  connect: pf
});
function Fk(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: Kbe } = Object.prototype, { getPrototypeOf: Wv } = Object, { iterator: og, toStringTag: Uk } = Symbol, ug = /* @__PURE__ */ ((t) => (e) => {
  const n = Kbe.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Us = (t) => (t = t.toLowerCase(), (e) => ug(e) === t), lg = (t) => (e) => typeof e === t, { isArray: Bc } = Array, jf = lg("undefined");
function Zbe(t) {
  return t !== null && !jf(t) && t.constructor !== null && !jf(t.constructor) && Di(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const $k = Us("ArrayBuffer");
function Jbe(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && $k(t.buffer), e;
}
const eye = lg("string"), Di = lg("function"), Hk = lg("number"), cg = (t) => t !== null && typeof t == "object", tye = (t) => t === !0 || t === !1, cm = (t) => {
  if (ug(t) !== "object")
    return !1;
  const e = Wv(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Uk in t) && !(og in t);
}, nye = Us("Date"), rye = Us("File"), iye = Us("Blob"), sye = Us("FileList"), aye = (t) => cg(t) && Di(t.pipe), oye = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Di(t.append) && ((e = ug(t)) === "formdata" || // detect form-data instance
  e === "object" && Di(t.toString) && t.toString() === "[object FormData]"));
}, uye = Us("URLSearchParams"), [lye, cye, dye, fye] = ["ReadableStream", "Request", "Response", "Headers"].map(Us), hye = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Ah(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let r, i;
  if (typeof t != "object" && (t = [t]), Bc(t))
    for (r = 0, i = t.length; r < i; r++)
      e.call(null, t[r], r, t);
  else {
    const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t), a = s.length;
    let o;
    for (r = 0; r < a; r++)
      o = s[r], e.call(null, t[o], o, t);
  }
}
function jk(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], e === i.toLowerCase())
      return i;
  return null;
}
const hu = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, zk = (t) => !jf(t) && t !== hu;
function kb() {
  const { caseless: t } = zk(this) && this || {}, e = {}, n = (r, i) => {
    const s = t && jk(e, i) || i;
    cm(e[s]) && cm(r) ? e[s] = kb(e[s], r) : cm(r) ? e[s] = kb({}, r) : Bc(r) ? e[s] = r.slice() : e[s] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Ah(arguments[r], n);
  return e;
}
const pye = (t, e, n, { allOwnKeys: r } = {}) => (Ah(e, (i, s) => {
  n && Di(i) ? t[s] = Fk(i, n) : t[s] = i;
}, { allOwnKeys: r }), t), mye = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), gye = (t, e, n, r) => {
  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, Aye = (t, e, n, r) => {
  let i, s, a;
  const o = {};
  if (e = e || {}, t == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0; )
      a = i[s], (!r || r(a, t, e)) && !o[a] && (e[a] = t[a], o[a] = !0);
    t = n !== !1 && Wv(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, bye = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const r = t.indexOf(e, n);
  return r !== -1 && r === n;
}, yye = (t) => {
  if (!t) return null;
  if (Bc(t)) return t;
  let e = t.length;
  if (!Hk(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, vye = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Wv(Uint8Array)), Tye = (t, e) => {
  const r = (t && t[og]).call(t);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const s = i.value;
    e.call(t, s[0], s[1]);
  }
}, _ye = (t, e) => {
  let n;
  const r = [];
  for (; (n = t.exec(e)) !== null; )
    r.push(n);
  return r;
}, Eye = Us("HTMLFormElement"), xye = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), s4 = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), wye = Us("RegExp"), qk = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), r = {};
  Ah(n, (i, s) => {
    let a;
    (a = e(i, s, t)) !== !1 && (r[s] = a || i);
  }), Object.defineProperties(t, r);
}, Cye = (t) => {
  qk(t, (e, n) => {
    if (Di(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = t[n];
    if (Di(r)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, Sye = (t, e) => {
  const n = {}, r = (i) => {
    i.forEach((s) => {
      n[s] = !0;
    });
  };
  return Bc(t) ? r(t) : r(String(t).split(e)), n;
}, Iye = () => {
}, kye = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;
function Dye(t) {
  return !!(t && Di(t.append) && t[Uk] === "FormData" && t[og]);
}
const Mye = (t) => {
  const e = new Array(10), n = (r, i) => {
    if (cg(r)) {
      if (e.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        e[i] = r;
        const s = Bc(r) ? [] : {};
        return Ah(r, (a, o) => {
          const u = n(a, i + 1);
          !jf(u) && (s[o] = u);
        }), e[i] = void 0, s;
      }
    }
    return r;
  };
  return n(t, 0);
}, Oye = Us("AsyncFunction"), Nye = (t) => t && (cg(t) || Di(t)) && Di(t.then) && Di(t.catch), Vk = ((t, e) => t ? setImmediate : e ? ((n, r) => (hu.addEventListener("message", ({ source: i, data: s }) => {
  i === hu && s === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), hu.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Di(hu.postMessage)
), Lye = typeof queueMicrotask < "u" ? queueMicrotask.bind(hu) : typeof process < "u" && process.nextTick || Vk, Pye = (t) => t != null && Di(t[og]), Re = {
  isArray: Bc,
  isArrayBuffer: $k,
  isBuffer: Zbe,
  isFormData: oye,
  isArrayBufferView: Jbe,
  isString: eye,
  isNumber: Hk,
  isBoolean: tye,
  isObject: cg,
  isPlainObject: cm,
  isReadableStream: lye,
  isRequest: cye,
  isResponse: dye,
  isHeaders: fye,
  isUndefined: jf,
  isDate: nye,
  isFile: rye,
  isBlob: iye,
  isRegExp: wye,
  isFunction: Di,
  isStream: aye,
  isURLSearchParams: uye,
  isTypedArray: vye,
  isFileList: sye,
  forEach: Ah,
  merge: kb,
  extend: pye,
  trim: hye,
  stripBOM: mye,
  inherits: gye,
  toFlatObject: Aye,
  kindOf: ug,
  kindOfTest: Us,
  endsWith: bye,
  toArray: yye,
  forEachEntry: Tye,
  matchAll: _ye,
  isHTMLForm: Eye,
  hasOwnProperty: s4,
  hasOwnProp: s4,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: qk,
  freezeMethods: Cye,
  toObjectSet: Sye,
  toCamelCase: xye,
  noop: Iye,
  toFiniteNumber: kye,
  findKey: jk,
  global: hu,
  isContextDefined: zk,
  isSpecCompliantForm: Dye,
  toJSONObject: Mye,
  isAsyncFn: Oye,
  isThenable: Nye,
  setImmediate: Vk,
  asap: Lye,
  isIterable: Pye
};
function Vt(t, e, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
Re.inherits(Vt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Re.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Wk = Vt.prototype, Qk = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  Qk[t] = { value: t };
});
Object.defineProperties(Vt, Qk);
Object.defineProperty(Wk, "isAxiosError", { value: !0 });
Vt.from = (t, e, n, r, i, s) => {
  const a = Object.create(Wk);
  return Re.toFlatObject(t, a, function(u) {
    return u !== Error.prototype;
  }, (o) => o !== "isAxiosError"), Vt.call(a, t.message, e, n, r, i), a.cause = t, a.name = t.name, s && Object.assign(a, s), a;
};
const Rye = null;
function Db(t) {
  return Re.isPlainObject(t) || Re.isArray(t);
}
function Gk(t) {
  return Re.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function a4(t, e, n) {
  return t ? t.concat(e).map(function(i, s) {
    return i = Gk(i), !n && s ? "[" + i + "]" : i;
  }).join(n ? "." : "") : e;
}
function Bye(t) {
  return Re.isArray(t) && !t.some(Db);
}
const Fye = Re.toFlatObject(Re, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function dg(t, e, n) {
  if (!Re.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = Re.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, y) {
    return !Re.isUndefined(y[g]);
  });
  const r = n.metaTokens, i = n.visitor || d, s = n.dots, a = n.indexes, u = (n.Blob || typeof Blob < "u" && Blob) && Re.isSpecCompliantForm(e);
  if (!Re.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(m) {
    if (m === null) return "";
    if (Re.isDate(m))
      return m.toISOString();
    if (Re.isBoolean(m))
      return m.toString();
    if (!u && Re.isBlob(m))
      throw new Vt("Blob is not supported. Use a Buffer instead.");
    return Re.isArrayBuffer(m) || Re.isTypedArray(m) ? u && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function d(m, g, y) {
    let b = m;
    if (m && !y && typeof m == "object") {
      if (Re.endsWith(g, "{}"))
        g = r ? g : g.slice(0, -2), m = JSON.stringify(m);
      else if (Re.isArray(m) && Bye(m) || (Re.isFileList(m) || Re.endsWith(g, "[]")) && (b = Re.toArray(m)))
        return g = Gk(g), b.forEach(function(v, _) {
          !(Re.isUndefined(v) || v === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            a === !0 ? a4([g], _, s) : a === null ? g : g + "[]",
            c(v)
          );
        }), !1;
    }
    return Db(m) ? !0 : (e.append(a4(y, g, s), c(m)), !1);
  }
  const l = [], f = Object.assign(Fye, {
    defaultVisitor: d,
    convertValue: c,
    isVisitable: Db
  });
  function p(m, g) {
    if (!Re.isUndefined(m)) {
      if (l.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      l.push(m), Re.forEach(m, function(b, E) {
        (!(Re.isUndefined(b) || b === null) && i.call(
          e,
          b,
          Re.isString(E) ? E.trim() : E,
          g,
          f
        )) === !0 && p(b, g ? g.concat(E) : [E]);
      }), l.pop();
    }
  }
  if (!Re.isObject(t))
    throw new TypeError("data must be an object");
  return p(t), e;
}
function o4(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
    return e[r];
  });
}
function Qv(t, e) {
  this._pairs = [], t && dg(t, this, e);
}
const Yk = Qv.prototype;
Yk.append = function(e, n) {
  this._pairs.push([e, n]);
};
Yk.toString = function(e) {
  const n = e ? function(r) {
    return e.call(this, r, o4);
  } : o4;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function Uye(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Xk(t, e, n) {
  if (!e)
    return t;
  const r = n && n.encode || Uye;
  Re.isFunction(n) && (n = {
    serialize: n
  });
  const i = n && n.serialize;
  let s;
  if (i ? s = i(e, n) : s = Re.isURLSearchParams(e) ? e.toString() : new Qv(e, n).toString(r), s) {
    const a = t.indexOf("#");
    a !== -1 && (t = t.slice(0, a)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return t;
}
class u4 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, r) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Re.forEach(this.handlers, function(r) {
      r !== null && e(r);
    });
  }
}
const Kk = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, $ye = typeof URLSearchParams < "u" ? URLSearchParams : Qv, Hye = typeof FormData < "u" ? FormData : null, jye = typeof Blob < "u" ? Blob : null, zye = {
  isBrowser: !0,
  classes: {
    URLSearchParams: $ye,
    FormData: Hye,
    Blob: jye
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Gv = typeof window < "u" && typeof document < "u", Mb = typeof navigator == "object" && navigator || void 0, qye = Gv && (!Mb || ["ReactNative", "NativeScript", "NS"].indexOf(Mb.product) < 0), Vye = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Wye = Gv && window.location.href || "http://localhost", Qye = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Gv,
  hasStandardBrowserEnv: qye,
  hasStandardBrowserWebWorkerEnv: Vye,
  navigator: Mb,
  origin: Wye
}, Symbol.toStringTag, { value: "Module" })), Yr = {
  ...Qye,
  ...zye
};
function Gye(t, e) {
  return dg(t, new Yr.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, s) {
      return Yr.isNode && Re.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function Yye(t) {
  return Re.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function Xye(t) {
  const e = {}, n = Object.keys(t);
  let r;
  const i = n.length;
  let s;
  for (r = 0; r < i; r++)
    s = n[r], e[s] = t[s];
  return e;
}
function Zk(t) {
  function e(n, r, i, s) {
    let a = n[s++];
    if (a === "__proto__") return !0;
    const o = Number.isFinite(+a), u = s >= n.length;
    return a = !a && Re.isArray(i) ? i.length : a, u ? (Re.hasOwnProp(i, a) ? i[a] = [i[a], r] : i[a] = r, !o) : ((!i[a] || !Re.isObject(i[a])) && (i[a] = []), e(n, r, i[a], s) && Re.isArray(i[a]) && (i[a] = Xye(i[a])), !o);
  }
  if (Re.isFormData(t) && Re.isFunction(t.entries)) {
    const n = {};
    return Re.forEachEntry(t, (r, i) => {
      e(Yye(r), i, n, 0);
    }), n;
  }
  return null;
}
function Kye(t, e, n) {
  if (Re.isString(t))
    try {
      return (e || JSON.parse)(t), Re.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(t);
}
const bh = {
  transitional: Kk,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, s = Re.isObject(e);
    if (s && Re.isHTMLForm(e) && (e = new FormData(e)), Re.isFormData(e))
      return i ? JSON.stringify(Zk(e)) : e;
    if (Re.isArrayBuffer(e) || Re.isBuffer(e) || Re.isStream(e) || Re.isFile(e) || Re.isBlob(e) || Re.isReadableStream(e))
      return e;
    if (Re.isArrayBufferView(e))
      return e.buffer;
    if (Re.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (s) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Gye(e, this.formSerializer).toString();
      if ((o = Re.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return dg(
          o ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return s || i ? (n.setContentType("application/json", !1), Kye(e)) : e;
  }],
  transformResponse: [function(e) {
    const n = this.transitional || bh.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (Re.isResponse(e) || Re.isReadableStream(e))
      return e;
    if (e && Re.isString(e) && (r && !this.responseType || i)) {
      const a = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (o) {
        if (a)
          throw o.name === "SyntaxError" ? Vt.from(o, Vt.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Yr.classes.FormData,
    Blob: Yr.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Re.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  bh.headers[t] = {};
});
const Zye = Re.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Jye = (t) => {
  const e = {};
  let n, r, i;
  return t && t.split(`
`).forEach(function(a) {
    i = a.indexOf(":"), n = a.substring(0, i).trim().toLowerCase(), r = a.substring(i + 1).trim(), !(!n || e[n] && Zye[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r);
  }), e;
}, l4 = Symbol("internals");
function wd(t) {
  return t && String(t).trim().toLowerCase();
}
function dm(t) {
  return t === !1 || t == null ? t : Re.isArray(t) ? t.map(dm) : String(t);
}
function eve(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(t); )
    e[r[1]] = r[2];
  return e;
}
const tve = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function fA(t, e, n, r, i) {
  if (Re.isFunction(r))
    return r.call(this, e, n);
  if (i && (e = n), !!Re.isString(e)) {
    if (Re.isString(r))
      return e.indexOf(r) !== -1;
    if (Re.isRegExp(r))
      return r.test(e);
  }
}
function nve(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
}
function rve(t, e) {
  const n = Re.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(t, r + n, {
      value: function(i, s, a) {
        return this[r].call(this, e, i, s, a);
      },
      configurable: !0
    });
  });
}
let Mi = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, r) {
    const i = this;
    function s(o, u, c) {
      const d = wd(u);
      if (!d)
        throw new Error("header name must be a non-empty string");
      const l = Re.findKey(i, d);
      (!l || i[l] === void 0 || c === !0 || c === void 0 && i[l] !== !1) && (i[l || u] = dm(o));
    }
    const a = (o, u) => Re.forEach(o, (c, d) => s(c, d, u));
    if (Re.isPlainObject(e) || e instanceof this.constructor)
      a(e, n);
    else if (Re.isString(e) && (e = e.trim()) && !tve(e))
      a(Jye(e), n);
    else if (Re.isObject(e) && Re.isIterable(e)) {
      let o = {}, u, c;
      for (const d of e) {
        if (!Re.isArray(d))
          throw TypeError("Object iterator must return a key-value pair");
        o[c = d[0]] = (u = o[c]) ? Re.isArray(u) ? [...u, d[1]] : [u, d[1]] : d[1];
      }
      a(o, n);
    } else
      e != null && s(n, e, r);
    return this;
  }
  get(e, n) {
    if (e = wd(e), e) {
      const r = Re.findKey(this, e);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return eve(i);
        if (Re.isFunction(n))
          return n.call(this, i, r);
        if (Re.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = wd(e), e) {
      const r = Re.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!n || fA(this, this[r], r, n)));
    }
    return !1;
  }
  delete(e, n) {
    const r = this;
    let i = !1;
    function s(a) {
      if (a = wd(a), a) {
        const o = Re.findKey(r, a);
        o && (!n || fA(r, r[o], o, n)) && (delete r[o], i = !0);
      }
    }
    return Re.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const s = n[r];
      (!e || fA(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const n = this, r = {};
    return Re.forEach(this, (i, s) => {
      const a = Re.findKey(r, s);
      if (a) {
        n[a] = dm(i), delete n[s];
        return;
      }
      const o = e ? nve(s) : String(s).trim();
      o !== s && delete n[s], n[o] = dm(i), r[o] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return Re.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = e && Re.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const r = new this(e);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(e) {
    const r = (this[l4] = this[l4] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(a) {
      const o = wd(a);
      r[o] || (rve(i, a), r[o] = !0);
    }
    return Re.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
Mi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Re.reduceDescriptors(Mi.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[n] = r;
    }
  };
});
Re.freezeMethods(Mi);
function hA(t, e) {
  const n = this || bh, r = e || n, i = Mi.from(r.headers);
  let s = r.data;
  return Re.forEach(t, function(o) {
    s = o.call(n, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function Jk(t) {
  return !!(t && t.__CANCEL__);
}
function Fc(t, e, n) {
  Vt.call(this, t ?? "canceled", Vt.ERR_CANCELED, e, n), this.name = "CanceledError";
}
Re.inherits(Fc, Vt, {
  __CANCEL__: !0
});
function e5(t, e, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? t(n) : e(new Vt(
    "Request failed with status code " + n.status,
    [Vt.ERR_BAD_REQUEST, Vt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function ive(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function sve(t, e) {
  t = t || 10;
  const n = new Array(t), r = new Array(t);
  let i = 0, s = 0, a;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const c = Date.now(), d = r[s];
    a || (a = c), n[i] = u, r[i] = c;
    let l = s, f = 0;
    for (; l !== i; )
      f += n[l++], l = l % t;
    if (i = (i + 1) % t, i === s && (s = (s + 1) % t), c - a < e)
      return;
    const p = d && c - d;
    return p ? Math.round(f * 1e3 / p) : void 0;
  };
}
function ave(t, e) {
  let n = 0, r = 1e3 / e, i, s;
  const a = (c, d = Date.now()) => {
    n = d, i = null, s && (clearTimeout(s), s = null), t.apply(null, c);
  };
  return [(...c) => {
    const d = Date.now(), l = d - n;
    l >= r ? a(c, d) : (i = c, s || (s = setTimeout(() => {
      s = null, a(i);
    }, r - l)));
  }, () => i && a(i)];
}
const Gm = (t, e, n = 3) => {
  let r = 0;
  const i = sve(50, 250);
  return ave((s) => {
    const a = s.loaded, o = s.lengthComputable ? s.total : void 0, u = a - r, c = i(u), d = a <= o;
    r = a;
    const l = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: u,
      rate: c || void 0,
      estimated: c && o && d ? (o - a) / c : void 0,
      event: s,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    t(l);
  }, n);
}, c4 = (t, e) => {
  const n = t != null;
  return [(r) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: r
  }), e[1]];
}, d4 = (t) => (...e) => Re.asap(() => t(...e)), ove = Yr.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (n) => (n = new URL(n, Yr.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(
  new URL(Yr.origin),
  Yr.navigator && /(msie|trident)/i.test(Yr.navigator.userAgent)
) : () => !0, uve = Yr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, r, i, s) {
      const a = [t + "=" + encodeURIComponent(e)];
      Re.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), Re.isString(r) && a.push("path=" + r), Re.isString(i) && a.push("domain=" + i), s === !0 && a.push("secure"), document.cookie = a.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function lve(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function cve(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function t5(t, e, n) {
  let r = !lve(e);
  return t && (r || n == !1) ? cve(t, e) : e;
}
const f4 = (t) => t instanceof Mi ? { ...t } : t;
function Hu(t, e) {
  e = e || {};
  const n = {};
  function r(c, d, l, f) {
    return Re.isPlainObject(c) && Re.isPlainObject(d) ? Re.merge.call({ caseless: f }, c, d) : Re.isPlainObject(d) ? Re.merge({}, d) : Re.isArray(d) ? d.slice() : d;
  }
  function i(c, d, l, f) {
    if (Re.isUndefined(d)) {
      if (!Re.isUndefined(c))
        return r(void 0, c, l, f);
    } else return r(c, d, l, f);
  }
  function s(c, d) {
    if (!Re.isUndefined(d))
      return r(void 0, d);
  }
  function a(c, d) {
    if (Re.isUndefined(d)) {
      if (!Re.isUndefined(c))
        return r(void 0, c);
    } else return r(void 0, d);
  }
  function o(c, d, l) {
    if (l in e)
      return r(c, d);
    if (l in t)
      return r(void 0, c);
  }
  const u = {
    url: s,
    method: s,
    data: s,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: o,
    headers: (c, d, l) => i(f4(c), f4(d), l, !0)
  };
  return Re.forEach(Object.keys(Object.assign({}, t, e)), function(d) {
    const l = u[d] || i, f = l(t[d], e[d], d);
    Re.isUndefined(f) && l !== o || (n[d] = f);
  }), n;
}
const n5 = (t) => {
  const e = Hu({}, t);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: a, auth: o } = e;
  e.headers = a = Mi.from(a), e.url = Xk(t5(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), o && a.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let u;
  if (Re.isFormData(n)) {
    if (Yr.hasStandardBrowserEnv || Yr.hasStandardBrowserWebWorkerEnv)
      a.setContentType(void 0);
    else if ((u = a.getContentType()) !== !1) {
      const [c, ...d] = u ? u.split(";").map((l) => l.trim()).filter(Boolean) : [];
      a.setContentType([c || "multipart/form-data", ...d].join("; "));
    }
  }
  if (Yr.hasStandardBrowserEnv && (r && Re.isFunction(r) && (r = r(e)), r || r !== !1 && ove(e.url))) {
    const c = i && s && uve.read(s);
    c && a.set(i, c);
  }
  return e;
}, dve = typeof XMLHttpRequest < "u", fve = dve && function(t) {
  return new Promise(function(n, r) {
    const i = n5(t);
    let s = i.data;
    const a = Mi.from(i.headers).normalize();
    let { responseType: o, onUploadProgress: u, onDownloadProgress: c } = i, d, l, f, p, m;
    function g() {
      p && p(), m && m(), i.cancelToken && i.cancelToken.unsubscribe(d), i.signal && i.signal.removeEventListener("abort", d);
    }
    let y = new XMLHttpRequest();
    y.open(i.method.toUpperCase(), i.url, !0), y.timeout = i.timeout;
    function b() {
      if (!y)
        return;
      const v = Mi.from(
        "getAllResponseHeaders" in y && y.getAllResponseHeaders()
      ), D = {
        data: !o || o === "text" || o === "json" ? y.responseText : y.response,
        status: y.status,
        statusText: y.statusText,
        headers: v,
        config: t,
        request: y
      };
      e5(function(M) {
        n(M), g();
      }, function(M) {
        r(M), g();
      }, D), y = null;
    }
    "onloadend" in y ? y.onloadend = b : y.onreadystatechange = function() {
      !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, y.onabort = function() {
      y && (r(new Vt("Request aborted", Vt.ECONNABORTED, t, y)), y = null);
    }, y.onerror = function() {
      r(new Vt("Network Error", Vt.ERR_NETWORK, t, y)), y = null;
    }, y.ontimeout = function() {
      let _ = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const D = i.transitional || Kk;
      i.timeoutErrorMessage && (_ = i.timeoutErrorMessage), r(new Vt(
        _,
        D.clarifyTimeoutError ? Vt.ETIMEDOUT : Vt.ECONNABORTED,
        t,
        y
      )), y = null;
    }, s === void 0 && a.setContentType(null), "setRequestHeader" in y && Re.forEach(a.toJSON(), function(_, D) {
      y.setRequestHeader(D, _);
    }), Re.isUndefined(i.withCredentials) || (y.withCredentials = !!i.withCredentials), o && o !== "json" && (y.responseType = i.responseType), c && ([f, m] = Gm(c, !0), y.addEventListener("progress", f)), u && y.upload && ([l, p] = Gm(u), y.upload.addEventListener("progress", l), y.upload.addEventListener("loadend", p)), (i.cancelToken || i.signal) && (d = (v) => {
      y && (r(!v || v.type ? new Fc(null, t, y) : v), y.abort(), y = null);
    }, i.cancelToken && i.cancelToken.subscribe(d), i.signal && (i.signal.aborted ? d() : i.signal.addEventListener("abort", d)));
    const E = ive(i.url);
    if (E && Yr.protocols.indexOf(E) === -1) {
      r(new Vt("Unsupported protocol " + E + ":", Vt.ERR_BAD_REQUEST, t));
      return;
    }
    y.send(s || null);
  });
}, hve = (t, e) => {
  const { length: n } = t = t ? t.filter(Boolean) : [];
  if (e || n) {
    let r = new AbortController(), i;
    const s = function(c) {
      if (!i) {
        i = !0, o();
        const d = c instanceof Error ? c : this.reason;
        r.abort(d instanceof Vt ? d : new Fc(d instanceof Error ? d.message : d));
      }
    };
    let a = e && setTimeout(() => {
      a = null, s(new Vt(`timeout ${e} of ms exceeded`, Vt.ETIMEDOUT));
    }, e);
    const o = () => {
      t && (a && clearTimeout(a), a = null, t.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s);
      }), t = null);
    };
    t.forEach((c) => c.addEventListener("abort", s));
    const { signal: u } = r;
    return u.unsubscribe = () => Re.asap(o), u;
  }
}, pve = function* (t, e) {
  let n = t.byteLength;
  if (n < e) {
    yield t;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + e, yield t.slice(r, i), r = i;
}, mve = async function* (t, e) {
  for await (const n of gve(t))
    yield* pve(n, e);
}, gve = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await e.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await e.cancel();
  }
}, h4 = (t, e, n, r) => {
  const i = mve(t, e);
  let s = 0, a, o = (u) => {
    a || (a = !0, r && r(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: c, value: d } = await i.next();
        if (c) {
          o(), u.close();
          return;
        }
        let l = d.byteLength;
        if (n) {
          let f = s += l;
          n(f);
        }
        u.enqueue(new Uint8Array(d));
      } catch (c) {
        throw o(c), c;
      }
    },
    cancel(u) {
      return o(u), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, fg = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", r5 = fg && typeof ReadableStream == "function", Ave = fg && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), i5 = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, bve = r5 && i5(() => {
  let t = !1;
  const e = new Request(Yr.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), p4 = 64 * 1024, Ob = r5 && i5(() => Re.isReadableStream(new Response("").body)), Ym = {
  stream: Ob && ((t) => t.body)
};
fg && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Ym[e] && (Ym[e] = Re.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
      throw new Vt(`Response type '${e}' is not supported`, Vt.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const yve = async (t) => {
  if (t == null)
    return 0;
  if (Re.isBlob(t))
    return t.size;
  if (Re.isSpecCompliantForm(t))
    return (await new Request(Yr.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (Re.isArrayBufferView(t) || Re.isArrayBuffer(t))
    return t.byteLength;
  if (Re.isURLSearchParams(t) && (t = t + ""), Re.isString(t))
    return (await Ave(t)).byteLength;
}, vve = async (t, e) => {
  const n = Re.toFiniteNumber(t.getContentLength());
  return n ?? yve(e);
}, Tve = fg && (async (t) => {
  let {
    url: e,
    method: n,
    data: r,
    signal: i,
    cancelToken: s,
    timeout: a,
    onDownloadProgress: o,
    onUploadProgress: u,
    responseType: c,
    headers: d,
    withCredentials: l = "same-origin",
    fetchOptions: f
  } = n5(t);
  c = c ? (c + "").toLowerCase() : "text";
  let p = hve([i, s && s.toAbortSignal()], a), m;
  const g = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let y;
  try {
    if (u && bve && n !== "get" && n !== "head" && (y = await vve(d, r)) !== 0) {
      let D = new Request(e, {
        method: "POST",
        body: r,
        duplex: "half"
      }), S;
      if (Re.isFormData(r) && (S = D.headers.get("content-type")) && d.setContentType(S), D.body) {
        const [M, O] = c4(
          y,
          Gm(d4(u))
        );
        r = h4(D.body, p4, M, O);
      }
    }
    Re.isString(l) || (l = l ? "include" : "omit");
    const b = "credentials" in Request.prototype;
    m = new Request(e, {
      ...f,
      signal: p,
      method: n.toUpperCase(),
      headers: d.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: b ? l : void 0
    });
    let E = await fetch(m, f);
    const v = Ob && (c === "stream" || c === "response");
    if (Ob && (o || v && g)) {
      const D = {};
      ["status", "statusText", "headers"].forEach((T) => {
        D[T] = E[T];
      });
      const S = Re.toFiniteNumber(E.headers.get("content-length")), [M, O] = o && c4(
        S,
        Gm(d4(o), !0)
      ) || [];
      E = new Response(
        h4(E.body, p4, M, () => {
          O && O(), g && g();
        }),
        D
      );
    }
    c = c || "text";
    let _ = await Ym[Re.findKey(Ym, c) || "text"](E, t);
    return !v && g && g(), await new Promise((D, S) => {
      e5(D, S, {
        data: _,
        headers: Mi.from(E.headers),
        status: E.status,
        statusText: E.statusText,
        config: t,
        request: m
      });
    });
  } catch (b) {
    throw g && g(), b && b.name === "TypeError" && /Load failed|fetch/i.test(b.message) ? Object.assign(
      new Vt("Network Error", Vt.ERR_NETWORK, t, m),
      {
        cause: b.cause || b
      }
    ) : Vt.from(b, b && b.code, t, m);
  }
}), Nb = {
  http: Rye,
  xhr: fve,
  fetch: Tve
};
Re.forEach(Nb, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const m4 = (t) => `- ${t}`, _ve = (t) => Re.isFunction(t) || t === null || t === !1, s5 = {
  getAdapter: (t) => {
    t = Re.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, r;
    const i = {};
    for (let s = 0; s < e; s++) {
      n = t[s];
      let a;
      if (r = n, !_ve(n) && (r = Nb[(a = String(n)).toLowerCase()], r === void 0))
        throw new Vt(`Unknown adapter '${a}'`);
      if (r)
        break;
      i[a || "#" + s] = r;
    }
    if (!r) {
      const s = Object.entries(i).map(
        ([o, u]) => `adapter ${o} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let a = e ? s.length > 1 ? `since :
` + s.map(m4).join(`
`) : " " + m4(s[0]) : "as no adapter specified";
      throw new Vt(
        "There is no suitable adapter to dispatch the request " + a,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Nb
};
function pA(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new Fc(null, t);
}
function g4(t) {
  return pA(t), t.headers = Mi.from(t.headers), t.data = hA.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), s5.getAdapter(t.adapter || bh.adapter)(t).then(function(r) {
    return pA(t), r.data = hA.call(
      t,
      t.transformResponse,
      r
    ), r.headers = Mi.from(r.headers), r;
  }, function(r) {
    return Jk(r) || (pA(t), r && r.response && (r.response.data = hA.call(
      t,
      t.transformResponse,
      r.response
    ), r.response.headers = Mi.from(r.response.headers))), Promise.reject(r);
  });
}
const a5 = "1.10.0", hg = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  hg[t] = function(r) {
    return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const A4 = {};
hg.transitional = function(e, n, r) {
  function i(s, a) {
    return "[Axios v" + a5 + "] Transitional option '" + s + "'" + a + (r ? ". " + r : "");
  }
  return (s, a, o) => {
    if (e === !1)
      throw new Vt(
        i(a, " has been removed" + (n ? " in " + n : "")),
        Vt.ERR_DEPRECATED
      );
    return n && !A4[a] && (A4[a] = !0, console.warn(
      i(
        a,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(s, a, o) : !0;
  };
};
hg.spelling = function(e) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
};
function Eve(t, e, n) {
  if (typeof t != "object")
    throw new Vt("options must be an object", Vt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(t);
  let i = r.length;
  for (; i-- > 0; ) {
    const s = r[i], a = e[s];
    if (a) {
      const o = t[s], u = o === void 0 || a(o, s, t);
      if (u !== !0)
        throw new Vt("option " + s + " must be " + u, Vt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Vt("Unknown option " + s, Vt.ERR_BAD_OPTION);
  }
}
const fm = {
  assertOptions: Eve,
  validators: hg
}, Ws = fm.validators;
let Cu = class {
  constructor(e) {
    this.defaults = e || {}, this.interceptors = {
      request: new u4(),
      response: new u4()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (r) {
      if (r instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Hu(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: s } = n;
    r !== void 0 && fm.assertOptions(r, {
      silentJSONParsing: Ws.transitional(Ws.boolean),
      forcedJSONParsing: Ws.transitional(Ws.boolean),
      clarifyTimeoutError: Ws.transitional(Ws.boolean)
    }, !1), i != null && (Re.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : fm.assertOptions(i, {
      encode: Ws.function,
      serialize: Ws.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), fm.assertOptions(n, {
      baseUrl: Ws.spelling("baseURL"),
      withXsrfToken: Ws.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let a = s && Re.merge(
      s.common,
      s[n.method]
    );
    s && Re.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete s[m];
      }
    ), n.headers = Mi.concat(a, s);
    const o = [];
    let u = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (u = u && g.synchronous, o.unshift(g.fulfilled, g.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(g) {
      c.push(g.fulfilled, g.rejected);
    });
    let d, l = 0, f;
    if (!u) {
      const m = [g4.bind(this), void 0];
      for (m.unshift.apply(m, o), m.push.apply(m, c), f = m.length, d = Promise.resolve(n); l < f; )
        d = d.then(m[l++], m[l++]);
      return d;
    }
    f = o.length;
    let p = n;
    for (l = 0; l < f; ) {
      const m = o[l++], g = o[l++];
      try {
        p = m(p);
      } catch (y) {
        g.call(this, y);
        break;
      }
    }
    try {
      d = g4.call(this, p);
    } catch (m) {
      return Promise.reject(m);
    }
    for (l = 0, f = c.length; l < f; )
      d = d.then(c[l++], c[l++]);
    return d;
  }
  getUri(e) {
    e = Hu(this.defaults, e);
    const n = t5(e.baseURL, e.url, e.allowAbsoluteUrls);
    return Xk(n, e.params, e.paramsSerializer);
  }
};
Re.forEach(["delete", "get", "head", "options"], function(e) {
  Cu.prototype[e] = function(n, r) {
    return this.request(Hu(r || {}, {
      method: e,
      url: n,
      data: (r || {}).data
    }));
  };
});
Re.forEach(["post", "put", "patch"], function(e) {
  function n(r) {
    return function(s, a, o) {
      return this.request(Hu(o || {}, {
        method: e,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: a
      }));
    };
  }
  Cu.prototype[e] = n(), Cu.prototype[e + "Form"] = n(!0);
});
let xve = class o5 {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(s) {
      n = s;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let s = r._listeners.length;
      for (; s-- > 0; )
        r._listeners[s](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const a = new Promise((o) => {
        r.subscribe(o), s = o;
      }).then(i);
      return a.cancel = function() {
        r.unsubscribe(s);
      }, a;
    }, e(function(s, a, o) {
      r.reason || (r.reason = new Fc(s, a, o), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), n = (r) => {
      e.abort(r);
    };
    return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new o5(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function wve(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function Cve(t) {
  return Re.isObject(t) && t.isAxiosError === !0;
}
const Lb = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Lb).forEach(([t, e]) => {
  Lb[e] = t;
});
function u5(t) {
  const e = new Cu(t), n = Fk(Cu.prototype.request, e);
  return Re.extend(n, Cu.prototype, e, { allOwnKeys: !0 }), Re.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(i) {
    return u5(Hu(t, i));
  }, n;
}
const Qn = u5(bh);
Qn.Axios = Cu;
Qn.CanceledError = Fc;
Qn.CancelToken = xve;
Qn.isCancel = Jk;
Qn.VERSION = a5;
Qn.toFormData = dg;
Qn.AxiosError = Vt;
Qn.Cancel = Qn.CanceledError;
Qn.all = function(e) {
  return Promise.all(e);
};
Qn.spread = wve;
Qn.isAxiosError = Cve;
Qn.mergeConfig = Hu;
Qn.AxiosHeaders = Mi;
Qn.formToJSON = (t) => Zk(Re.isHTMLForm(t) ? new FormData(t) : t);
Qn.getAdapter = s5.getAdapter;
Qn.HttpStatusCode = Lb;
Qn.default = Qn;
const {
  Axios: AXe,
  AxiosError: bXe,
  CanceledError: yXe,
  isCancel: vXe,
  CancelToken: TXe,
  VERSION: _Xe,
  all: EXe,
  Cancel: xXe,
  isAxiosError: wXe,
  spread: CXe,
  toFormData: SXe,
  AxiosHeaders: b4,
  HttpStatusCode: IXe,
  formToJSON: kXe,
  getAdapter: DXe,
  mergeConfig: MXe
} = Qn;
var xp = {}, mA = {}, wp = {}, Cd = {}, y4;
function l5() {
  if (y4) return Cd;
  y4 = 1, Object.defineProperty(Cd, "__esModule", { value: !0 }), Cd.createTimeAwareMapObserver = void 0;
  var t = function(e) {
    var n = /* @__PURE__ */ new Map();
    return {
      create: function(r, i) {
        var s = setTimeout(function() {
          i(r);
        }, e);
        n.set(r, s);
      },
      cancel: function(r) {
        if (n.has(r)) {
          var i = n.get(r);
          n.delete(r), clearTimeout(i);
        }
      }
    };
  };
  return Cd.createTimeAwareMapObserver = t, Cd;
}
var v4;
function Sve() {
  if (v4) return wp;
  v4 = 1, Object.defineProperty(wp, "__esModule", { value: !0 });
  var t = l5();
  function e(n) {
    var r = /* @__PURE__ */ new Map(), i = (0, t.createTimeAwareMapObserver)(n.timeToClear);
    function s(l) {
      var f = r.get(l);
      return f || null;
    }
    function a(l) {
      return r.delete(l), i.cancel(l), !0;
    }
    function o() {
      return r.size;
    }
    function u(l) {
      return r.has(l);
    }
    function c() {
      return Array.from(r.keys());
    }
    function d(l, f) {
      return r.set(l, f), i.create(l, a), !0;
    }
    return {
      keys: c,
      size: o,
      has: u,
      get: s,
      set: d,
      remove: a
    };
  }
  return wp.default = e, wp;
}
var Cp = {}, Sd = {}, T4;
function Ive() {
  if (T4) return Sd;
  T4 = 1, Object.defineProperty(Sd, "__esModule", { value: !0 }), Sd.LRULinkedList = void 0;
  var t = (
    /** @class */
    /* @__PURE__ */ function() {
      function n(r, i) {
        this.next = null, this.data = i, this.id = r, this.prev = null;
      }
      return n;
    }()
  ), e = (
    /** @class */
    function() {
      function n(r) {
        this.__size = 0, this.limit = 0, this.positions = /* @__PURE__ */ new Map(), this.HEAD = null, this.TAIL = null, this.limit = r.lruSize;
      }
      return Object.defineProperty(n.prototype, "size", {
        get: function() {
          return this.__size;
        },
        set: function(r) {
          this.__size = r, this.__size > this.limit && this.shrinkList();
        },
        enumerable: !1,
        configurable: !0
      }), n.prototype.moveToHead = function(r) {
        var i = this.remove(r.id);
        if (i) {
          var s = this.addNodeToHead(i.id, i.data);
          return s;
        }
        return null;
      }, n.prototype.addNodeToHead = function(r, i) {
        if (this.positions.has(r)) {
          var s = this.moveToHead(this.positions.get(r));
          return this.positions.get(r).data = i, s;
        }
        if (this.HEAD) {
          var a = this.HEAD, o = new t(r, i);
          return o.next = a, o.prev = null, a.prev = o, this.HEAD = o, this.positions.set(r, o), this.size++, o;
        } else {
          var u = new t(r, i);
          return this.HEAD = u, this.TAIL || (this.TAIL = u), this.positions.set(r, u), this.size++, u;
        }
      }, n.prototype.remove = function(r) {
        if (!this.HEAD)
          return null;
        var i = this.positions.get(r);
        if (!i)
          return null;
        var s = i.prev, a = i.next;
        return s && a ? (s.next = a, a.prev = s, this.positions.delete(r), this.size--, i) : s && !a ? (s.next = null, this.TAIL = s, this.positions.delete(r), this.size--, i) : !s && a ? (a.prev = null, this.HEAD = a, this.positions.delete(r), this.size--, i) : !s && !a ? (this.HEAD = null, this.TAIL = null, this.positions.delete(r), this.size--, i) : null;
      }, n.prototype.keys = function() {
        return Array.from(this.positions.keys());
      }, n.prototype.shrinkList = function() {
        for (var r = this.size - this.limit, i = this.TAIL, s = 1; s <= r; s++)
          this.positions.delete(i.id), this.size--, i = i.prev;
        i.next = null, this.TAIL = i;
      }, n.prototype.has = function(r) {
        return !!this.positions.has(r);
      }, n.prototype.traverse = function() {
        if (this.HEAD)
          for (var r = this.HEAD; r; )
            r = r.next;
      }, n.prototype.get = function(r) {
        var i = this.positions.get(r);
        if (i) {
          var s = this.moveToHead(i);
          return s ? s.data : null;
        }
        return null;
      }, n;
    }()
  );
  return Sd.LRULinkedList = e, Sd;
}
var _4;
function kve() {
  if (_4) return Cp;
  _4 = 1, Object.defineProperty(Cp, "__esModule", { value: !0 });
  var t = Ive();
  function e(n) {
    var r = new t.LRULinkedList(n);
    function i(d) {
      var l = r.get(d);
      return l || null;
    }
    function s(d) {
      return r.remove(d), !0;
    }
    function a(d) {
      return r.has(d);
    }
    function o() {
      return r.size;
    }
    function u() {
      return r.keys();
    }
    function c(d, l) {
      return r.addNodeToHead(d, l), !0;
    }
    return {
      keys: u,
      size: o,
      get: i,
      set: c,
      remove: s,
      has: a
    };
  }
  return Cp.default = e, Cp;
}
var Sp = {}, Id = {}, E4;
function Dve() {
  if (E4) return Id;
  E4 = 1, Object.defineProperty(Id, "__esModule", { value: !0 }), Id.MRULinkedList = void 0;
  var t = (
    /** @class */
    /* @__PURE__ */ function() {
      function n(r, i) {
        this.next = null, this.data = i, this.id = r, this.prev = null;
      }
      return n;
    }()
  ), e = (
    /** @class */
    function() {
      function n(r) {
        this.__size = 0, this.limit = 0, this.positions = /* @__PURE__ */ new Map(), this.HEAD = null, this.TAIL = null, this.limit = r.mruSize;
      }
      return Object.defineProperty(n.prototype, "size", {
        get: function() {
          return this.__size;
        },
        set: function(r) {
          this.__size = r, this.__size > this.limit && this.shrinkList();
        },
        enumerable: !1,
        configurable: !0
      }), n.prototype.keys = function() {
        return Array.from(this.positions.keys());
      }, n.prototype.moveToTail = function(r) {
        var i = this.remove(r.id);
        if (i) {
          var s = this.addNodeToTail(i.id, i.data);
          return s;
        }
        return null;
      }, n.prototype.moveToHead = function(r) {
        var i = this.remove(r.id);
        if (i) {
          var s = this.addNodeToHead(i.id, i.data);
          return s;
        }
        return null;
      }, n.prototype.addNodeToHead = function(r, i) {
        if (this.positions.has(r)) {
          var s = this.moveToHead(this.positions.get(r));
          return this.positions.get(r).data = i, s;
        }
        if (this.HEAD) {
          var a = this.HEAD, o = new t(r, i);
          return o.next = a, o.prev = null, a.prev = o, this.HEAD = o, this.positions.set(r, o), this.size++, o;
        } else {
          var u = new t(r, i);
          return this.HEAD = u, this.TAIL || (this.TAIL = u), this.positions.set(r, u), this.size++, u;
        }
      }, n.prototype.addNodeToTail = function(r, i) {
        if (this.positions.has(r)) {
          var s = this.moveToTail(this.positions.get(r));
          return this.positions.get(r).data = i, s;
        }
        if (this.TAIL) {
          var a = this.TAIL, o = new t(r, i);
          return o.prev = a, o.next = null, a.next = o, this.TAIL = o, this.positions.set(r, o), this.size++, o;
        } else {
          var u = new t(r, i);
          return this.TAIL = u, this.HEAD || (this.HEAD = u), this.positions.set(r, u), this.size++, u;
        }
      }, n.prototype.remove = function(r) {
        if (!this.HEAD)
          return null;
        var i = this.positions.get(r);
        if (!i)
          return null;
        var s = i.prev, a = i.next;
        return s && a ? (s.next = a, a.prev = s, this.positions.delete(r), this.size--, i) : s && !a ? (s.next = null, this.TAIL = s, this.positions.delete(r), this.size--, i) : !s && a ? (a.prev = null, this.HEAD = a, this.positions.delete(r), this.size--, i) : !s && !a ? (this.HEAD = null, this.TAIL = null, this.positions.delete(r), this.size--, i) : null;
      }, n.prototype.shrinkList = function() {
        for (var r = this.size - this.limit, i = this.TAIL, s = 1; s <= r; s++)
          this.positions.delete(i.id), this.size--, i = i.prev;
        i.next = null, this.TAIL = i;
      }, n.prototype.has = function(r) {
        return !!this.positions.has(r);
      }, n.prototype.traverse = function() {
        if (this.HEAD)
          for (var r = this.HEAD; r; )
            r = r.next;
      }, n.prototype.get = function(r) {
        var i = this.positions.get(r);
        if (i) {
          var s = this.moveToTail(i);
          return s ? s.data : null;
        }
        return null;
      }, n;
    }()
  );
  return Id.MRULinkedList = e, Id;
}
var x4;
function Mve() {
  if (x4) return Sp;
  x4 = 1, Object.defineProperty(Sp, "__esModule", { value: !0 });
  var t = Dve();
  function e(n) {
    var r = new t.MRULinkedList(n);
    function i(d) {
      var l = r.get(d);
      return l || null;
    }
    function s(d) {
      return r.remove(d), !0;
    }
    function a(d) {
      return r.has(d);
    }
    function o() {
      return r.size;
    }
    function u() {
      return r.keys();
    }
    function c(d, l) {
      return r.addNodeToHead(d, l), !0;
    }
    return {
      keys: u,
      size: o,
      has: a,
      get: i,
      set: c,
      remove: s
    };
  }
  return Sp.default = e, Sp;
}
var Ip = {}, kd = {}, w4;
function Ove() {
  if (w4) return kd;
  w4 = 1, Object.defineProperty(kd, "__esModule", { value: !0 }), kd.TLRULinkedList = void 0;
  var t = l5(), e = (
    /** @class */
    /* @__PURE__ */ function() {
      function r(i, s) {
        this.next = null, this.data = s, this.id = i, this.prev = null;
      }
      return r;
    }()
  ), n = (
    /** @class */
    function() {
      function r(i) {
        this.__size = 0, this.limit = 0, this.positions = /* @__PURE__ */ new Map(), this.HEAD = null, this.TAIL = null, this.limit = i.lruSize, this.timer = (0, t.createTimeAwareMapObserver)(i.timeToClear);
      }
      return Object.defineProperty(r.prototype, "size", {
        get: function() {
          return this.__size;
        },
        set: function(i) {
          this.__size = i, this.__size > this.limit && this.shrinkList();
        },
        enumerable: !1,
        configurable: !0
      }), r.prototype.moveToHead = function(i) {
        var s = this.remove(i.id);
        if (s) {
          var a = this.addNodeToHead(s.id, s.data);
          return a;
        }
        return null;
      }, r.prototype.addNodeToHead = function(i, s) {
        if (this.positions.has(i)) {
          var a = this.moveToHead(this.positions.get(i));
          return this.positions.get(i).data = s, a;
        }
        var o = this.remove.bind(this);
        if (this.timer.create(i, o), this.HEAD) {
          var u = this.HEAD, c = new e(i, s);
          return c.next = u, c.prev = null, u.prev = c, this.HEAD = c, this.positions.set(i, c), this.size++, c;
        } else {
          var d = new e(i, s);
          return this.HEAD = d, this.TAIL || (this.TAIL = d), this.positions.set(i, d), this.size++, d;
        }
      }, r.prototype.remove = function(i) {
        if (!this.HEAD)
          return null;
        var s = this.positions.get(i);
        if (!s)
          return null;
        var a = s.prev, o = s.next;
        return a && o ? (a.next = o, o.prev = a, this.positions.delete(i), this.timer.cancel(i), this.size--, s) : a && !o ? (a.next = null, this.TAIL = a, this.positions.delete(i), this.timer.cancel(i), this.size--, s) : !a && o ? (o.prev = null, this.HEAD = o, this.positions.delete(i), this.timer.cancel(i), this.size--, s) : !a && !o ? (this.HEAD = null, this.TAIL = null, this.positions.delete(i), this.timer.cancel(i), this.size--, s) : null;
      }, r.prototype.keys = function() {
        return Array.from(this.positions.keys());
      }, r.prototype.shrinkList = function() {
        for (var i = this.size - this.limit, s = this.TAIL, a = 1; a <= i; a++)
          this.positions.delete(s.id), this.timer.cancel(s.id), this.size--, s = s.prev;
        s.next = null, this.TAIL = s;
      }, r.prototype.has = function(i) {
        return !!this.positions.has(i);
      }, r.prototype.traverse = function() {
        if (this.HEAD)
          for (var i = this.HEAD; i; )
            i = i.next;
      }, r.prototype.get = function(i) {
        var s = this.positions.get(i);
        if (s) {
          var a = this.moveToHead(s);
          return a ? a.data : null;
        }
        return null;
      }, r;
    }()
  );
  return kd.TLRULinkedList = n, kd;
}
var C4;
function Nve() {
  if (C4) return Ip;
  C4 = 1, Object.defineProperty(Ip, "__esModule", { value: !0 });
  var t = Ove();
  function e(n) {
    var r = new t.TLRULinkedList(n);
    function i(d) {
      var l = r.get(d);
      return l || null;
    }
    function s(d) {
      return r.remove(d), !0;
    }
    function a(d) {
      return r.has(d);
    }
    function o() {
      return r.size;
    }
    function u() {
      return r.keys();
    }
    function c(d, l) {
      return r.addNodeToHead(d, l), !0;
    }
    return {
      keys: u,
      size: o,
      get: i,
      set: c,
      remove: s,
      has: a
    };
  }
  return Ip.default = e, Ip;
}
var S4;
function Lve() {
  return S4 || (S4 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.defaultConfig = void 0;
    var e = Sve(), n = kve(), r = Mve(), i = Nve();
    t.defaultConfig = {
      strategy: "lru",
      policy: "lru",
      timeToClear: 72e5,
      lruSize: 500,
      mruSize: 500
    };
    function s(a) {
      var o = {};
      typeof a == "object" && (o = a);
      var u = Object.assign({}, t.defaultConfig, o);
      switch (u.policy) {
        case "timeout":
          return (0, e.default)(u);
        case "lru":
          return (0, n.default)(u);
        case "mru":
          return (0, r.default)(u);
        case "tlru":
          return (0, i.default)(u);
        default:
          throw new Error(u.policy + " is not a supported policy.");
      }
    }
    t.default = s;
  }(mA)), mA;
}
var I4;
function Pve() {
  if (I4) return xp;
  I4 = 1, Object.defineProperty(xp, "__esModule", { value: !0 });
  var t = Lve();
  return xp.default = t.default, xp;
}
var Rve = Pve();
const k4 = /* @__PURE__ */ Fr(Rve);
class c5 {
  constructor(e = null) {
    Ke(this, "head");
    Ke(this, "tail");
    Ke(this, "main");
    Ke(this, "length");
    this.head = e, this.tail = e, this.main = e, this.length = e ? 1 : 0;
  }
  numberOfMessages() {
    let e = 0, n = this.head;
    for (; n; )
      e += n.length, n = n.next;
    return e;
  }
  concate(e) {
    var n;
    (n = this.main) == null || n.concate(e);
  }
  unshift(e) {
    var n;
    (n = this.main) == null || n.unshift(e);
  }
  insert(e) {
    if (this.length === 0) {
      this.head = this.tail = this.main = e, this.length = 1;
      return;
    }
    if (e.length === 0) return;
    let n = this.tail;
    for (; n && n.head.createdAt > e.head.createdAt; )
      n = n.prev;
    n ? (n === this.tail && (this.tail = e), e.next = n.next, e.next && (e.next.prev = e), n.next = e, e.prev = n) : (e.next = this.head, e.next && (e.next.prev = e), this.head = e), this.main = e, this.length++;
  }
  merge() {
    if (this.length <= 1) return;
    let e = this.tail;
    for (; e; ) {
      if (e.prev && e.canCombine(e.prev)) {
        e.combine(e.prev), e.prev === this.main && (this.main = e), e.prev = e.prev.prev, e.prev ? e.prev.next = e : this.head = e, this.length--;
        break;
      }
      e = e.prev;
    }
    e && this.merge();
  }
  isValid() {
    if (this.head && this.head.prev || this.tail && this.tail.next)
      return !1;
    let e = 0, n = this.head;
    for (; n; ) {
      if (n.prev && n.prev.next !== n || n.next && n.next.prev !== n)
        return !1;
      e++, n = n.next;
    }
    return e === this.length;
  }
}
var to = {}, Dd = {}, D4;
function Bve() {
  return D4 || (D4 = 1, function(t) {
    var e = Dd && Dd.__awaiter || function(i, s, a, o) {
      return new (a || (a = Promise))(function(u, c) {
        function d(p) {
          try {
            f(o.next(p));
          } catch (m) {
            c(m);
          }
        }
        function l(p) {
          try {
            f(o.throw(p));
          } catch (m) {
            c(m);
          }
        }
        function f(p) {
          p.done ? u(p.value) : new a(function(m) {
            m(p.value);
          }).then(d, l);
        }
        f((o = o.apply(i, s || [])).next());
      });
    };
    Object.defineProperty(t, "__esModule", { value: !0 });
    var n;
    (function(i) {
      i[i.Idle = 0] = "Idle", i[i.Reading = 1] = "Reading", i[i.Writing = 2] = "Writing";
    })(n = t.State || (t.State = {})), t.ErrNotLocked = new Error("rwlock is already unlocked"), t.ErrTimeout = new Error("acquire lock timeout");
    class r {
      constructor() {
        this.pendingReaders = [], this.pendingWriters = [], this.numReaders = 0, this.state = n.Idle, this.getState = this.getState.bind(this), this.readLock = this.readLock.bind(this), this.writeLock = this.writeLock.bind(this), this.unlock = this.unlock.bind(this);
      }
      getState() {
        return this.state;
      }
      readLock(s = 1 / 0) {
        return e(this, void 0, void 0, function* () {
          return new Promise((a, o) => {
            this.state === n.Writing ? this.pend(this.pendingReaders, a, o, s) : (this.numReaders++, this.state = n.Reading, a());
          });
        });
      }
      writeLock(s = 1 / 0) {
        return e(this, void 0, void 0, function* () {
          return new Promise((a, o) => {
            this.state !== n.Idle ? this.pend(this.pendingWriters, a, o, s) : (this.state = n.Writing, a());
          });
        });
      }
      unlock() {
        switch (this.state) {
          case n.Reading:
            if (this.numReaders--, this.numReaders)
              return;
            this.pendingWriters.length ? this.allowWrite() : this.state = n.Idle;
            return;
          case n.Writing:
            const s = this.pendingReaders.length, a = this.pendingWriters.length;
            s && a ? Math.random() >= 0.5 ? this.allowRead() : this.allowWrite() : s ? this.allowRead() : a ? this.allowWrite() : this.state = n.Idle;
            return;
          default:
            throw t.ErrNotLocked;
        }
      }
      pend(s, a, o, u) {
        let c = null, d = !1;
        const l = () => {
          d || (c && clearTimeout(c), a());
        }, f = () => {
          d = !0, o(t.ErrTimeout);
        };
        u && u >= 0 && u < 1 / 0 && (c = setTimeout(f, u)), s.push(l);
      }
      allowWrite() {
        const s = this.pendingWriters.shift();
        this.state = n.Writing, s();
      }
      allowRead() {
        const s = this.pendingReaders.slice();
        this.numReaders = s.length, this.pendingReaders = [], this.state = n.Reading;
        for (const a of s)
          a();
      }
    }
    t.RWLock = r;
  }(Dd)), Dd;
}
var M4;
function Fve() {
  if (M4) return to;
  M4 = 1, Object.defineProperty(to, "__esModule", { value: !0 });
  const t = Bve();
  return to.ErrNotLocked = t.ErrNotLocked, to.ErrTimeout = t.ErrTimeout, to.RWLock = t.RWLock, to.State = t.State, to.default = t.RWLock, to;
}
var Uve = Fve();
const $ve = /* @__PURE__ */ Fr(Uve);
var Wr = /* @__PURE__ */ ((t) => (t.RoomName = "roomName", t.RoomMember = "roomMember", t.RoomPrefTags = "roomPrefTags", t.RoomPrefFolder = "roomPrefFolder", t.RoomTags = "roomTags", t.Messages = "messages", t))(Wr || {});
const Hve = {
  count: 0,
  config: {},
  uid: "",
  axios: Qn,
  isRequesting: {},
  socket: pf({ autoConnect: !1 }),
  imageCache: k4(),
  translationCache: k4(),
  users: {},
  rooms: {},
  sortedRooms: [],
  numberOfFetchedRooms: 0,
  numberOfTotalRooms: 0,
  uploadProgresses: {},
  downloadProgresses: {},
  linkPreviews: {},
  actionMenuRoomId: "",
  folders: {},
  sortedFolderIds: [],
  roomIdsInFolders: {},
  selectedRoomIdsForCreateFolder: {},
  selectedFolderId: "",
  searchKeyword: "",
  searchType: Wr.RoomName,
  searchRooms: {},
  roomTag: "",
  deliveringMessages: /* @__PURE__ */ new Map(),
  processingMessages: /* @__PURE__ */ new Map(),
  rwlock: new $ve(),
  // chatroom
  selectedRoomId: "",
  messageMultiList: new c5(),
  numberOfTotalMessages: -1,
  replyId: "",
  navigationTargetId: "",
  isRoomInfoVisible: !1,
  isTyping: {},
  isSearchInRoomMode: !1,
  messageSearchKeyword: "",
  searchedMessageIds: /* @__PURE__ */ new Map(),
  blockedUsers: {}
}, jve = () => {
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const d5 = function(t) {
  const e = [];
  let n = 0;
  for (let r = 0; r < t.length; r++) {
    let i = t.charCodeAt(r);
    i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = i >> 6 | 192, e[n++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023), e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128) : (e[n++] = i >> 12 | 224, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128);
  }
  return e;
}, zve = function(t) {
  const e = [];
  let n = 0, r = 0;
  for (; n < t.length; ) {
    const i = t[n++];
    if (i < 128)
      e[r++] = String.fromCharCode(i);
    else if (i > 191 && i < 224) {
      const s = t[n++];
      e[r++] = String.fromCharCode((i & 31) << 6 | s & 63);
    } else if (i > 239 && i < 365) {
      const s = t[n++], a = t[n++], o = t[n++], u = ((i & 7) << 18 | (s & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      e[r++] = String.fromCharCode(55296 + (u >> 10)), e[r++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      const s = t[n++], a = t[n++];
      e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | a & 63);
    }
  }
  return e.join("");
}, f5 = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(t, e) {
    if (!Array.isArray(t))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = [];
    for (let i = 0; i < t.length; i += 3) {
      const s = t[i], a = i + 1 < t.length, o = a ? t[i + 1] : 0, u = i + 2 < t.length, c = u ? t[i + 2] : 0, d = s >> 2, l = (s & 3) << 4 | o >> 4;
      let f = (o & 15) << 2 | c >> 6, p = c & 63;
      u || (p = 64, a || (f = 64)), r.push(n[d], n[l], n[f], n[p]);
    }
    return r.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(d5(t), e);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(t, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : zve(this.decodeStringToByteArray(t, e));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(t, e) {
    this.init_();
    const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = [];
    for (let i = 0; i < t.length; ) {
      const s = n[t.charAt(i++)], o = i < t.length ? n[t.charAt(i)] : 0;
      ++i;
      const c = i < t.length ? n[t.charAt(i)] : 64;
      ++i;
      const l = i < t.length ? n[t.charAt(i)] : 64;
      if (++i, s == null || o == null || c == null || l == null)
        throw new qve();
      const f = s << 2 | o >> 4;
      if (r.push(f), c !== 64) {
        const p = o << 4 & 240 | c >> 2;
        if (r.push(p), l !== 64) {
          const m = c << 6 & 192 | l;
          r.push(m);
        }
      }
    }
    return r;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let t = 0; t < this.ENCODED_VALS.length; t++)
        this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t);
    }
  }
};
class qve extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const Vve = function(t) {
  const e = d5(t);
  return f5.encodeByteArray(e, !0);
}, h5 = function(t) {
  return Vve(t).replace(/\./g, "");
}, Wve = function(t) {
  try {
    return f5.decodeString(t, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Qve() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Gve = () => Qve().__FIREBASE_DEFAULTS__, Yve = () => {
  if (typeof process > "u" || typeof process.env > "u")
    return;
  const t = process.env.__FIREBASE_DEFAULTS__;
  if (t)
    return JSON.parse(t);
}, Xve = () => {
  if (typeof document > "u")
    return;
  let t;
  try {
    t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = t && Wve(t[1]);
  return e && JSON.parse(e);
}, Kve = () => {
  try {
    return jve() || Gve() || Yve() || Xve();
  } catch (t) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
    return;
  }
}, p5 = () => {
  var t;
  return (t = Kve()) === null || t === void 0 ? void 0 : t.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zve {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((e, n) => {
      this.resolve = e, this.reject = n;
    });
  }
  /**
   * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (n, r) => {
      n ? this.reject(n) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => {
      }), e.length === 1 ? e(n) : e(n, r));
    };
  }
}
function m5() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function g5() {
  return new Promise((t, e) => {
    try {
      let n = !0;
      const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r);
      i.onsuccess = () => {
        i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0);
      }, i.onupgradeneeded = () => {
        n = !1;
      }, i.onerror = () => {
        var s;
        e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (n) {
      e(n);
    }
  });
}
function Jve() {
  return !(typeof navigator > "u" || !navigator.cookieEnabled);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const eTe = "FirebaseError";
class Uc extends Error {
  constructor(e, n, r) {
    super(n), this.code = e, this.customData = r, this.name = eTe, Object.setPrototypeOf(this, Uc.prototype), Error.captureStackTrace && Error.captureStackTrace(this, pg.prototype.create);
  }
}
class pg {
  constructor(e, n, r) {
    this.service = e, this.serviceName = n, this.errors = r;
  }
  create(e, ...n) {
    const r = n[0] || {}, i = `${this.service}/${e}`, s = this.errors[e], a = s ? tTe(s, r) : "Error", o = `${this.serviceName}: ${a} (${i}).`;
    return new Uc(i, o, r);
  }
}
function tTe(t, e) {
  return t.replace(nTe, (n, r) => {
    const i = e[r];
    return i != null ? String(i) : `<${r}?>`;
  });
}
const nTe = /\{\$([^}]+)}/g;
function Pb(t, e) {
  if (t === e)
    return !0;
  const n = Object.keys(t), r = Object.keys(e);
  for (const i of n) {
    if (!r.includes(i))
      return !1;
    const s = t[i], a = e[i];
    if (O4(s) && O4(a)) {
      if (!Pb(s, a))
        return !1;
    } else if (s !== a)
      return !1;
  }
  for (const i of r)
    if (!n.includes(i))
      return !1;
  return !0;
}
function O4(t) {
  return t !== null && typeof t == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function A5(t) {
  return t && t._delegate ? t._delegate : t;
}
let Mo = class {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, n, r) {
    this.name = e, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const su = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rTe {
  constructor(e, n) {
    this.name = e, this.container = n, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide multiple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const n = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(n)) {
      const r = new Zve();
      if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize())
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: n
          });
          i && r.resolve(i);
        } catch {
        }
    }
    return this.instancesDeferred.get(n).promise;
  }
  getImmediate(e) {
    var n;
    const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier), i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: r
        });
      } catch (s) {
        if (i)
          return null;
        throw s;
      }
    else {
      if (i)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = e, !!this.shouldAutoInitialize()) {
      if (sTe(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: su });
        } catch {
        }
      for (const [n, r] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(n);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: i
          });
          r.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(e = su) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((n) => "INTERNAL" in n).map((n) => n.INTERNAL.delete()),
      ...e.filter((n) => "_delete" in n).map((n) => n._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = su) {
    return this.instances.has(e);
  }
  getOptions(e = su) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: n = {} } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(r))
      throw Error(`${this.name}(${r}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: r,
      options: n
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      r === o && a.resolve(i);
    }
    return i;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, n) {
    var r;
    const i = this.normalizeInstanceIdentifier(n), s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : /* @__PURE__ */ new Set();
    s.add(e), this.onInitCallbacks.set(i, s);
    const a = this.instances.get(i);
    return a && e(a, i), () => {
      s.delete(e);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, n) {
    const r = this.onInitCallbacks.get(n);
    if (r)
      for (const i of r)
        try {
          i(e, n);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: e, options: n = {} }) {
    let r = this.instances.get(e);
    if (!r && this.component && (r = this.component.instanceFactory(this.container, {
      instanceIdentifier: iTe(e),
      options: n
    }), this.instances.set(e, r), this.instancesOptions.set(e, n), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, e, r);
      } catch {
      }
    return r || null;
  }
  normalizeInstanceIdentifier(e = su) {
    return this.component ? this.component.multipleInstances ? e : su : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function iTe(t) {
  return t === su ? void 0 : t;
}
function sTe(t) {
  return t.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class aTe {
  constructor(e) {
    this.name = e, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const n = this.getProvider(e.name);
    if (n.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    n.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e))
      return this.providers.get(e);
    const n = new rTe(e, this);
    return this.providers.set(e, n), n;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Vn;
(function(t) {
  t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT";
})(Vn || (Vn = {}));
const oTe = {
  debug: Vn.DEBUG,
  verbose: Vn.VERBOSE,
  info: Vn.INFO,
  warn: Vn.WARN,
  error: Vn.ERROR,
  silent: Vn.SILENT
}, uTe = Vn.INFO, lTe = {
  [Vn.DEBUG]: "log",
  [Vn.VERBOSE]: "log",
  [Vn.INFO]: "info",
  [Vn.WARN]: "warn",
  [Vn.ERROR]: "error"
}, cTe = (t, e, ...n) => {
  if (e < t.logLevel)
    return;
  const r = (/* @__PURE__ */ new Date()).toISOString(), i = lTe[e];
  if (i)
    console[i](`[${r}]  ${t.name}:`, ...n);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
};
class dTe {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    this.name = e, this._logLevel = uTe, this._logHandler = cTe, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in Vn))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == "string" ? oTe[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, Vn.DEBUG, ...e), this._logHandler(this, Vn.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, Vn.VERBOSE, ...e), this._logHandler(this, Vn.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, Vn.INFO, ...e), this._logHandler(this, Vn.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, Vn.WARN, ...e), this._logHandler(this, Vn.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, Vn.ERROR, ...e), this._logHandler(this, Vn.ERROR, ...e);
  }
}
const fTe = (t, e) => e.some((n) => t instanceof n);
let N4, L4;
function hTe() {
  return N4 || (N4 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function pTe() {
  return L4 || (L4 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const b5 = /* @__PURE__ */ new WeakMap(), Rb = /* @__PURE__ */ new WeakMap(), y5 = /* @__PURE__ */ new WeakMap(), gA = /* @__PURE__ */ new WeakMap(), Yv = /* @__PURE__ */ new WeakMap();
function mTe(t) {
  const e = new Promise((n, r) => {
    const i = () => {
      t.removeEventListener("success", s), t.removeEventListener("error", a);
    }, s = () => {
      n(Ua(t.result)), i();
    }, a = () => {
      r(t.error), i();
    };
    t.addEventListener("success", s), t.addEventListener("error", a);
  });
  return e.then((n) => {
    n instanceof IDBCursor && b5.set(n, t);
  }).catch(() => {
  }), Yv.set(e, t), e;
}
function gTe(t) {
  if (Rb.has(t))
    return;
  const e = new Promise((n, r) => {
    const i = () => {
      t.removeEventListener("complete", s), t.removeEventListener("error", a), t.removeEventListener("abort", a);
    }, s = () => {
      n(), i();
    }, a = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), i();
    };
    t.addEventListener("complete", s), t.addEventListener("error", a), t.addEventListener("abort", a);
  });
  Rb.set(t, e);
}
let Bb = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return Rb.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || y5.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Ua(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function ATe(t) {
  Bb = t(Bb);
}
function bTe(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(AA(this), e, ...n);
    return y5.set(r, e.sort ? e.sort() : [e]), Ua(r);
  } : pTe().includes(t) ? function(...e) {
    return t.apply(AA(this), e), Ua(b5.get(this));
  } : function(...e) {
    return Ua(t.apply(AA(this), e));
  };
}
function yTe(t) {
  return typeof t == "function" ? bTe(t) : (t instanceof IDBTransaction && gTe(t), fTe(t, hTe()) ? new Proxy(t, Bb) : t);
}
function Ua(t) {
  if (t instanceof IDBRequest)
    return mTe(t);
  if (gA.has(t))
    return gA.get(t);
  const e = yTe(t);
  return e !== t && (gA.set(t, e), Yv.set(e, t)), e;
}
const AA = (t) => Yv.get(t);
function mg(t, e, { blocked: n, upgrade: r, blocking: i, terminated: s } = {}) {
  const a = indexedDB.open(t, e), o = Ua(a);
  return r && a.addEventListener("upgradeneeded", (u) => {
    r(Ua(a.result), u.oldVersion, u.newVersion, Ua(a.transaction), u);
  }), n && a.addEventListener("blocked", (u) => n(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    u.oldVersion,
    u.newVersion,
    u
  )), o.then((u) => {
    s && u.addEventListener("close", () => s()), i && u.addEventListener("versionchange", (c) => i(c.oldVersion, c.newVersion, c));
  }).catch(() => {
  }), o;
}
function bA(t, { blocked: e } = {}) {
  const n = indexedDB.deleteDatabase(t);
  return e && n.addEventListener("blocked", (r) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    r.oldVersion,
    r
  )), Ua(n).then(() => {
  });
}
const vTe = ["get", "getKey", "getAll", "getAllKeys", "count"], TTe = ["put", "add", "delete", "clear"], yA = /* @__PURE__ */ new Map();
function P4(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (yA.get(e))
    return yA.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, i = TTe.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || vTe.includes(n))
  )
    return;
  const s = async function(a, ...o) {
    const u = this.transaction(a, i ? "readwrite" : "readonly");
    let c = u.store;
    return r && (c = c.index(o.shift())), (await Promise.all([
      c[n](...o),
      i && u.done
    ]))[0];
  };
  return yA.set(e, s), s;
}
ATe((t) => ({
  ...t,
  get: (e, n, r) => P4(e, n) || t.get(e, n, r),
  has: (e, n) => !!P4(e, n) || t.has(e, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _Te {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((n) => {
      if (ETe(n)) {
        const r = n.getImmediate();
        return `${r.library}/${r.version}`;
      } else
        return null;
    }).filter((n) => n).join(" ");
  }
}
function ETe(t) {
  const e = t.getComponent();
  return (e == null ? void 0 : e.type) === "VERSION";
}
const Fb = "@firebase/app", R4 = "0.13.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const za = new dTe("@firebase/app"), xTe = "@firebase/app-compat", wTe = "@firebase/analytics-compat", CTe = "@firebase/analytics", STe = "@firebase/app-check-compat", ITe = "@firebase/app-check", kTe = "@firebase/auth", DTe = "@firebase/auth-compat", MTe = "@firebase/database", OTe = "@firebase/data-connect", NTe = "@firebase/database-compat", LTe = "@firebase/functions", PTe = "@firebase/functions-compat", RTe = "@firebase/installations", BTe = "@firebase/installations-compat", FTe = "@firebase/messaging", UTe = "@firebase/messaging-compat", $Te = "@firebase/performance", HTe = "@firebase/performance-compat", jTe = "@firebase/remote-config", zTe = "@firebase/remote-config-compat", qTe = "@firebase/storage", VTe = "@firebase/storage-compat", WTe = "@firebase/firestore", QTe = "@firebase/ai", GTe = "@firebase/firestore-compat", YTe = "firebase";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ub = "[DEFAULT]", XTe = {
  [Fb]: "fire-core",
  [xTe]: "fire-core-compat",
  [CTe]: "fire-analytics",
  [wTe]: "fire-analytics-compat",
  [ITe]: "fire-app-check",
  [STe]: "fire-app-check-compat",
  [kTe]: "fire-auth",
  [DTe]: "fire-auth-compat",
  [MTe]: "fire-rtdb",
  [OTe]: "fire-data-connect",
  [NTe]: "fire-rtdb-compat",
  [LTe]: "fire-fn",
  [PTe]: "fire-fn-compat",
  [RTe]: "fire-iid",
  [BTe]: "fire-iid-compat",
  [FTe]: "fire-fcm",
  [UTe]: "fire-fcm-compat",
  [$Te]: "fire-perf",
  [HTe]: "fire-perf-compat",
  [jTe]: "fire-rc",
  [zTe]: "fire-rc-compat",
  [qTe]: "fire-gcs",
  [VTe]: "fire-gcs-compat",
  [WTe]: "fire-fst",
  [GTe]: "fire-fst-compat",
  [QTe]: "fire-vertex",
  "fire-js": "fire-js",
  // Platform identifier for JS SDK.
  [YTe]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Xm = /* @__PURE__ */ new Map(), KTe = /* @__PURE__ */ new Map(), $b = /* @__PURE__ */ new Map();
function B4(t, e) {
  try {
    t.container.addComponent(e);
  } catch (n) {
    za.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n);
  }
}
function ju(t) {
  const e = t.name;
  if ($b.has(e))
    return za.debug(`There were multiple attempts to register component ${e}.`), !1;
  $b.set(e, t);
  for (const n of Xm.values())
    B4(n, t);
  for (const n of KTe.values())
    B4(n, t);
  return !0;
}
function Xv(t, e) {
  const n = t.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return n && n.triggerHeartbeat(), t.container.getProvider(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ZTe = {
  "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
  "bad-app-name": "Illegal App name: '{$appName}'",
  "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
  "app-deleted": "Firebase App named '{$appName}' already deleted",
  "server-app-deleted": "Firebase Server App has been deleted",
  "no-options": "Need to provide options, when not being deployed to hosting via source.",
  "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  "invalid-log-argument": "First argument to `onLog` must be null or a function.",
  "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
  "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
  "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}, wo = new pg("app", "Firebase", ZTe);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JTe {
  constructor(e, n, r) {
    this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new Mo(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = e;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw wo.create("app-deleted", { appName: this._name });
  }
}
function v5(t, e = {}) {
  let n = t;
  typeof e != "object" && (e = { name: e });
  const r = Object.assign({ name: Ub, automaticDataCollectionEnabled: !0 }, e), i = r.name;
  if (typeof i != "string" || !i)
    throw wo.create("bad-app-name", {
      appName: String(i)
    });
  if (n || (n = p5()), !n)
    throw wo.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Xm.get(i);
  if (s) {
    if (Pb(n, s.options) && Pb(r, s.config))
      return s;
    throw wo.create("duplicate-app", { appName: i });
  }
  const a = new aTe(i);
  for (const u of $b.values())
    a.addComponent(u);
  const o = new JTe(n, r, a);
  return Xm.set(i, o), o;
}
function e_e(t = Ub) {
  const e = Xm.get(t);
  if (!e && t === Ub && p5())
    return v5();
  if (!e)
    throw wo.create("no-app", { appName: t });
  return e;
}
function Co(t, e, n) {
  var r;
  let i = (r = XTe[t]) !== null && r !== void 0 ? r : t;
  n && (i += `-${n}`);
  const s = i.match(/\s|\//), a = e.match(/\s|\//);
  if (s || a) {
    const o = [
      `Unable to register library "${i}" with version "${e}":`
    ];
    s && o.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && a && o.push("and"), a && o.push(`version name "${e}" contains illegal characters (whitespace or "/")`), za.warn(o.join(" "));
    return;
  }
  ju(new Mo(
    `${i}-version`,
    () => ({ library: i, version: e }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const t_e = "firebase-heartbeat-database", n_e = 1, zf = "firebase-heartbeat-store";
let vA = null;
function T5() {
  return vA || (vA = mg(t_e, n_e, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          try {
            t.createObjectStore(zf);
          } catch (n) {
            console.warn(n);
          }
      }
    }
  }).catch((t) => {
    throw wo.create("idb-open", {
      originalErrorMessage: t.message
    });
  })), vA;
}
async function r_e(t) {
  try {
    const n = (await T5()).transaction(zf), r = await n.objectStore(zf).get(_5(t));
    return await n.done, r;
  } catch (e) {
    if (e instanceof Uc)
      za.warn(e.message);
    else {
      const n = wo.create("idb-get", {
        originalErrorMessage: e == null ? void 0 : e.message
      });
      za.warn(n.message);
    }
  }
}
async function F4(t, e) {
  try {
    const r = (await T5()).transaction(zf, "readwrite");
    await r.objectStore(zf).put(e, _5(t)), await r.done;
  } catch (n) {
    if (n instanceof Uc)
      za.warn(n.message);
    else {
      const r = wo.create("idb-set", {
        originalErrorMessage: n == null ? void 0 : n.message
      });
      za.warn(r.message);
    }
  }
}
function _5(t) {
  return `${t.name}!${t.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const i_e = 1024, s_e = 30;
class a_e {
  constructor(e) {
    this.container = e, this._heartbeatsCache = null;
    const n = this.container.getProvider("app").getImmediate();
    this._storage = new u_e(n), this._heartbeatsCachePromise = this._storage.read().then((r) => (this._heartbeatsCache = r, r));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    var e, n;
    try {
      const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), s = U4();
      if (((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some((a) => a.date === s))
        return;
      if (this._heartbeatsCache.heartbeats.push({ date: s, agent: i }), this._heartbeatsCache.heartbeats.length > s_e) {
        const a = l_e(this._heartbeatsCache.heartbeats);
        this._heartbeatsCache.heartbeats.splice(a, 1);
      }
      return this._storage.overwrite(this._heartbeatsCache);
    } catch (r) {
      za.warn(r);
    }
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    var e;
    try {
      if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
        return "";
      const n = U4(), { heartbeatsToSend: r, unsentEntries: i } = o_e(this._heartbeatsCache.heartbeats), s = h5(JSON.stringify({ version: 2, heartbeats: r }));
      return this._heartbeatsCache.lastSentHeartbeatDate = n, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s;
    } catch (n) {
      return za.warn(n), "";
    }
  }
}
function U4() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function o_e(t, e = i_e) {
  const n = [];
  let r = t.slice();
  for (const i of t) {
    const s = n.find((a) => a.agent === i.agent);
    if (s) {
      if (s.dates.push(i.date), $4(n) > e) {
        s.dates.pop();
        break;
      }
    } else if (n.push({
      agent: i.agent,
      dates: [i.date]
    }), $4(n) > e) {
      n.pop();
      break;
    }
    r = r.slice(1);
  }
  return {
    heartbeatsToSend: n,
    unsentEntries: r
  };
}
class u_e {
  constructor(e) {
    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return m5() ? g5().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    if (await this._canUseIndexedDBPromise) {
      const n = await r_e(this.app);
      return n != null && n.heartbeats ? n : { heartbeats: [] };
    } else
      return { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return F4(this.app, {
        lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(e) {
    var n;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return F4(this.app, {
        lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
        heartbeats: [
          ...i.heartbeats,
          ...e.heartbeats
        ]
      });
    } else
      return;
  }
}
function $4(t) {
  return h5(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: t })
  ).length;
}
function l_e(t) {
  if (t.length === 0)
    return -1;
  let e = 0, n = t[0].date;
  for (let r = 1; r < t.length; r++)
    t[r].date < n && (n = t[r].date, e = r);
  return e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function c_e(t) {
  ju(new Mo(
    "platform-logger",
    (e) => new _Te(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), ju(new Mo(
    "heartbeat",
    (e) => new a_e(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Co(Fb, R4, t), Co(Fb, R4, "esm2017"), Co("fire-js", "");
}
c_e("");
const E5 = "@firebase/installations", Kv = "0.6.17";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const x5 = 1e4, w5 = `w:${Kv}`, C5 = "FIS_v2", d_e = "https://firebaseinstallations.googleapis.com/v1", f_e = 60 * 60 * 1e3, h_e = "installations", p_e = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const m_e = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "not-registered": "Firebase Installation is not registered.",
  "installation-not-found": "Firebase Installation not found.",
  "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  "app-offline": "Could not process request. Application offline.",
  "delete-pending-registration": "Can't delete installation while there is a pending registration request."
}, zu = new pg(h_e, p_e, m_e);
function S5(t) {
  return t instanceof Uc && t.code.includes(
    "request-failed"
    /* ErrorCode.REQUEST_FAILED */
  );
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function I5({ projectId: t }) {
  return `${d_e}/projects/${t}/installations`;
}
function k5(t) {
  return {
    token: t.token,
    requestStatus: 2,
    expiresIn: A_e(t.expiresIn),
    creationTime: Date.now()
  };
}
async function D5(t, e) {
  const r = (await e.json()).error;
  return zu.create("request-failed", {
    requestName: t,
    serverCode: r.code,
    serverMessage: r.message,
    serverStatus: r.status
  });
}
function M5({ apiKey: t }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": t
  });
}
function g_e(t, { refreshToken: e }) {
  const n = M5(t);
  return n.append("Authorization", b_e(e)), n;
}
async function O5(t) {
  const e = await t();
  return e.status >= 500 && e.status < 600 ? t() : e;
}
function A_e(t) {
  return Number(t.replace("s", "000"));
}
function b_e(t) {
  return `${C5} ${t}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function y_e({ appConfig: t, heartbeatServiceProvider: e }, { fid: n }) {
  const r = I5(t), i = M5(t), s = e.getImmediate({
    optional: !0
  });
  if (s) {
    const c = await s.getHeartbeatsHeader();
    c && i.append("x-firebase-client", c);
  }
  const a = {
    fid: n,
    authVersion: C5,
    appId: t.appId,
    sdkVersion: w5
  }, o = {
    method: "POST",
    headers: i,
    body: JSON.stringify(a)
  }, u = await O5(() => fetch(r, o));
  if (u.ok) {
    const c = await u.json();
    return {
      fid: c.fid || n,
      registrationStatus: 2,
      refreshToken: c.refreshToken,
      authToken: k5(c.authToken)
    };
  } else
    throw await D5("Create Installation", u);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function N5(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function v_e(t) {
  return btoa(String.fromCharCode(...t)).replace(/\+/g, "-").replace(/\//g, "_");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const T_e = /^[cdef][\w-]{21}$/, Hb = "";
function __e() {
  try {
    const t = new Uint8Array(17);
    (self.crypto || self.msCrypto).getRandomValues(t), t[0] = 112 + t[0] % 16;
    const n = E_e(t);
    return T_e.test(n) ? n : Hb;
  } catch {
    return Hb;
  }
}
function E_e(t) {
  return v_e(t).substr(0, 22);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function gg(t) {
  return `${t.appName}!${t.appId}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const L5 = /* @__PURE__ */ new Map();
function P5(t, e) {
  const n = gg(t);
  R5(n, e), x_e(n, e);
}
function R5(t, e) {
  const n = L5.get(t);
  if (n)
    for (const r of n)
      r(e);
}
function x_e(t, e) {
  const n = w_e();
  n && n.postMessage({ key: t, fid: e }), C_e();
}
let pu = null;
function w_e() {
  return !pu && "BroadcastChannel" in self && (pu = new BroadcastChannel("[Firebase] FID Change"), pu.onmessage = (t) => {
    R5(t.data.key, t.data.fid);
  }), pu;
}
function C_e() {
  L5.size === 0 && pu && (pu.close(), pu = null);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const S_e = "firebase-installations-database", I_e = 1, qu = "firebase-installations-store";
let TA = null;
function Zv() {
  return TA || (TA = mg(S_e, I_e, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          t.createObjectStore(qu);
      }
    }
  })), TA;
}
async function Km(t, e) {
  const n = gg(t), i = (await Zv()).transaction(qu, "readwrite"), s = i.objectStore(qu), a = await s.get(n);
  return await s.put(e, n), await i.done, (!a || a.fid !== e.fid) && P5(t, e.fid), e;
}
async function B5(t) {
  const e = gg(t), r = (await Zv()).transaction(qu, "readwrite");
  await r.objectStore(qu).delete(e), await r.done;
}
async function Ag(t, e) {
  const n = gg(t), i = (await Zv()).transaction(qu, "readwrite"), s = i.objectStore(qu), a = await s.get(n), o = e(a);
  return o === void 0 ? await s.delete(n) : await s.put(o, n), await i.done, o && (!a || a.fid !== o.fid) && P5(t, o.fid), o;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Jv(t) {
  let e;
  const n = await Ag(t.appConfig, (r) => {
    const i = k_e(r), s = D_e(t, i);
    return e = s.registrationPromise, s.installationEntry;
  });
  return n.fid === Hb ? { installationEntry: await e } : {
    installationEntry: n,
    registrationPromise: e
  };
}
function k_e(t) {
  const e = t || {
    fid: __e(),
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  };
  return F5(e);
}
function D_e(t, e) {
  if (e.registrationStatus === 0) {
    if (!navigator.onLine) {
      const i = Promise.reject(zu.create(
        "app-offline"
        /* ErrorCode.APP_OFFLINE */
      ));
      return {
        installationEntry: e,
        registrationPromise: i
      };
    }
    const n = {
      fid: e.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    }, r = M_e(t, n);
    return { installationEntry: n, registrationPromise: r };
  } else return e.registrationStatus === 1 ? {
    installationEntry: e,
    registrationPromise: O_e(t)
  } : { installationEntry: e };
}
async function M_e(t, e) {
  try {
    const n = await y_e(t, e);
    return Km(t.appConfig, n);
  } catch (n) {
    throw S5(n) && n.customData.serverCode === 409 ? await B5(t.appConfig) : await Km(t.appConfig, {
      fid: e.fid,
      registrationStatus: 0
      /* RequestStatus.NOT_STARTED */
    }), n;
  }
}
async function O_e(t) {
  let e = await H4(t.appConfig);
  for (; e.registrationStatus === 1; )
    await N5(100), e = await H4(t.appConfig);
  if (e.registrationStatus === 0) {
    const { installationEntry: n, registrationPromise: r } = await Jv(t);
    return r || n;
  }
  return e;
}
function H4(t) {
  return Ag(t, (e) => {
    if (!e)
      throw zu.create(
        "installation-not-found"
        /* ErrorCode.INSTALLATION_NOT_FOUND */
      );
    return F5(e);
  });
}
function F5(t) {
  return N_e(t) ? {
    fid: t.fid,
    registrationStatus: 0
    /* RequestStatus.NOT_STARTED */
  } : t;
}
function N_e(t) {
  return t.registrationStatus === 1 && t.registrationTime + x5 < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function L_e({ appConfig: t, heartbeatServiceProvider: e }, n) {
  const r = P_e(t, n), i = g_e(t, n), s = e.getImmediate({
    optional: !0
  });
  if (s) {
    const c = await s.getHeartbeatsHeader();
    c && i.append("x-firebase-client", c);
  }
  const a = {
    installation: {
      sdkVersion: w5,
      appId: t.appId
    }
  }, o = {
    method: "POST",
    headers: i,
    body: JSON.stringify(a)
  }, u = await O5(() => fetch(r, o));
  if (u.ok) {
    const c = await u.json();
    return k5(c);
  } else
    throw await D5("Generate Auth Token", u);
}
function P_e(t, { fid: e }) {
  return `${I5(t)}/${e}/authTokens:generate`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function eT(t, e = !1) {
  let n;
  const r = await Ag(t.appConfig, (s) => {
    if (!U5(s))
      throw zu.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const a = s.authToken;
    if (!e && F_e(a))
      return s;
    if (a.requestStatus === 1)
      return n = R_e(t, e), s;
    {
      if (!navigator.onLine)
        throw zu.create(
          "app-offline"
          /* ErrorCode.APP_OFFLINE */
        );
      const o = $_e(s);
      return n = B_e(t, o), o;
    }
  });
  return n ? await n : r.authToken;
}
async function R_e(t, e) {
  let n = await j4(t.appConfig);
  for (; n.authToken.requestStatus === 1; )
    await N5(100), n = await j4(t.appConfig);
  const r = n.authToken;
  return r.requestStatus === 0 ? eT(t, e) : r;
}
function j4(t) {
  return Ag(t, (e) => {
    if (!U5(e))
      throw zu.create(
        "not-registered"
        /* ErrorCode.NOT_REGISTERED */
      );
    const n = e.authToken;
    return H_e(n) ? Object.assign(Object.assign({}, e), { authToken: {
      requestStatus: 0
      /* RequestStatus.NOT_STARTED */
    } }) : e;
  });
}
async function B_e(t, e) {
  try {
    const n = await L_e(t, e), r = Object.assign(Object.assign({}, e), { authToken: n });
    return await Km(t.appConfig, r), n;
  } catch (n) {
    if (S5(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404))
      await B5(t.appConfig);
    else {
      const r = Object.assign(Object.assign({}, e), { authToken: {
        requestStatus: 0
        /* RequestStatus.NOT_STARTED */
      } });
      await Km(t.appConfig, r);
    }
    throw n;
  }
}
function U5(t) {
  return t !== void 0 && t.registrationStatus === 2;
}
function F_e(t) {
  return t.requestStatus === 2 && !U_e(t);
}
function U_e(t) {
  const e = Date.now();
  return e < t.creationTime || t.creationTime + t.expiresIn < e + f_e;
}
function $_e(t) {
  const e = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return Object.assign(Object.assign({}, t), { authToken: e });
}
function H_e(t) {
  return t.requestStatus === 1 && t.requestTime + x5 < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function j_e(t) {
  const e = t, { installationEntry: n, registrationPromise: r } = await Jv(e);
  return r ? r.catch(console.error) : eT(e).catch(console.error), n.fid;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function z_e(t, e = !1) {
  const n = t;
  return await q_e(n), (await eT(n, e)).token;
}
async function q_e(t) {
  const { registrationPromise: e } = await Jv(t);
  e && await e;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function V_e(t) {
  if (!t || !t.options)
    throw _A("App Configuration");
  if (!t.name)
    throw _A("App Name");
  const e = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const n of e)
    if (!t.options[n])
      throw _A(n);
  return {
    appName: t.name,
    projectId: t.options.projectId,
    apiKey: t.options.apiKey,
    appId: t.options.appId
  };
}
function _A(t) {
  return zu.create("missing-app-config-values", {
    valueName: t
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $5 = "installations", W_e = "installations-internal", Q_e = (t) => {
  const e = t.getProvider("app").getImmediate(), n = V_e(e), r = Xv(e, "heartbeat");
  return {
    app: e,
    appConfig: n,
    heartbeatServiceProvider: r,
    _delete: () => Promise.resolve()
  };
}, G_e = (t) => {
  const e = t.getProvider("app").getImmediate(), n = Xv(e, $5).getImmediate();
  return {
    getId: () => j_e(n),
    getToken: (i) => z_e(n, i)
  };
};
function Y_e() {
  ju(new Mo(
    $5,
    Q_e,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  )), ju(new Mo(
    W_e,
    G_e,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  ));
}
Y_e();
Co(E5, Kv);
Co(E5, Kv, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const X_e = "/firebase-messaging-sw.js", K_e = "/firebase-cloud-messaging-push-scope", H5 = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4", Z_e = "https://fcmregistrations.googleapis.com/v1", j5 = "google.c.a.c_id", J_e = "google.c.a.c_l", e3e = "google.c.a.ts", t3e = "google.c.a.e", z4 = 1e4;
var q4;
(function(t) {
  t[t.DATA_MESSAGE = 1] = "DATA_MESSAGE", t[t.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION";
})(q4 || (q4 = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var qf;
(function(t) {
  t.PUSH_RECEIVED = "push-received", t.NOTIFICATION_CLICKED = "notification-clicked";
})(qf || (qf = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ka(t) {
  const e = new Uint8Array(t);
  return btoa(String.fromCharCode(...e)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function n3e(t) {
  const e = "=".repeat((4 - t.length % 4) % 4), n = (t + e).replace(/\-/g, "+").replace(/_/g, "/"), r = atob(n), i = new Uint8Array(r.length);
  for (let s = 0; s < r.length; ++s)
    i[s] = r.charCodeAt(s);
  return i;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EA = "fcm_token_details_db", r3e = 5, V4 = "fcm_token_object_Store";
async function i3e(t) {
  if ("databases" in indexedDB && !(await indexedDB.databases()).map((s) => s.name).includes(EA))
    return null;
  let e = null;
  return (await mg(EA, r3e, {
    upgrade: async (r, i, s, a) => {
      var o;
      if (i < 2 || !r.objectStoreNames.contains(V4))
        return;
      const u = a.objectStore(V4), c = await u.index("fcmSenderId").get(t);
      if (await u.clear(), !!c) {
        if (i === 2) {
          const d = c;
          if (!d.auth || !d.p256dh || !d.endpoint)
            return;
          e = {
            token: d.fcmToken,
            createTime: (o = d.createTime) !== null && o !== void 0 ? o : Date.now(),
            subscriptionOptions: {
              auth: d.auth,
              p256dh: d.p256dh,
              endpoint: d.endpoint,
              swScope: d.swScope,
              vapidKey: typeof d.vapidKey == "string" ? d.vapidKey : ka(d.vapidKey)
            }
          };
        } else if (i === 3) {
          const d = c;
          e = {
            token: d.fcmToken,
            createTime: d.createTime,
            subscriptionOptions: {
              auth: ka(d.auth),
              p256dh: ka(d.p256dh),
              endpoint: d.endpoint,
              swScope: d.swScope,
              vapidKey: ka(d.vapidKey)
            }
          };
        } else if (i === 4) {
          const d = c;
          e = {
            token: d.fcmToken,
            createTime: d.createTime,
            subscriptionOptions: {
              auth: ka(d.auth),
              p256dh: ka(d.p256dh),
              endpoint: d.endpoint,
              swScope: d.swScope,
              vapidKey: ka(d.vapidKey)
            }
          };
        }
      }
    }
  })).close(), await bA(EA), await bA("fcm_vapid_details_db"), await bA("undefined"), s3e(e) ? e : null;
}
function s3e(t) {
  if (!t || !t.subscriptionOptions)
    return !1;
  const { subscriptionOptions: e } = t;
  return typeof t.createTime == "number" && t.createTime > 0 && typeof t.token == "string" && t.token.length > 0 && typeof e.auth == "string" && e.auth.length > 0 && typeof e.p256dh == "string" && e.p256dh.length > 0 && typeof e.endpoint == "string" && e.endpoint.length > 0 && typeof e.swScope == "string" && e.swScope.length > 0 && typeof e.vapidKey == "string" && e.vapidKey.length > 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const a3e = "firebase-messaging-database", o3e = 1, Vf = "firebase-messaging-store";
let xA = null;
function z5() {
  return xA || (xA = mg(a3e, o3e, {
    upgrade: (t, e) => {
      switch (e) {
        case 0:
          t.createObjectStore(Vf);
      }
    }
  })), xA;
}
async function u3e(t) {
  const e = q5(t), r = await (await z5()).transaction(Vf).objectStore(Vf).get(e);
  if (r)
    return r;
  {
    const i = await i3e(t.appConfig.senderId);
    if (i)
      return await tT(t, i), i;
  }
}
async function tT(t, e) {
  const n = q5(t), i = (await z5()).transaction(Vf, "readwrite");
  return await i.objectStore(Vf).put(e, n), await i.done, e;
}
function q5({ appConfig: t }) {
  return t.appId;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const l3e = {
  "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
  "only-available-in-window": "This method is available in a Window context.",
  "only-available-in-sw": "This method is available in a service worker context.",
  "permission-default": "The notification permission was not granted and dismissed instead.",
  "permission-blocked": "The notification permission was not granted and blocked instead.",
  "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
  "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
  "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
  "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
  "token-update-no-token": "FCM returned no token when updating the user to push.",
  "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
  "invalid-vapid-key": "The public VAPID key must be a string.",
  "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
}, pi = new pg("messaging", "Messaging", l3e);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function c3e(t, e) {
  const n = await rT(t), r = V5(e), i = {
    method: "POST",
    headers: n,
    body: JSON.stringify(r)
  };
  let s;
  try {
    s = await (await fetch(nT(t.appConfig), i)).json();
  } catch (a) {
    throw pi.create("token-subscribe-failed", {
      errorInfo: a == null ? void 0 : a.toString()
    });
  }
  if (s.error) {
    const a = s.error.message;
    throw pi.create("token-subscribe-failed", {
      errorInfo: a
    });
  }
  if (!s.token)
    throw pi.create(
      "token-subscribe-no-token"
      /* ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN */
    );
  return s.token;
}
async function d3e(t, e) {
  const n = await rT(t), r = V5(e.subscriptionOptions), i = {
    method: "PATCH",
    headers: n,
    body: JSON.stringify(r)
  };
  let s;
  try {
    s = await (await fetch(`${nT(t.appConfig)}/${e.token}`, i)).json();
  } catch (a) {
    throw pi.create("token-update-failed", {
      errorInfo: a == null ? void 0 : a.toString()
    });
  }
  if (s.error) {
    const a = s.error.message;
    throw pi.create("token-update-failed", {
      errorInfo: a
    });
  }
  if (!s.token)
    throw pi.create(
      "token-update-no-token"
      /* ErrorCode.TOKEN_UPDATE_NO_TOKEN */
    );
  return s.token;
}
async function f3e(t, e) {
  const r = {
    method: "DELETE",
    headers: await rT(t)
  };
  try {
    const s = await (await fetch(`${nT(t.appConfig)}/${e}`, r)).json();
    if (s.error) {
      const a = s.error.message;
      throw pi.create("token-unsubscribe-failed", {
        errorInfo: a
      });
    }
  } catch (i) {
    throw pi.create("token-unsubscribe-failed", {
      errorInfo: i == null ? void 0 : i.toString()
    });
  }
}
function nT({ projectId: t }) {
  return `${Z_e}/projects/${t}/registrations`;
}
async function rT({ appConfig: t, installations: e }) {
  const n = await e.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": t.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${n}`
  });
}
function V5({ p256dh: t, auth: e, endpoint: n, vapidKey: r }) {
  const i = {
    web: {
      endpoint: n,
      auth: e,
      p256dh: t
    }
  };
  return r !== H5 && (i.web.applicationPubKey = r), i;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const h3e = 7 * 24 * 60 * 60 * 1e3;
async function p3e(t) {
  const e = await g3e(t.swRegistration, t.vapidKey), n = {
    vapidKey: t.vapidKey,
    swScope: t.swRegistration.scope,
    endpoint: e.endpoint,
    auth: ka(e.getKey("auth")),
    p256dh: ka(e.getKey("p256dh"))
  }, r = await u3e(t.firebaseDependencies);
  if (r) {
    if (A3e(r.subscriptionOptions, n))
      return Date.now() >= r.createTime + h3e ? m3e(t, {
        token: r.token,
        createTime: Date.now(),
        subscriptionOptions: n
      }) : r.token;
    try {
      await f3e(t.firebaseDependencies, r.token);
    } catch (i) {
      console.warn(i);
    }
    return W4(t.firebaseDependencies, n);
  } else return W4(t.firebaseDependencies, n);
}
async function m3e(t, e) {
  try {
    const n = await d3e(t.firebaseDependencies, e), r = Object.assign(Object.assign({}, e), { token: n, createTime: Date.now() });
    return await tT(t.firebaseDependencies, r), n;
  } catch (n) {
    throw n;
  }
}
async function W4(t, e) {
  const r = {
    token: await c3e(t, e),
    createTime: Date.now(),
    subscriptionOptions: e
  };
  return await tT(t, r), r.token;
}
async function g3e(t, e) {
  const n = await t.pushManager.getSubscription();
  return n || t.pushManager.subscribe({
    userVisibleOnly: !0,
    // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key
    // submitted to pushManager#subscribe must be of type Uint8Array.
    applicationServerKey: n3e(e)
  });
}
function A3e(t, e) {
  const n = e.vapidKey === t.vapidKey, r = e.endpoint === t.endpoint, i = e.auth === t.auth, s = e.p256dh === t.p256dh;
  return n && r && i && s;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Q4(t) {
  const e = {
    from: t.from,
    // eslint-disable-next-line camelcase
    collapseKey: t.collapse_key,
    // eslint-disable-next-line camelcase
    messageId: t.fcmMessageId
  };
  return b3e(e, t), y3e(e, t), v3e(e, t), e;
}
function b3e(t, e) {
  if (!e.notification)
    return;
  t.notification = {};
  const n = e.notification.title;
  n && (t.notification.title = n);
  const r = e.notification.body;
  r && (t.notification.body = r);
  const i = e.notification.image;
  i && (t.notification.image = i);
  const s = e.notification.icon;
  s && (t.notification.icon = s);
}
function y3e(t, e) {
  e.data && (t.data = e.data);
}
function v3e(t, e) {
  var n, r, i, s, a;
  if (!e.fcmOptions && !(!((n = e.notification) === null || n === void 0) && n.click_action))
    return;
  t.fcmOptions = {};
  const o = (i = (r = e.fcmOptions) === null || r === void 0 ? void 0 : r.link) !== null && i !== void 0 ? i : (s = e.notification) === null || s === void 0 ? void 0 : s.click_action;
  o && (t.fcmOptions.link = o);
  const u = (a = e.fcmOptions) === null || a === void 0 ? void 0 : a.analytics_label;
  u && (t.fcmOptions.analyticsLabel = u);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function T3e(t) {
  return typeof t == "object" && !!t && j5 in t;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _3e(t) {
  if (!t || !t.options)
    throw wA("App Configuration Object");
  if (!t.name)
    throw wA("App Name");
  const e = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ], { options: n } = t;
  for (const r of e)
    if (!n[r])
      throw wA(r);
  return {
    appName: t.name,
    projectId: n.projectId,
    apiKey: n.apiKey,
    appId: n.appId,
    senderId: n.messagingSenderId
  };
}
function wA(t) {
  return pi.create("missing-app-config-values", {
    valueName: t
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class E3e {
  constructor(e, n, r) {
    this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
    const i = _3e(e);
    this.firebaseDependencies = {
      app: e,
      appConfig: i,
      installations: n,
      analyticsProvider: r
    };
  }
  _delete() {
    return Promise.resolve();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function x3e(t) {
  try {
    t.swRegistration = await navigator.serviceWorker.register(X_e, {
      scope: K_e
    }), t.swRegistration.update().catch(() => {
    }), await w3e(t.swRegistration);
  } catch (e) {
    throw pi.create("failed-service-worker-registration", {
      browserErrorMessage: e == null ? void 0 : e.message
    });
  }
}
async function w3e(t) {
  return new Promise((e, n) => {
    const r = setTimeout(() => n(new Error(`Service worker not registered after ${z4} ms`)), z4), i = t.installing || t.waiting;
    t.active ? (clearTimeout(r), e()) : i ? i.onstatechange = (s) => {
      var a;
      ((a = s.target) === null || a === void 0 ? void 0 : a.state) === "activated" && (i.onstatechange = null, clearTimeout(r), e());
    } : (clearTimeout(r), n(new Error("No incoming service worker found.")));
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function C3e(t, e) {
  if (!e && !t.swRegistration && await x3e(t), !(!e && t.swRegistration)) {
    if (!(e instanceof ServiceWorkerRegistration))
      throw pi.create(
        "invalid-sw-registration"
        /* ErrorCode.INVALID_SW_REGISTRATION */
      );
    t.swRegistration = e;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function S3e(t, e) {
  e ? t.vapidKey = e : t.vapidKey || (t.vapidKey = H5);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function W5(t, e) {
  if (!navigator)
    throw pi.create(
      "only-available-in-window"
      /* ErrorCode.AVAILABLE_IN_WINDOW */
    );
  if (Notification.permission === "default" && await Notification.requestPermission(), Notification.permission !== "granted")
    throw pi.create(
      "permission-blocked"
      /* ErrorCode.PERMISSION_BLOCKED */
    );
  return await S3e(t, e == null ? void 0 : e.vapidKey), await C3e(t, e == null ? void 0 : e.serviceWorkerRegistration), p3e(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function I3e(t, e, n) {
  const r = k3e(e);
  (await t.firebaseDependencies.analyticsProvider.get()).logEvent(r, {
    /* eslint-disable camelcase */
    message_id: n[j5],
    message_name: n[J_e],
    message_time: n[e3e],
    message_device_time: Math.floor(Date.now() / 1e3)
    /* eslint-enable camelcase */
  });
}
function k3e(t) {
  switch (t) {
    case qf.NOTIFICATION_CLICKED:
      return "notification_open";
    case qf.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function D3e(t, e) {
  const n = e.data;
  if (!n.isFirebaseMessaging)
    return;
  t.onMessageHandler && n.messageType === qf.PUSH_RECEIVED && (typeof t.onMessageHandler == "function" ? t.onMessageHandler(Q4(n)) : t.onMessageHandler.next(Q4(n)));
  const r = n.data;
  T3e(r) && r[t3e] === "1" && await I3e(t, n.messageType, r);
}
const G4 = "@firebase/messaging", Y4 = "0.12.21";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const M3e = (t) => {
  const e = new E3e(t.getProvider("app").getImmediate(), t.getProvider("installations-internal").getImmediate(), t.getProvider("analytics-internal"));
  return navigator.serviceWorker.addEventListener("message", (n) => D3e(e, n)), e;
}, O3e = (t) => {
  const e = t.getProvider("messaging").getImmediate();
  return {
    getToken: (r) => W5(e, r)
  };
};
function N3e() {
  ju(new Mo(
    "messaging",
    M3e,
    "PUBLIC"
    /* ComponentType.PUBLIC */
  )), ju(new Mo(
    "messaging-internal",
    O3e,
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Co(G4, Y4), Co(G4, Y4, "esm2017");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function L3e() {
  try {
    await g5();
  } catch {
    return !1;
  }
  return typeof window < "u" && m5() && Jve() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function P3e(t = e_e()) {
  return L3e().then((e) => {
    if (!e)
      throw pi.create(
        "unsupported-browser"
        /* ErrorCode.UNSUPPORTED_BROWSER */
      );
  }, (e) => {
    throw pi.create(
      "indexed-db-unsupported"
      /* ErrorCode.INDEXED_DB_UNSUPPORTED */
    );
  }), Xv(A5(t), "messaging").getImmediate();
}
async function R3e(t, e) {
  return t = A5(t), W5(t, e);
}
N3e();
var Da = /* @__PURE__ */ ((t) => (t.FetchRooms = "/rooms", t.Search = "/search", t.Subscribe = "/me/subscribe", t.Unsubscribe = "/me/unsubscribe", t))(Da || {});
class xl {
  constructor(e, n, r) {
    Ke(this, "id");
    Ke(this, "name");
    Ke(this, "roomIds");
    this.id = e, this.name = n, this.roomIds = r;
  }
  get payload() {
    return {
      children: this.roomIds.map((e) => ({
        id: e,
        type: "room"
      }))
    };
  }
}
var lt = /* @__PURE__ */ ((t) => (t.increment = "increment", t.fetchRooms = "fetchRooms", t.fetchRoom = "fetchRoom", t.loadMessages = "loadMessages", t.updateLastRead = "updateLastRead", t.handleMessageFromSocket = "handleMessageFromSocket", t.handleRoomFromSocket = "handleRoomFromSocket", t.handleLastReadFromSocket = "handleLastReadFromSocket", t.sendMessage = "sendMessage", t.retryMessage = "retryMessage", t.recallMessage = "recallMessage", t.hideMessage = "hideMessage", t.deleteMessage = "deleteMessage", t.uploadMedia = "uploadMedia", t.fetchLinkPreview = "fetchLinkPreview", t.handleLinkPreviews = "handleLinkPreviews", t.fetchVideoBlob = "fetchVideoBlob", t.navigateToMessage = "navigateToMessage", t.uploadImage = "uploadImage", t.updateRoomPrefs = "updateRoomPrefs", t.fetchPrefs = "fetchPrefs", t.updatePref = "updatePref", t.deletePref = "deletePref", t.updateFolder = "updateFolder", t.removeFolder = "removeFolder", t.handlePrefChangeFromSocket = "handlePrefChangeFromSocket", t.handlePrefDeleteFromSocket = "handlePrefDeleteFromSocket", t.aggregateRoomsAndFolders = "aggregateRoomsAndFolders", t.removeMembers = "removeMembers", t.handleTypingFromSocket = "handleTypingFromSocket", t.insertUnreadMessage = "insertUnreadMessage", t.translate = "translate", t.searchRooms = "searchRooms", t.subscribe = "subscribe", t.unsubscribe = "unsubscribe", t.removeRoomFromFolder = "removeRoomFromFolder", t.addRoomToFolder = "addRoomToFolder", t.fetchRoomsInFolders = "fetchRoomsInFolders", t.batchSendMessage = "batchSendMessage", t.toggleNotification = "toggleNotification", t.translateMessage = "translateMessage", t.blockUser = "blockUser", t.unblockUser = "unblockUser", t.getBlockList = "getBlockList", t.hideMessagesFromUserInRoom = "hideMessagesFromUserInRoom", t.sendReaction = "sendReaction", t.deleteReaction = "deleteReaction", t.quickReply = "quickReply", t.checkNotificationPermission = "checkNotificationPermission", t))(lt || {}), nt = /* @__PURE__ */ ((t) => (t.increment = "increment", t.setState = "setState", t.updateField = "updateField", t.deleteField = "deleteField", t.updateRoom = "updateRoom", t.updateMessage = "updateMessage", t.updateLastRead = "updateLastRead", t.pushMessage = "pushMessage", t.replaceMessage = "replaceMessage", t.deleteMessages = "deleteMessages", t.clearChatRoom = "clearChatRoom", t.deleteRoom = "deleteRoom", t.setMap = "setMap", t.deleteMap = "deleteMap", t.insertMessageLinkedList = "insertMessageLinkedList", t.concateMessageLinkedList = "concateMessageLinkedList", t.unshiftMessageLinkedList = "unshiftMessageLinkedList", t))(nt || {});
class B3e {
  constructor(e) {
    Ke(this, "head");
    Ke(this, "tail");
    Ke(this, "length");
    Ke(this, "map");
    Ke(this, "messageGroups");
    Ke(this, "firstMessageOfDate");
    Ke(this, "prev", null);
    Ke(this, "next", null);
    this.head = null, this.tail = null, this.length = 0, this.map = /* @__PURE__ */ new Map(), this.messageGroups = /* @__PURE__ */ new Map(), this.firstMessageOfDate = /* @__PURE__ */ new Map();
    const n = (r) => {
      const i = Fn.createReactive(r);
      return i ? [i].concat(n(r.reply)) : [];
    };
    for (const r of e.reverse()) {
      const i = Fn.createReactive(r);
      i && this.append(i);
      for (const s of n(r.reply))
        this.map.set(s.id, s);
    }
  }
  append(e) {
    if (!this.contains(e.id)) {
      if (this.tail) {
        let n = this.tail;
        for (; n && n.createdAt > e.createdAt; )
          n = n.prev;
        n ? (n === this.tail && (this.tail = e), e.next = n.next, n.next = e, e.prev = n) : (e.next = this.head, this.head = e), e.next && (e.next.prev = e);
      } else
        this.head = this.tail = e;
      this.map.set(e.id, e), this.length++, this.insertMessageToGroup(e);
    }
  }
  insertMessageToGroup(e) {
    if (e.isSystem) return;
    if (this.messageGroups.has(e.groupId)) {
      const r = this.messageGroups.get(e.groupId);
      if (r) {
        let i = !1;
        for (let s = r.length - 1; s >= 0; s--)
          if (r[s].createdAt < e.createdAt) {
            s == r.length - 1 ? r.push(e) : r.splice(s + 1, 0, e), i = !0;
            break;
          }
        i || r.unshift(e);
      }
    } else
      this.messageGroups.set(e.groupId, [e]);
    const n = this.firstMessageOfDate.get(e.dateId);
    (!n || n.createdAt > e.createdAt) && this.firstMessageOfDate.set(e.dateId, e);
  }
  remove(e) {
    var i, s;
    const n = this.finds(e);
    if (!n) return;
    n.prev ? n.prev.next = n.next : this.head = n.next, n.next ? n.next.prev = n.prev : this.tail = n.prev, this.map.delete(e), this.length--;
    const r = this.messageGroups.get(n.groupId);
    if (r) {
      const a = r.indexOf(n);
      a >= 0 && (r.splice(a, 1), r.length === 0 && this.messageGroups.delete(n.groupId));
    }
    ((i = this.firstMessageOfDate.get(n.dateId)) == null ? void 0 : i.id) === n.id && (n.dateId === ((s = n.next) == null ? void 0 : s.dateId) ? this.firstMessageOfDate.set(n.dateId, n.next) : this.firstMessageOfDate.delete(n.dateId));
  }
  replace(e, n) {
    var i;
    const r = this.finds(e);
    if (r) {
      r.prev ? r.prev.next = n : this.head = n, r.next ? r.next.prev = n : this.tail = n, n.prev = r.prev, n.next = r.next, this.map.delete(e), this.map.set(n.id, n);
      const s = this.messageGroups.get(r.groupId);
      if (s) {
        const a = s.indexOf(r);
        a >= 0 && (n.isSystem ? s.splice(a, 1) : s[a] = n);
      }
      ((i = this.firstMessageOfDate.get(r.dateId)) == null ? void 0 : i.id) === r.id && this.firstMessageOfDate.set(r.dateId, n);
    }
  }
  concate(e) {
    if (e.length !== 0) {
      this.tail ? (this.tail.next = e.head, e.head && (e.head.prev = this.tail), this.tail = e.tail) : (this.head = e.head, this.tail = e.tail);
      for (const [n, r] of e.map)
        this.map.set(n, r);
      this.length += e.length;
      for (const [n, r] of e.messageGroups)
        if (this.messageGroups.has(n)) {
          if (this.messageGroups.get(n))
            for (const s of r)
              this.insertMessageToGroup(s);
        } else
          this.messageGroups.set(n, r);
      for (const [n, r] of e.firstMessageOfDate) {
        const i = this.firstMessageOfDate.get(n);
        i !== void 0 ? i.createdAt > r.createdAt && this.firstMessageOfDate.set(n, r) : this.firstMessageOfDate.set(n, r);
      }
    }
  }
  unshift(e) {
    if (e.length !== 0) {
      this.head ? (this.head.prev = e.tail, e.tail && (e.tail.next = this.head), this.head = e.head) : (this.head = e.head, this.tail = e.tail);
      for (const [n, r] of e.map)
        this.map.set(n, r);
      this.length += e.length;
      for (const [n, r] of e.messageGroups)
        if (this.messageGroups.has(n)) {
          if (this.messageGroups.get(n))
            for (const s of r)
              this.insertMessageToGroup(s);
        } else
          this.messageGroups.set(n, r);
      for (const [n, r] of e.firstMessageOfDate) {
        const i = this.firstMessageOfDate.get(n);
        i !== void 0 ? i.createdAt > r.createdAt && this.firstMessageOfDate.set(n, r) : this.firstMessageOfDate.set(n, r);
      }
    }
  }
  resetHead(e) {
    if (this.head && this.head.id === e) return;
    const n = this.finds(e);
    if (n) {
      this.head = n, n.prev = null;
      let r = 0, i = n;
      for (; i; )
        r++, i = i.next;
      this.length = r;
    }
  }
  resetTail(e) {
    if (this.tail && this.tail.id === e) return;
    const n = this.finds(e);
    if (n) {
      this.tail = n, n.next = null;
      let r = 0, i = n;
      for (; i; )
        r++, i = i.prev;
      this.length = r;
    }
  }
  canCombine(e) {
    var n, r;
    return e.length === 0 || !e.head || !e.tail ? !1 : this.contains(e.tail.id) || this.contains(e.head.id) || e.contains(((n = this.head) == null ? void 0 : n.id) ?? "") && e.contains(((r = this.tail) == null ? void 0 : r.id) ?? "");
  }
  combine(e) {
    var i, s, a, o;
    if (e.length === 0 || !e.head || !e.tail) return;
    const n = this.contains(e.head.id), r = this.contains(e.tail.id);
    if (!(n && r)) {
      if (!n && !r)
        e.contains(((i = this.head) == null ? void 0 : i.id) ?? "") && e.contains(((s = this.tail) == null ? void 0 : s.id) ?? "") && (this.head = e.head, this.tail = e.tail, this.length = e.length, this.map = e.map);
      else if (r) {
        const u = (a = this.finds(e.tail.id)) == null ? void 0 : a.next;
        u ? this.resetHead(u.id) : (this.head = null, this.tail = null, this.length = 0), this.unshift(e);
      } else if (n) {
        const u = (o = this.finds(e.head.id)) == null ? void 0 : o.prev;
        u ? this.resetTail(u.id) : (this.head = null, this.tail = null, this.length = 0), this.concate(e);
      }
    }
  }
  array() {
    const e = [];
    let n = this.head;
    for (; n; )
      e.push(n), n = n.next;
    return e;
  }
  finds(e) {
    const n = this.map.get(e);
    if (n)
      return n.next || n.prev || this.head === n && this.tail === n ? n : void 0;
  }
  contains(e) {
    return this.finds(e) !== void 0;
  }
  isValid() {
    if (this.head && this.head.prev || this.tail && this.tail.next)
      return !1;
    let e = 0, n = this.head;
    for (; n; ) {
      if (n.prev && n.prev.next !== n || n.next && n.next.prev !== n)
        return !1;
      e++, n = n.next;
    }
    return e === this.length;
  }
}
const F3e = { class: "mb-1 flex items-center justify-between text-xl font-medium text-gray-700 dark:text-gray-300" }, U3e = { class: "mb-3 text-base whitespace-break-spaces text-gray-600 dark:text-gray-400" }, $3e = { class: "mb-3 text-sm text-gray-600 dark:text-gray-400" }, H3e = { class: "flex items-center justify-center gap-2" }, j3e = ["disabled"], z3e = ["disabled"], q3e = /* @__PURE__ */ Ze({
  __name: "NotificationPermissionModal",
  setup(t) {
    const e = Yt(), n = $n(), r = Se(!1), i = async () => {
      try {
        if (r.value = !0, !("Notification" in window)) {
          console.warn("This browser does not support notifications"), n.closeAll();
          return;
        }
        const a = await Notification.requestPermission();
        a === "granted" ? (await e.dispatch("imkit/subscribe"), localStorage.setItem("notification-permission-skipped", "true"), n.closeAll()) : a === "denied" && (localStorage.setItem("notification-permission-skipped", "true"), n.closeAll());
      } catch (a) {
        console.error("Error requesting notification permission:", a);
      }
    }, s = () => {
      localStorage.setItem("notification-permission-skipped", "true"), n.closeAll();
    };
    return (a, o) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[200px] rounded-xl p-5 flex flex-col gap-3 max-w-[360px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", F3e, [
          An(_e(a.$t("allowOfflineNotifications")) + " ? ", 1),
          W("button", {
            class: "ml-auto",
            onClick: s
          }, [
            et(Br, { class: "h-5 w-5" })
          ])
        ]),
        W("div", U3e, _e(a.$t("notificationPermissionDescription")), 1),
        W("div", $3e, _e(a.$t("notificationSettingsPath")), 1),
        W("div", H3e, [
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 w-[100px] grow rounded-lg border border-green-500 text-base text-green-500",
            disabled: r.value,
            onClick: s
          }, _e(a.$t("askLater")), 9, j3e),
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 w-[100px] grow rounded-lg bg-green-500 text-base text-white",
            disabled: r.value,
            onClick: i
          }, _e(a.$t("allowNotifications")), 9, z3e)
        ])
      ]),
      _: 1
    }));
  }
});
var $a = /* @__PURE__ */ ((t) => (t.Direct = "direct", t.Group = "group", t))($a || {});
class hm {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    Ke(this, "id");
    Ke(this, "name");
    Ke(this, "type");
    Ke(this, "createdAt");
    Ke(this, "updatedAt");
    Ke(this, "memberIds");
    Ke(this, "isOutgoingGroupSender");
    Ke(this, "coverUrl");
    Ke(this, "lastMessage");
    Ke(this, "numberOfUnread");
    Ke(this, "lastReadMessageId");
    Ke(this, "pref");
    Ke(this, "roomTags");
    Ke(this, "extra");
    Ke(this, "muted", !1);
    Ke(this, "isSuperuser", !1);
    Ke(this, "description");
    var E;
    const {
      _id: r,
      name: i,
      roomType: s,
      createdTimeMS: a,
      lastMessage: o,
      members: u,
      cover: c,
      unread: d,
      memberProperties: l,
      extParams: f,
      pref: p,
      roomTags: m,
      muted: g,
      isSuperuser: y,
      description: b
    } = e;
    if (this.id = r, this.name = i, this.type = s || "direct", this.createdAt = a, this.lastMessage = Fn.createReactive(o), this.updatedAt = ((E = this.lastMessage) == null ? void 0 : E.createdAt) ?? a, this.memberIds = [], this.isOutgoingGroupSender = {}, u.forEach(
      (v) => {
        this.memberIds.push(v._id), v.clientType === "group" && v.members.some((_) => _._id === n) && v.members.forEach((_) => {
          this.isOutgoingGroupSender[_._id] = !0;
        });
      }
    ), this.coverUrl = c ?? "", this.numberOfUnread = d ?? 0, this.lastReadMessageId = {}, this.pref = p, this.roomTags = m ?? [], this.muted = g, this.description = b ?? "", l)
      for (const { client: v, lastRead: _ } of l)
        _ && (this.lastReadMessageId[v] = _);
    try {
      this.extra = JSON.parse(f);
    } catch {
      this.extra = {};
    }
    s === "custom" && (this.type = this.extra.roomType), this.isSuperuser = y ?? !1;
  }
  get memberIdsWithoutMeAndMyGroup() {
    const {
      state: {
        imkit: { uid: e, users: n }
      }
    } = Yt(), r = (s) => {
      var a, o;
      return s !== e && !((o = (a = n[s]) == null ? void 0 : a.memberIds) != null && o[e]) && s !== "BOT" && !s.endsWith("_sub");
    }, i = e.endsWith("_sub") ? (s) => s !== this.extra.agentId : () => !0;
    return this.memberIds.filter(
      (s) => r(s) && i(s)
    );
  }
  _displayName(e, n) {
    if (this.type == "group")
      return `${this.name} (${this.memberIds.length})`;
    if (this.type == "direct")
      if (this.extra.guestId) {
        const r = this.extra.guestId;
        return n[r].nickname ?? "";
      } else
        return this.memberIds.filter((r) => r !== e).map((r) => n[r].nickname).join(", ");
    return "";
  }
  get displayName() {
    var r;
    const {
      state: {
        imkit: { uid: e, users: n }
      }
    } = Yt();
    if (this.name)
      return this.name;
    if (this.memberIdsWithoutMeAndMyGroup.length === 0) {
      const { t: i } = Ri();
      return i("emptyChat");
    } else {
      if (this.type == "direct")
        return (r = this.memberIdsWithoutMeAndMyGroup.map((i) => n[i])[0]) == null ? void 0 : r.nickname;
      if (this.type == "group")
        return this.memberIds.filter(
          (i) => i !== e && i !== "BOT" && !i.endsWith("_sub")
        ).map((i) => n[i].nickname).join(", ");
    }
    return "";
  }
  get avatars() {
    const {
      state: {
        imkit: { uid: e, users: n }
      }
    } = Yt();
    return this.coverUrl && this.coverUrl.length > 0 ? [{ url: this.coverUrl, name: this.displayName ?? "" }] : this.memberIdsWithoutMeAndMyGroup.length === 0 ? [
      { url: n[e].avatarUrl ?? "", name: n[e].nickname ?? "" }
    ] : this.type == "direct" ? this.memberIdsWithoutMeAndMyGroup.map((r) => ({
      url: n[r].avatarUrl ?? "",
      name: n[r].nickname ?? ""
    })) : this.type == "group" ? this.memberIds.map((r) => n[r]).sort((r, i) => r.id === e ? 1 : i.id === e ? -1 : (i.avatarUrl ?? "").length - (r.avatarUrl ?? "").length).map((r) => ({
      url: r.avatarUrl ?? "",
      name: r.nickname ?? ""
    })) : [{ url: "", name: this.displayName ?? "" }];
  }
}
function V3e(t, e) {
  return e.forEach(function(n) {
    n && typeof n != "string" && !Array.isArray(n) && Object.keys(n).forEach(function(r) {
      if (r !== "default" && !(r in t)) {
        var i = Object.getOwnPropertyDescriptor(n, r);
        Object.defineProperty(t, r, i.get ? i : { enumerable: !0, get: function() {
          return n[r];
        } });
      }
    });
  }), Object.freeze(t);
}
function Q5(t, e) {
  return new Promise(function(n, r) {
    let i;
    return W3e(t).then(function(s) {
      try {
        return i = s, n(new Blob([e.slice(0, 2), i, e.slice(2)], { type: "image/jpeg" }));
      } catch (a) {
        return r(a);
      }
    }, r);
  });
}
const W3e = (t) => new Promise((e, n) => {
  const r = new FileReader();
  r.addEventListener("load", ({ target: { result: i } }) => {
    const s = new DataView(i);
    let a = 0;
    if (s.getUint16(a) !== 65496) return n("not a valid JPEG");
    for (a += 2; ; ) {
      const o = s.getUint16(a);
      if (o === 65498) break;
      const u = s.getUint16(a + 2);
      if (o === 65505 && s.getUint32(a + 4) === 1165519206) {
        const c = a + 10;
        let d;
        switch (s.getUint16(c)) {
          case 18761:
            d = !0;
            break;
          case 19789:
            d = !1;
            break;
          default:
            return n("TIFF header contains invalid endian");
        }
        if (s.getUint16(c + 2, d) !== 42) return n("TIFF header contains invalid version");
        const l = s.getUint32(c + 4, d), f = c + l + 2 + 12 * s.getUint16(c + l, d);
        for (let p = c + l + 2; p < f; p += 12)
          if (s.getUint16(p, d) == 274) {
            if (s.getUint16(p + 2, d) !== 3) return n("Orientation data type is invalid");
            if (s.getUint32(p + 4, d) !== 1) return n("Orientation data count is invalid");
            s.setUint16(p + 8, 1, d);
            break;
          }
        return e(i.slice(a, a + 2 + u));
      }
      a += 2 + u;
    }
    return e(new Blob());
  }), r.readAsArrayBuffer(t);
});
var Zm = {}, Q3e = { get exports() {
  return Zm;
}, set exports(t) {
  Zm = t;
} };
(function(t) {
  var e, n, r = {};
  Q3e.exports = r, r.parse = function(i, s) {
    for (var a = r.bin.readUshort, o = r.bin.readUint, u = 0, c = {}, d = new Uint8Array(i), l = d.length - 4; o(d, l) != 101010256; ) l--;
    u = l, u += 4;
    var f = a(d, u += 4);
    a(d, u += 2);
    var p = o(d, u += 2), m = o(d, u += 4);
    u += 4, u = m;
    for (var g = 0; g < f; g++) {
      o(d, u), u += 4, u += 4, u += 4, o(d, u += 4), p = o(d, u += 4);
      var y = o(d, u += 4), b = a(d, u += 4), E = a(d, u + 2), v = a(d, u + 4);
      u += 6;
      var _ = o(d, u += 8);
      u += 4, u += b + E + v, r._readLocal(d, _, c, p, y, s);
    }
    return c;
  }, r._readLocal = function(i, s, a, o, u, c) {
    var d = r.bin.readUshort, l = r.bin.readUint;
    l(i, s), d(i, s += 4), d(i, s += 2);
    var f = d(i, s += 2);
    l(i, s += 2), l(i, s += 4), s += 4;
    var p = d(i, s += 8), m = d(i, s += 2);
    s += 2;
    var g = r.bin.readUTF8(i, s, p);
    if (s += p, s += m, c) a[g] = { size: u, csize: o };
    else {
      var y = new Uint8Array(i.buffer, s);
      if (f == 0) a[g] = new Uint8Array(y.buffer.slice(s, s + o));
      else {
        if (f != 8) throw "unknown compression method: " + f;
        var b = new Uint8Array(u);
        r.inflateRaw(y, b), a[g] = b;
      }
    }
  }, r.inflateRaw = function(i, s) {
    return r.F.inflate(i, s);
  }, r.inflate = function(i, s) {
    return i[0], i[1], r.inflateRaw(new Uint8Array(i.buffer, i.byteOffset + 2, i.length - 6), s);
  }, r.deflate = function(i, s) {
    s == null && (s = { level: 6 });
    var a = 0, o = new Uint8Array(50 + Math.floor(1.1 * i.length));
    o[a] = 120, o[a + 1] = 156, a += 2, a = r.F.deflateRaw(i, o, a, s.level);
    var u = r.adler(i, 0, i.length);
    return o[a + 0] = u >>> 24 & 255, o[a + 1] = u >>> 16 & 255, o[a + 2] = u >>> 8 & 255, o[a + 3] = u >>> 0 & 255, new Uint8Array(o.buffer, 0, a + 4);
  }, r.deflateRaw = function(i, s) {
    s == null && (s = { level: 6 });
    var a = new Uint8Array(50 + Math.floor(1.1 * i.length)), o = r.F.deflateRaw(i, a, o, s.level);
    return new Uint8Array(a.buffer, 0, o);
  }, r.encode = function(i, s) {
    s == null && (s = !1);
    var a = 0, o = r.bin.writeUint, u = r.bin.writeUshort, c = {};
    for (var d in i) {
      var l = !r._noNeed(d) && !s, f = i[d], p = r.crc.crc(f, 0, f.length);
      c[d] = { cpr: l, usize: f.length, crc: p, file: l ? r.deflateRaw(f) : f };
    }
    for (var d in c) a += c[d].file.length + 30 + 46 + 2 * r.bin.sizeUTF8(d);
    a += 22;
    var m = new Uint8Array(a), g = 0, y = [];
    for (var d in c) {
      var b = c[d];
      y.push(g), g = r._writeHeader(m, g, d, b, 0);
    }
    var E = 0, v = g;
    for (var d in c)
      b = c[d], y.push(g), g = r._writeHeader(m, g, d, b, 1, y[E++]);
    var _ = g - v;
    return o(m, g, 101010256), g += 4, u(m, g += 4, E), u(m, g += 2, E), o(m, g += 2, _), o(m, g += 4, v), g += 4, g += 2, m.buffer;
  }, r._noNeed = function(i) {
    var s = i.split(".").pop().toLowerCase();
    return "png,jpg,jpeg,zip".indexOf(s) != -1;
  }, r._writeHeader = function(i, s, a, o, u, c) {
    var d = r.bin.writeUint, l = r.bin.writeUshort, f = o.file;
    return d(i, s, u == 0 ? 67324752 : 33639248), s += 4, u == 1 && (s += 2), l(i, s, 20), l(i, s += 2, 0), l(i, s += 2, o.cpr ? 8 : 0), d(i, s += 2, 0), d(i, s += 4, o.crc), d(i, s += 4, f.length), d(i, s += 4, o.usize), l(i, s += 4, r.bin.sizeUTF8(a)), l(i, s += 2, 0), s += 2, u == 1 && (s += 2, s += 2, d(i, s += 6, c), s += 4), s += r.bin.writeUTF8(i, s, a), u == 0 && (i.set(f, s), s += f.length), s;
  }, r.crc = { table: function() {
    for (var i = new Uint32Array(256), s = 0; s < 256; s++) {
      for (var a = s, o = 0; o < 8; o++) 1 & a ? a = 3988292384 ^ a >>> 1 : a >>>= 1;
      i[s] = a;
    }
    return i;
  }(), update: function(i, s, a, o) {
    for (var u = 0; u < o; u++) i = r.crc.table[255 & (i ^ s[a + u])] ^ i >>> 8;
    return i;
  }, crc: function(i, s, a) {
    return 4294967295 ^ r.crc.update(4294967295, i, s, a);
  } }, r.adler = function(i, s, a) {
    for (var o = 1, u = 0, c = s, d = s + a; c < d; ) {
      for (var l = Math.min(c + 5552, d); c < l; ) u += o += i[c++];
      o %= 65521, u %= 65521;
    }
    return u << 16 | o;
  }, r.bin = { readUshort: function(i, s) {
    return i[s] | i[s + 1] << 8;
  }, writeUshort: function(i, s, a) {
    i[s] = 255 & a, i[s + 1] = a >> 8 & 255;
  }, readUint: function(i, s) {
    return 16777216 * i[s + 3] + (i[s + 2] << 16 | i[s + 1] << 8 | i[s]);
  }, writeUint: function(i, s, a) {
    i[s] = 255 & a, i[s + 1] = a >> 8 & 255, i[s + 2] = a >> 16 & 255, i[s + 3] = a >> 24 & 255;
  }, readASCII: function(i, s, a) {
    for (var o = "", u = 0; u < a; u++) o += String.fromCharCode(i[s + u]);
    return o;
  }, writeASCII: function(i, s, a) {
    for (var o = 0; o < a.length; o++) i[s + o] = a.charCodeAt(o);
  }, pad: function(i) {
    return i.length < 2 ? "0" + i : i;
  }, readUTF8: function(i, s, a) {
    for (var o, u = "", c = 0; c < a; c++) u += "%" + r.bin.pad(i[s + c].toString(16));
    try {
      o = decodeURIComponent(u);
    } catch {
      return r.bin.readASCII(i, s, a);
    }
    return o;
  }, writeUTF8: function(i, s, a) {
    for (var o = a.length, u = 0, c = 0; c < o; c++) {
      var d = a.charCodeAt(c);
      if ((4294967168 & d) == 0) i[s + u] = d, u++;
      else if ((4294965248 & d) == 0) i[s + u] = 192 | d >> 6, i[s + u + 1] = 128 | d >> 0 & 63, u += 2;
      else if ((4294901760 & d) == 0) i[s + u] = 224 | d >> 12, i[s + u + 1] = 128 | d >> 6 & 63, i[s + u + 2] = 128 | d >> 0 & 63, u += 3;
      else {
        if ((4292870144 & d) != 0) throw "e";
        i[s + u] = 240 | d >> 18, i[s + u + 1] = 128 | d >> 12 & 63, i[s + u + 2] = 128 | d >> 6 & 63, i[s + u + 3] = 128 | d >> 0 & 63, u += 4;
      }
    }
    return u;
  }, sizeUTF8: function(i) {
    for (var s = i.length, a = 0, o = 0; o < s; o++) {
      var u = i.charCodeAt(o);
      if ((4294967168 & u) == 0) a++;
      else if ((4294965248 & u) == 0) a += 2;
      else if ((4294901760 & u) == 0) a += 3;
      else {
        if ((4292870144 & u) != 0) throw "e";
        a += 4;
      }
    }
    return a;
  } }, r.F = {}, r.F.deflateRaw = function(i, s, a, o) {
    var u = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][o], c = r.F.U, d = r.F._goodIndex;
    r.F._hash;
    var l = r.F._putsE, f = 0, p = a << 3, m = 0, g = i.length;
    if (o == 0) {
      for (; f < g; )
        l(s, p, f + (H = Math.min(65535, g - f)) == g ? 1 : 0), p = r.F._copyExact(i, f, H, s, p + 8), f += H;
      return p >>> 3;
    }
    var y = c.lits, b = c.strt, E = c.prev, v = 0, _ = 0, D = 0, S = 0, M = 0, O = 0;
    for (g > 2 && (b[O = r.F._hash(i, 0)] = 0), f = 0; f < g; f++) {
      if (M = O, f + 1 < g - 2) {
        O = r.F._hash(i, f + 1);
        var T = f + 1 & 32767;
        E[T] = b[O], b[O] = T;
      }
      if (m <= f) {
        (v > 14e3 || _ > 26697) && g - f > 100 && (m < f && (y[v] = f - m, v += 2, m = f), p = r.F._writeBlock(f == g - 1 || m == g ? 1 : 0, y, v, S, i, D, f - D, s, p), v = _ = S = 0, D = f);
        var N = 0;
        f < g - 2 && (N = r.F._bestMatch(i, f, E, M, Math.min(u[2], g - f), u[3]));
        var H = N >>> 16, $ = 65535 & N;
        if (N != 0) {
          $ = 65535 & N;
          var j = d(H = N >>> 16, c.of0);
          c.lhst[257 + j]++;
          var U = d($, c.df0);
          c.dhst[U]++, S += c.exb[j] + c.dxb[U], y[v] = H << 23 | f - m, y[v + 1] = $ << 16 | j << 8 | U, v += 2, m = f + H;
        } else c.lhst[i[f]]++;
        _++;
      }
    }
    for (D == f && i.length != 0 || (m < f && (y[v] = f - m, v += 2, m = f), p = r.F._writeBlock(1, y, v, S, i, D, f - D, s, p), v = 0, _ = 0, v = _ = S = 0, D = f); (7 & p) != 0; ) p++;
    return p >>> 3;
  }, r.F._bestMatch = function(i, s, a, o, u, c) {
    var d = 32767 & s, l = a[d], f = d - l + 32768 & 32767;
    if (l == d || o != r.F._hash(i, s - f)) return 0;
    for (var p = 0, m = 0, g = Math.min(32767, s); f <= g && --c != 0 && l != d; ) {
      if (p == 0 || i[s + p] == i[s + p - f]) {
        var y = r.F._howLong(i, s, f);
        if (y > p) {
          if (m = f, (p = y) >= u) break;
          f + 2 < y && (y = f + 2);
          for (var b = 0, E = 0; E < y - 2; E++) {
            var v = s - f + E + 32768 & 32767, _ = v - a[v] + 32768 & 32767;
            _ > b && (b = _, l = v);
          }
        }
      }
      f += (d = l) - (l = a[d]) + 32768 & 32767;
    }
    return p << 16 | m;
  }, r.F._howLong = function(i, s, a) {
    if (i[s] != i[s - a] || i[s + 1] != i[s + 1 - a] || i[s + 2] != i[s + 2 - a]) return 0;
    var o = s, u = Math.min(i.length, s + 258);
    for (s += 3; s < u && i[s] == i[s - a]; ) s++;
    return s - o;
  }, r.F._hash = function(i, s) {
    return (i[s] << 8 | i[s + 1]) + (i[s + 2] << 4) & 65535;
  }, r.saved = 0, r.F._writeBlock = function(i, s, a, o, u, c, d, l, f) {
    var p, m, g, y, b, E, v, _, D, S = r.F.U, M = r.F._putsF, O = r.F._putsE;
    S.lhst[256]++, m = (p = r.F.getTrees())[0], g = p[1], y = p[2], b = p[3], E = p[4], v = p[5], _ = p[6], D = p[7];
    var T = 32 + ((f + 3 & 7) == 0 ? 0 : 8 - (f + 3 & 7)) + (d << 3), N = o + r.F.contSize(S.fltree, S.lhst) + r.F.contSize(S.fdtree, S.dhst), H = o + r.F.contSize(S.ltree, S.lhst) + r.F.contSize(S.dtree, S.dhst);
    H += 14 + 3 * v + r.F.contSize(S.itree, S.ihst) + (2 * S.ihst[16] + 3 * S.ihst[17] + 7 * S.ihst[18]);
    for (var $ = 0; $ < 286; $++) S.lhst[$] = 0;
    for ($ = 0; $ < 30; $++) S.dhst[$] = 0;
    for ($ = 0; $ < 19; $++) S.ihst[$] = 0;
    var j = T < N && T < H ? 0 : N < H ? 1 : 2;
    if (M(l, f, i), M(l, f + 1, j), f += 3, j == 0) {
      for (; (7 & f) != 0; ) f++;
      f = r.F._copyExact(u, c, d, l, f);
    } else {
      var U, V;
      if (j == 1 && (U = S.fltree, V = S.fdtree), j == 2) {
        r.F.makeCodes(S.ltree, m), r.F.revCodes(S.ltree, m), r.F.makeCodes(S.dtree, g), r.F.revCodes(S.dtree, g), r.F.makeCodes(S.itree, y), r.F.revCodes(S.itree, y), U = S.ltree, V = S.dtree, O(l, f, b - 257), O(l, f += 5, E - 1), O(l, f += 5, v - 4), f += 4;
        for (var B = 0; B < v; B++) O(l, f + 3 * B, S.itree[1 + (S.ordr[B] << 1)]);
        f += 3 * v, f = r.F._codeTiny(_, S.itree, l, f), f = r.F._codeTiny(D, S.itree, l, f);
      }
      for (var R = c, K = 0; K < a; K += 2) {
        for (var Q = s[K], P = Q >>> 23, I = R + (8388607 & Q); R < I; ) f = r.F._writeLit(u[R++], U, l, f);
        if (P != 0) {
          var G = s[K + 1], te = G >> 16, ee = G >> 8 & 255, Z = 255 & G;
          O(l, f = r.F._writeLit(257 + ee, U, l, f), P - S.of0[ee]), f += S.exb[ee], M(l, f = r.F._writeLit(Z, V, l, f), te - S.df0[Z]), f += S.dxb[Z], R += P;
        }
      }
      f = r.F._writeLit(256, U, l, f);
    }
    return f;
  }, r.F._copyExact = function(i, s, a, o, u) {
    var c = u >>> 3;
    return o[c] = a, o[c + 1] = a >>> 8, o[c + 2] = 255 - o[c], o[c + 3] = 255 - o[c + 1], c += 4, o.set(new Uint8Array(i.buffer, s, a), c), u + (a + 4 << 3);
  }, r.F.getTrees = function() {
    for (var i = r.F.U, s = r.F._hufTree(i.lhst, i.ltree, 15), a = r.F._hufTree(i.dhst, i.dtree, 15), o = [], u = r.F._lenCodes(i.ltree, o), c = [], d = r.F._lenCodes(i.dtree, c), l = 0; l < o.length; l += 2) i.ihst[o[l]]++;
    for (l = 0; l < c.length; l += 2) i.ihst[c[l]]++;
    for (var f = r.F._hufTree(i.ihst, i.itree, 7), p = 19; p > 4 && i.itree[1 + (i.ordr[p - 1] << 1)] == 0; ) p--;
    return [s, a, f, u, d, p, o, c];
  }, r.F.getSecond = function(i) {
    for (var s = [], a = 0; a < i.length; a += 2) s.push(i[a + 1]);
    return s;
  }, r.F.nonZero = function(i) {
    for (var s = "", a = 0; a < i.length; a += 2) i[a + 1] != 0 && (s += (a >> 1) + ",");
    return s;
  }, r.F.contSize = function(i, s) {
    for (var a = 0, o = 0; o < s.length; o++) a += s[o] * i[1 + (o << 1)];
    return a;
  }, r.F._codeTiny = function(i, s, a, o) {
    for (var u = 0; u < i.length; u += 2) {
      var c = i[u], d = i[u + 1];
      o = r.F._writeLit(c, s, a, o);
      var l = c == 16 ? 2 : c == 17 ? 3 : 7;
      c > 15 && (r.F._putsE(a, o, d, l), o += l);
    }
    return o;
  }, r.F._lenCodes = function(i, s) {
    for (var a = i.length; a != 2 && i[a - 1] == 0; ) a -= 2;
    for (var o = 0; o < a; o += 2) {
      var u = i[o + 1], c = o + 3 < a ? i[o + 3] : -1, d = o + 5 < a ? i[o + 5] : -1, l = o == 0 ? -1 : i[o - 1];
      if (u == 0 && c == u && d == u) {
        for (var f = o + 5; f + 2 < a && i[f + 2] == u; ) f += 2;
        (p = Math.min(f + 1 - o >>> 1, 138)) < 11 ? s.push(17, p - 3) : s.push(18, p - 11), o += 2 * p - 2;
      } else if (u == l && c == u && d == u) {
        for (f = o + 5; f + 2 < a && i[f + 2] == u; ) f += 2;
        var p = Math.min(f + 1 - o >>> 1, 6);
        s.push(16, p - 3), o += 2 * p - 2;
      } else s.push(u, 0);
    }
    return a >>> 1;
  }, r.F._hufTree = function(i, s, a) {
    var o = [], u = i.length, c = s.length, d = 0;
    for (d = 0; d < c; d += 2) s[d] = 0, s[d + 1] = 0;
    for (d = 0; d < u; d++) i[d] != 0 && o.push({ lit: d, f: i[d] });
    var l = o.length, f = o.slice(0);
    if (l == 0) return 0;
    if (l == 1) {
      var p = o[0].lit;
      return f = p == 0 ? 1 : 0, s[1 + (p << 1)] = 1, s[1 + (f << 1)] = 1, 1;
    }
    o.sort(function(_, D) {
      return _.f - D.f;
    });
    var m = o[0], g = o[1], y = 0, b = 1, E = 2;
    for (o[0] = { lit: -1, f: m.f + g.f, l: m, r: g, d: 0 }; b != l - 1; ) m = y != b && (E == l || o[y].f < o[E].f) ? o[y++] : o[E++], g = y != b && (E == l || o[y].f < o[E].f) ? o[y++] : o[E++], o[b++] = { lit: -1, f: m.f + g.f, l: m, r: g };
    var v = r.F.setDepth(o[b - 1], 0);
    for (v > a && (r.F.restrictDepth(f, a, v), v = a), d = 0; d < l; d++) s[1 + (f[d].lit << 1)] = f[d].d;
    return v;
  }, r.F.setDepth = function(i, s) {
    return i.lit != -1 ? (i.d = s, s) : Math.max(r.F.setDepth(i.l, s + 1), r.F.setDepth(i.r, s + 1));
  }, r.F.restrictDepth = function(i, s, a) {
    var o = 0, u = 1 << a - s, c = 0;
    for (i.sort(function(l, f) {
      return f.d == l.d ? l.f - f.f : f.d - l.d;
    }), o = 0; o < i.length && i[o].d > s; o++) {
      var d = i[o].d;
      i[o].d = s, c += u - (1 << a - d);
    }
    for (c >>>= a - s; c > 0; )
      (d = i[o].d) < s ? (i[o].d++, c -= 1 << s - d - 1) : o++;
    for (; o >= 0; o--) i[o].d == s && c < 0 && (i[o].d--, c++);
    c != 0 && console.log("debt left");
  }, r.F._goodIndex = function(i, s) {
    var a = 0;
    return s[16 | a] <= i && (a |= 16), s[8 | a] <= i && (a |= 8), s[4 | a] <= i && (a |= 4), s[2 | a] <= i && (a |= 2), s[1 | a] <= i && (a |= 1), a;
  }, r.F._writeLit = function(i, s, a, o) {
    return r.F._putsF(a, o, s[i << 1]), o + s[1 + (i << 1)];
  }, r.F.inflate = function(i, s) {
    var a = Uint8Array;
    if (i[0] == 3 && i[1] == 0) return s || new a(0);
    var o = r.F, u = o._bitsF, c = o._bitsE, d = o._decodeTiny, l = o.makeCodes, f = o.codes2map, p = o._get17, m = o.U, g = s == null;
    g && (s = new a(i.length >>> 2 << 3));
    for (var y, b, E = 0, v = 0, _ = 0, D = 0, S = 0, M = 0, O = 0, T = 0, N = 0; E == 0; ) if (E = u(i, N, 1), v = u(i, N + 1, 2), N += 3, v != 0) {
      if (g && (s = r.F._check(s, T + (1 << 17))), v == 1 && (y = m.flmap, b = m.fdmap, M = 511, O = 31), v == 2) {
        _ = c(i, N, 5) + 257, D = c(i, N + 5, 5) + 1, S = c(i, N + 10, 4) + 4, N += 14;
        for (var H = 0; H < 38; H += 2) m.itree[H] = 0, m.itree[H + 1] = 0;
        var $ = 1;
        for (H = 0; H < S; H++) {
          var j = c(i, N + 3 * H, 3);
          m.itree[1 + (m.ordr[H] << 1)] = j, j > $ && ($ = j);
        }
        N += 3 * S, l(m.itree, $), f(m.itree, $, m.imap), y = m.lmap, b = m.dmap, N = d(m.imap, (1 << $) - 1, _ + D, i, N, m.ttree);
        var U = o._copyOut(m.ttree, 0, _, m.ltree);
        M = (1 << U) - 1;
        var V = o._copyOut(m.ttree, _, D, m.dtree);
        O = (1 << V) - 1, l(m.ltree, U), f(m.ltree, U, y), l(m.dtree, V), f(m.dtree, V, b);
      }
      for (; ; ) {
        var B = y[p(i, N) & M];
        N += 15 & B;
        var R = B >>> 4;
        if (!(R >>> 8)) s[T++] = R;
        else {
          if (R == 256) break;
          var K = T + R - 254;
          if (R > 264) {
            var Q = m.ldef[R - 257];
            K = T + (Q >>> 3) + c(i, N, 7 & Q), N += 7 & Q;
          }
          var P = b[p(i, N) & O];
          N += 15 & P;
          var I = P >>> 4, G = m.ddef[I], te = (G >>> 4) + u(i, N, 15 & G);
          for (N += 15 & G, g && (s = r.F._check(s, T + (1 << 17))); T < K; ) s[T] = s[T++ - te], s[T] = s[T++ - te], s[T] = s[T++ - te], s[T] = s[T++ - te];
          T = K;
        }
      }
    } else {
      (7 & N) != 0 && (N += 8 - (7 & N));
      var ee = 4 + (N >>> 3), Z = i[ee - 4] | i[ee - 3] << 8;
      g && (s = r.F._check(s, T + Z)), s.set(new a(i.buffer, i.byteOffset + ee, Z), T), N = ee + Z << 3, T += Z;
    }
    return s.length == T ? s : s.slice(0, T);
  }, r.F._check = function(i, s) {
    var a = i.length;
    if (s <= a) return i;
    var o = new Uint8Array(Math.max(a << 1, s));
    return o.set(i, 0), o;
  }, r.F._decodeTiny = function(i, s, a, o, u, c) {
    for (var d = r.F._bitsE, l = r.F._get17, f = 0; f < a; ) {
      var p = i[l(o, u) & s];
      u += 15 & p;
      var m = p >>> 4;
      if (m <= 15) c[f] = m, f++;
      else {
        var g = 0, y = 0;
        m == 16 ? (y = 3 + d(o, u, 2), u += 2, g = c[f - 1]) : m == 17 ? (y = 3 + d(o, u, 3), u += 3) : m == 18 && (y = 11 + d(o, u, 7), u += 7);
        for (var b = f + y; f < b; ) c[f] = g, f++;
      }
    }
    return u;
  }, r.F._copyOut = function(i, s, a, o) {
    for (var u = 0, c = 0, d = o.length >>> 1; c < a; ) {
      var l = i[c + s];
      o[c << 1] = 0, o[1 + (c << 1)] = l, l > u && (u = l), c++;
    }
    for (; c < d; ) o[c << 1] = 0, o[1 + (c << 1)] = 0, c++;
    return u;
  }, r.F.makeCodes = function(i, s) {
    for (var a, o, u, c, d = r.F.U, l = i.length, f = d.bl_count, p = 0; p <= s; p++) f[p] = 0;
    for (p = 1; p < l; p += 2) f[i[p]]++;
    var m = d.next_code;
    for (a = 0, f[0] = 0, o = 1; o <= s; o++) a = a + f[o - 1] << 1, m[o] = a;
    for (u = 0; u < l; u += 2) (c = i[u + 1]) != 0 && (i[u] = m[c], m[c]++);
  }, r.F.codes2map = function(i, s, a) {
    for (var o = i.length, u = r.F.U.rev15, c = 0; c < o; c += 2) if (i[c + 1] != 0) for (var d = c >> 1, l = i[c + 1], f = d << 4 | l, p = s - l, m = i[c] << p, g = m + (1 << p); m != g; )
      a[u[m] >>> 15 - s] = f, m++;
  }, r.F.revCodes = function(i, s) {
    for (var a = r.F.U.rev15, o = 15 - s, u = 0; u < i.length; u += 2) {
      var c = i[u] << s - i[u + 1];
      i[u] = a[c] >>> o;
    }
  }, r.F._putsE = function(i, s, a) {
    a <<= 7 & s;
    var o = s >>> 3;
    i[o] |= a, i[o + 1] |= a >>> 8;
  }, r.F._putsF = function(i, s, a) {
    a <<= 7 & s;
    var o = s >>> 3;
    i[o] |= a, i[o + 1] |= a >>> 8, i[o + 2] |= a >>> 16;
  }, r.F._bitsE = function(i, s, a) {
    return (i[s >>> 3] | i[1 + (s >>> 3)] << 8) >>> (7 & s) & (1 << a) - 1;
  }, r.F._bitsF = function(i, s, a) {
    return (i[s >>> 3] | i[1 + (s >>> 3)] << 8 | i[2 + (s >>> 3)] << 16) >>> (7 & s) & (1 << a) - 1;
  }, r.F._get17 = function(i, s) {
    return (i[s >>> 3] | i[1 + (s >>> 3)] << 8 | i[2 + (s >>> 3)] << 16) >>> (7 & s);
  }, r.F._get25 = function(i, s) {
    return (i[s >>> 3] | i[1 + (s >>> 3)] << 8 | i[2 + (s >>> 3)] << 16 | i[3 + (s >>> 3)] << 24) >>> (7 & s);
  }, r.F.U = (e = Uint16Array, n = Uint32Array, { next_code: new e(16), bl_count: new e(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new e(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new n(32), flmap: new e(512), fltree: [], fdmap: new e(32), fdtree: [], lmap: new e(32768), ltree: [], ttree: [], dmap: new e(32768), dtree: [], imap: new e(512), itree: [], rev15: new e(32768), lhst: new n(286), dhst: new n(30), ihst: new n(19), lits: new n(15e3), strt: new e(65536), prev: new e(32768) }), function() {
    for (var i = r.F.U, s = 0; s < 32768; s++) {
      var a = s;
      a = (4278255360 & (a = (4042322160 & (a = (3435973836 & (a = (2863311530 & a) >>> 1 | (1431655765 & a) << 1)) >>> 2 | (858993459 & a) << 2)) >>> 4 | (252645135 & a) << 4)) >>> 8 | (16711935 & a) << 8, i.rev15[s] = (a >>> 16 | a << 16) >>> 17;
    }
    function o(u, c, d) {
      for (; c-- != 0; ) u.push(0, d);
    }
    for (s = 0; s < 32; s++) i.ldef[s] = i.of0[s] << 3 | i.exb[s], i.ddef[s] = i.df0[s] << 4 | i.dxb[s];
    o(i.fltree, 144, 8), o(i.fltree, 112, 9), o(i.fltree, 24, 7), o(i.fltree, 8, 8), r.F.makeCodes(i.fltree, 9), r.F.codes2map(i.fltree, 9, i.flmap), r.F.revCodes(i.fltree, 9), o(i.fdtree, 32, 5), r.F.makeCodes(i.fdtree, 5), r.F.codes2map(i.fdtree, 5, i.fdmap), r.F.revCodes(i.fdtree, 5), o(i.itree, 19, 0), o(i.ltree, 286, 0), o(i.dtree, 30, 0), o(i.ttree, 320, 0);
  }();
})();
var G3e = V3e({ __proto__: null, default: Zm }, [Zm]);
const Es = function() {
  var t = { nextZero(d, l) {
    for (; d[l] != 0; ) l++;
    return l;
  }, readUshort: (d, l) => d[l] << 8 | d[l + 1], writeUshort(d, l, f) {
    d[l] = f >> 8 & 255, d[l + 1] = 255 & f;
  }, readUint: (d, l) => 16777216 * d[l] + (d[l + 1] << 16 | d[l + 2] << 8 | d[l + 3]), writeUint(d, l, f) {
    d[l] = f >> 24 & 255, d[l + 1] = f >> 16 & 255, d[l + 2] = f >> 8 & 255, d[l + 3] = 255 & f;
  }, readASCII(d, l, f) {
    let p = "";
    for (let m = 0; m < f; m++) p += String.fromCharCode(d[l + m]);
    return p;
  }, writeASCII(d, l, f) {
    for (let p = 0; p < f.length; p++) d[l + p] = f.charCodeAt(p);
  }, readBytes(d, l, f) {
    const p = [];
    for (let m = 0; m < f; m++) p.push(d[l + m]);
    return p;
  }, pad: (d) => d.length < 2 ? `0${d}` : d, readUTF8(d, l, f) {
    let p, m = "";
    for (let g = 0; g < f; g++) m += `%${t.pad(d[l + g].toString(16))}`;
    try {
      p = decodeURIComponent(m);
    } catch {
      return t.readASCII(d, l, f);
    }
    return p;
  } };
  function e(d, l, f, p) {
    const m = l * f, g = s(p), y = Math.ceil(l * g / 8), b = new Uint8Array(4 * m), E = new Uint32Array(b.buffer), { ctype: v } = p, { depth: _ } = p, D = t.readUshort;
    if (v == 6) {
      const Q = m << 2;
      if (_ == 8) for (var S = 0; S < Q; S += 4) b[S] = d[S], b[S + 1] = d[S + 1], b[S + 2] = d[S + 2], b[S + 3] = d[S + 3];
      if (_ == 16) for (S = 0; S < Q; S++) b[S] = d[S << 1];
    } else if (v == 2) {
      const Q = p.tabs.tRNS;
      if (Q == null) {
        if (_ == 8) for (S = 0; S < m; S++) {
          var M = 3 * S;
          E[S] = 255 << 24 | d[M + 2] << 16 | d[M + 1] << 8 | d[M];
        }
        if (_ == 16) for (S = 0; S < m; S++)
          M = 6 * S, E[S] = 255 << 24 | d[M + 4] << 16 | d[M + 2] << 8 | d[M];
      } else {
        var O = Q[0];
        const P = Q[1], I = Q[2];
        if (_ == 8) for (S = 0; S < m; S++) {
          var T = S << 2;
          M = 3 * S, E[S] = 255 << 24 | d[M + 2] << 16 | d[M + 1] << 8 | d[M], d[M] == O && d[M + 1] == P && d[M + 2] == I && (b[T + 3] = 0);
        }
        if (_ == 16) for (S = 0; S < m; S++)
          T = S << 2, M = 6 * S, E[S] = 255 << 24 | d[M + 4] << 16 | d[M + 2] << 8 | d[M], D(d, M) == O && D(d, M + 2) == P && D(d, M + 4) == I && (b[T + 3] = 0);
      }
    } else if (v == 3) {
      const Q = p.tabs.PLTE, P = p.tabs.tRNS, I = P ? P.length : 0;
      if (_ == 1) for (var N = 0; N < f; N++) {
        var H = N * y, $ = N * l;
        for (S = 0; S < l; S++) {
          T = $ + S << 2;
          var j = 3 * (U = d[H + (S >> 3)] >> 7 - ((7 & S) << 0) & 1);
          b[T] = Q[j], b[T + 1] = Q[j + 1], b[T + 2] = Q[j + 2], b[T + 3] = U < I ? P[U] : 255;
        }
      }
      if (_ == 2) for (N = 0; N < f; N++) for (H = N * y, $ = N * l, S = 0; S < l; S++)
        T = $ + S << 2, j = 3 * (U = d[H + (S >> 2)] >> 6 - ((3 & S) << 1) & 3), b[T] = Q[j], b[T + 1] = Q[j + 1], b[T + 2] = Q[j + 2], b[T + 3] = U < I ? P[U] : 255;
      if (_ == 4) for (N = 0; N < f; N++) for (H = N * y, $ = N * l, S = 0; S < l; S++)
        T = $ + S << 2, j = 3 * (U = d[H + (S >> 1)] >> 4 - ((1 & S) << 2) & 15), b[T] = Q[j], b[T + 1] = Q[j + 1], b[T + 2] = Q[j + 2], b[T + 3] = U < I ? P[U] : 255;
      if (_ == 8) for (S = 0; S < m; S++) {
        var U;
        T = S << 2, j = 3 * (U = d[S]), b[T] = Q[j], b[T + 1] = Q[j + 1], b[T + 2] = Q[j + 2], b[T + 3] = U < I ? P[U] : 255;
      }
    } else if (v == 4) {
      if (_ == 8) for (S = 0; S < m; S++) {
        T = S << 2;
        var V = d[B = S << 1];
        b[T] = V, b[T + 1] = V, b[T + 2] = V, b[T + 3] = d[B + 1];
      }
      if (_ == 16) for (S = 0; S < m; S++) {
        var B;
        T = S << 2, V = d[B = S << 2], b[T] = V, b[T + 1] = V, b[T + 2] = V, b[T + 3] = d[B + 2];
      }
    } else if (v == 0) for (O = p.tabs.tRNS ? p.tabs.tRNS : -1, N = 0; N < f; N++) {
      const Q = N * y, P = N * l;
      if (_ == 1) for (var R = 0; R < l; R++) {
        var K = (V = 255 * (d[Q + (R >>> 3)] >>> 7 - (7 & R) & 1)) == 255 * O ? 0 : 255;
        E[P + R] = K << 24 | V << 16 | V << 8 | V;
      }
      else if (_ == 2) for (R = 0; R < l; R++)
        K = (V = 85 * (d[Q + (R >>> 2)] >>> 6 - ((3 & R) << 1) & 3)) == 85 * O ? 0 : 255, E[P + R] = K << 24 | V << 16 | V << 8 | V;
      else if (_ == 4) for (R = 0; R < l; R++)
        K = (V = 17 * (d[Q + (R >>> 1)] >>> 4 - ((1 & R) << 2) & 15)) == 17 * O ? 0 : 255, E[P + R] = K << 24 | V << 16 | V << 8 | V;
      else if (_ == 8) for (R = 0; R < l; R++)
        K = (V = d[Q + R]) == O ? 0 : 255, E[P + R] = K << 24 | V << 16 | V << 8 | V;
      else if (_ == 16) for (R = 0; R < l; R++)
        V = d[Q + (R << 1)], K = D(d, Q + (R << 1)) == O ? 0 : 255, E[P + R] = K << 24 | V << 16 | V << 8 | V;
    }
    return b;
  }
  function n(d, l, f, p) {
    const m = s(d), g = Math.ceil(f * m / 8), y = new Uint8Array((g + 1 + d.interlace) * p);
    return l = d.tabs.CgBI ? i(l, y) : r(l, y), d.interlace == 0 ? l = a(l, d, 0, f, p) : d.interlace == 1 && (l = function(E, v) {
      const _ = v.width, D = v.height, S = s(v), M = S >> 3, O = Math.ceil(_ * S / 8), T = new Uint8Array(D * O);
      let N = 0;
      const H = [0, 0, 4, 0, 2, 0, 1], $ = [0, 4, 0, 2, 0, 1, 0], j = [8, 8, 8, 4, 4, 2, 2], U = [8, 8, 4, 4, 2, 2, 1];
      let V = 0;
      for (; V < 7; ) {
        const R = j[V], K = U[V];
        let Q = 0, P = 0, I = H[V];
        for (; I < D; ) I += R, P++;
        let G = $[V];
        for (; G < _; ) G += K, Q++;
        const te = Math.ceil(Q * S / 8);
        a(E, v, N, Q, P);
        let ee = 0, Z = H[V];
        for (; Z < D; ) {
          let ye = $[V], he = N + ee * te << 3;
          for (; ye < _; ) {
            var B;
            if (S == 1 && (B = (B = E[he >> 3]) >> 7 - (7 & he) & 1, T[Z * O + (ye >> 3)] |= B << 7 - ((7 & ye) << 0)), S == 2 && (B = (B = E[he >> 3]) >> 6 - (7 & he) & 3, T[Z * O + (ye >> 2)] |= B << 6 - ((3 & ye) << 1)), S == 4 && (B = (B = E[he >> 3]) >> 4 - (7 & he) & 15, T[Z * O + (ye >> 1)] |= B << 4 - ((1 & ye) << 2)), S >= 8) {
              const Ee = Z * O + ye * M;
              for (let be = 0; be < M; be++) T[Ee + be] = E[(he >> 3) + be];
            }
            he += S, ye += K;
          }
          ee++, Z += R;
        }
        Q * P != 0 && (N += P * (1 + te)), V += 1;
      }
      return T;
    }(l, d)), l;
  }
  function r(d, l) {
    return i(new Uint8Array(d.buffer, 2, d.length - 6), l);
  }
  var i = function() {
    const d = { H: {} };
    return d.H.N = function(l, f) {
      const p = Uint8Array;
      let m, g, y = 0, b = 0, E = 0, v = 0, _ = 0, D = 0, S = 0, M = 0, O = 0;
      if (l[0] == 3 && l[1] == 0) return f || new p(0);
      const T = d.H, N = T.b, H = T.e, $ = T.R, j = T.n, U = T.A, V = T.Z, B = T.m, R = f == null;
      for (R && (f = new p(l.length >>> 2 << 5)); y == 0; ) if (y = N(l, O, 1), b = N(l, O + 1, 2), O += 3, b != 0) {
        if (R && (f = d.H.W(f, M + (1 << 17))), b == 1 && (m = B.J, g = B.h, D = 511, S = 31), b == 2) {
          E = H(l, O, 5) + 257, v = H(l, O + 5, 5) + 1, _ = H(l, O + 10, 4) + 4, O += 14;
          let Q = 1;
          for (var K = 0; K < 38; K += 2) B.Q[K] = 0, B.Q[K + 1] = 0;
          for (K = 0; K < _; K++) {
            const G = H(l, O + 3 * K, 3);
            B.Q[1 + (B.X[K] << 1)] = G, G > Q && (Q = G);
          }
          O += 3 * _, j(B.Q, Q), U(B.Q, Q, B.u), m = B.w, g = B.d, O = $(B.u, (1 << Q) - 1, E + v, l, O, B.v);
          const P = T.V(B.v, 0, E, B.C);
          D = (1 << P) - 1;
          const I = T.V(B.v, E, v, B.D);
          S = (1 << I) - 1, j(B.C, P), U(B.C, P, m), j(B.D, I), U(B.D, I, g);
        }
        for (; ; ) {
          const Q = m[V(l, O) & D];
          O += 15 & Q;
          const P = Q >>> 4;
          if (!(P >>> 8)) f[M++] = P;
          else {
            if (P == 256) break;
            {
              let I = M + P - 254;
              if (P > 264) {
                const ye = B.q[P - 257];
                I = M + (ye >>> 3) + H(l, O, 7 & ye), O += 7 & ye;
              }
              const G = g[V(l, O) & S];
              O += 15 & G;
              const te = G >>> 4, ee = B.c[te], Z = (ee >>> 4) + N(l, O, 15 & ee);
              for (O += 15 & ee; M < I; ) f[M] = f[M++ - Z], f[M] = f[M++ - Z], f[M] = f[M++ - Z], f[M] = f[M++ - Z];
              M = I;
            }
          }
        }
      } else {
        (7 & O) != 0 && (O += 8 - (7 & O));
        const Q = 4 + (O >>> 3), P = l[Q - 4] | l[Q - 3] << 8;
        R && (f = d.H.W(f, M + P)), f.set(new p(l.buffer, l.byteOffset + Q, P), M), O = Q + P << 3, M += P;
      }
      return f.length == M ? f : f.slice(0, M);
    }, d.H.W = function(l, f) {
      const p = l.length;
      if (f <= p) return l;
      const m = new Uint8Array(p << 1);
      return m.set(l, 0), m;
    }, d.H.R = function(l, f, p, m, g, y) {
      const b = d.H.e, E = d.H.Z;
      let v = 0;
      for (; v < p; ) {
        const _ = l[E(m, g) & f];
        g += 15 & _;
        const D = _ >>> 4;
        if (D <= 15) y[v] = D, v++;
        else {
          let S = 0, M = 0;
          D == 16 ? (M = 3 + b(m, g, 2), g += 2, S = y[v - 1]) : D == 17 ? (M = 3 + b(m, g, 3), g += 3) : D == 18 && (M = 11 + b(m, g, 7), g += 7);
          const O = v + M;
          for (; v < O; ) y[v] = S, v++;
        }
      }
      return g;
    }, d.H.V = function(l, f, p, m) {
      let g = 0, y = 0;
      const b = m.length >>> 1;
      for (; y < p; ) {
        const E = l[y + f];
        m[y << 1] = 0, m[1 + (y << 1)] = E, E > g && (g = E), y++;
      }
      for (; y < b; ) m[y << 1] = 0, m[1 + (y << 1)] = 0, y++;
      return g;
    }, d.H.n = function(l, f) {
      const p = d.H.m, m = l.length;
      let g, y, b, E;
      const v = p.j;
      for (var _ = 0; _ <= f; _++) v[_] = 0;
      for (_ = 1; _ < m; _ += 2) v[l[_]]++;
      const D = p.K;
      for (g = 0, v[0] = 0, y = 1; y <= f; y++) g = g + v[y - 1] << 1, D[y] = g;
      for (b = 0; b < m; b += 2) E = l[b + 1], E != 0 && (l[b] = D[E], D[E]++);
    }, d.H.A = function(l, f, p) {
      const m = l.length, g = d.H.m.r;
      for (let y = 0; y < m; y += 2) if (l[y + 1] != 0) {
        const b = y >> 1, E = l[y + 1], v = b << 4 | E, _ = f - E;
        let D = l[y] << _;
        const S = D + (1 << _);
        for (; D != S; )
          p[g[D] >>> 15 - f] = v, D++;
      }
    }, d.H.l = function(l, f) {
      const p = d.H.m.r, m = 15 - f;
      for (let g = 0; g < l.length; g += 2) {
        const y = l[g] << f - l[g + 1];
        l[g] = p[y] >>> m;
      }
    }, d.H.M = function(l, f, p) {
      p <<= 7 & f;
      const m = f >>> 3;
      l[m] |= p, l[m + 1] |= p >>> 8;
    }, d.H.I = function(l, f, p) {
      p <<= 7 & f;
      const m = f >>> 3;
      l[m] |= p, l[m + 1] |= p >>> 8, l[m + 2] |= p >>> 16;
    }, d.H.e = function(l, f, p) {
      return (l[f >>> 3] | l[1 + (f >>> 3)] << 8) >>> (7 & f) & (1 << p) - 1;
    }, d.H.b = function(l, f, p) {
      return (l[f >>> 3] | l[1 + (f >>> 3)] << 8 | l[2 + (f >>> 3)] << 16) >>> (7 & f) & (1 << p) - 1;
    }, d.H.Z = function(l, f) {
      return (l[f >>> 3] | l[1 + (f >>> 3)] << 8 | l[2 + (f >>> 3)] << 16) >>> (7 & f);
    }, d.H.i = function(l, f) {
      return (l[f >>> 3] | l[1 + (f >>> 3)] << 8 | l[2 + (f >>> 3)] << 16 | l[3 + (f >>> 3)] << 24) >>> (7 & f);
    }, d.H.m = function() {
      const l = Uint16Array, f = Uint32Array;
      return { K: new l(16), j: new l(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new l(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new f(32), J: new l(512), _: [], h: new l(32), $: [], w: new l(32768), C: [], v: [], d: new l(32768), D: [], u: new l(512), Q: [], r: new l(32768), s: new f(286), Y: new f(30), a: new f(19), t: new f(15e3), k: new l(65536), g: new l(32768) };
    }(), function() {
      const l = d.H.m;
      for (var f = 0; f < 32768; f++) {
        let m = f;
        m = (2863311530 & m) >>> 1 | (1431655765 & m) << 1, m = (3435973836 & m) >>> 2 | (858993459 & m) << 2, m = (4042322160 & m) >>> 4 | (252645135 & m) << 4, m = (4278255360 & m) >>> 8 | (16711935 & m) << 8, l.r[f] = (m >>> 16 | m << 16) >>> 17;
      }
      function p(m, g, y) {
        for (; g-- != 0; ) m.push(0, y);
      }
      for (f = 0; f < 32; f++) l.q[f] = l.S[f] << 3 | l.T[f], l.c[f] = l.p[f] << 4 | l.z[f];
      p(l._, 144, 8), p(l._, 112, 9), p(l._, 24, 7), p(l._, 8, 8), d.H.n(l._, 9), d.H.A(l._, 9, l.J), d.H.l(l._, 9), p(l.$, 32, 5), d.H.n(l.$, 5), d.H.A(l.$, 5, l.h), d.H.l(l.$, 5), p(l.Q, 19, 0), p(l.C, 286, 0), p(l.D, 30, 0), p(l.v, 320, 0);
    }(), d.H.N;
  }();
  function s(d) {
    return [1, null, 3, 1, 2, null, 4][d.ctype] * d.depth;
  }
  function a(d, l, f, p, m) {
    let g = s(l);
    const y = Math.ceil(p * g / 8);
    let b, E;
    g = Math.ceil(g / 8);
    let v = d[f], _ = 0;
    if (v > 1 && (d[f] = [0, 0, 1][v - 2]), v == 3) for (_ = g; _ < y; _++) d[_ + 1] = d[_ + 1] + (d[_ + 1 - g] >>> 1) & 255;
    for (let D = 0; D < m; D++) if (b = f + D * y, E = b + D + 1, v = d[E - 1], _ = 0, v == 0) for (; _ < y; _++) d[b + _] = d[E + _];
    else if (v == 1) {
      for (; _ < g; _++) d[b + _] = d[E + _];
      for (; _ < y; _++) d[b + _] = d[E + _] + d[b + _ - g];
    } else if (v == 2) for (; _ < y; _++) d[b + _] = d[E + _] + d[b + _ - y];
    else if (v == 3) {
      for (; _ < g; _++) d[b + _] = d[E + _] + (d[b + _ - y] >>> 1);
      for (; _ < y; _++) d[b + _] = d[E + _] + (d[b + _ - y] + d[b + _ - g] >>> 1);
    } else {
      for (; _ < g; _++) d[b + _] = d[E + _] + o(0, d[b + _ - y], 0);
      for (; _ < y; _++) d[b + _] = d[E + _] + o(d[b + _ - g], d[b + _ - y], d[b + _ - g - y]);
    }
    return d;
  }
  function o(d, l, f) {
    const p = d + l - f, m = p - d, g = p - l, y = p - f;
    return m * m <= g * g && m * m <= y * y ? d : g * g <= y * y ? l : f;
  }
  function u(d, l, f) {
    f.width = t.readUint(d, l), l += 4, f.height = t.readUint(d, l), l += 4, f.depth = d[l], l++, f.ctype = d[l], l++, f.compress = d[l], l++, f.filter = d[l], l++, f.interlace = d[l], l++;
  }
  function c(d, l, f, p, m, g, y, b, E) {
    const v = Math.min(l, m), _ = Math.min(f, g);
    let D = 0, S = 0;
    for (let V = 0; V < _; V++) for (let B = 0; B < v; B++) if (y >= 0 && b >= 0 ? (D = V * l + B << 2, S = (b + V) * m + y + B << 2) : (D = (-b + V) * l - y + B << 2, S = V * m + B << 2), E == 0) p[S] = d[D], p[S + 1] = d[D + 1], p[S + 2] = d[D + 2], p[S + 3] = d[D + 3];
    else if (E == 1) {
      var M = d[D + 3] * 0.00392156862745098, O = d[D] * M, T = d[D + 1] * M, N = d[D + 2] * M, H = p[S + 3] * (1 / 255), $ = p[S] * H, j = p[S + 1] * H, U = p[S + 2] * H;
      const R = 1 - M, K = M + H * R, Q = K == 0 ? 0 : 1 / K;
      p[S + 3] = 255 * K, p[S + 0] = (O + $ * R) * Q, p[S + 1] = (T + j * R) * Q, p[S + 2] = (N + U * R) * Q;
    } else if (E == 2)
      M = d[D + 3], O = d[D], T = d[D + 1], N = d[D + 2], H = p[S + 3], $ = p[S], j = p[S + 1], U = p[S + 2], M == H && O == $ && T == j && N == U ? (p[S] = 0, p[S + 1] = 0, p[S + 2] = 0, p[S + 3] = 0) : (p[S] = O, p[S + 1] = T, p[S + 2] = N, p[S + 3] = M);
    else if (E == 3) {
      if (M = d[D + 3], O = d[D], T = d[D + 1], N = d[D + 2], H = p[S + 3], $ = p[S], j = p[S + 1], U = p[S + 2], M == H && O == $ && T == j && N == U) continue;
      if (M < 220 && H > 20) return !1;
    }
    return !0;
  }
  return { decode: function(l) {
    const f = new Uint8Array(l);
    let p = 8;
    const m = t, g = m.readUshort, y = m.readUint, b = { tabs: {}, frames: [] }, E = new Uint8Array(f.length);
    let v, _ = 0, D = 0;
    const S = [137, 80, 78, 71, 13, 10, 26, 10];
    for (var M = 0; M < 8; M++) if (f[M] != S[M]) throw "The input is not a PNG file!";
    for (; p < f.length; ) {
      const V = m.readUint(f, p);
      p += 4;
      const B = m.readASCII(f, p, 4);
      if (p += 4, B == "IHDR") u(f, p, b);
      else if (B == "iCCP") {
        for (var O = p; f[O] != 0; ) O++;
        m.readASCII(f, p, O - p), f[O + 1];
        const R = f.slice(O + 2, p + V);
        let K = null;
        try {
          K = r(R);
        } catch {
          K = i(R);
        }
        b.tabs[B] = K;
      } else if (B == "CgBI") b.tabs[B] = f.slice(p, p + 4);
      else if (B == "IDAT") {
        for (M = 0; M < V; M++) E[_ + M] = f[p + M];
        _ += V;
      } else if (B == "acTL") b.tabs[B] = { num_frames: y(f, p), num_plays: y(f, p + 4) }, v = new Uint8Array(f.length);
      else if (B == "fcTL") {
        D != 0 && ((U = b.frames[b.frames.length - 1]).data = n(b, v.slice(0, D), U.rect.width, U.rect.height), D = 0);
        const R = { x: y(f, p + 12), y: y(f, p + 16), width: y(f, p + 4), height: y(f, p + 8) };
        let K = g(f, p + 22);
        K = g(f, p + 20) / (K == 0 ? 100 : K);
        const Q = { rect: R, delay: Math.round(1e3 * K), dispose: f[p + 24], blend: f[p + 25] };
        b.frames.push(Q);
      } else if (B == "fdAT") {
        for (M = 0; M < V - 4; M++) v[D + M] = f[p + M + 4];
        D += V - 4;
      } else if (B == "pHYs") b.tabs[B] = [m.readUint(f, p), m.readUint(f, p + 4), f[p + 8]];
      else if (B == "cHRM")
        for (b.tabs[B] = [], M = 0; M < 8; M++) b.tabs[B].push(m.readUint(f, p + 4 * M));
      else if (B == "tEXt" || B == "zTXt") {
        b.tabs[B] == null && (b.tabs[B] = {});
        var T = m.nextZero(f, p), N = m.readASCII(f, p, T - p), H = p + V - T - 1;
        if (B == "tEXt") j = m.readASCII(f, T + 1, H);
        else {
          var $ = r(f.slice(T + 2, T + 2 + H));
          j = m.readUTF8($, 0, $.length);
        }
        b.tabs[B][N] = j;
      } else if (B == "iTXt") {
        b.tabs[B] == null && (b.tabs[B] = {}), T = 0, O = p, T = m.nextZero(f, O), N = m.readASCII(f, O, T - O);
        const R = f[O = T + 1];
        var j;
        f[O + 1], O += 2, T = m.nextZero(f, O), m.readASCII(f, O, T - O), O = T + 1, T = m.nextZero(f, O), m.readUTF8(f, O, T - O), H = V - ((O = T + 1) - p), R == 0 ? j = m.readUTF8(f, O, H) : ($ = r(f.slice(O, O + H)), j = m.readUTF8($, 0, $.length)), b.tabs[B][N] = j;
      } else if (B == "PLTE") b.tabs[B] = m.readBytes(f, p, V);
      else if (B == "hIST") {
        const R = b.tabs.PLTE.length / 3;
        for (b.tabs[B] = [], M = 0; M < R; M++) b.tabs[B].push(g(f, p + 2 * M));
      } else if (B == "tRNS") b.ctype == 3 ? b.tabs[B] = m.readBytes(f, p, V) : b.ctype == 0 ? b.tabs[B] = g(f, p) : b.ctype == 2 && (b.tabs[B] = [g(f, p), g(f, p + 2), g(f, p + 4)]);
      else if (B == "gAMA") b.tabs[B] = m.readUint(f, p) / 1e5;
      else if (B == "sRGB") b.tabs[B] = f[p];
      else if (B == "bKGD") b.ctype == 0 || b.ctype == 4 ? b.tabs[B] = [g(f, p)] : b.ctype == 2 || b.ctype == 6 ? b.tabs[B] = [g(f, p), g(f, p + 2), g(f, p + 4)] : b.ctype == 3 && (b.tabs[B] = f[p]);
      else if (B == "IEND") break;
      p += V, m.readUint(f, p), p += 4;
    }
    var U;
    return D != 0 && ((U = b.frames[b.frames.length - 1]).data = n(b, v.slice(0, D), U.rect.width, U.rect.height)), b.data = n(b, E, b.width, b.height), delete b.compress, delete b.interlace, delete b.filter, b;
  }, toRGBA8: function(l) {
    const f = l.width, p = l.height;
    if (l.tabs.acTL == null) return [e(l.data, f, p, l).buffer];
    const m = [];
    l.frames[0].data == null && (l.frames[0].data = l.data);
    const g = f * p * 4, y = new Uint8Array(g), b = new Uint8Array(g), E = new Uint8Array(g);
    for (let _ = 0; _ < l.frames.length; _++) {
      const D = l.frames[_], S = D.rect.x, M = D.rect.y, O = D.rect.width, T = D.rect.height, N = e(D.data, O, T, l);
      if (_ != 0) for (var v = 0; v < g; v++) E[v] = y[v];
      if (D.blend == 0 ? c(N, O, T, y, f, p, S, M, 0) : D.blend == 1 && c(N, O, T, y, f, p, S, M, 1), m.push(y.buffer.slice(0)), D.dispose != 0) {
        if (D.dispose == 1) c(b, O, T, y, f, p, S, M, 0);
        else if (D.dispose == 2) for (v = 0; v < g; v++) y[v] = E[v];
      }
    }
    return m;
  }, _paeth: o, _copyTile: c, _bin: t };
}();
(function() {
  const { _copyTile: t } = Es, { _bin: e } = Es, n = Es._paeth;
  var r = { table: function() {
    const O = new Uint32Array(256);
    for (let T = 0; T < 256; T++) {
      let N = T;
      for (let H = 0; H < 8; H++) 1 & N ? N = 3988292384 ^ N >>> 1 : N >>>= 1;
      O[T] = N;
    }
    return O;
  }(), update(O, T, N, H) {
    for (let $ = 0; $ < H; $++) O = r.table[255 & (O ^ T[N + $])] ^ O >>> 8;
    return O;
  }, crc: (O, T, N) => 4294967295 ^ r.update(4294967295, O, T, N) };
  function i(O, T, N, H) {
    T[N] += O[0] * H >> 4, T[N + 1] += O[1] * H >> 4, T[N + 2] += O[2] * H >> 4, T[N + 3] += O[3] * H >> 4;
  }
  function s(O) {
    return Math.max(0, Math.min(255, O));
  }
  function a(O, T) {
    const N = O[0] - T[0], H = O[1] - T[1], $ = O[2] - T[2], j = O[3] - T[3];
    return N * N + H * H + $ * $ + j * j;
  }
  function o(O, T, N, H, $, j, U) {
    U == null && (U = 1);
    const V = H.length, B = [];
    for (var R = 0; R < V; R++) {
      const Z = H[R];
      B.push([Z >>> 0 & 255, Z >>> 8 & 255, Z >>> 16 & 255, Z >>> 24 & 255]);
    }
    for (R = 0; R < V; R++) {
      let Z = 4294967295;
      for (var K = 0, Q = 0; Q < V; Q++) {
        var P = a(B[R], B[Q]);
        Q != R && P < Z && (Z = P, K = Q);
      }
    }
    const I = new Uint32Array($.buffer), G = new Int16Array(T * N * 4), te = [0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5];
    for (R = 0; R < te.length; R++) te[R] = 255 * ((te[R] + 0.5) / 16 - 0.5);
    for (let Z = 0; Z < N; Z++) for (let ye = 0; ye < T; ye++) {
      var ee;
      R = 4 * (Z * T + ye), U != 2 ? ee = [s(O[R] + G[R]), s(O[R + 1] + G[R + 1]), s(O[R + 2] + G[R + 2]), s(O[R + 3] + G[R + 3])] : (P = te[4 * (3 & Z) + (3 & ye)], ee = [s(O[R] + P), s(O[R + 1] + P), s(O[R + 2] + P), s(O[R + 3] + P)]), K = 0;
      let he = 16777215;
      for (Q = 0; Q < V; Q++) {
        const ve = a(ee, B[Q]);
        ve < he && (he = ve, K = Q);
      }
      const Ee = B[K], be = [ee[0] - Ee[0], ee[1] - Ee[1], ee[2] - Ee[2], ee[3] - Ee[3]];
      U == 1 && (ye != T - 1 && i(be, G, R + 4, 7), Z != N - 1 && (ye != 0 && i(be, G, R + 4 * T - 4, 3), i(be, G, R + 4 * T, 5), ye != T - 1 && i(be, G, R + 4 * T + 4, 1))), j[R >> 2] = K, I[R >> 2] = H[K];
    }
  }
  function u(O, T, N, H, $) {
    $ == null && ($ = {});
    const { crc: j } = r, U = e.writeUint, V = e.writeUshort, B = e.writeASCII;
    let R = 8;
    const K = O.frames.length > 1;
    let Q, P = !1, I = 33 + (K ? 20 : 0);
    if ($.sRGB != null && (I += 13), $.pHYs != null && (I += 21), $.iCCP != null && (Q = pako.deflate($.iCCP), I += 21 + Q.length + 4), O.ctype == 3) {
      for (var G = O.plte.length, te = 0; te < G; te++) O.plte[te] >>> 24 != 255 && (P = !0);
      I += 8 + 3 * G + 4 + (P ? 8 + 1 * G + 4 : 0);
    }
    for (var ee = 0; ee < O.frames.length; ee++)
      K && (I += 38), I += (Ee = O.frames[ee]).cimg.length + 12, ee != 0 && (I += 4);
    I += 12;
    const Z = new Uint8Array(I), ye = [137, 80, 78, 71, 13, 10, 26, 10];
    for (te = 0; te < 8; te++) Z[te] = ye[te];
    if (U(Z, R, 13), R += 4, B(Z, R, "IHDR"), R += 4, U(Z, R, T), R += 4, U(Z, R, N), R += 4, Z[R] = O.depth, R++, Z[R] = O.ctype, R++, Z[R] = 0, R++, Z[R] = 0, R++, Z[R] = 0, R++, U(Z, R, j(Z, R - 17, 17)), R += 4, $.sRGB != null && (U(Z, R, 1), R += 4, B(Z, R, "sRGB"), R += 4, Z[R] = $.sRGB, R++, U(Z, R, j(Z, R - 5, 5)), R += 4), $.iCCP != null) {
      const be = 13 + Q.length;
      U(Z, R, be), R += 4, B(Z, R, "iCCP"), R += 4, B(Z, R, "ICC profile"), R += 11, R += 2, Z.set(Q, R), R += Q.length, U(Z, R, j(Z, R - (be + 4), be + 4)), R += 4;
    }
    if ($.pHYs != null && (U(Z, R, 9), R += 4, B(Z, R, "pHYs"), R += 4, U(Z, R, $.pHYs[0]), R += 4, U(Z, R, $.pHYs[1]), R += 4, Z[R] = $.pHYs[2], R++, U(Z, R, j(Z, R - 13, 13)), R += 4), K && (U(Z, R, 8), R += 4, B(Z, R, "acTL"), R += 4, U(Z, R, O.frames.length), R += 4, U(Z, R, $.loop != null ? $.loop : 0), R += 4, U(Z, R, j(Z, R - 12, 12)), R += 4), O.ctype == 3) {
      for (U(Z, R, 3 * (G = O.plte.length)), R += 4, B(Z, R, "PLTE"), R += 4, te = 0; te < G; te++) {
        const be = 3 * te, ve = O.plte[te], Ce = 255 & ve, Ne = ve >>> 8 & 255, qe = ve >>> 16 & 255;
        Z[R + be + 0] = Ce, Z[R + be + 1] = Ne, Z[R + be + 2] = qe;
      }
      if (R += 3 * G, U(Z, R, j(Z, R - 3 * G - 4, 3 * G + 4)), R += 4, P) {
        for (U(Z, R, G), R += 4, B(Z, R, "tRNS"), R += 4, te = 0; te < G; te++) Z[R + te] = O.plte[te] >>> 24 & 255;
        R += G, U(Z, R, j(Z, R - G - 4, G + 4)), R += 4;
      }
    }
    let he = 0;
    for (ee = 0; ee < O.frames.length; ee++) {
      var Ee = O.frames[ee];
      K && (U(Z, R, 26), R += 4, B(Z, R, "fcTL"), R += 4, U(Z, R, he++), R += 4, U(Z, R, Ee.rect.width), R += 4, U(Z, R, Ee.rect.height), R += 4, U(Z, R, Ee.rect.x), R += 4, U(Z, R, Ee.rect.y), R += 4, V(Z, R, H[ee]), R += 2, V(Z, R, 1e3), R += 2, Z[R] = Ee.dispose, R++, Z[R] = Ee.blend, R++, U(Z, R, j(Z, R - 30, 30)), R += 4);
      const be = Ee.cimg;
      U(Z, R, (G = be.length) + (ee == 0 ? 0 : 4)), R += 4;
      const ve = R;
      B(Z, R, ee == 0 ? "IDAT" : "fdAT"), R += 4, ee != 0 && (U(Z, R, he++), R += 4), Z.set(be, R), R += G, U(Z, R, j(Z, ve, R - ve)), R += 4;
    }
    return U(Z, R, 0), R += 4, B(Z, R, "IEND"), R += 4, U(Z, R, j(Z, R - 4, 4)), R += 4, Z.buffer;
  }
  function c(O, T, N) {
    for (let H = 0; H < O.frames.length; H++) {
      const $ = O.frames[H];
      $.rect.width;
      const j = $.rect.height, U = new Uint8Array(j * $.bpl + j);
      $.cimg = p($.img, j, $.bpp, $.bpl, U, T, N);
    }
  }
  function d(O, T, N, H, $) {
    const j = $[0], U = $[1], V = $[2], B = $[3], R = $[4], K = $[5];
    let Q = 6, P = 8, I = 255;
    for (var G = 0; G < O.length; G++) {
      const at = new Uint8Array(O[G]);
      for (var te = at.length, ee = 0; ee < te; ee += 4) I &= at[ee + 3];
    }
    const Z = I != 255, ye = function(Ie, ne, ue, ie, Te, je) {
      const We = [];
      for (var Qe = 0; Qe < Ie.length; Qe++) {
        const Xt = new Uint8Array(Ie[Qe]), jt = new Uint32Array(Xt.buffer);
        var xe;
        let Tt = 0, bn = 0, Ve = ne, ut = ue, _t = ie ? 1 : 0;
        if (Qe != 0) {
          const zt = je || ie || Qe == 1 || We[Qe - 2].dispose != 0 ? 1 : 2;
          let wn = 0, Hn = 1e9;
          for (let jn = 0; jn < zt; jn++) {
            var Be = new Uint8Array(Ie[Qe - 1 - jn]);
            const Y = new Uint32Array(Ie[Qe - 1 - jn]);
            let J = ne, me = ue, Oe = -1, rt = -1;
            for (let qt = 0; qt < ue; qt++) for (let Bt = 0; Bt < ne; Bt++)
              jt[xt = qt * ne + Bt] != Y[xt] && (Bt < J && (J = Bt), Bt > Oe && (Oe = Bt), qt < me && (me = qt), qt > rt && (rt = qt));
            Oe == -1 && (J = me = Oe = rt = 0), Te && ((1 & J) == 1 && J--, (1 & me) == 1 && me--);
            const ht = (Oe - J + 1) * (rt - me + 1);
            ht < Hn && (Hn = ht, wn = jn, Tt = J, bn = me, Ve = Oe - J + 1, ut = rt - me + 1);
          }
          Be = new Uint8Array(Ie[Qe - 1 - wn]), wn == 1 && (We[Qe - 1].dispose = 2), xe = new Uint8Array(Ve * ut * 4), t(Be, ne, ue, xe, Ve, ut, -Tt, -bn, 0), _t = t(Xt, ne, ue, xe, Ve, ut, -Tt, -bn, 3) ? 1 : 0, _t == 1 ? f(Xt, ne, ue, xe, { x: Tt, y: bn, width: Ve, height: ut }) : t(Xt, ne, ue, xe, Ve, ut, -Tt, -bn, 0);
        } else xe = Xt.slice(0);
        We.push({ rect: { x: Tt, y: bn, width: Ve, height: ut }, img: xe, blend: _t, dispose: 0 });
      }
      if (ie) for (Qe = 0; Qe < We.length; Qe++) {
        if ((Rt = We[Qe]).blend == 1) continue;
        const Xt = Rt.rect, jt = We[Qe - 1].rect, Tt = Math.min(Xt.x, jt.x), bn = Math.min(Xt.y, jt.y), Ve = { x: Tt, y: bn, width: Math.max(Xt.x + Xt.width, jt.x + jt.width) - Tt, height: Math.max(Xt.y + Xt.height, jt.y + jt.height) - bn };
        We[Qe - 1].dispose = 1, Qe - 1 != 0 && l(Ie, ne, ue, We, Qe - 1, Ve, Te), l(Ie, ne, ue, We, Qe, Ve, Te);
      }
      let At = 0;
      if (Ie.length != 1) for (var xt = 0; xt < We.length; xt++) {
        var Rt;
        At += (Rt = We[xt]).rect.width * Rt.rect.height;
      }
      return We;
    }(O, T, N, j, U, V), he = {}, Ee = [], be = [];
    if (H != 0) {
      const at = [];
      for (ee = 0; ee < ye.length; ee++) at.push(ye[ee].img.buffer);
      const Ie = function(Te) {
        let je = 0;
        for (var We = 0; We < Te.length; We++) je += Te[We].byteLength;
        const Qe = new Uint8Array(je);
        let xe = 0;
        for (We = 0; We < Te.length; We++) {
          const Be = new Uint8Array(Te[We]), At = Be.length;
          for (let xt = 0; xt < At; xt += 4) {
            let Rt = Be[xt], Xt = Be[xt + 1], jt = Be[xt + 2];
            const Tt = Be[xt + 3];
            Tt == 0 && (Rt = Xt = jt = 0), Qe[xe + xt] = Rt, Qe[xe + xt + 1] = Xt, Qe[xe + xt + 2] = jt, Qe[xe + xt + 3] = Tt;
          }
          xe += At;
        }
        return Qe.buffer;
      }(at), ne = g(Ie, H);
      for (ee = 0; ee < ne.plte.length; ee++) Ee.push(ne.plte[ee].est.rgba);
      let ue = 0;
      for (ee = 0; ee < ye.length; ee++) {
        const ie = (Ce = ye[ee]).img.length;
        var ve = new Uint8Array(ne.inds.buffer, ue >> 2, ie >> 2);
        be.push(ve);
        const Te = new Uint8Array(ne.abuf, ue, ie);
        K && o(Ce.img, Ce.rect.width, Ce.rect.height, Ee, Te, ve), Ce.img.set(Te), ue += ie;
      }
    } else for (G = 0; G < ye.length; G++) {
      var Ce = ye[G];
      const at = new Uint32Array(Ce.img.buffer);
      var Ne = Ce.rect.width;
      for (te = at.length, ve = new Uint8Array(te), be.push(ve), ee = 0; ee < te; ee++) {
        const Ie = at[ee];
        if (ee != 0 && Ie == at[ee - 1]) ve[ee] = ve[ee - 1];
        else if (ee > Ne && Ie == at[ee - Ne]) ve[ee] = ve[ee - Ne];
        else {
          let ne = he[Ie];
          if (ne == null && (he[Ie] = ne = Ee.length, Ee.push(Ie), Ee.length >= 300)) break;
          ve[ee] = ne;
        }
      }
    }
    const qe = Ee.length;
    for (qe <= 256 && R == 0 && (P = qe <= 2 ? 1 : qe <= 4 ? 2 : qe <= 16 ? 4 : 8, P = Math.max(P, B)), G = 0; G < ye.length; G++) {
      (Ce = ye[G]).rect.x, Ce.rect.y, Ne = Ce.rect.width;
      const at = Ce.rect.height;
      let Ie = Ce.img;
      new Uint32Array(Ie.buffer);
      let ne = 4 * Ne, ue = 4;
      if (qe <= 256 && R == 0) {
        ne = Math.ceil(P * Ne / 8);
        var $e = new Uint8Array(ne * at);
        const ie = be[G];
        for (let Te = 0; Te < at; Te++) {
          ee = Te * ne;
          const je = Te * Ne;
          if (P == 8) for (var Xe = 0; Xe < Ne; Xe++) $e[ee + Xe] = ie[je + Xe];
          else if (P == 4) for (Xe = 0; Xe < Ne; Xe++) $e[ee + (Xe >> 1)] |= ie[je + Xe] << 4 - 4 * (1 & Xe);
          else if (P == 2) for (Xe = 0; Xe < Ne; Xe++) $e[ee + (Xe >> 2)] |= ie[je + Xe] << 6 - 2 * (3 & Xe);
          else if (P == 1) for (Xe = 0; Xe < Ne; Xe++) $e[ee + (Xe >> 3)] |= ie[je + Xe] << 7 - 1 * (7 & Xe);
        }
        Ie = $e, Q = 3, ue = 1;
      } else if (Z == 0 && ye.length == 1) {
        $e = new Uint8Array(Ne * at * 3);
        const ie = Ne * at;
        for (ee = 0; ee < ie; ee++) {
          const Te = 3 * ee, je = 4 * ee;
          $e[Te] = Ie[je], $e[Te + 1] = Ie[je + 1], $e[Te + 2] = Ie[je + 2];
        }
        Ie = $e, Q = 2, ue = 3, ne = 3 * Ne;
      }
      Ce.img = Ie, Ce.bpl = ne, Ce.bpp = ue;
    }
    return { ctype: Q, depth: P, plte: Ee, frames: ye };
  }
  function l(O, T, N, H, $, j, U) {
    const V = Uint8Array, B = Uint32Array, R = new V(O[$ - 1]), K = new B(O[$ - 1]), Q = $ + 1 < O.length ? new V(O[$ + 1]) : null, P = new V(O[$]), I = new B(P.buffer);
    let G = T, te = N, ee = -1, Z = -1;
    for (let he = 0; he < j.height; he++) for (let Ee = 0; Ee < j.width; Ee++) {
      const be = j.x + Ee, ve = j.y + he, Ce = ve * T + be, Ne = I[Ce];
      Ne == 0 || H[$ - 1].dispose == 0 && K[Ce] == Ne && (Q == null || Q[4 * Ce + 3] != 0) || (be < G && (G = be), be > ee && (ee = be), ve < te && (te = ve), ve > Z && (Z = ve));
    }
    ee == -1 && (G = te = ee = Z = 0), U && ((1 & G) == 1 && G--, (1 & te) == 1 && te--), j = { x: G, y: te, width: ee - G + 1, height: Z - te + 1 };
    const ye = H[$];
    ye.rect = j, ye.blend = 1, ye.img = new Uint8Array(j.width * j.height * 4), H[$ - 1].dispose == 0 ? (t(R, T, N, ye.img, j.width, j.height, -j.x, -j.y, 0), f(P, T, N, ye.img, j)) : t(P, T, N, ye.img, j.width, j.height, -j.x, -j.y, 0);
  }
  function f(O, T, N, H, $) {
    t(O, T, N, H, $.width, $.height, -$.x, -$.y, 2);
  }
  function p(O, T, N, H, $, j, U) {
    const V = [];
    let B, R = [0, 1, 2, 3, 4];
    j != -1 ? R = [j] : (T * H > 5e5 || N == 1) && (R = [0]), U && (B = { level: 0 });
    const K = G3e;
    for (var Q = 0; Q < R.length; Q++) {
      for (let G = 0; G < T; G++) m($, O, G, H, N, R[Q]);
      V.push(K.deflate($, B));
    }
    let P, I = 1e9;
    for (Q = 0; Q < V.length; Q++) V[Q].length < I && (P = Q, I = V[Q].length);
    return V[P];
  }
  function m(O, T, N, H, $, j) {
    const U = N * H;
    let V = U + N;
    if (O[V] = j, V++, j == 0) if (H < 500) for (var B = 0; B < H; B++) O[V + B] = T[U + B];
    else O.set(new Uint8Array(T.buffer, U, H), V);
    else if (j == 1) {
      for (B = 0; B < $; B++) O[V + B] = T[U + B];
      for (B = $; B < H; B++) O[V + B] = T[U + B] - T[U + B - $] + 256 & 255;
    } else if (N == 0) {
      for (B = 0; B < $; B++) O[V + B] = T[U + B];
      if (j == 2) for (B = $; B < H; B++) O[V + B] = T[U + B];
      if (j == 3) for (B = $; B < H; B++) O[V + B] = T[U + B] - (T[U + B - $] >> 1) + 256 & 255;
      if (j == 4) for (B = $; B < H; B++) O[V + B] = T[U + B] - n(T[U + B - $], 0, 0) + 256 & 255;
    } else {
      if (j == 2) for (B = 0; B < H; B++) O[V + B] = T[U + B] + 256 - T[U + B - H] & 255;
      if (j == 3) {
        for (B = 0; B < $; B++) O[V + B] = T[U + B] + 256 - (T[U + B - H] >> 1) & 255;
        for (B = $; B < H; B++) O[V + B] = T[U + B] + 256 - (T[U + B - H] + T[U + B - $] >> 1) & 255;
      }
      if (j == 4) {
        for (B = 0; B < $; B++) O[V + B] = T[U + B] + 256 - n(0, T[U + B - H], 0) & 255;
        for (B = $; B < H; B++) O[V + B] = T[U + B] + 256 - n(T[U + B - $], T[U + B - H], T[U + B - $ - H]) & 255;
      }
    }
  }
  function g(O, T) {
    const N = new Uint8Array(O), H = N.slice(0), $ = new Uint32Array(H.buffer), j = y(H, T), U = j[0], V = j[1], B = N.length, R = new Uint8Array(B >> 2);
    let K;
    if (N.length < 2e7) for (var Q = 0; Q < B; Q += 4)
      K = b(U, P = N[Q] * (1 / 255), I = N[Q + 1] * (1 / 255), G = N[Q + 2] * (1 / 255), te = N[Q + 3] * (1 / 255)), R[Q >> 2] = K.ind, $[Q >> 2] = K.est.rgba;
    else for (Q = 0; Q < B; Q += 4) {
      var P = N[Q] * 0.00392156862745098, I = N[Q + 1] * (1 / 255), G = N[Q + 2] * (1 / 255), te = N[Q + 3] * (1 / 255);
      for (K = U; K.left; ) K = E(K.est, P, I, G, te) <= 0 ? K.left : K.right;
      R[Q >> 2] = K.ind, $[Q >> 2] = K.est.rgba;
    }
    return { abuf: H.buffer, inds: R, plte: V };
  }
  function y(O, T, N) {
    N == null && (N = 1e-4);
    const H = new Uint32Array(O.buffer), $ = { i0: 0, i1: O.length, bst: null, est: null, tdst: 0, left: null, right: null };
    $.bst = D(O, $.i0, $.i1), $.est = S($.bst);
    const j = [$];
    for (; j.length < T; ) {
      let V = 0, B = 0;
      for (var U = 0; U < j.length; U++) j[U].est.L > V && (V = j[U].est.L, B = U);
      if (V < N) break;
      const R = j[B], K = v(O, H, R.i0, R.i1, R.est.e, R.est.eMq255);
      if (R.i0 >= K || R.i1 <= K) {
        R.est.L = 0;
        continue;
      }
      const Q = { i0: R.i0, i1: K, bst: null, est: null, tdst: 0, left: null, right: null };
      Q.bst = D(O, Q.i0, Q.i1), Q.est = S(Q.bst);
      const P = { i0: K, i1: R.i1, bst: null, est: null, tdst: 0, left: null, right: null };
      for (P.bst = { R: [], m: [], N: R.bst.N - Q.bst.N }, U = 0; U < 16; U++) P.bst.R[U] = R.bst.R[U] - Q.bst.R[U];
      for (U = 0; U < 4; U++) P.bst.m[U] = R.bst.m[U] - Q.bst.m[U];
      P.est = S(P.bst), R.left = Q, R.right = P, j[B] = Q, j.push(P);
    }
    for (j.sort((V, B) => B.bst.N - V.bst.N), U = 0; U < j.length; U++) j[U].ind = U;
    return [$, j];
  }
  function b(O, T, N, H, $) {
    if (O.left == null) return O.tdst = function(Q, P, I, G, te) {
      const ee = P - Q[0], Z = I - Q[1], ye = G - Q[2], he = te - Q[3];
      return ee * ee + Z * Z + ye * ye + he * he;
    }(O.est.q, T, N, H, $), O;
    const j = E(O.est, T, N, H, $);
    let U = O.left, V = O.right;
    j > 0 && (U = O.right, V = O.left);
    const B = b(U, T, N, H, $);
    if (B.tdst <= j * j) return B;
    const R = b(V, T, N, H, $);
    return R.tdst < B.tdst ? R : B;
  }
  function E(O, T, N, H, $) {
    const { e: j } = O;
    return j[0] * T + j[1] * N + j[2] * H + j[3] * $ - O.eMq;
  }
  function v(O, T, N, H, $, j) {
    for (H -= 4; N < H; ) {
      for (; _(O, N, $) <= j; ) N += 4;
      for (; _(O, H, $) > j; ) H -= 4;
      if (N >= H) break;
      const U = T[N >> 2];
      T[N >> 2] = T[H >> 2], T[H >> 2] = U, N += 4, H -= 4;
    }
    for (; _(O, N, $) > j; ) N -= 4;
    return N + 4;
  }
  function _(O, T, N) {
    return O[T] * N[0] + O[T + 1] * N[1] + O[T + 2] * N[2] + O[T + 3] * N[3];
  }
  function D(O, T, N) {
    const H = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], $ = [0, 0, 0, 0], j = N - T >> 2;
    for (let U = T; U < N; U += 4) {
      const V = O[U] * 0.00392156862745098, B = O[U + 1] * (1 / 255), R = O[U + 2] * (1 / 255), K = O[U + 3] * (1 / 255);
      $[0] += V, $[1] += B, $[2] += R, $[3] += K, H[0] += V * V, H[1] += V * B, H[2] += V * R, H[3] += V * K, H[5] += B * B, H[6] += B * R, H[7] += B * K, H[10] += R * R, H[11] += R * K, H[15] += K * K;
    }
    return H[4] = H[1], H[8] = H[2], H[9] = H[6], H[12] = H[3], H[13] = H[7], H[14] = H[11], { R: H, m: $, N: j };
  }
  function S(O) {
    const { R: T } = O, { m: N } = O, { N: H } = O, $ = N[0], j = N[1], U = N[2], V = N[3], B = H == 0 ? 0 : 1 / H, R = [T[0] - $ * $ * B, T[1] - $ * j * B, T[2] - $ * U * B, T[3] - $ * V * B, T[4] - j * $ * B, T[5] - j * j * B, T[6] - j * U * B, T[7] - j * V * B, T[8] - U * $ * B, T[9] - U * j * B, T[10] - U * U * B, T[11] - U * V * B, T[12] - V * $ * B, T[13] - V * j * B, T[14] - V * U * B, T[15] - V * V * B], K = R, Q = M;
    let P = [Math.random(), Math.random(), Math.random(), Math.random()], I = 0, G = 0;
    if (H != 0) for (let ee = 0; ee < 16 && (P = Q.multVec(K, P), G = Math.sqrt(Q.dot(P, P)), P = Q.sml(1 / G, P), !(ee != 0 && Math.abs(G - I) < 1e-9)); ee++) I = G;
    const te = [$ * B, j * B, U * B, V * B];
    return { Cov: R, q: te, e: P, L: I, eMq255: Q.dot(Q.sml(255, te), P), eMq: Q.dot(P, te), rgba: (Math.round(255 * te[3]) << 24 | Math.round(255 * te[2]) << 16 | Math.round(255 * te[1]) << 8 | Math.round(255 * te[0]) << 0) >>> 0 };
  }
  var M = { multVec: (O, T) => [O[0] * T[0] + O[1] * T[1] + O[2] * T[2] + O[3] * T[3], O[4] * T[0] + O[5] * T[1] + O[6] * T[2] + O[7] * T[3], O[8] * T[0] + O[9] * T[1] + O[10] * T[2] + O[11] * T[3], O[12] * T[0] + O[13] * T[1] + O[14] * T[2] + O[15] * T[3]], dot: (O, T) => O[0] * T[0] + O[1] * T[1] + O[2] * T[2] + O[3] * T[3], sml: (O, T) => [O * T[0], O * T[1], O * T[2], O * T[3]] };
  Es.encode = function(T, N, H, $, j, U, V) {
    $ == null && ($ = 0), V == null && (V = !1);
    const B = d(T, N, H, $, [!1, !1, !1, 0, V, !1]);
    return c(B, -1), u(B, N, H, j, U);
  }, Es.encodeLL = function(T, N, H, $, j, U, V, B) {
    const R = { ctype: 0 + ($ == 1 ? 0 : 2) + (j == 0 ? 0 : 4), depth: U, frames: [] }, K = ($ + j) * U, Q = K * N;
    for (let P = 0; P < T.length; P++) R.frames.push({ rect: { x: 0, y: 0, width: N, height: H }, img: new Uint8Array(T[P]), blend: 0, dispose: 1, bpp: Math.ceil(K / 8), bpl: Math.ceil(Q / 8) });
    return c(R, 0, !0), u(R, N, H, V, B);
  }, Es.encode.compress = d, Es.encode.dither = o, Es.quantize = g, Es.quantize.getKDtree = y, Es.quantize.getNearest = b;
})();
const G5 = { toArrayBuffer(t, e) {
  const n = t.width, r = t.height, i = n << 2, s = t.getContext("2d").getImageData(0, 0, n, r), a = new Uint32Array(s.data.buffer), o = (32 * n + 31) / 32 << 2, u = o * r, c = 122 + u, d = new ArrayBuffer(c), l = new DataView(d), f = 1 << 20;
  let p, m, g, y, b = f, E = 0, v = 0, _ = 0;
  function D(O) {
    l.setUint16(v, O, !0), v += 2;
  }
  function S(O) {
    l.setUint32(v, O, !0), v += 4;
  }
  function M(O) {
    v += O;
  }
  D(19778), S(c), M(4), S(122), S(108), S(n), S(-r >>> 0), D(1), D(32), S(3), S(u), S(2835), S(2835), M(8), S(16711680), S(65280), S(255), S(4278190080), S(1466527264), function O() {
    for (; E < r && b > 0; ) {
      for (y = 122 + E * o, p = 0; p < i; ) b--, m = a[_++], g = m >>> 24, l.setUint32(y + p, m << 8 | g), p += 4;
      E++;
    }
    _ < a.length ? (b = f, setTimeout(O, G5._dly)) : e(d);
  }();
}, toBlob(t, e) {
  this.toArrayBuffer(t, (n) => {
    e(new Blob([n], { type: "image/bmp" }));
  });
}, _dly: 9 };
var xi = { CHROME: "CHROME", FIREFOX: "FIREFOX", DESKTOP_SAFARI: "DESKTOP_SAFARI", IE: "IE", IOS: "IOS", ETC: "ETC" }, Y3e = { [xi.CHROME]: 16384, [xi.FIREFOX]: 11180, [xi.DESKTOP_SAFARI]: 16384, [xi.IE]: 8192, [xi.IOS]: 4096, [xi.ETC]: 8192 };
const iT = typeof window < "u", Y5 = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, Jm = iT && window.cordova && window.cordova.require && window.cordova.require("cordova/modulemapper"), X3e = (iT || Y5) && (Jm && Jm.getOriginalSymbol(window, "File") || typeof File < "u" && File), X5 = (iT || Y5) && (Jm && Jm.getOriginalSymbol(window, "FileReader") || typeof FileReader < "u" && FileReader);
function sT(t, e, n = Date.now()) {
  return new Promise((r) => {
    const i = t.split(","), s = i[0].match(/:(.*?);/)[1], a = globalThis.atob(i[1]);
    let o = a.length;
    const u = new Uint8Array(o);
    for (; o--; ) u[o] = a.charCodeAt(o);
    const c = new Blob([u], { type: s });
    c.name = e, c.lastModified = n, r(c);
  });
}
function K5(t) {
  return new Promise((e, n) => {
    const r = new X5();
    r.onload = () => e(r.result), r.onerror = (i) => n(i), r.readAsDataURL(t);
  });
}
function Z5(t) {
  return new Promise((e, n) => {
    const r = new Image();
    r.onload = () => e(r), r.onerror = (i) => n(i), r.src = t;
  });
}
function mu() {
  if (mu.cachedResult !== void 0) return mu.cachedResult;
  let t = xi.ETC;
  const { userAgent: e } = navigator;
  return /Chrom(e|ium)/i.test(e) ? t = xi.CHROME : /iP(ad|od|hone)/i.test(e) && /WebKit/i.test(e) ? t = xi.IOS : /Safari/i.test(e) ? t = xi.DESKTOP_SAFARI : /Firefox/i.test(e) ? t = xi.FIREFOX : (/MSIE/i.test(e) || document.documentMode) && (t = xi.IE), mu.cachedResult = t, mu.cachedResult;
}
function J5(t, e) {
  const n = mu(), r = Y3e[n];
  let i = t, s = e, a = i * s;
  const o = i > s ? s / i : i / s;
  for (; a > r * r; ) {
    const u = (r + i) / 2, c = (r + s) / 2;
    u < c ? (s = c, i = c * o) : (s = u * o, i = u), a = i * s;
  }
  return { width: i, height: s };
}
function bg(t, e) {
  let n, r;
  try {
    if (n = new OffscreenCanvas(t, e), r = n.getContext("2d"), r === null) throw new Error("getContext of OffscreenCanvas returns null");
  } catch {
    n = document.createElement("canvas"), r = n.getContext("2d");
  }
  return n.width = t, n.height = e, [n, r];
}
function eD(t, e) {
  const { width: n, height: r } = J5(t.width, t.height), [i, s] = bg(n, r);
  return e && /jpe?g/.test(e) && (s.fillStyle = "white", s.fillRect(0, 0, i.width, i.height)), s.drawImage(t, 0, 0, i.width, i.height), i;
}
function pm() {
  return pm.cachedResult !== void 0 || (pm.cachedResult = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && typeof document < "u" && "ontouchend" in document), pm.cachedResult;
}
function e0(t, e = {}) {
  return new Promise(function(n, r) {
    let i, s;
    var a = function() {
      try {
        return s = eD(i, e.fileType || t.type), n([i, s]);
      } catch (u) {
        return r(u);
      }
    }, o = function(u) {
      try {
        var c = function(d) {
          try {
            throw d;
          } catch (l) {
            return r(l);
          }
        };
        try {
          let d;
          return K5(t).then(function(l) {
            try {
              return d = l, Z5(d).then(function(f) {
                try {
                  return i = f, function() {
                    try {
                      return a();
                    } catch (p) {
                      return r(p);
                    }
                  }();
                } catch (p) {
                  return c(p);
                }
              }, c);
            } catch (f) {
              return c(f);
            }
          }, c);
        } catch (d) {
          c(d);
        }
      } catch (d) {
        return r(d);
      }
    };
    try {
      if (pm() || [xi.DESKTOP_SAFARI, xi.MOBILE_SAFARI].includes(mu())) throw new Error("Skip createImageBitmap on IOS and Safari");
      return createImageBitmap(t).then(function(u) {
        try {
          return i = u, a();
        } catch {
          return o();
        }
      }, o);
    } catch {
      o();
    }
  });
}
function t0(t, e, n, r, i = 1) {
  return new Promise(function(s, a) {
    let o;
    if (e === "image/png") {
      let c, d, l;
      return c = t.getContext("2d"), { data: d } = c.getImageData(0, 0, t.width, t.height), l = Es.encode([d.buffer], t.width, t.height, 4096 * i), o = new Blob([l], { type: e }), o.name = n, o.lastModified = r, u.call(this);
    }
    {
      let c = function() {
        return u.call(this);
      };
      if (e === "image/bmp") return new Promise((d) => G5.toBlob(t, d)).then((function(d) {
        try {
          return o = d, o.name = n, o.lastModified = r, c.call(this);
        } catch (l) {
          return a(l);
        }
      }).bind(this), a);
      {
        let d = function() {
          return c.call(this);
        };
        if (typeof OffscreenCanvas == "function" && t instanceof OffscreenCanvas) return t.convertToBlob({ type: e, quality: i }).then((function(l) {
          try {
            return o = l, o.name = n, o.lastModified = r, d.call(this);
          } catch (f) {
            return a(f);
          }
        }).bind(this), a);
        {
          let l;
          return l = t.toDataURL(e, i), sT(l, n, r).then((function(f) {
            try {
              return o = f, d.call(this);
            } catch (p) {
              return a(p);
            }
          }).bind(this), a);
        }
      }
    }
    function u() {
      return s(o);
    }
  });
}
function Xs(t) {
  t.width = 0, t.height = 0;
}
function Pl() {
  return new Promise(function(t, e) {
    let n, r, i, s;
    return Pl.cachedResult !== void 0 ? t(Pl.cachedResult) : sT("data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==", "test.jpg", Date.now()).then(function(a) {
      try {
        return n = a, e0(n).then(function(o) {
          try {
            return r = o[1], t0(r, n.type, n.name, n.lastModified).then(function(u) {
              try {
                return i = u, Xs(r), e0(i).then(function(c) {
                  try {
                    return s = c[0], Pl.cachedResult = s.width === 1 && s.height === 2, t(Pl.cachedResult);
                  } catch (d) {
                    return e(d);
                  }
                }, e);
              } catch (c) {
                return e(c);
              }
            }, e);
          } catch (u) {
            return e(u);
          }
        }, e);
      } catch (o) {
        return e(o);
      }
    }, e);
  });
}
function tD(t) {
  return new Promise((e, n) => {
    const r = new X5();
    r.onload = (i) => {
      const s = new DataView(i.target.result);
      if (s.getUint16(0, !1) != 65496) return e(-2);
      const a = s.byteLength;
      let o = 2;
      for (; o < a; ) {
        if (s.getUint16(o + 2, !1) <= 8) return e(-1);
        const u = s.getUint16(o, !1);
        if (o += 2, u == 65505) {
          if (s.getUint32(o += 2, !1) != 1165519206) return e(-1);
          const c = s.getUint16(o += 6, !1) == 18761;
          o += s.getUint32(o + 4, c);
          const d = s.getUint16(o, c);
          o += 2;
          for (let l = 0; l < d; l++) if (s.getUint16(o + 12 * l, c) == 274) return e(s.getUint16(o + 12 * l + 8, c));
        } else {
          if ((65280 & u) != 65280) break;
          o += s.getUint16(o, !1);
        }
      }
      return e(-1);
    }, r.onerror = (i) => n(i), r.readAsArrayBuffer(t);
  });
}
function nD(t, e) {
  const { width: n } = t, { height: r } = t, { maxWidthOrHeight: i } = e;
  let s, a = t;
  return isFinite(i) && (n > i || r > i) && ([a, s] = bg(n, r), n > r ? (a.width = i, a.height = r / n * i) : (a.width = n / r * i, a.height = i), s.drawImage(t, 0, 0, a.width, a.height), Xs(t)), a;
}
function rD(t, e) {
  const { width: n } = t, { height: r } = t, [i, s] = bg(n, r);
  switch (e > 4 && e < 9 ? (i.width = r, i.height = n) : (i.width = n, i.height = r), e) {
    case 2:
      s.transform(-1, 0, 0, 1, n, 0);
      break;
    case 3:
      s.transform(-1, 0, 0, -1, n, r);
      break;
    case 4:
      s.transform(1, 0, 0, -1, 0, r);
      break;
    case 5:
      s.transform(0, 1, 1, 0, 0, 0);
      break;
    case 6:
      s.transform(0, 1, -1, 0, r, 0);
      break;
    case 7:
      s.transform(0, -1, -1, 0, r, n);
      break;
    case 8:
      s.transform(0, -1, 1, 0, 0, n);
  }
  return s.drawImage(t, 0, 0, n, r), Xs(t), i;
}
function X4(t, e, n = 0) {
  return new Promise(function(r, i) {
    let s, a, o, u, c, d, l, f, p, m, g, y, b, E, v, _, D, S, M, O;
    function T(H = 5) {
      if (e.signal && e.signal.aborted) throw e.signal.reason;
      s += H, e.onProgress(Math.min(s, 100));
    }
    function N(H) {
      if (e.signal && e.signal.aborted) throw e.signal.reason;
      s = Math.min(Math.max(H, s), 100), e.onProgress(s);
    }
    return s = n, a = e.maxIteration || 10, o = 1024 * e.maxSizeMB * 1024, T(), e0(t, e).then((function(H) {
      try {
        return [, u] = H, T(), c = nD(u, e), T(), new Promise(function($, j) {
          var U;
          if (!(U = e.exifOrientation)) return tD(t).then((function(B) {
            try {
              return U = B, V.call(this);
            } catch (R) {
              return j(R);
            }
          }).bind(this), j);
          function V() {
            return $(U);
          }
          return V.call(this);
        }).then((function($) {
          try {
            return d = $, T(), Pl().then((function(j) {
              try {
                return l = j ? c : rD(c, d), T(), f = e.initialQuality || 1, p = e.fileType || t.type, t0(l, p, t.name, t.lastModified, f).then((function(U) {
                  try {
                    {
                      let B = function() {
                        if (a-- && (v > o || v > b)) {
                          let K, Q;
                          return K = O ? 0.95 * M.width : M.width, Q = O ? 0.95 * M.height : M.height, [D, S] = bg(K, Q), S.drawImage(M, 0, 0, K, Q), f *= p === "image/png" ? 0.85 : 0.95, t0(D, p, t.name, t.lastModified, f).then(function(P) {
                            try {
                              return _ = P, Xs(M), M = D, v = _.size, N(Math.min(99, Math.floor((E - v) / (E - o) * 100))), B;
                            } catch (I) {
                              return i(I);
                            }
                          }, i);
                        }
                        return [1];
                      }, R = function() {
                        return Xs(M), Xs(D), Xs(c), Xs(l), Xs(u), N(100), r(_);
                      };
                      if (m = U, T(), g = m.size > o, y = m.size > t.size, !g && !y) return N(100), r(m);
                      var V;
                      return b = t.size, E = m.size, v = E, M = l, O = !e.alwaysKeepResolution && g, (V = (function(K) {
                        for (; K; ) {
                          if (K.then) return void K.then(V, i);
                          try {
                            if (K.pop) {
                              if (K.length) return K.pop() ? R.call(this) : K;
                              K = B;
                            } else K = K.call(this);
                          } catch (Q) {
                            return i(Q);
                          }
                        }
                      }).bind(this))(B);
                    }
                  } catch (B) {
                    return i(B);
                  }
                }).bind(this), i);
              } catch (U) {
                return i(U);
              }
            }).bind(this), i);
          } catch (j) {
            return i(j);
          }
        }).bind(this), i);
      } catch ($) {
        return i($);
      }
    }).bind(this), i);
  });
}
const K3e = `
let scriptImported = false
self.addEventListener('message', async (e) => {
  const { file, id, imageCompressionLibUrl, options } = e.data
  options.onProgress = (progress) => self.postMessage({ progress, id })
  try {
    if (!scriptImported) {
      // console.log('[worker] importScripts', imageCompressionLibUrl)
      self.importScripts(imageCompressionLibUrl)
      scriptImported = true
    }
    // console.log('[worker] self', self)
    const compressedFile = await imageCompression(file, options)
    self.postMessage({ file: compressedFile, id })
  } catch (e) {
    // console.error('[worker] error', e)
    self.postMessage({ error: e.message + '\\n' + e.stack, id })
  }
})
`;
let CA;
function Z3e(t, e) {
  return new Promise((n, r) => {
    CA || (CA = function(a) {
      const o = [];
      return o.push(a), URL.createObjectURL(new Blob(o));
    }(K3e));
    const i = new Worker(CA);
    i.addEventListener("message", function(a) {
      if (e.signal && e.signal.aborted) i.terminate();
      else if (a.data.progress === void 0) {
        if (a.data.error) return r(new Error(a.data.error)), void i.terminate();
        n(a.data.file), i.terminate();
      } else e.onProgress(a.data.progress);
    }), i.addEventListener("error", r), e.signal && e.signal.addEventListener("abort", () => {
      r(e.signal.reason), i.terminate();
    }), i.postMessage({ file: t, imageCompressionLibUrl: e.libURL, options: { ...e, onProgress: void 0, signal: void 0 } });
  });
}
function jr(t, e) {
  return new Promise(function(n, r) {
    let i, s, a, o, u, c;
    if (i = { ...e }, a = 0, { onProgress: o } = i, i.maxSizeMB = i.maxSizeMB || Number.POSITIVE_INFINITY, u = typeof i.useWebWorker != "boolean" || i.useWebWorker, delete i.useWebWorker, i.onProgress = (p) => {
      a = p, typeof o == "function" && o(a);
    }, !(t instanceof Blob || t instanceof X3e)) return r(new Error("The file given is not an instance of Blob or File"));
    if (!/^image/.test(t.type)) return r(new Error("The file given is not an image"));
    if (c = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, !u || typeof Worker != "function" || c) return X4(t, i).then((function(p) {
      try {
        return s = p, f.call(this);
      } catch (m) {
        return r(m);
      }
    }).bind(this), r);
    var d = (function() {
      try {
        return f.call(this);
      } catch (p) {
        return r(p);
      }
    }).bind(this), l = function(p) {
      try {
        return X4(t, i).then(function(m) {
          try {
            return s = m, d();
          } catch (g) {
            return r(g);
          }
        }, r);
      } catch (m) {
        return r(m);
      }
    };
    try {
      return i.libURL = i.libURL || "https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js", Z3e(t, i).then(function(p) {
        try {
          return s = p, d();
        } catch {
          return l();
        }
      }, l);
    } catch {
      l();
    }
    function f() {
      try {
        s.name = t.name, s.lastModified = t.lastModified;
      } catch {
      }
      try {
        i.preserveExif && t.type === "image/jpeg" && (!i.fileType || i.fileType && i.fileType === t.type) && (s = Q5(t, s));
      } catch {
      }
      return n(s);
    }
  });
}
jr.getDataUrlFromFile = K5, jr.getFilefromDataUrl = sT, jr.loadImage = Z5, jr.drawImageInCanvas = eD, jr.drawFileInCanvas = e0, jr.canvasToFile = t0, jr.getExifOrientation = tD, jr.handleMaxWidthOrHeight = nD, jr.followExifOrientation = rD, jr.cleanupCanvasMemory = Xs, jr.isAutoOrientationInBrowser = Pl, jr.approximateBelowMaximumCanvasSizeOfBrowser = J5, jr.copyExifWithoutOrientation = Q5, jr.getBrowserName = mu, jr.version = "2.0.2";
var J3e = "firebase", eEe = "11.9.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Co(J3e, eEe, "app");
let tEe = class {
  constructor(e) {
    Ke(this, "value");
    Ke(this, "next");
    this.value = e;
  }
};
var ji, _u, Eu;
class nEe {
  constructor() {
    rp(this, ji);
    rp(this, _u);
    rp(this, Eu);
    this.clear();
  }
  enqueue(e) {
    const n = new tEe(e);
    vs(this, ji) ? (vs(this, _u).next = n, _a(this, _u, n)) : (_a(this, ji, n), _a(this, _u, n)), H1(this, Eu)._++;
  }
  dequeue() {
    const e = vs(this, ji);
    if (e)
      return _a(this, ji, vs(this, ji).next), H1(this, Eu)._--, e.value;
  }
  peek() {
    if (vs(this, ji))
      return vs(this, ji).value;
  }
  clear() {
    _a(this, ji, void 0), _a(this, _u, void 0), _a(this, Eu, 0);
  }
  get size() {
    return vs(this, Eu);
  }
  *[Symbol.iterator]() {
    let e = vs(this, ji);
    for (; e; )
      yield e.value, e = e.next;
  }
  *drain() {
    for (; vs(this, ji); )
      yield this.dequeue();
  }
}
ji = new WeakMap(), _u = new WeakMap(), Eu = new WeakMap();
function rEe(t) {
  K4(t);
  const e = new nEe();
  let n = 0;
  const r = () => {
    n < t && e.size > 0 && (e.dequeue()(), n++);
  }, i = () => {
    n--, r();
  }, s = async (u, c, d) => {
    const l = (async () => u(...d))();
    c(l);
    try {
      await l;
    } catch {
    }
    i();
  }, a = (u, c, d) => {
    new Promise((l) => {
      e.enqueue(l);
    }).then(
      s.bind(void 0, u, c, d)
    ), (async () => (await Promise.resolve(), n < t && r()))();
  }, o = (u, ...c) => new Promise((d) => {
    a(u, d, c);
  });
  return Object.defineProperties(o, {
    activeCount: {
      get: () => n
    },
    pendingCount: {
      get: () => e.size
    },
    clearQueue: {
      value() {
        e.clear();
      }
    },
    concurrency: {
      get: () => t,
      set(u) {
        K4(u), t = u, queueMicrotask(() => {
          for (; n < t && e.size > 0; )
            r();
        });
      }
    }
  }), o;
}
function K4(t) {
  if (!((Number.isInteger(t) || t === Number.POSITIVE_INFINITY) && t > 0))
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
}
const Pr = [];
for (let t = 0; t < 256; ++t)
  Pr.push((t + 256).toString(16).slice(1));
function iEe(t, e = 0) {
  return (Pr[t[e + 0]] + Pr[t[e + 1]] + Pr[t[e + 2]] + Pr[t[e + 3]] + "-" + Pr[t[e + 4]] + Pr[t[e + 5]] + "-" + Pr[t[e + 6]] + Pr[t[e + 7]] + "-" + Pr[t[e + 8]] + Pr[t[e + 9]] + "-" + Pr[t[e + 10]] + Pr[t[e + 11]] + Pr[t[e + 12]] + Pr[t[e + 13]] + Pr[t[e + 14]] + Pr[t[e + 15]]).toLowerCase();
}
let SA;
const sEe = new Uint8Array(16);
function aEe() {
  if (!SA) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    SA = crypto.getRandomValues.bind(crypto);
  }
  return SA(sEe);
}
const oEe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Z4 = { randomUUID: oEe };
function n0(t, e, n) {
  var i;
  if (Z4.randomUUID && !t)
    return Z4.randomUUID();
  t = t || {};
  const r = t.random ?? ((i = t.rng) == null ? void 0 : i.call(t)) ?? aEe();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, iEe(r);
}
const uEe = {
  [lt.increment]({ commit: t }) {
    t(nt.increment);
  },
  async [lt.fetchRooms]({ state: t, commit: e, dispatch: n }, { pageSize: r } = { pageSize: void 0 }) {
    if (t.isRequesting[Da.FetchRooms]) return;
    const { numberOfFetchedRooms: i, uid: s } = t;
    if (i === t.numberOfTotalRooms && i > 0)
      return;
    const a = r !== void 0 ? r : Math.min(Math.max(30, i), 120), {
      data: { result: o }
    } = await t.axios.get(Da.FetchRooms, {
      params: {
        skip: i,
        limit: a,
        q: t.roomTag ? `{ "members": "${s}", "roomTags": "${t.roomTag}" }` : `{ "members": "${s}" }`
      }
    }), { data: u, totalCount: c } = o, d = {}, l = {};
    for (const f of u) {
      d[f._id] = new hm(f, t.uid);
      for (const p of f.members)
        l[p.id] || (l[p.id] = new Ma(p));
    }
    e(nt.updateField, { key: "rooms", value: d }), e(nt.updateField, { key: "users", value: l }), e(nt.setState, {
      numberOfTotalRooms: c,
      numberOfFetchedRooms: i + a
    }), n(lt.aggregateRoomsAndFolders);
  },
  async [lt.handleMessageFromSocket]({ state: t, commit: e, dispatch: n }, r) {
    var s, a;
    let i = t.rooms[r.roomId];
    if (i) {
      const { id: o, numberOfUnread: u } = i;
      r.roomId === t.selectedRoomId ? (t.config.settings.linkPreviewEnabled && await n(lt.handleLinkPreviews, [r]), await t.rwlock.writeLock(), (s = t.messageMultiList.main) != null && s.contains(r.id) ? e(nt.replaceMessage, {
        targetMessageId: r.id,
        message: r
      }) : e(nt.pushMessage, r), t.rwlock.unlock(), e(nt.updateRoom, {
        id: o,
        updatedAt: r.createdAt,
        lastMessage: r,
        numberOfUnread: 0
      }), r.senderId !== t.uid && n(lt.updateLastRead, o), e(nt.setState, {
        numberOfTotalMessages: t.numberOfTotalMessages + 1
      })) : e(nt.updateRoom, {
        id: o,
        updatedAt: r.createdAt,
        lastMessage: r,
        numberOfUnread: r.senderId !== t.uid ? u + 1 : u
      }), (a = i.pref) != null && a.hidden && n(lt.updateRoomPrefs, {
        roomId: o,
        prefs: {
          hidden: !1
        }
      }), n(lt.aggregateRoomsAndFolders);
    } else
      await n(lt.fetchRoom, r.roomId), i = t.rooms[r.roomId];
  },
  async [lt.loadMessages]({ state: t, commit: e, dispatch: n }, { roomId: r, beforeMessageId: i, afterMessageId: s, targetMessageId: a }) {
    var m;
    const o = a ? `/rooms/${r}/messages/v3/${a}` : s ? `/rooms/${r}/messages/v3/${s}` : `/rooms/${r}/messages/v3`;
    if (t.isRequesting[o] || t.messageMultiList.numberOfMessages() >= t.numberOfTotalMessages && t.numberOfTotalMessages !== -1)
      return;
    const {
      data: { result: u }
    } = await t.axios.get(o, {
      params: a ? {
        before: 15,
        after: 15
      } : i ? {
        limit: 30,
        beforeMessage: i
      } : s ? {
        after: 30
      } : {
        limit: 30
      }
    }), { data: c, totalCount: d } = u;
    s && c.shift();
    const l = {};
    for (const g of c) {
      const y = (m = g.sender) == null ? void 0 : m._id, b = l[y];
      y && !b && (l[y] = new Ma(g.sender));
    }
    e(nt.updateField, { key: "users", value: l });
    const f = new B3e(c), p = f.array();
    return t.config.settings.linkPreviewEnabled && await n(lt.handleLinkPreviews, p), e(i ? nt.unshiftMessageLinkedList : s ? nt.concateMessageLinkedList : nt.insertMessageLinkedList, f), d > t.numberOfTotalMessages && e(nt.setState, { numberOfTotalMessages: d }), c;
  },
  async [lt.fetchRoom]({ state: t, dispatch: e }, n) {
    const {
      data: { result: r }
    } = await t.axios.get(`/rooms/${n}`);
    e(lt.handleRoomFromSocket, r);
  },
  async [lt.updateLastRead]({ state: t, commit: e }, n) {
    var a;
    const r = `/rooms/${n}/lastRead`;
    if (t.isRequesting[r]) return;
    const i = t.rooms[n], {
      data: { result: s }
    } = await t.axios.put(r, {
      message: (a = i.lastMessage) == null ? void 0 : a.id
    });
    s && e(nt.updateRoom, {
      id: n,
      numberOfUnread: 0
    });
  },
  async [lt.handleRoomFromSocket]({ state: t, commit: e, dispatch: n }, r) {
    const i = new hm(r, t.uid), s = {};
    s[i.id] = i, e(nt.updateField, { key: "rooms", value: s });
    const a = {};
    r.members.flatMap((d) => Array.isArray(d.members) ? [...d.members, d] : [d]).forEach((d) => {
      a[d.id] || (a[d.id] = new Ma(d));
    });
    const o = i.extra.clientName;
    for (const d in o)
      a[d] && (a[d].nickname = o[d]);
    const u = i.extra.clientAvatar;
    for (const d in u)
      a[d] && (a[d].avatarUrl = u[d]);
    const c = i.extra.subAccountShareAvatars;
    for (const d in a)
      c[d] && (a[d].avatarUrl = i.extra.clientAvatar[i.extra.agentId], a[d].nickname = i.extra.clientName[i.extra.agentId]);
    e(nt.updateField, { key: "users", value: a }), n(lt.aggregateRoomsAndFolders);
  },
  async [lt.handleLastReadFromSocket]({ commit: t }, e) {
    t(nt.updateLastRead, e);
  },
  async [lt.sendMessage]({ state: t, commit: e, dispatch: n }, r) {
    const { roomId: i } = r;
    if (!i) return;
    const s = Fn.fromPayload(r, t.uid);
    if (s) {
      s.status = Ss.Sending, e(nt.setMap, {
        mapName: "deliveringMessages",
        key: s.id,
        value: s
      }), e(nt.pushMessage, s);
      try {
        if (r.messageType === ft.Image) {
          const { files: u } = r, c = await Promise.all(
            r.images.map(
              (l, f) => n(lt.uploadImage, {
                image: l,
                file: u[f]
              })
            )
          ), d = [];
          r.images.forEach((l, f) => {
            t.imageCache.set(c[f].thumbnailUrl, l.thumbnailUrl);
            const { id: p, width: m, height: g } = l;
            d.push({
              originalUrl: c[f].originalUrl,
              thumbnailUrl: c[f].thumbnailUrl,
              width: m,
              height: g
            }), e(nt.deleteField, {
              key: "uploadProgresses",
              value: `${p}-original`
            }), e(nt.deleteField, {
              key: "uploadProgresses",
              value: `${p}-thumbnail`
            });
          }), r.images = d, delete r.files;
        } else if (r.messageType === ft.Video) {
          const { file: u, video: c } = r, d = c.thumbnailFile;
          if (!d) return;
          const l = await Promise.all([
            n(lt.uploadMedia, {
              id: d.id,
              file: d.file
            }),
            n(lt.uploadMedia, {
              id: c.id,
              file: u
            })
          ]);
          r.width = c.width, r.height = c.height, r.duration = c.duration, r.thumbnailUrl = l[0], r.originalUrl = l[1], t.imageCache.set(l[0], c.thumbnailUrl), delete r.file, e(nt.deleteField, {
            key: "uploadProgresses",
            value: c.id
          });
        } else if (r.messageType === ft.File) {
          const { file: u } = r, c = await n(lt.uploadMedia, {
            id: s.id,
            file: u
          });
          r.originalUrl = c, delete r.file, e(nt.deleteField, {
            key: "uploadProgresses",
            value: s.id
          });
        } else if (r.messageType === ft.Audio) {
          const { file: u } = r, c = await n(lt.uploadMedia, {
            id: s.id,
            file: u
          });
          r.originalUrl = c, delete r.file, e(nt.deleteField, {
            key: "uploadProgresses",
            value: s.id
          });
        } else r.messageType === ft.Flex && delete r.roomId;
        await t.rwlock.readLock();
        const {
          data: { result: a }
        } = await t.axios.post(`/rooms/${i}/message`, r), o = Fn.createReactive(a);
        return o ? (e(nt.setMap, {
          mapName: "processingMessages",
          key: o.id,
          value: o
        }), e(nt.deleteMap, {
          mapName: "deliveringMessages",
          key: s.id
        }), t.config.settings.linkPreviewEnabled && await n(lt.handleLinkPreviews, [o]), o.roomId === t.selectedRoomId ? e(nt.replaceMessage, {
          message: o,
          targetMessageId: s.id
        }) : e(nt.updateRoom, {
          id: o.roomId,
          updatedAt: o.createdAt,
          lastMessage: o
        }), e(nt.deleteMap, {
          mapName: "processingMessages",
          key: o.id
        }), o) : void 0;
      } catch (a) {
        throw s.status = Ss.Failed, e(nt.updateMessage, s), e(nt.deleteMap, {
          mapName: "deliveringMessages",
          key: s.id
        }), a;
      } finally {
        t.rwlock.unlock();
      }
    }
  },
  async [lt.retryMessage]({ state: t, commit: e, dispatch: n }, r) {
    r.status = Ss.Sending, e(nt.updateMessage, r), e(nt.setMap, {
      mapName: "deliveringMessages",
      key: r.id,
      value: r
    });
    try {
      await t.rwlock.readLock();
      const {
        data: { result: i }
      } = await t.axios.post(
        `/rooms/${r.roomId}/message`,
        r.payload
      ), s = Fn.createReactive(i);
      return s ? (e(nt.setMap, {
        mapName: "processingMessages",
        key: s.id,
        value: s
      }), e(nt.deleteMap, {
        mapName: "deliveringMessages",
        key: r.id
      }), t.config.settings.linkPreviewEnabled && await n(lt.handleLinkPreviews, [s]), s.roomId === t.selectedRoomId ? e(nt.replaceMessage, {
        message: s,
        targetMessageId: r.id
      }) : e(nt.updateRoom, {
        id: s.roomId,
        updatedAt: s.createdAt,
        lastMessage: s
      }), e(nt.deleteMap, {
        mapName: "processingMessages",
        key: s.id
      }), s) : void 0;
    } catch (i) {
      throw r.status = Ss.Failed, e(nt.updateMessage, r), e(nt.deleteMap, {
        mapName: "deliveringMessages",
        key: r.id
      }), i;
    } finally {
      t.rwlock.unlock();
    }
  },
  async [lt.batchSendMessage]({ state: t }, e) {
    await t.axios.post("/messages/batch", e);
  },
  async [lt.recallMessage]({ state: t, commit: e }, n) {
    var o;
    const { roomId: r } = n;
    if (!r) return;
    const {
      data: { result: i }
    } = await t.axios.post(`/rooms/${r}/message`, n), s = Fn.createReactive(i);
    if (!s) return;
    const a = t.rooms[`${r}`];
    a && ((o = a.lastMessage) == null ? void 0 : o.id) === s.id && e(nt.updateRoom, {
      id: r,
      lastMessage: s
    }), e(nt.replaceMessage, {
      targetMessageId: s.id,
      message: s
    });
  },
  async [lt.hideMessage]({ state: t, commit: e }, n) {
    const { roomId: r, messageIds: i } = n;
    !r || !i || i.length === 0 || (await t.axios.post("/messages/user-delete", {
      room: r,
      messages: i
    }), e(nt.deleteMessages, i));
  },
  async [lt.deleteMessage]({ state: t, commit: e }, n) {
    const { roomId: r, messageId: i } = n;
    !r || !i || (await t.axios.delete(`/rooms/${r}/messages/${i}`), e(nt.deleteMessages, [i]));
  },
  async [lt.uploadMedia]({ state: t, commit: e }, { id: n, file: r }) {
    const i = new FormData();
    i.append("file", r);
    const {
      data: {
        result: { _id: s }
      }
    } = await t.axios.post("/files/chatserver-upload", i, {
      headers: {
        "Content-Type": "multipart/form-data"
      },
      onUploadProgress: (a) => {
        const { total: o } = a;
        o && e(nt.updateField, {
          key: "uploadProgresses",
          value: { [n]: a.loaded / o }
        });
      }
    });
    return `${t.config.domain}/files/chatserver-upload/${s}`;
  },
  async [lt.uploadImage]({ dispatch: t }, { image: e, file: n }) {
    if (n.size > 1024 * 1024)
      try {
        const i = await jr(n, {
          maxSizeMB: 1,
          maxWidthOrHeight: 1920,
          useWebWorker: !0
        }), s = await Promise.all([
          t(lt.uploadMedia, {
            id: `${e.id}-original`,
            file: n
          }),
          t(lt.uploadMedia, {
            id: `${e.id}-thumbnail`,
            file: i
          })
        ]);
        return { originalUrl: s[0], thumbnailUrl: s[1] };
      } catch (i) {
        console.error(i);
      }
    const r = await t(lt.uploadMedia, {
      id: `${e.id}-original`,
      file: n
    });
    return { originalUrl: r, thumbnailUrl: r };
  },
  async [lt.fetchLinkPreview](t, e) {
    const { data: n } = await Qn.get(
      encodeURI(`https://url.imkit.io/?url=${e}`)
    );
    return n;
  },
  async [lt.handleLinkPreviews]({ state: t, commit: e, dispatch: n }, r) {
    const i = Array.from(
      new Set(
        r.flatMap((o) => (o == null ? void 0 : o.urls) || []).filter((o) => !t.linkPreviews[o])
      )
    );
    if (i.length === 0) return;
    const s = {};
    (await Promise.allSettled(
      i.map((o) => n(lt.fetchLinkPreview, o))
    )).forEach((o, u) => {
      o.status === "fulfilled" && (s[i[u]] = o.value);
    }), e(nt.updateField, {
      key: "linkPreviews",
      value: s
    });
  },
  async [lt.fetchVideoBlob]({ state: t }, e) {
    const { data: n } = await t.axios.get(e, { responseType: "blob" });
    return n;
  },
  async [lt.navigateToMessage]({ state: t, commit: e, dispatch: n }, r) {
    var i;
    (i = t.messageMultiList.main) != null && i.contains(r) ? e(nt.setState, {
      navigationTargetId: r
    }) : (await n(lt.loadMessages, {
      roomId: t.selectedRoomId,
      targetMessageId: r
    }), await e(nt.setState, {
      navigationTargetId: r
    }));
  },
  async [lt.updateRoomPrefs]({ state: t, commit: e, dispatch: n }, { roomId: r, prefs: i, roomTag: s }) {
    let a = `/roomPrefs/${r}`;
    s && (a = `${a}/group/${s}`), await t.axios.post(a, i);
    const o = t.rooms[r];
    o && (e(nt.updateRoom, {
      id: r,
      pref: { ...o.pref, ...i }
    }), n(lt.aggregateRoomsAndFolders));
  },
  async [lt.fetchPrefs]({ state: t, commit: e }) {
    const {
      data: { result: n }
    } = await t.axios.get("/me/pref"), r = {}, i = [], s = {}, a = {}, o = {};
    for (const u of n)
      if (u.key === "folders-meta")
        for (const c of u.data)
          s[c.key] = c.name, i.push(c.key);
      else {
        if (u.key === "blackList")
          continue;
        a[u.key] = u.data.children.map(
          (c) => c.id
        );
      }
    for (const u of i) {
      r[u] = new xl(u, s[u], a[u] || []);
      for (const c of a[u] || [])
        o[c] = !0;
    }
    e(nt.setState, {
      folders: r,
      sortedFolderIds: i,
      roomIdsInFolders: o
    });
  },
  async [lt.fetchRoomsInFolders]({ state: t, dispatch: e }) {
    const n = Object.keys(t.roomIdsInFolders).length;
    for (; t.numberOfFetchedRooms < n; )
      await e(lt.fetchRooms, {
        pageSize: 200
      });
    const r = rEe(6), i = Object.keys(t.roomIdsInFolders).filter((s) => !t.rooms[s]).map((s) => r(() => e(lt.fetchRoom, s)));
    await Promise.allSettled(i);
  },
  async [lt.updatePref]({ state: t }, { key: e, value: n }) {
    return await t.axios.post(`/me/pref/${e}`, n);
  },
  async [lt.deletePref]({ state: t }, e) {
    return await t.axios.delete(`/me/pref/${e}`);
  },
  async [lt.updateFolder]({ state: t, dispatch: e, commit: n }, { folderKey: r, name: i }) {
    const s = Object.keys(t.selectedRoomIdsForCreateFolder).filter(
      (o) => t.selectedRoomIdsForCreateFolder[o]
    );
    await e(lt.updatePref, {
      key: "folders-meta",
      value: t.sortedFolderIds.map((o) => t.folders[o]).filter((o) => !!o && o.id !== r).map((o) => ({
        key: o.id,
        name: o.name
      })).concat([{ key: r, name: i }]).sort((o, u) => o.key.localeCompare(u.key))
    }), await e(lt.updatePref, {
      key: r,
      value: {
        children: s.map((o) => ({
          id: o,
          type: "room"
        }))
      }
    }), t.folders[r] && n(nt.updateField, {
      key: "roomIdsInFolders",
      value: t.folders[r].roomIds.reduce(
        (o, u) => (o[u] = !1, o),
        {}
      )
    });
    const a = new xl(r, i, s);
    n(nt.updateField, {
      key: "folders",
      value: {
        [r]: a
      }
    }), n(nt.updateField, {
      key: "roomIdsInFolders",
      value: s.reduce(
        (o, u) => (o[u] = !0, o),
        {}
      )
    }), n(nt.setState, {
      sortedFolderIds: [.../* @__PURE__ */ new Set([...t.sortedFolderIds, r])],
      selectedRoomIdsForCreateFolder: {}
    }), e(lt.aggregateRoomsAndFolders);
  },
  async [lt.removeFolder]({ state: t, dispatch: e }, n) {
    await e(lt.deletePref, n), await e(lt.updatePref, {
      key: "folders-meta",
      value: t.sortedFolderIds.map((r) => t.folders[r]).filter((r) => !!r && r.id !== n).map((r) => ({
        key: r.id,
        name: r.name
      }))
    }), e(lt.handlePrefDeleteFromSocket);
  },
  async [lt.handlePrefChangeFromSocket]({ state: t, commit: e, dispatch: n }, r) {
    const { key: i, data: s } = r;
    if (i === "folders-meta") {
      const a = {}, o = [];
      for (const { key: u, name: c } of s) {
        const d = t.folders[u] || new xl(u, c, []);
        a[u] = d, o.push(u);
      }
      e(nt.setState, {
        folders: a,
        sortedFolderIds: o
      });
    } else {
      const { id: a, name: o } = t.folders[i];
      if (a) {
        const u = s.children.map(
          (d) => d.id
        ), c = new xl(a, o, u);
        e(nt.updateField, {
          key: "folders",
          value: {
            [i]: c
          }
        }), e(nt.updateField, {
          key: "roomIdsInFolders",
          value: u.reduce(
            (d, l) => (d[l] = !0, d),
            {}
          )
        });
      }
    }
    n(lt.aggregateRoomsAndFolders);
  },
  async [lt.handlePrefDeleteFromSocket]({ state: t, commit: e, dispatch: n }, r) {
    const i = t.folders[r];
    if (!i)
      return;
    const s = {};
    for (const a of i.roomIds)
      s[a] = !1;
    e(nt.deleteField, {
      key: "folders",
      value: r
    }), e(nt.updateField, {
      key: "roomIdsInFolders",
      value: s
    }), e(nt.setState, {
      sortedFolderIds: t.sortedFolderIds.filter((a) => a !== r)
    }), n(lt.aggregateRoomsAndFolders);
  },
  async [lt.aggregateRoomsAndFolders]({ state: t, commit: e }) {
    const n = Object.values(t.rooms).filter((r) => {
      var i;
      return !t.roomIdsInFolders[r.id] && !((i = r.pref) != null && i.hidden);
    }).sort(
      (r, i) => {
        var s, a, o;
        return ((s = r.pref) == null ? void 0 : s.sticky) === ((a = i.pref) == null ? void 0 : a.sticky) ? i.updatedAt - r.updatedAt : (o = r.pref) != null && o.sticky ? -1 : 1;
      }
    );
    e(nt.setState, {
      sortedRooms: n
    });
  },
  async [lt.removeMembers]({ state: t, commit: e }, { roomId: n, uids: r }) {
    var s;
    if (t.rooms[n] && (await t.axios.post(`/rooms/${n}/delete/members`, {
      systemMessage: !0,
      members: r
    }), r.includes(t.uid))) {
      e(nt.deleteRoom, n);
      const a = (s = t.sortedRooms.find(
        (o) => o.numberOfUnread === 0
      )) == null ? void 0 : s.id;
      a && e(nt.setState, {
        selectedRoomId: a
      });
    }
  },
  async [lt.handleTypingFromSocket]({ state: t, commit: e }, n) {
    const { room: r, sender: i, senderInfo: s } = n;
    if (r !== t.selectedRoomId || i === t.uid) return;
    e(nt.updateField, {
      key: "users",
      value: { [s._id]: new Ma(s) }
    });
    const a = t.isTyping[i];
    a !== void 0 && clearTimeout(a);
    const o = setTimeout(() => {
      e(nt.deleteField, {
        key: "isTyping",
        value: i
      });
    }, 6e3);
    e(nt.updateField, {
      key: "isTyping",
      value: { [i]: o }
    });
  },
  async [lt.insertUnreadMessage]({ state: t, commit: e }) {
    var a, o, u, c;
    const n = t.rooms[t.selectedRoomId];
    if (!n) return;
    const r = n.lastReadMessageId[t.uid];
    if (!r) return;
    const i = (a = t.messageMultiList.main) == null ? void 0 : a.finds(r);
    if (!i || i.senderId === t.uid || ((o = n.lastMessage) == null ? void 0 : o.id) === r || ((c = (u = t.messageMultiList.main) == null ? void 0 : u.tail) == null ? void 0 : c.id) === r) return;
    const s = Fn.fromPayload(
      {
        roomId: t.selectedRoomId,
        messageType: ft.Announcement,
        message: zr.global.t("unreadMessages"),
        createdAtMS: i.createdAt + 1
      },
      t.uid
    );
    s && e(nt.pushMessage, s);
  },
  async [lt.translate]({ state: t }, e) {
    if (t.translationCache.has(e))
      return t.translationCache.get(e) || e;
    let n = navigator.language.split("-")[0];
    const r = {
      am: "am",
      ar: "ar",
      eu: "eu",
      bn: "bn",
      "en-gb": "en-GB",
      "pt-br": "pt-BR",
      bg: "bg",
      ca: "ca",
      chr: "chr",
      hr: "hr",
      cs: "cs",
      da: "da",
      nl: "nl",
      en: "en",
      et: "et",
      fil: "fil",
      fi: "fi",
      fr: "fr",
      de: "de",
      el: "el",
      gu: "gu",
      iw: "iw",
      hi: "hi",
      hu: "hu",
      is: "is",
      id: "id",
      it: "it",
      ja: "ja",
      kn: "kn",
      ko: "ko",
      lv: "lv",
      lt: "lt",
      ms: "ms",
      ml: "ml",
      mr: "mr",
      no: "no",
      pl: "pl",
      "pt-pt": "pt-PT",
      ro: "ro",
      ru: "ru",
      sr: "sr",
      "zh-cn": "zh-CN",
      sk: "sk",
      sl: "sl",
      es: "es",
      sw: "sw",
      sv: "sv",
      ta: "ta",
      te: "te",
      th: "th",
      "zh-tw": "zh-TW",
      tr: "tr",
      ur: "ur",
      uk: "uk",
      vi: "vi",
      cy: "cy"
    };
    r[navigator.language.toLowerCase()] && (n = r[navigator.language.toLowerCase()]);
    const i = await fetch(
      "https://translation.googleapis.com/language/translate/v2",
      {
        method: "POST",
        headers: new Headers({
          "Content-Type": "application/x-www-form-urlencoded"
        }),
        body: new URLSearchParams({
          q: e,
          key: t.config.translationApiKey,
          target: n
        }),
        redirect: "follow"
      }
    ).then((s) => s.json()).then((s) => {
      var a;
      return (a = s.data) == null ? void 0 : a.translations[0].translatedText;
    });
    return t.translationCache.set(e, i), i;
  },
  // IMActionTypes.searchRooms
  async [lt.searchRooms]({ state: t, commit: e }, n) {
    if (t.isRequesting[Da.Search]) return;
    const r = Object.values(Wr), {
      data: { result: i }
    } = await t.axios.post(Da.Search, {
      type: r,
      keyword: n
    }), s = {}, a = {}, o = {}, u = /* @__PURE__ */ new Map();
    for (const l of r)
      i[l].forEach((f) => {
        l === Wr.Messages && (u.set(f.room._id, f.messages), f = f.room), s[f._id] = new hm(f, t.uid), o[l] || (o[l] = []), o[l].push(s[f._id]);
        for (const p of f.members)
          a[p.id] || (a[p.id] = new Ma(p));
      });
    for (const l of Object.values(t.folders))
      l.name.includes(n) && (o[Wr.RoomPrefFolder] || (o[Wr.RoomPrefFolder] = []), o[Wr.RoomPrefFolder].push(l));
    const c = Object.keys(o), d = c.length > 0 ? c[0] : Wr.RoomName;
    e(nt.updateField, { key: "rooms", value: s }), e(nt.updateField, { key: "users", value: a }), e(nt.setState, {
      searchRooms: o,
      searchType: d,
      searchKeyword: n,
      searchedMessageIds: u
    });
  },
  async [lt.subscribe]({ state: t }) {
    if (!t.config.firebaseConfig || !t.config.firebaseVapidKey) return;
    const e = v5(t.config.firebaseConfig), n = P3e(e), r = await R3e(n, {
      vapidKey: t.config.firebaseVapidKey
    });
    if (!r) return;
    let i = localStorage.getItem("imkit-deviceId");
    i || (i = n0(), localStorage.setItem("imkit-deviceId", i)), await t.axios.post(Da.Subscribe, {
      type: "fcm",
      token: r,
      deviceId: i
    });
  },
  async [lt.unsubscribe]({ state: t }) {
    let e = localStorage.getItem("imkit-deviceId");
    e || (e = n0(), localStorage.setItem("imkit-deviceId", e)), await t.axios.post(Da.Unsubscribe, {
      type: "fcm",
      deviceId: e
    });
  },
  async [lt.removeRoomFromFolder]({ state: t, commit: e, dispatch: n }, r) {
    if (!t.roomIdsInFolders[r]) return;
    const i = t.folders[t.selectedFolderId];
    if (!i) return;
    const s = i.id, a = i.roomIds.filter((u) => u !== r);
    await n(lt.updatePref, {
      key: s,
      value: {
        children: a.map((u) => ({
          id: u,
          type: "room"
        }))
      }
    });
    const o = new xl(s, i.name, a);
    e(nt.updateField, {
      key: "folders",
      value: {
        [s]: o
      }
    }), e(nt.updateField, {
      key: "roomIdsInFolders",
      value: { [r]: !1 }
    }), n(lt.aggregateRoomsAndFolders);
  },
  async [lt.addRoomToFolder]({ state: t, commit: e, dispatch: n }, { roomId: r, folderId: i }) {
    const s = t.folders[i];
    if (!s) return;
    const a = Array.from(/* @__PURE__ */ new Set([...s.roomIds, r]));
    await n(lt.updatePref, {
      key: i,
      value: {
        children: a.map((u) => ({
          id: u,
          type: "room"
        }))
      }
    });
    const o = new xl(i, s.name, a);
    e(nt.updateField, {
      key: "folders",
      value: {
        [i]: o
      }
    }), e(nt.updateField, {
      key: "roomIdsInFolders",
      value: { [r]: !0 }
    }), n(lt.aggregateRoomsAndFolders);
  },
  async [lt.toggleNotification]({ state: t, commit: e }, n) {
    const r = t.rooms[n];
    r && (r.muted ? await t.axios.delete(`/me/mute/${n}`) : await t.axios.post(`/me/mute/${n}`), e(nt.updateRoom, {
      id: n,
      muted: !r.muted
    }));
  },
  async [lt.translateMessage]({ state: t, commit: e, dispatch: n }, r) {
    if (t.config.translationApiKey && r.type === ft.Text && r.senderId !== t.uid) {
      const i = r.text;
      try {
        const s = await n(lt.translate, i);
        r.translatedText = s !== i ? s : null, e(nt.replaceMessage, {
          message: r,
          targetMessageId: r.id
        });
      } catch (s) {
        console.error(s);
      }
    }
  },
  async [lt.blockUser]({ state: t, commit: e }, { roomId: n, uid: r }) {
    await t.axios.post(`/blockStatus/room/${n}/${r}`), e(nt.updateField, {
      key: "blockedUsers",
      value: { [r]: !0 }
    });
  },
  async [lt.unblockUser]({ state: t, commit: e }, { roomId: n, uid: r }) {
    await t.axios.delete(`/blockStatus/room/${n}/${r}`), e(nt.deleteField, {
      key: "blockedUsers",
      value: r
    });
  },
  async [lt.getBlockList]({ state: t, commit: e }, n) {
    const r = await t.axios.get(`/blockStatus/room/${n}`), i = {};
    for (const s of r.data.result.data)
      !s.blockee || s.unblockAt || (i[s.blockee.id] = !0);
    e(nt.updateField, {
      key: "blockedUsers",
      value: i
    });
  },
  async [lt.hideMessagesFromUserInRoom]({ state: t }, e) {
    await t.axios.post("/messages/user-delete/all-in-room", {
      room: e
    });
  },
  async [lt.sendReaction]({ state: t }, { messageId: e, reaction: n }) {
    await t.axios.post(`/messages/${e}/reaction`, {
      reaction: n
    });
  },
  async [lt.deleteReaction]({ state: t }, { messageId: e, reaction: n }) {
    const r = {
      reaction: n
    };
    await t.axios.delete(`/messages/${e}/reaction`, {
      params: r
    });
  },
  async [lt.quickReply]({ state: t, dispatch: e }, n) {
    const r = {
      roomId: n.roomId,
      messageType: "text",
      message: n.message,
      reply: t.replyId ? t.replyId : null
    };
    e(lt.sendMessage, r);
  },
  async [lt.checkNotificationPermission]({ dispatch: t }) {
    if ("Notification" in window) {
      if (Notification.permission === "granted")
        t(lt.subscribe);
      else if (Notification.permission === "default" && !localStorage.getItem("notification-permission-skipped")) {
        const { open: n } = Jn({
          component: q3e
        });
        n();
      }
    }
  }
}, lEe = {
  doubleCount: (t) => t.count * 2,
  roomsInSelectedFolder: (t) => {
    const { selectedFolderId: e } = t, n = t.folders[e];
    return n ? n.roomIds.map((i) => t.rooms[i]).filter((i) => t.roomTag ? i && i.roomTags.includes(t.roomTag) : i).sort(
      (i, s) => {
        var a, o, u;
        return ((a = i.pref) == null ? void 0 : a.sticky) === ((o = s.pref) == null ? void 0 : o.sticky) ? s.updatedAt - i.updatedAt : (u = i.pref) != null && u.sticky ? -1 : 1;
      }
    ) : [];
  }
}, cEe = {
  [nt.increment](t) {
    t.count++;
  },
  [nt.setState](t, e) {
    Object.assign(t, e);
  },
  [nt.updateField](t, e) {
    const { key: n, value: r } = e;
    Object.assign(t[n], r);
  },
  [nt.deleteField](t, e) {
    const { key: n, value: r } = e;
    delete t[n][r];
  },
  [nt.updateRoom](t, e) {
    const { id: n } = e, r = t.rooms[n];
    r && Object.assign(r, e);
  },
  [nt.updateMessage](t, e) {
    var i;
    const { id: n } = e, r = (i = t.messageMultiList.main) == null ? void 0 : i.finds(n);
    r && Object.assign(r, e);
  },
  [nt.updateLastRead](t, e) {
    const { roomId: n, uid: r, messageId: i } = e, s = t.rooms[n];
    s && (s.lastReadMessageId[r] = i);
  },
  [nt.pushMessage](t, e) {
    var n;
    e.roomId === t.selectedRoomId && ((n = t.messageMultiList.main) == null || n.append(e));
  },
  [nt.replaceMessage](t, e) {
    var i, s;
    const { targetMessageId: n, message: r } = e;
    r.roomId === t.selectedRoomId && ((i = t.messageMultiList.main) == null || i.remove(n), (s = t.messageMultiList.main) == null || s.append(r));
  },
  [nt.deleteMessages](t, e) {
    e.forEach((n) => {
      var r;
      (r = t.messageMultiList.main) == null || r.remove(n);
    });
  },
  [nt.clearChatRoom](t) {
    t.messageMultiList = new c5(), t.numberOfTotalMessages = -1, t.replyId = "", t.navigationTargetId = "", t.isTyping = {}, t.isSearchInRoomMode = !1, t.messageSearchKeyword = "", t.blockedUsers = {};
  },
  [nt.deleteRoom](t, e) {
    delete t.rooms[e], delete t.roomIdsInFolders[e], delete t.selectedRoomIdsForCreateFolder[e], t.sortedRooms = t.sortedRooms.filter((n) => n.id !== e);
  },
  [nt.setMap](t, e) {
    const { mapName: n, key: r, value: i } = e;
    t[n].set(r, i);
  },
  [nt.deleteMap](t, e) {
    const { mapName: n, key: r } = e;
    t[n].delete(r);
  },
  [nt.insertMessageLinkedList](t, e) {
    t.messageMultiList.insert(e), t.messageMultiList.merge();
  },
  [nt.concateMessageLinkedList](t, e) {
    t.messageMultiList.concate(e), t.messageMultiList.merge();
  },
  [nt.unshiftMessageLinkedList](t, e) {
    t.messageMultiList.unshift(e), t.messageMultiList.merge();
  }
}, iD = {
  state: Hve,
  mutations: cEe,
  getters: lEe,
  actions: uEe,
  namespaced: !0
}, dEe = [], Wf = sR({
  plugins: dEe,
  modules: {
    imkit: iD
  }
});
var mm = { exports: {} }, fEe = mm.exports, J4;
function hEe() {
  return J4 || (J4 = 1, function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(fEe, function() {
      var n = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, r = {};
      return function(i, s, a) {
        var o, u = function(f, p, m) {
          m === void 0 && (m = {});
          var g = new Date(f), y = function(b, E) {
            E === void 0 && (E = {});
            var v = E.timeZoneName || "short", _ = b + "|" + v, D = r[_];
            return D || (D = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: b, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: v }), r[_] = D), D;
          }(p, m);
          return y.formatToParts(g);
        }, c = function(f, p) {
          for (var m = u(f, p), g = [], y = 0; y < m.length; y += 1) {
            var b = m[y], E = b.type, v = b.value, _ = n[E];
            _ >= 0 && (g[_] = parseInt(v, 10));
          }
          var D = g[3], S = D === 24 ? 0 : D, M = g[0] + "-" + g[1] + "-" + g[2] + " " + S + ":" + g[4] + ":" + g[5] + ":000", O = +f;
          return (a.utc(M).valueOf() - (O -= O % 1e3)) / 6e4;
        }, d = s.prototype;
        d.tz = function(f, p) {
          f === void 0 && (f = o);
          var m, g = this.utcOffset(), y = this.toDate(), b = y.toLocaleString("en-US", { timeZone: f }), E = Math.round((y - new Date(b)) / 1e3 / 60), v = 15 * -Math.round(y.getTimezoneOffset() / 15) - E;
          if (!Number(v)) m = this.utcOffset(0, p);
          else if (m = a(b, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(v, !0), p) {
            var _ = m.utcOffset();
            m = m.add(g - _, "minute");
          }
          return m.$x.$timezone = f, m;
        }, d.offsetName = function(f) {
          var p = this.$x.$timezone || a.tz.guess(), m = u(this.valueOf(), p, { timeZoneName: f }).find(function(g) {
            return g.type.toLowerCase() === "timezonename";
          });
          return m && m.value;
        };
        var l = d.startOf;
        d.startOf = function(f, p) {
          if (!this.$x || !this.$x.$timezone) return l.call(this, f, p);
          var m = a(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
          return l.call(m, f, p).tz(this.$x.$timezone, !0);
        }, a.tz = function(f, p, m) {
          var g = m && p, y = m || p || o, b = c(+a(), y);
          if (typeof f != "string") return a(f).tz(y);
          var E = function(S, M, O) {
            var T = S - 60 * M * 1e3, N = c(T, O);
            if (M === N) return [T, M];
            var H = c(T -= 60 * (N - M) * 1e3, O);
            return N === H ? [T, N] : [S - 60 * Math.min(N, H) * 1e3, Math.max(N, H)];
          }(a.utc(f, g).valueOf(), b, y), v = E[0], _ = E[1], D = a(v).utcOffset(_);
          return D.$x.$timezone = y, D;
        }, a.tz.guess = function() {
          return Intl.DateTimeFormat().resolvedOptions().timeZone;
        }, a.tz.setDefault = function(f) {
          o = f;
        };
      };
    });
  }(mm)), mm.exports;
}
var pEe = hEe();
const mEe = /* @__PURE__ */ Fr(pEe);
var gm = { exports: {} }, gEe = gm.exports, ex;
function AEe() {
  return ex || (ex = 1, function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(gEe, function() {
      var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, i = /([+-]|\d\d)/g;
      return function(s, a, o) {
        var u = a.prototype;
        o.utc = function(g) {
          var y = { date: g, utc: !0, args: arguments };
          return new a(y);
        }, u.utc = function(g) {
          var y = o(this.toDate(), { locale: this.$L, utc: !0 });
          return g ? y.add(this.utcOffset(), n) : y;
        }, u.local = function() {
          return o(this.toDate(), { locale: this.$L, utc: !1 });
        };
        var c = u.parse;
        u.parse = function(g) {
          g.utc && (this.$u = !0), this.$utils().u(g.$offset) || (this.$offset = g.$offset), c.call(this, g);
        };
        var d = u.init;
        u.init = function() {
          if (this.$u) {
            var g = this.$d;
            this.$y = g.getUTCFullYear(), this.$M = g.getUTCMonth(), this.$D = g.getUTCDate(), this.$W = g.getUTCDay(), this.$H = g.getUTCHours(), this.$m = g.getUTCMinutes(), this.$s = g.getUTCSeconds(), this.$ms = g.getUTCMilliseconds();
          } else d.call(this);
        };
        var l = u.utcOffset;
        u.utcOffset = function(g, y) {
          var b = this.$utils().u;
          if (b(g)) return this.$u ? 0 : b(this.$offset) ? l.call(this) : this.$offset;
          if (typeof g == "string" && (g = function(D) {
            D === void 0 && (D = "");
            var S = D.match(r);
            if (!S) return null;
            var M = ("" + S[0]).match(i) || ["-", 0, 0], O = M[0], T = 60 * +M[1] + +M[2];
            return T === 0 ? 0 : O === "+" ? T : -T;
          }(g), g === null)) return this;
          var E = Math.abs(g) <= 16 ? 60 * g : g, v = this;
          if (y) return v.$offset = E, v.$u = g === 0, v;
          if (g !== 0) {
            var _ = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (v = this.local().add(E + _, n)).$offset = E, v.$x.$localOffset = _;
          } else v = this.utc();
          return v;
        };
        var f = u.format;
        u.format = function(g) {
          var y = g || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return f.call(this, y);
        }, u.valueOf = function() {
          var g = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * g;
        }, u.isUTC = function() {
          return !!this.$u;
        }, u.toISOString = function() {
          return this.toDate().toISOString();
        }, u.toString = function() {
          return this.toDate().toUTCString();
        };
        var p = u.toDate;
        u.toDate = function(g) {
          return g === "s" && this.$offset ? o(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : p.call(this);
        };
        var m = u.diff;
        u.diff = function(g, y, b) {
          if (g && this.$u === g.$u) return m.call(this, g, y, b);
          var E = this.local(), v = o(g).local();
          return m.call(E, v, y, b);
        };
      };
    });
  }(gm)), gm.exports;
}
var bEe = AEe();
const yEe = /* @__PURE__ */ Fr(bEe);
Wn.extend(yEe);
Wn.extend(mEe);
var ft = /* @__PURE__ */ ((t) => (t.Text = "text", t.Image = "image", t.Sticker = "sticker", t.Video = "video", t.File = "file", t.Template = "template", t.Flex = "flex", t.Location = "location", t.Audio = "audio", t.Recall = "recall", t.JoinRoom = "joinRoom", t.LeaveRoom = "leaveRoom", t.AddMember = "addMember", t.DeleteMember = "deleteMember", t.AddMembers = "addMembers", t.Announcement = "announcement", t.Typing = "typing", t.PaymentSelect = "payment-select", t.Line = "line", t))(ft || {}), Ss = /* @__PURE__ */ ((t) => (t.Sending = "sending", t.Delivered = "delivered", t.Failed = "failed", t))(Ss || {});
class Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e) {
    Ke(this, "id");
    Ke(this, "roomId");
    Ke(this, "senderId");
    Ke(this, "type");
    Ke(this, "status");
    Ke(this, "createdAt");
    Ke(this, "updatedAt");
    Ke(this, "groupId");
    Ke(this, "dateId");
    Ke(this, "reactions");
    Ke(this, "template");
    Ke(this, "text");
    Ke(this, "prev", null);
    Ke(this, "next", null);
    Ke(this, "payload", null);
    const {
      _id: n,
      room: r,
      sender: i,
      messageType: s,
      createdAtMS: a,
      updatedAtMS: o,
      extra: u,
      reactions: c
    } = e;
    this.id = n, this.roomId = r, this.senderId = (i == null ? void 0 : i._id) || "", s === "line" ? this.type = u.type : this.type = s, this.status = "delivered", this.createdAt = a, this.updatedAt = o, this.groupId = `${Wn(a).startOf("minute").unix()}-${this.senderId}`, this.dateId = Wn.tz(a).startOf("day").unix(), this.reactions = c ?? [];
  }
  _string(e, n) {
    var i, s, a;
    let r = zr.global.t("message");
    switch (this.type) {
      case "image":
        r = zr.global.t("image");
        break;
      case "sticker":
        r = zr.global.t("sticker");
        break;
      case "video":
        r = zr.global.t("video");
        break;
      case "file":
        r = zr.global.t("file");
        break;
      case "location":
        r = zr.global.t("location");
        break;
      case "audio":
        r = zr.global.t("audio");
        break;
      case "recall":
        return this.senderId === e ? zr.global.t("youUnsentMessage") : zr.global.t("someoneUnsentMessage", [
          ((i = n[this.senderId]) == null ? void 0 : i.nickname) ?? ""
        ]);
      case "payment-select":
        return this.senderId === e ? zr.global.t("paymentSendPaymentRequestMessage", [
          zr.global.t("you")
        ]) : zr.global.t("paymentSendPaymentMessage", [
          ((s = n[this.senderId]) == null ? void 0 : s.nickname) ?? ""
        ]);
    }
    return this.senderId === e ? zr.global.t("youSent", [r]) : zr.global.t("someoneSent", [
      ((a = n[this.senderId]) == null ? void 0 : a.nickname) ?? "",
      r
    ]);
  }
  get string() {
    const {
      state: {
        imkit: { uid: e, users: n }
      }
    } = Wf;
    return this._string(e, n);
  }
  get isIncoming() {
    return !this.isOutgoing;
  }
  get isOutgoing() {
    var r;
    const {
      state: {
        imkit: { rooms: e, uid: n }
      }
    } = Wf;
    return this.senderId === n || ((r = e[this.roomId]) == null ? void 0 : r.isOutgoingGroupSender[this.senderId]);
  }
  get isSystem() {
    return (/* @__PURE__ */ new Set([
      "recall",
      "joinRoom",
      "leaveRoom",
      "addMember",
      "deleteMember",
      "addMembers",
      "announcement"
      /* Announcement */
    ])).has(this.type);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static create(e) {
    if (!e)
      return null;
    switch (e.messageType) {
      case "text":
        return new r0(e);
      case "image":
        return new vEe(e);
      case "sticker":
        return new tx(e);
      case "video":
        return new TEe(e);
      case "file":
        return new wEe(e);
      case "template":
        return new _Ee(e);
      case "flex":
        return new EEe(e);
      case "location":
        return new xEe(e);
      case "audio":
        return new CEe(e);
      case "announcement":
        return new r0(e);
      case "addMember":
        return new IA(e);
      case "deleteMember":
        return new IA(e);
      case "addMembers":
        return new IA(e);
      case "payment-select":
        return new SEe(e);
      case "line":
        switch (e.extra !== "object" && (e.extra = JSON.parse(e.extra)), e.extra.type) {
          case "sticker":
            return new tx(e);
          default:
            return new Fn(e);
        }
      default:
        return new Fn(e);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static createReactive(e) {
    const n = Fn.create(e);
    return n ? ja(n) : null;
  }
  static fromPayload(e, n) {
    const r = Date.now(), { roomId: i } = e, s = {
      _id: n0(),
      room: i,
      sender: { _id: n },
      createdAtMS: r,
      updatedAtMS: r,
      ...e
    }, a = Fn.createReactive(s);
    return a && (a.payload = e), a;
  }
}
const Hl = class Hl extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "text");
    Ke(this, "translatedText");
    Ke(this, "replyId");
    Ke(this, "urls");
    const { message: r, reply: i } = n;
    this.text = r ?? "", this.translatedText = null, this.replyId = (i == null ? void 0 : i._id) ?? null;
    try {
      this.urls = Array.from(
        new Set(
          Hl.autolinker.parse(r).map((s) => typeof s.getUrl == "function" ? s.getUrl() : "").filter((s) => s !== "")
        )
      );
    } catch (s) {
      this.urls = [], console.log(n), console.error(s);
    }
  }
  get string() {
    return Hj(this.html).text();
  }
  get html() {
    return Hl.autolinker.link(this.text.replaceAll(`
`, "<br>"));
  }
  static linkfy(n) {
    try {
      return Hl.autolinker.link(n.replaceAll(`
`, "<br>"));
    } catch (r) {
      return console.error(r), n;
    }
  }
};
Ke(Hl, "autolinker", new Vj({
  className: "underline",
  email: !1,
  phone: !1,
  stripPrefix: !1,
  stripTrailingSlash: !1,
  mention: "imkit",
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  replaceFn: function(n) {
    switch (n.getType()) {
      case "url":
        return !0;
      case "mention": {
        if (!Wf) return `@${n.getMention()}`;
        const r = n.getMention(), i = Wf.state.imkit.users[r];
        return i ? `<span class="cursor-pointer text-blue-500" data-uid="${r}">@${i.nickname}</span>` : `@${n.getMention()}`;
      }
    }
  }
}));
let r0 = Hl;
class vEe extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "images");
    const { images: r, width: i, height: s, thumbnailUrl: a, originalUrl: o } = n;
    r && r.length > 0 ? this.images = r : this.images = [
      {
        id: o,
        width: i,
        height: s,
        thumbnailUrl: a,
        originalUrl: o
      }
    ];
  }
}
class tx extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "stickerId");
    Ke(this, "stickerUrl");
    const { sticker: r, extra: i } = n;
    r ? rbe(r) ? (this.stickerId = "", this.stickerUrl = r) : (this.stickerId = r, this.stickerUrl = "") : (this.stickerId = "", this.stickerUrl = `https://stickershop.line-scdn.net/stickershop/v1/sticker/${i.stickerId}/ios/sticker.png`);
  }
}
class TEe extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "video");
    const {
      id: r,
      width: i,
      height: s,
      thumbnailUrl: a,
      originalUrl: o,
      duration: u,
      thumbnailFile: c,
      video: d
    } = n;
    d ? this.video = d : this.video = {
      id: r || o,
      width: i,
      height: s,
      thumbnailUrl: a,
      originalUrl: o,
      duration: u,
      thumbnailFile: c
    };
  }
}
var Pa = /* @__PURE__ */ ((t) => (t.Buttons = "buttons", t.Confirm = "confirm", t.Carousel = "carousel", t.ImageCarousel = "image_carousel", t))(Pa || {});
class _Ee extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "template");
    // eslint-disable-line @typescript-eslint/no-explicit-any
    Ke(this, "templateType");
    const { template: r } = n;
    try {
      this.template = typeof r == "object" ? r : JSON.parse(r);
      const { type: i } = this.template;
      this.templateType = i;
    } catch (i) {
      console.log(n), console.error(i), this.template = {}, this.templateType = "buttons";
    }
  }
}
var jb = /* @__PURE__ */ ((t) => (t.Bubble = "bubble", t.Carousel = "carousel", t))(jb || {});
class EEe extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "contents");
    // eslint-disable-line @typescript-eslint/no-explicit-any
    Ke(this, "flexType");
    Ke(this, "extra");
    const { contents: r, extra: i } = n;
    try {
      this.contents = typeof r == "object" ? r : JSON.parse(r);
      const { type: s } = this.contents;
      this.flexType = s, this.extra = i;
    } catch (s) {
      console.log(n), console.error(s), this.contents = {}, this.flexType = "bubble", this.extra = {};
    }
  }
}
class xEe extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "address");
    Ke(this, "latitude");
    Ke(this, "longitude");
    const { message: r, latitude: i, longitude: s } = n;
    this.address = r, this.latitude = i, this.longitude = s;
  }
}
class IA extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "members");
    switch (n.messageType) {
      case "addMember":
        this.members = [new Ma(n.member)];
        break;
      case "deleteMember":
        this.members = n.extra.members.map((r) => new Ma(r));
        break;
      case "addMembers":
        this.members = n.extra.invitees.map((r) => new Ma(r));
        break;
      default:
        this.members = [];
    }
  }
}
class wEe extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "url");
    Ke(this, "mimeType");
    Ke(this, "fileName");
    Ke(this, "bytes");
    Ke(this, "fileExtension");
    const { originalUrl: r, extra: i } = n;
    this.url = r;
    const { mimeType: s, fileName: a, bytes: o, fileExtension: u } = typeof i == "object" ? i : JSON.parse(i);
    this.mimeType = s, this.fileName = a, this.bytes = o, this.fileExtension = u;
  }
}
class CEe extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "url");
    Ke(this, "mimeType");
    Ke(this, "fileName");
    Ke(this, "bytes");
    Ke(this, "fileExtension");
    Ke(this, "duration");
    const { originalUrl: r, extra: i, duration: s } = n;
    this.url = r;
    const { mimeType: a, fileName: o, bytes: u, fileExtension: c } = typeof i == "object" ? i : JSON.parse(i);
    this.mimeType = a, this.fileName = o, this.bytes = u, this.fileExtension = c, this.duration = s;
  }
}
class SEe extends Fn {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(n) {
    super(n);
    Ke(this, "paymentId");
    Ke(this, "paymentType");
    Ke(this, "payer");
    Ke(this, "payee");
    Ke(this, "value");
    Ke(this, "timestamp");
    Ke(this, "availableMethods");
    Ke(this, "currency");
    Ke(this, "remark");
    const {
      id: r,
      type: i,
      payer: s,
      payee: a,
      value: o,
      timestamp: u,
      availableMethods: c,
      currency: d,
      remark: l
    } = n.extra;
    this.paymentId = r, this.paymentType = i, this.payer = s, this.payee = a, this.value = o, this.timestamp = u, this.availableMethods = c, this.currency = d, this.remark = l;
  }
}
const sD = Zy ? window : void 0;
function Qd(t) {
  var e;
  const n = ki(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
function Am(...t) {
  const e = [], n = () => {
    e.forEach((o) => o()), e.length = 0;
  }, r = (o, u, c, d) => (o.addEventListener(u, c, d), () => o.removeEventListener(u, c, d)), i = de(() => {
    const o = jl(ki(t[0])).filter((u) => u != null);
    return o.every((u) => typeof u != "string") ? o : void 0;
  }), s = e6(
    () => {
      var o, u;
      return [
        (u = (o = i.value) == null ? void 0 : o.map((c) => Qd(c))) != null ? u : [sD].filter((c) => c != null),
        jl(ki(i.value ? t[1] : t[0])),
        jl(ke(i.value ? t[2] : t[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        ki(i.value ? t[3] : t[2])
      ];
    },
    ([o, u, c, d]) => {
      if (n(), !(o != null && o.length) || !(u != null && u.length) || !(c != null && c.length))
        return;
      const l = JS(d) ? { ...d } : d;
      e.push(
        ...o.flatMap(
          (f) => u.flatMap(
            (p) => c.map((m) => r(f, p, m, l))
          )
        )
      );
    },
    { flush: "post" }
  ), a = () => {
    s(), n();
  };
  return Ky(n), a;
}
let nx = !1;
function rx(t, e, n = {}) {
  const { window: r = sD, ignore: i = [], capture: s = !0, detectIframe: a = !1, controls: o = !1 } = n;
  if (!r)
    return o ? { stop: iu, cancel: iu, trigger: iu } : iu;
  if (G2 && !nx) {
    nx = !0;
    const y = { passive: !0 };
    Array.from(r.document.body.children).forEach((b) => b.addEventListener("click", iu, y)), r.document.documentElement.addEventListener("click", iu, y);
  }
  let u = !0;
  const c = (y) => ki(i).some((b) => {
    if (typeof b == "string")
      return Array.from(r.document.querySelectorAll(b)).some((E) => E === y.target || y.composedPath().includes(E));
    {
      const E = Qd(b);
      return E && (y.target === E || y.composedPath().includes(E));
    }
  });
  function d(y) {
    const b = ki(y);
    return b && b.$.subTree.shapeFlag === 16;
  }
  function l(y, b) {
    const E = ki(y), v = E.$.subTree && E.$.subTree.children;
    return v == null || !Array.isArray(v) ? !1 : v.some((_) => _.el === b.target || b.composedPath().includes(_.el));
  }
  const f = (y) => {
    const b = Qd(t);
    if (y.target != null && !(!(b instanceof Element) && d(t) && l(t, y)) && !(!b || b === y.target || y.composedPath().includes(b))) {
      if ("detail" in y && y.detail === 0 && (u = !c(y)), !u) {
        u = !0;
        return;
      }
      e(y);
    }
  };
  let p = !1;
  const m = [
    Am(r, "click", (y) => {
      p || (p = !0, setTimeout(() => {
        p = !1;
      }, 0), f(y));
    }, { passive: !0, capture: s }),
    Am(r, "pointerdown", (y) => {
      const b = Qd(t);
      u = !c(y) && !!(b && !y.composedPath().includes(b));
    }, { passive: !0 }),
    a && Am(r, "blur", (y) => {
      setTimeout(() => {
        var b;
        const E = Qd(t);
        ((b = r.document.activeElement) == null ? void 0 : b.tagName) === "IFRAME" && !(E != null && E.contains(r.document.activeElement)) && e(y);
      }, 0);
    }, { passive: !0 })
  ].filter(Boolean), g = () => m.forEach((y) => y());
  return o ? {
    stop: g,
    cancel: () => {
      u = !1;
    },
    trigger: (y) => {
      u = !0, f(y), u = !1;
    }
  } : g;
}
const kA = /* @__PURE__ */ new WeakMap(), So = {
  mounted(t, e) {
    const n = !e.modifiers.bubble;
    let r;
    if (typeof e.value == "function")
      r = rx(t, e.value, { capture: n });
    else {
      const [i, s] = e.value;
      r = rx(t, i, Object.assign({ capture: n }, s));
    }
    kA.set(t, r);
  },
  unmounted(t) {
    const e = kA.get(t);
    e && typeof e == "function" ? e() : e == null || e.stop(), kA.delete(t);
  }
};
function DA(t) {
  return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t;
}
function aD(t) {
  const e = window.getComputedStyle(t);
  if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight)
    return !0;
  {
    const n = t.parentNode;
    return !n || n.tagName === "BODY" ? !1 : aD(n);
  }
}
function IEe(t) {
  const e = t || window.event, n = e.target;
  return aD(n) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1);
}
const MA = /* @__PURE__ */ new WeakMap();
function kEe(t, e = !1) {
  const n = ch(e);
  let r = null, i = "";
  Ct(x7(t), (o) => {
    const u = DA(ki(o));
    if (u) {
      const c = u;
      if (MA.get(c) || MA.set(c, c.style.overflow), c.style.overflow !== "hidden" && (i = c.style.overflow), c.style.overflow === "hidden")
        return n.value = !0;
      if (n.value)
        return c.style.overflow = "hidden";
    }
  }, {
    immediate: !0
  });
  const s = () => {
    const o = DA(ki(t));
    !o || n.value || (G2 && (r = Am(
      o,
      "touchmove",
      (u) => {
        IEe(u);
      },
      { passive: !1 }
    )), o.style.overflow = "hidden", n.value = !0);
  }, a = () => {
    const o = DA(ki(t));
    !o || !n.value || (G2 && (r == null || r()), o.style.overflow = i, MA.delete(o), n.value = !1);
  };
  return Ky(a), de({
    get() {
      return n.value;
    },
    set(o) {
      o ? s() : a();
    }
  });
}
function DEe() {
  let t = !1;
  const e = ch(!1);
  return (n, r) => {
    if (e.value = r.value, t)
      return;
    t = !0;
    const i = kEe(n, r.value);
    Ct(e, (s) => i.value = s);
  };
}
DEe();
const MEe = { class: "flex gap-3" }, OEe = { class: "flex flex-col gap-1" }, NEe = { class: "text-sm font-bold text-gray-600 dark:text-gray-300" }, LEe = { class: "multiline-ellipsis text-xs text-gray-500 dark:text-gray-300" }, PEe = {
  key: 0,
  class: "ml-auto h-10 w-10 rounded-sm object-cover"
}, REe = ["innerHTML"], BEe = ["innerHTML"], FEe = {
  key: 2,
  class: "mt-1 break-words text-gray-400"
}, UEe = {
  key: 3,
  class: "my-1 flex flex-col gap-3"
}, $Ee = ["onClick"], HEe = { class: "align-center flex grow flex-col justify-center gap-0.5 overflow-hidden" }, jEe = { class: "ellipsis text-sm font-bold" }, zEe = { class: "multiline-ellipsis text-xs" }, qEe = ["src"], VEe = /* @__PURE__ */ Ze({
  __name: "TextMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = Yt(), r = de(
      () => {
        var m;
        return (m = n.state.imkit.messageMultiList.main) == null ? void 0 : m.map.get(e.message.replyId);
      }
    ), i = de(() => {
      const m = r.value;
      return m ? n.state.imkit.users[m.senderId] : null;
    }), s = de(() => e.message.isIncoming), a = de(() => {
      if (!n.state.imkit.config.settings.linkPreviewEnabled) return [];
      const { urls: m } = e.message;
      return m ? m.map((g) => n.state.imkit.linkPreviews[g]).filter((g) => g) : [];
    }), o = de(() => {
      if (r.value.type === ft.Text)
        return r.value.text;
      if (r.value.type === ft.Image) {
        const { t: m } = Ri();
        return {
          [ft.Text]: m("text"),
          [ft.Image]: m("image"),
          [ft.Video]: m("video"),
          [ft.Sticker]: m("sticker")
        }[r.value.type];
      }
      return "";
    }), u = de(() => {
      if (r.value.type === ft.Image)
        return r.value.images[0];
    }), c = (m) => {
      const g = m.target;
      if (g.tagName === "SPAN" && g.dataset.uid) {
        const y = n.state.imkit.users[g.dataset.uid];
        if (!y) return;
        const { open: b } = Jn({
          component: S6,
          attrs: {
            url: y.avatarUrl ?? "",
            name: y.nickname ?? ""
          }
        });
        b();
      }
    };
    function d(m) {
      return m.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");
    }
    const l = de(() => {
      const m = n.state.imkit.messageSearchKeyword;
      if (m) {
        const g = d(m), y = new RegExp(
          `(?<![a-zA-Z0-9_])${g}(?![a-zA-Z0-9_])`,
          "uig"
        );
        return e.message.html.replace(y, (b) => `<span class="bg-amber-400 text-white">${b}</span>`);
      }
      return e.message.html;
    }), f = (m) => {
      window.open(m, "_blank");
    }, p = () => {
      n.dispatch("imkit/navigateToMessage", e.message.replyId);
    };
    return (m, g) => {
      var b, E, v;
      const y = Mc("src");
      return X(), se(wt, null, [
        r.value ? (X(), se("div", {
          key: 0,
          class: "flex flex-col gap-2",
          onClick: p
        }, [
          W("div", MEe, [
            et(Zr, {
              class: "row-span-2 h-6 w-6 shrink-0 rounded-lg text-sm",
              url: ((b = i.value) == null ? void 0 : b.avatarUrl) ?? "",
              name: ((E = i.value) == null ? void 0 : E.nickname) ?? ""
            }, null, 8, ["url", "name"]),
            W("div", OEe, [
              W("div", NEe, _e((v = i.value) == null ? void 0 : v.nickname), 1),
              W("div", LEe, _e(o.value), 1)
            ]),
            u.value ? Gt((X(), se("img", PEe, null, 512)), [
              [y, u.value.thumbnailUrl]
            ]) : Fe("", !0)
          ]),
          g[0] || (g[0] = W("div", { class: "-mx-4 h-px bg-gray-200 dark:bg-zinc-600" }, null, -1)),
          W("div", {
            class: "break-words",
            innerHTML: l.value
          }, null, 8, REe)
        ])) : (X(), se("div", {
          key: 1,
          class: "break-words",
          onClick: c,
          innerHTML: l.value
        }, null, 8, BEe)),
        s.value && m.message.translatedText ? (X(), se("div", FEe, _e(m.$t("translation")) + ": " + _e(m.message.translatedText), 1)) : Fe("", !0),
        a.value.length > 0 ? (X(), se("div", UEe, [
          (X(!0), se(wt, null, on(a.value, (_) => (X(), se("div", {
            key: _.url,
            class: "flex cursor-pointer items-stretch justify-center gap-2",
            onClick: (D) => f(_.url)
          }, [
            g[1] || (g[1] = W("div", { class: "my-0.5 w-0.5 shrink-0 rounded-full bg-blue-300" }, null, -1)),
            W("div", HEe, [
              W("div", jEe, _e(_.title), 1),
              W("div", zEe, _e(_.description || m.$t("tapOpen")), 1)
            ]),
            _.images.length > 0 ? (X(), se("img", {
              key: 0,
              src: _.images[0],
              class: "my-auto h-12 w-12 shrink-0 rounded-sm object-cover"
            }, null, 8, qEe)) : Fe("", !0)
          ], 8, $Ee))), 128))
        ])) : Fe("", !0)
      ], 64);
    };
  }
}), xa = /* @__PURE__ */ mn(VEe, [["__scopeId", "data-v-914409ef"]]);
function WEe() {
  return Math.random().toString(16).substring(2);
}
var aT = Ze({
  props: {
    // Sets width/diameter of the inner stroke.
    diameter: {
      type: Number,
      required: !1,
      default: 200
    },
    // Sets the total steps/progress to the end.
    totalSteps: {
      type: Number,
      required: !0,
      default: 10
    },
    // Sets the current progress of the inner stroke.
    completedSteps: {
      type: Number,
      required: !0,
      default: 0
    },
    // Sets the start color of the inner stroke (gradient).
    startColor: {
      type: String,
      required: !1,
      default: "#00C58E"
    },
    // Sets the end color of the inner stroke (gradient).
    stopColor: {
      type: String,
      required: !1,
      default: "#00E0A1"
    },
    // Sets the color of the inner stroke to be applied to the shape.
    innerStrokeColor: {
      type: String,
      required: !1,
      default: "#2F495E"
    },
    // Sets the width of the stroke to be applied to the shape.
    // Read more: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
    strokeWidth: {
      type: Number,
      required: !1,
      default: 10
    },
    // Sets the  width of the inner stroke to be applied to the shape.
    innerStrokeWidth: {
      type: Number,
      required: !1,
      default: 10
    },
    // Sets the shape to be used at the end of stroked.
    // Read more: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linecap
    strokeLinecap: {
      type: String,
      required: !1,
      default: "round"
    },
    // Sets how long the animation should take to complete one cycle.
    // Read more: https://www.w3schools.com/cssref/css3_pr_animation-duration.asp
    animateSpeed: {
      type: Number,
      required: !1,
      default: 1e3
    },
    // Sets the frames per seconds to update inner stroke animation.
    fps: {
      type: Number,
      required: !1,
      default: 60
    },
    // Sets how the animation progresses through the duration of each cycle.
    // Read more: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function
    timingFunc: {
      type: String,
      required: !1,
      default: "linear"
    },
    // Sets the inner stroke direction.
    isClockwise: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  setup(t) {
    const e = ja({
      fx: 0.99,
      fy: 0.5,
      cx: 0.5,
      cy: 0.5,
      r: 0.65
    }), n = `rg-${WEe()}`, r = Se(0), i = Se(0), s = Se(null), a = de(() => t.diameter / 2), o = de(() => t.diameter - t.innerStrokeWidth * 2), u = de(() => Math.PI * o.value), c = de(() => t.totalSteps === 0 ? 0 : 100 / t.totalSteps), d = de(() => c.value * t.completedSteps), l = de(() => 2 * Math.PI / t.totalSteps), f = de(() => 100 / t.fps), p = de(() => t.animateSpeed / f.value), m = de(() => l.value / p.value), g = de(() => o.value / 2), y = de(() => ({
      height: `${t.diameter}px`,
      width: `${t.diameter}px`
    })), b = de(() => ({
      height: `${t.diameter}px`,
      width: `${t.diameter}px`,
      strokeWidth: `${t.strokeWidth}px`,
      strokeDashoffset: r.value,
      transition: `stroke-dashoffset ${t.animateSpeed}ms ${t.timingFunc}`
    })), E = de(() => ({
      height: `${t.diameter}px`,
      width: `${t.diameter}px`,
      strokeWidth: `${t.innerStrokeWidth}px`
    })), v = de(() => ({
      width: `${o.value}px`
    }));
    Ct(() => [t.diameter, t.totalSteps, t.completedSteps, t.strokeWidth], M, {
      immediate: !0
    });
    function _(O) {
      const N = 0.5 + 0.5 * Math.cos(O), H = 0.5 + 0.5 * Math.sin(O);
      return {
        x: N,
        y: H
      };
    }
    function D() {
      const O = _(i.value);
      O.x && O.y && (e.fx = O.x, e.fy = O.y);
    }
    function S() {
      return t.isClockwise ? 1 : -1;
    }
    function M() {
      r.value = (100 - d.value) / 100 * u.value * S(), s.value && clearInterval(s.value);
      const O = (t.completedSteps - 1) * l.value;
      let T = (i.value - O) / m.value;
      const N = Math.abs(T - p.value) / p.value, H = T < p.value;
      s.value = setInterval(() => {
        if (H && T >= p.value || !H && T < p.value) {
          s.value && clearInterval(s.value);
          return;
        }
        i.value = O + m.value * T, D(), T += H ? N : -N;
      }, f.value);
    }
    return {
      gradientAnimation: s,
      innerCircleRadius: g,
      radialGradientId: n,
      strokeDashoffset: r,
      innerCircleStyle: v,
      containerStyle: y,
      circumference: u,
      progressStyle: b,
      currentAngle: i,
      strokeStyle: E,
      gradient: e,
      radius: a
    };
  }
});
const QEe = ["width", "height"], GEe = ["id", "fx", "fy", "cx", "cy", "r"], YEe = ["stop-color"], XEe = ["stop-color"], KEe = ["r", "cx", "cy", "stroke", "stroke-dasharray", "stroke-linecap"], ZEe = ["transform", "r", "cx", "cy", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap"];
function JEe(t, e, n, r, i, s) {
  return X(), se("div", {
    class: "vrp__wrapper",
    style: Qt(t.containerStyle)
  }, [W("div", {
    class: "vrp__inner",
    style: Qt(t.innerCircleStyle)
  }, [Jr(t.$slots, "default")], 4), (X(), se("svg", {
    width: t.diameter,
    height: t.diameter,
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, [W("defs", null, [W("radialGradient", {
    id: t.radialGradientId,
    fx: t.gradient.fx,
    fy: t.gradient.fy,
    cx: t.gradient.cx,
    cy: t.gradient.cy,
    r: t.gradient.r
  }, [W("stop", {
    offset: "30%",
    "stop-color": t.startColor
  }, null, 8, YEe), W("stop", {
    offset: "100%",
    "stop-color": t.stopColor
  }, null, 8, XEe)], 8, GEe)]), W("circle", {
    r: t.innerCircleRadius,
    cx: t.radius,
    cy: t.radius,
    fill: "transparent",
    stroke: t.innerStrokeColor,
    "stroke-dasharray": t.circumference,
    "stroke-dashoffset": "0",
    "stroke-linecap": t.strokeLinecap,
    style: Qt(t.strokeStyle)
  }, null, 12, KEe), W("circle", {
    transform: "rotate(270, " + t.radius + "," + t.radius + ")",
    r: t.innerCircleRadius,
    cx: t.radius,
    cy: t.radius,
    fill: "transparent",
    stroke: `url('#${t.radialGradientId}')`,
    "stroke-dasharray": t.circumference,
    "stroke-dashoffset": t.circumference,
    "stroke-linecap": t.strokeLinecap,
    style: Qt(t.progressStyle)
  }, null, 12, ZEe)], 8, QEe))], 4);
}
function e4e(t, e) {
  e === void 0 && (e = {});
  var n = e.insertAt;
  if (!(typeof document > "u")) {
    var r = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style");
    i.type = "text/css", n === "top" && r.firstChild ? r.insertBefore(i, r.firstChild) : r.appendChild(i), i.styleSheet ? i.styleSheet.cssText = t : i.appendChild(document.createTextNode(t));
  }
}
var t4e = `
.vrp__wrapper[data-v-6a0cf1f6] {\r
  position: relative;
}
.vrp__inner[data-v-6a0cf1f6] {\r
  position: absolute;\r
  top: 0;\r
  right: 0;\r
  bottom: 0;\r
  left: 0;\r
  border-radius: 50%;\r
  margin: 0 auto;\r
  display: flex;\r
  flex-direction: column;\r
  align-items: center;\r
  justify-content: center;
}\r
`;
e4e(t4e);
aT.render = JEe;
aT.__scopeId = "data-v-6a0cf1f6";
var yg = /* @__PURE__ */ (() => {
  const t = aT;
  return t.install = (e) => {
    e.component("RadialProgressBar", t);
  }, t;
})();
const n4e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAADNklEQVR4nO2Z20sVURTGd9r9IlLmDYxuBEmBURBSkQWF2EsvUUT17EOFb9ZbFIRBQdEfYIUUBNlDd6KgIqOrhWU3MQiiIior7QLlL9Y5a07b0eM5xzPjmYnzgXj2ntnfWt+stfdes8eYLLLIIuMARgILgU3AdmArsBZYBOSaoANYDBwBvhEfH4BGoNIEDUAJcBLotRx+ChwHDgGHgWbgiUtUMzDLBAFAFfBOHfsE7AbKBrl/NrAL+KJjPgPVw+t1f6dWAz/UoRNAYQpjp2rEBL+BLf56G9+RcqBbHdk5RI4RMlZT8hew1HtPo4bG60qzUlLC6h8FPFYRezyws1e5JEXz03bcIp4JNAHfXZOzHVgH1Gn7GpDjgb0c4IpyNnglotqaiJK7rcBV4JUlSFLhDzDXE6MmYrdCOeXhFXlB1qPOylpf4rpeqcIiS2e6zrsBnFbuWpMOgJtKtC/BvKlN+6kNzL1Z7V9Ih2SBkryUyeyph8n7UKg+fEyHpM6rVSgd8G+BGTeUwcuAe0qQmY1JAXSqHzNMspA8tyaYU9DF9otMAHijvhwA1gCjEw2YYy2pnTrRUg+nxwDaXHvXe6B+wHkLTAE69MZTwEQTEAB5wBJgo27KUroI7vSr5YBjevFSplaoFKuMW1ZlkWcXe726e5eaEAAYq+WQoMnp3K8dB02IABQDXzUIFdJxX4UsNyED0BALgr6RCSb7ZExS4K6PZwKCNmn8jPyEMT4Zi8An7nyl75LGa22UhVDIBKXvlsZlbawPoZB5Sv9CGtu0cSaEQuqVvlEaBdYbYFVYhBB9D3LqsBqnc4d2vAWmh0TIUaVukdMXpzMXOG+JWRFUIUQj4YiQTCp33zAJOOcYBs4CG4BpCUtnn4UQdX6+zgknnWRXXxVvQK7e3EXquJGqEBnD0NDSLxJxDBTo0f9F3Wec0nkwXPdRSA/wXE9yamJzYjgxmJBQgayQgCGUEQEeAA/lpSeeEH0hegTcNkEFUQedz2zFbiEqQq4JWk1QQfSI0/lOIstlqbWEFlnXngX+fIC+T935b/+ORSvwoG9kbAQ/EkmICZ8IV5q161840ilBZJL+TJ2F+U/wF9Y5UmVGwaQRAAAAAElFTkSuQmCC", r4e = {
  key: 0,
  class: "relative flex items-center justify-center"
}, i4e = {
  class: "h-auto max-h-[75vh] w-auto max-w-[90vw] object-contain",
  alt: "",
  style: { "object-fit": "contain" }
}, s4e = {
  key: 0,
  class: "absolute h-auto max-h-[75vh] w-auto max-w-[90vw] object-contain",
  alt: "",
  style: { "object-fit": "contain" }
}, a4e = {
  key: 1,
  class: "mt-4 flex gap-4"
}, o4e = /* @__PURE__ */ Ze({
  __name: "ImageModal",
  props: {
    image: {}
  },
  setup(t) {
    const e = $n(), n = Yt(), r = de(() => n.state.imkit.downloadProgresses), i = de(() => n.state.imkit.imageCache), s = (a) => {
      const o = document.createElement("a"), u = i.value.get(a.originalUrl);
      o.href = u;
      const c = u.split(";")[0].replace("data:", "").split("/")[1];
      o.download = `download.${c}`, o.click();
    };
    return (a, o) => {
      const u = Mc("src");
      return X(), gt(ke(pr), {
        class: "flex items-center justify-center p-4",
        "content-transition": "vfm-fade",
        "overlay-transition": "vfm-fade"
      }, {
        default: Zt(() => [
          a.image ? (X(), se("div", r4e, [
            Gt(W("img", i4e, null, 512), [
              [u, a.image.thumbnailUrl]
            ]),
            a.image.thumbnailUrl !== a.image.originalUrl ? Gt((X(), se("img", s4e, null, 512)), [
              [u, a.image.originalUrl]
            ]) : Fe("", !0),
            (!r.value[a.image.originalUrl] || r.value[a.image.originalUrl] < 1) && a.image.thumbnailUrl !== a.image.originalUrl ? (X(), se(wt, { key: 1 }, [
              o[2] || (o[2] = W("div", { class: "absolute inset-0 bg-gray-800/50 fill-blue-300" }, null, -1)),
              et(ke(yg), {
                class: "absolute!",
                diameter: 40,
                "completed-steps": r.value[a.image.originalUrl] * 100,
                "total-steps": 100,
                "start-color": "#60a5fa",
                "stop-color": "#60a5fa",
                "stroke-width": 4,
                "inner-stroke-width": 4
              }, null, 8, ["completed-steps"])
            ], 64)) : Fe("", !0)
          ])) : Fe("", !0),
          a.image ? (X(), se("div", a4e, [
            W("button", {
              class: "flex grow items-center justify-center gap-1.5 rounded-lg border px-3 py-2 text-base font-normal text-white",
              onClick: o[0] || (o[0] = (c) => s(a.image))
            }, [
              o[3] || (o[3] = W("img", {
                class: "h-5 w-5",
                src: n4e
              }, null, -1)),
              An(" " + _e(a.$t("download")), 1)
            ]),
            W("button", {
              class: "flex grow items-center justify-center gap-1.5 rounded-lg border px-3 py-2 text-base font-normal text-white",
              onClick: o[1] || (o[1] = (c) => ke(e).closeAll())
            }, _e(a.$t("close")), 1)
          ])) : Fe("", !0)
        ]),
        _: 1
      });
    };
  }
}), u4e = ["onClick"], l4e = /* @__PURE__ */ Ze({
  __name: "ImageMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = Yt(), r = de(() => n.state.imkit.uploadProgresses), i = (a, o) => {
      if (e.message.images.length === 1) {
        const { width: c, height: d } = o;
        return c < d ? {
          width: "200px",
          height: `${200 * d / c}px`
        } : {
          width: `${200 * c / d}px`,
          height: "200px"
        };
      } else
        return a === e.message.images.length - 1 && a % 2 === 0 ? { width: `${200 * 2 + 1}px`, height: "200px" } : { width: "200px", height: "200px" };
    }, s = (a) => {
      const { open: o } = Jn({
        component: o4e,
        attrs: {
          image: a
        }
      });
      o();
    };
    return (a, o) => {
      const u = Mc("src");
      return X(), se("div", {
        class: vt(["-mx-3 -my-2 grid gap-px", [a.message.images.length > 1 ? "grid-cols-2" : "grid-cols-1"]])
      }, [
        (X(!0), se(wt, null, on(a.message.images, (c, d) => (X(), se("div", {
          key: c.thumbnailUrl,
          class: vt(["relative flex items-center justify-center", {
            "col-span-2": a.message.images.length > 1 && d === a.message.images.length - 1 && d % 2 === 0
          }]),
          onClick: (l) => s(c)
        }, [
          Gt(W("img", {
            src: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
            class: "border-0 object-cover transition",
            style: Qt(i(d, c))
          }, null, 4), [
            [u, c.thumbnailUrl]
          ]),
          c.thumbnailUrl.startsWith("data") ? (X(), se(wt, { key: 0 }, [
            o[0] || (o[0] = W("div", { class: "absolute inset-0 bg-gray-800/50 fill-blue-300" }, null, -1)),
            et(ke(yg), {
              class: "absolute!",
              diameter: 40,
              "completed-steps": r.value[`${c.id}-original`] === void 0 ? (r.value[`${c.id}-original`] + r.value[`${c.id}-thumbnail`]) / 2 * 100 : r.value[`${c.id}-original`] * 100,
              "total-steps": 100,
              "start-color": "#60a5fa",
              "stop-color": "#60a5fa",
              "stroke-width": 4,
              "inner-stroke-width": 4
            }, null, 8, ["completed-steps"])
          ], 64)) : Fe("", !0)
        ], 10, u4e))), 128))
      ], 2);
    };
  }
}), c4e = ["src"], oD = /* @__PURE__ */ Ze({
  __name: "StickerMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = de(() => e.message.stickerUrl ? e.message.stickerUrl : `/sticker/${e.message.stickerId.split("-")[0]}/${e.message.stickerId}.png`);
    return (r, i) => (X(), se("img", {
      src: n.value,
      class: "h-32 w-32 border-0 object-contain"
    }, null, 8, c4e));
  }
}), uD = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABpUlEQVR4nO3bP68MURzH4RMhNIobEhoJFaFCKRI6Ha/AW9DSKeUqVVqlmkQv8ScUOoVGgUSnQCM8MpFJZJmz17V398zO9ym32nwyO7O/M+eUEhERERERK4Z9OLDq79EcnMIjfPfLB9zA3jJ1OIMv/u41zpUpw0t13VV1B/vL1OCYrXuLS2VKcN6/uzeZGzku2J6PuFrWne0H6j3AkbKu/H+gzidcw66ybiwmUO8xjpd1YrGBOl9xE3vKOrD4QL1XOFvGzs4F6nzDrW6+K2NlZwP13uBiGSPLCdT5gbujG1csL1DvPS6XsbD8QL37OFhaZ3WBxjGuWG2g3sNmxxVtBGp3XNFOoN/HlROlFdoL1Na4os1Avac4nEB1z7E7V1DdlQSqu51AdZsJVJefWMWz3KSHPcGhPOb/lD+KFRk1BmRYrchyx4AsmFVkyXVAFu0H5LVPRV4cDsir54psXmh+TFgE2UBVly14c2QT5xzZBjxHNpLPgaO2bnpHETp4MSfMdA+zdHAanwfi5DhUBydnDtS9w/UcqJvRBcHG7OcREREREVEm5icELZJIi+Y1dAAAAABJRU5ErkJggg==";
var OA, ix;
function vg() {
  if (ix) return OA;
  ix = 1;
  var t;
  return typeof window < "u" ? t = window : typeof cn < "u" ? t = cn : typeof self < "u" ? t = self : t = {}, OA = t, OA;
}
var d4e = vg();
const pe = /* @__PURE__ */ Fr(d4e), f4e = {}, h4e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: f4e
}, Symbol.toStringTag, { value: "Module" })), p4e = /* @__PURE__ */ lF(h4e);
var NA, sx;
function lD() {
  if (sx) return NA;
  sx = 1;
  var t = typeof cn < "u" ? cn : typeof window < "u" ? window : {}, e = p4e, n;
  return typeof document < "u" ? n = document : (n = t["__GLOBAL_DOCUMENT_CACHE@4"], n || (n = t["__GLOBAL_DOCUMENT_CACHE@4"] = e)), NA = n, NA;
}
var m4e = lD();
const ot = /* @__PURE__ */ Fr(m4e);
var kp = { exports: {} }, LA = { exports: {} }, ax;
function g4e() {
  return ax || (ax = 1, function(t) {
    function e() {
      return t.exports = e = Object.assign ? Object.assign.bind() : function(n) {
        for (var r = 1; r < arguments.length; r++) {
          var i = arguments[r];
          for (var s in i) ({}).hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }
        return n;
      }, t.exports.__esModule = !0, t.exports.default = t.exports, e.apply(null, arguments);
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
  }(LA)), LA.exports;
}
var PA, ox;
function A4e() {
  if (ox) return PA;
  ox = 1, PA = e;
  var t = Object.prototype.toString;
  function e(n) {
    if (!n)
      return !1;
    var r = t.call(n);
    return r === "[object Function]" || typeof n == "function" && r !== "[object RegExp]" || typeof window < "u" && // IE8 and below
    (n === window.setTimeout || n === window.alert || n === window.confirm || n === window.prompt);
  }
  return PA;
}
var RA, ux;
function b4e() {
  if (ux) return RA;
  ux = 1;
  function t(i, s) {
    var a = typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
    if (a) return (a = a.call(i)).next.bind(a);
    if (Array.isArray(i) || (a = e(i)) || s) {
      a && (i = a);
      var o = 0;
      return function() {
        return o >= i.length ? { done: !0 } : { done: !1, value: i[o++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function e(i, s) {
    if (i) {
      if (typeof i == "string") return n(i, s);
      var a = Object.prototype.toString.call(i).slice(8, -1);
      if (a === "Object" && i.constructor && (a = i.constructor.name), a === "Map" || a === "Set") return Array.from(i);
      if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return n(i, s);
    }
  }
  function n(i, s) {
    (s == null || s > i.length) && (s = i.length);
    for (var a = 0, o = new Array(s); a < s; a++)
      o[a] = i[a];
    return o;
  }
  var r = /* @__PURE__ */ function() {
    function i() {
      this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map(), this.enabled_ = !1;
    }
    var s = i.prototype;
    return s.getIsEnabled = function() {
      return this.enabled_;
    }, s.enable = function() {
      this.enabled_ = !0;
    }, s.disable = function() {
      this.enabled_ = !1;
    }, s.reset = function() {
      this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map(), this.enabled_ = !1;
    }, s.addInterceptor = function(o, u) {
      this.typeToInterceptorsMap_.has(o) || this.typeToInterceptorsMap_.set(o, /* @__PURE__ */ new Set());
      var c = this.typeToInterceptorsMap_.get(o);
      return c.has(u) ? !1 : (c.add(u), !0);
    }, s.removeInterceptor = function(o, u) {
      var c = this.typeToInterceptorsMap_.get(o);
      return c && c.has(u) ? (c.delete(u), !0) : !1;
    }, s.clearInterceptorsByType = function(o) {
      var u = this.typeToInterceptorsMap_.get(o);
      return u ? (this.typeToInterceptorsMap_.delete(o), this.typeToInterceptorsMap_.set(o, /* @__PURE__ */ new Set()), !0) : !1;
    }, s.clear = function() {
      return this.typeToInterceptorsMap_.size ? (this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map(), !0) : !1;
    }, s.getForType = function(o) {
      return this.typeToInterceptorsMap_.get(o) || /* @__PURE__ */ new Set();
    }, s.execute = function(o, u) {
      for (var c = this.getForType(o), d = t(c), l; !(l = d()).done; ) {
        var f = l.value;
        try {
          u = f(u);
        } catch {
        }
      }
      return u;
    }, i;
  }();
  return RA = r, RA;
}
var BA, lx;
function y4e() {
  if (lx) return BA;
  lx = 1;
  var t = /* @__PURE__ */ function() {
    function n() {
      this.maxAttempts_ = 1, this.delayFactor_ = 0.1, this.fuzzFactor_ = 0.1, this.initialDelay_ = 1e3, this.enabled_ = !1;
    }
    var r = n.prototype;
    return r.getIsEnabled = function() {
      return this.enabled_;
    }, r.enable = function() {
      this.enabled_ = !0;
    }, r.disable = function() {
      this.enabled_ = !1;
    }, r.reset = function() {
      this.maxAttempts_ = 1, this.delayFactor_ = 0.1, this.fuzzFactor_ = 0.1, this.initialDelay_ = 1e3, this.enabled_ = !1;
    }, r.getMaxAttempts = function() {
      return this.maxAttempts_;
    }, r.setMaxAttempts = function(s) {
      this.maxAttempts_ = s;
    }, r.getDelayFactor = function() {
      return this.delayFactor_;
    }, r.setDelayFactor = function(s) {
      this.delayFactor_ = s;
    }, r.getFuzzFactor = function() {
      return this.fuzzFactor_;
    }, r.setFuzzFactor = function(s) {
      this.fuzzFactor_ = s;
    }, r.getInitialDelay = function() {
      return this.initialDelay_;
    }, r.setInitialDelay = function(s) {
      this.initialDelay_ = s;
    }, r.createRetry = function(s) {
      var a = s === void 0 ? {} : s, o = a.maxAttempts, u = a.delayFactor, c = a.fuzzFactor, d = a.initialDelay;
      return new e({
        maxAttempts: o || this.maxAttempts_,
        delayFactor: u || this.delayFactor_,
        fuzzFactor: c || this.fuzzFactor_,
        initialDelay: d || this.initialDelay_
      });
    }, n;
  }(), e = /* @__PURE__ */ function() {
    function n(i) {
      this.maxAttempts_ = i.maxAttempts, this.delayFactor_ = i.delayFactor, this.fuzzFactor_ = i.fuzzFactor, this.currentDelay_ = i.initialDelay, this.currentAttempt_ = 1;
    }
    var r = n.prototype;
    return r.moveToNextAttempt = function() {
      this.currentAttempt_++;
      var s = this.currentDelay_ * this.delayFactor_;
      this.currentDelay_ = this.currentDelay_ + s;
    }, r.shouldRetry = function() {
      return this.currentAttempt_ < this.maxAttempts_;
    }, r.getCurrentDelay = function() {
      return this.currentDelay_;
    }, r.getCurrentMinPossibleDelay = function() {
      return (1 - this.fuzzFactor_) * this.currentDelay_;
    }, r.getCurrentMaxPossibleDelay = function() {
      return (1 + this.fuzzFactor_) * this.currentDelay_;
    }, r.getCurrentFuzzedDelay = function() {
      var s = this.getCurrentMinPossibleDelay(), a = this.getCurrentMaxPossibleDelay();
      return s + Math.random() * (a - s);
    }, n;
  }();
  return BA = t, BA;
}
var FA, cx;
function v4e() {
  if (cx) return FA;
  cx = 1;
  var t = vg(), e = function(i, s) {
    return s === void 0 && (s = !1), function(a, o, u) {
      if (a) {
        i(a);
        return;
      }
      if (o.statusCode >= 400 && o.statusCode <= 599) {
        var c = u;
        if (s)
          if (t.TextDecoder) {
            var d = n(o.headers && o.headers["content-type"]);
            try {
              c = new TextDecoder(d).decode(u);
            } catch {
            }
          } else
            c = String.fromCharCode.apply(null, new Uint8Array(u));
        i({
          cause: c
        });
        return;
      }
      i(null, u);
    };
  };
  function n(r) {
    return r === void 0 && (r = ""), r.toLowerCase().split(";").reduce(function(i, s) {
      var a = s.split("="), o = a[0], u = a[1];
      return o.trim() === "charset" ? u.trim() : i;
    }, "utf-8");
  }
  return FA = e, FA;
}
var dx;
function T4e() {
  if (dx) return kp.exports;
  dx = 1;
  var t = vg(), e = g4e(), n = A4e(), r = b4e(), i = y4e();
  c.httpHandler = v4e(), c.requestInterceptorsStorage = new r(), c.responseInterceptorsStorage = new r(), c.retryManager = new i();
  /**
   * @license
   * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
   * Copyright (c) 2014 David Björklund
   * Available under the MIT license
   * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
   */
  var s = function(m) {
    var g = {};
    return m && m.trim().split(`
`).forEach(function(y) {
      var b = y.indexOf(":"), E = y.slice(0, b).trim().toLowerCase(), v = y.slice(b + 1).trim();
      typeof g[E] > "u" ? g[E] = v : Array.isArray(g[E]) ? g[E].push(v) : g[E] = [g[E], v];
    }), g;
  };
  kp.exports = c, kp.exports.default = c, c.XMLHttpRequest = t.XMLHttpRequest || f, c.XDomainRequest = "withCredentials" in new c.XMLHttpRequest() ? c.XMLHttpRequest : t.XDomainRequest, a(["get", "put", "post", "patch", "head", "delete"], function(p) {
    c[p === "delete" ? "del" : p] = function(m, g, y) {
      return g = u(m, g, y), g.method = p.toUpperCase(), d(g);
    };
  });
  function a(p, m) {
    for (var g = 0; g < p.length; g++)
      m(p[g]);
  }
  function o(p) {
    for (var m in p)
      if (p.hasOwnProperty(m)) return !1;
    return !0;
  }
  function u(p, m, g) {
    var y = p;
    return n(m) ? (g = m, typeof p == "string" && (y = {
      uri: p
    })) : y = e({}, m, {
      uri: p
    }), y.callback = g, y;
  }
  function c(p, m, g) {
    return m = u(p, m, g), d(m);
  }
  function d(p) {
    if (typeof p.callback > "u")
      throw new Error("callback argument missing");
    if (p.requestType && c.requestInterceptorsStorage.getIsEnabled()) {
      var m = {
        uri: p.uri || p.url,
        headers: p.headers || {},
        body: p.body,
        metadata: p.metadata || {},
        retry: p.retry,
        timeout: p.timeout
      }, g = c.requestInterceptorsStorage.execute(p.requestType, m);
      p.uri = g.uri, p.headers = g.headers, p.body = g.body, p.metadata = g.metadata, p.retry = g.retry, p.timeout = g.timeout;
    }
    var y = !1, b = function(K, Q, P) {
      y || (y = !0, p.callback(K, Q, P));
    };
    function E() {
      S.readyState === 4 && !c.responseInterceptorsStorage.getIsEnabled() && setTimeout(D, 0);
    }
    function v() {
      var R = void 0;
      if (S.response ? R = S.response : R = S.responseText || l(S), U)
        try {
          R = JSON.parse(R);
        } catch {
        }
      return R;
    }
    function _(R) {
      if (clearTimeout(V), clearTimeout(p.retryTimeout), R instanceof Error || (R = new Error("" + (R || "Unknown XMLHttpRequest Error"))), R.statusCode = 0, !O && c.retryManager.getIsEnabled() && p.retry && p.retry.shouldRetry()) {
        p.retryTimeout = setTimeout(function() {
          p.retry.moveToNextAttempt(), p.xhr = S, d(p);
        }, p.retry.getCurrentFuzzedDelay());
        return;
      }
      if (p.requestType && c.responseInterceptorsStorage.getIsEnabled()) {
        var K = {
          headers: B.headers || {},
          body: B.body,
          responseUrl: S.responseURL,
          responseType: S.responseType
        }, Q = c.responseInterceptorsStorage.execute(p.requestType, K);
        B.body = Q.body, B.headers = Q.headers;
      }
      return b(R, B);
    }
    function D() {
      if (!O) {
        var R;
        clearTimeout(V), clearTimeout(p.retryTimeout), p.useXDR && S.status === void 0 ? R = 200 : R = S.status === 1223 ? 204 : S.status;
        var K = B, Q = null;
        if (R !== 0 ? (K = {
          body: v(),
          statusCode: R,
          method: N,
          headers: {},
          url: T,
          rawRequest: S
        }, S.getAllResponseHeaders && (K.headers = s(S.getAllResponseHeaders()))) : Q = new Error("Internal XMLHttpRequest Error"), p.requestType && c.responseInterceptorsStorage.getIsEnabled()) {
          var P = {
            headers: K.headers || {},
            body: K.body,
            responseUrl: S.responseURL,
            responseType: S.responseType
          }, I = c.responseInterceptorsStorage.execute(p.requestType, P);
          K.body = I.body, K.headers = I.headers;
        }
        return b(Q, K, K.body);
      }
    }
    var S = p.xhr || null;
    S || (p.cors || p.useXDR ? S = new c.XDomainRequest() : S = new c.XMLHttpRequest());
    var M, O, T = S.url = p.uri || p.url, N = S.method = p.method || "GET", H = p.body || p.data, $ = S.headers = p.headers || {}, j = !!p.sync, U = !1, V, B = {
      body: void 0,
      headers: {},
      statusCode: 0,
      method: N,
      url: T,
      rawRequest: S
    };
    if ("json" in p && p.json !== !1 && (U = !0, $.accept || $.Accept || ($.Accept = "application/json"), N !== "GET" && N !== "HEAD" && ($["content-type"] || $["Content-Type"] || ($["Content-Type"] = "application/json"), H = JSON.stringify(p.json === !0 ? H : p.json))), S.onreadystatechange = E, S.onload = D, S.onerror = _, S.onprogress = function() {
    }, S.onabort = function() {
      O = !0, clearTimeout(p.retryTimeout);
    }, S.ontimeout = _, S.open(N, T, !j, p.username, p.password), j || (S.withCredentials = !!p.withCredentials), !j && p.timeout > 0 && (V = setTimeout(function() {
      if (!O) {
        O = !0, S.abort("timeout");
        var R = new Error("XMLHttpRequest timeout");
        R.code = "ETIMEDOUT", _(R);
      }
    }, p.timeout)), S.setRequestHeader)
      for (M in $)
        $.hasOwnProperty(M) && S.setRequestHeader(M, $[M]);
    else if (p.headers && !o(p.headers))
      throw new Error("Headers cannot be set on an XDomainRequest object");
    return "responseType" in p && (S.responseType = p.responseType), "beforeSend" in p && typeof p.beforeSend == "function" && p.beforeSend(S), S.send(H || null), S;
  }
  function l(p) {
    try {
      if (p.responseType === "document")
        return p.responseXML;
      var m = p.responseXML && p.responseXML.documentElement.nodeName === "parsererror";
      if (p.responseType === "" && !m)
        return p.responseXML;
    } catch {
    }
    return null;
  }
  function f() {
  }
  return kp.exports;
}
var _4e = T4e();
const cD = /* @__PURE__ */ Fr(_4e);
var UA = { exports: {} }, $A, fx;
function E4e() {
  if (fx) return $A;
  fx = 1;
  var t = lD(), e = Object.create || /* @__PURE__ */ function() {
    function T() {
    }
    return function(N) {
      if (arguments.length !== 1)
        throw new Error("Object.create shim only accepts one parameter.");
      return T.prototype = N, new T();
    };
  }();
  function n(T, N) {
    this.name = "ParsingError", this.code = T.code, this.message = N || T.message;
  }
  n.prototype = e(Error.prototype), n.prototype.constructor = n, n.Errors = {
    BadSignature: {
      code: 0,
      message: "Malformed WebVTT signature."
    },
    BadTimeStamp: {
      code: 1,
      message: "Malformed time stamp."
    }
  };
  function r(T) {
    function N($, j, U, V) {
      return ($ | 0) * 3600 + (j | 0) * 60 + (U | 0) + (V | 0) / 1e3;
    }
    var H = T.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
    return H ? H[3] ? N(H[1], H[2], H[3].replace(":", ""), H[4]) : H[1] > 59 ? N(H[1], H[2], 0, H[4]) : N(0, H[1], H[2], H[4]) : null;
  }
  function i() {
    this.values = e(null);
  }
  i.prototype = {
    // Only accept the first assignment to any key.
    set: function(T, N) {
      !this.get(T) && N !== "" && (this.values[T] = N);
    },
    // Return the value for a key, or a default value.
    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
    // a number of possible default values as properties where 'defaultKey' is
    // the key of the property that will be chosen; otherwise it's assumed to be
    // a single value.
    get: function(T, N, H) {
      return H ? this.has(T) ? this.values[T] : N[H] : this.has(T) ? this.values[T] : N;
    },
    // Check whether we have a value for a key.
    has: function(T) {
      return T in this.values;
    },
    // Accept a setting if its one of the given alternatives.
    alt: function(T, N, H) {
      for (var $ = 0; $ < H.length; ++$)
        if (N === H[$]) {
          this.set(T, N);
          break;
        }
    },
    // Accept a setting if its a valid (signed) integer.
    integer: function(T, N) {
      /^-?\d+$/.test(N) && this.set(T, parseInt(N, 10));
    },
    // Accept a setting if its a valid percentage.
    percent: function(T, N) {
      return N.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (N = parseFloat(N), N >= 0 && N <= 100) ? (this.set(T, N), !0) : !1;
    }
  };
  function s(T, N, H, $) {
    var j = $ ? T.split($) : [T];
    for (var U in j)
      if (typeof j[U] == "string") {
        var V = j[U].split(H);
        if (V.length === 2) {
          var B = V[0].trim(), R = V[1].trim();
          N(B, R);
        }
      }
  }
  function a(T, N, H) {
    var $ = T;
    function j() {
      var B = r(T);
      if (B === null)
        throw new n(
          n.Errors.BadTimeStamp,
          "Malformed timestamp: " + $
        );
      return T = T.replace(/^[^\sa-zA-Z-]+/, ""), B;
    }
    function U(B, R) {
      var K = new i();
      s(B, function(Q, P) {
        switch (Q) {
          case "region":
            for (var I = H.length - 1; I >= 0; I--)
              if (H[I].id === P) {
                K.set(Q, H[I].region);
                break;
              }
            break;
          case "vertical":
            K.alt(Q, P, ["rl", "lr"]);
            break;
          case "line":
            var G = P.split(","), te = G[0];
            K.integer(Q, te), K.percent(Q, te) && K.set("snapToLines", !1), K.alt(Q, te, ["auto"]), G.length === 2 && K.alt("lineAlign", G[1], ["start", "center", "end"]);
            break;
          case "position":
            G = P.split(","), K.percent(Q, G[0]), G.length === 2 && K.alt("positionAlign", G[1], ["start", "center", "end"]);
            break;
          case "size":
            K.percent(Q, P);
            break;
          case "align":
            K.alt(Q, P, ["start", "center", "end", "left", "right"]);
            break;
        }
      }, /:/, /\s/), R.region = K.get("region", null), R.vertical = K.get("vertical", "");
      try {
        R.line = K.get("line", "auto");
      } catch {
      }
      R.lineAlign = K.get("lineAlign", "start"), R.snapToLines = K.get("snapToLines", !0), R.size = K.get("size", 100);
      try {
        R.align = K.get("align", "center");
      } catch {
        R.align = K.get("align", "middle");
      }
      try {
        R.position = K.get("position", "auto");
      } catch {
        R.position = K.get("position", {
          start: 0,
          left: 0,
          center: 50,
          middle: 50,
          end: 100,
          right: 100
        }, R.align);
      }
      R.positionAlign = K.get("positionAlign", {
        start: "start",
        left: "start",
        center: "center",
        middle: "center",
        end: "end",
        right: "end"
      }, R.align);
    }
    function V() {
      T = T.replace(/^\s+/, "");
    }
    if (V(), N.startTime = j(), V(), T.substr(0, 3) !== "-->")
      throw new n(
        n.Errors.BadTimeStamp,
        "Malformed time stamp (time stamps must be separated by '-->'): " + $
      );
    T = T.substr(3), V(), N.endTime = j(), V(), U(T, N);
  }
  var o = t.createElement && t.createElement("textarea"), u = {
    c: "span",
    i: "i",
    b: "b",
    u: "u",
    ruby: "ruby",
    rt: "rt",
    v: "span",
    lang: "span"
  }, c = {
    white: "rgba(255,255,255,1)",
    lime: "rgba(0,255,0,1)",
    cyan: "rgba(0,255,255,1)",
    red: "rgba(255,0,0,1)",
    yellow: "rgba(255,255,0,1)",
    magenta: "rgba(255,0,255,1)",
    blue: "rgba(0,0,255,1)",
    black: "rgba(0,0,0,1)"
  }, d = {
    v: "title",
    lang: "lang"
  }, l = {
    rt: "ruby"
  };
  function f(T, N) {
    function H() {
      if (!N)
        return null;
      function te(Z) {
        return N = N.substr(Z.length), Z;
      }
      var ee = N.match(/^([^<]*)(<[^>]*>?)?/);
      return te(ee[1] ? ee[1] : ee[2]);
    }
    function $(te) {
      return o.innerHTML = te, te = o.textContent, o.textContent = "", te;
    }
    function j(te, ee) {
      return !l[ee.localName] || l[ee.localName] === te.localName;
    }
    function U(te, ee) {
      var Z = u[te];
      if (!Z)
        return null;
      var ye = T.document.createElement(Z), he = d[te];
      return he && ee && (ye[he] = ee.trim()), ye;
    }
    for (var V = T.document.createElement("div"), B = V, R, K = []; (R = H()) !== null; ) {
      if (R[0] === "<") {
        if (R[1] === "/") {
          K.length && K[K.length - 1] === R.substr(2).replace(">", "") && (K.pop(), B = B.parentNode);
          continue;
        }
        var Q = r(R.substr(1, R.length - 2)), P;
        if (Q) {
          P = T.document.createProcessingInstruction("timestamp", Q), B.appendChild(P);
          continue;
        }
        var I = R.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
        if (!I || (P = U(I[1], I[3]), !P) || !j(B, P))
          continue;
        if (I[2]) {
          var G = I[2].split(".");
          G.forEach(function(te) {
            var ee = /^bg_/.test(te), Z = ee ? te.slice(3) : te;
            if (c.hasOwnProperty(Z)) {
              var ye = ee ? "background-color" : "color", he = c[Z];
              P.style[ye] = he;
            }
          }), P.className = G.join(" ");
        }
        K.push(I[1]), B.appendChild(P), B = P;
        continue;
      }
      B.appendChild(T.document.createTextNode($(R)));
    }
    return V;
  }
  var p = [
    [1470, 1470],
    [1472, 1472],
    [1475, 1475],
    [1478, 1478],
    [1488, 1514],
    [1520, 1524],
    [1544, 1544],
    [1547, 1547],
    [1549, 1549],
    [1563, 1563],
    [1566, 1610],
    [1645, 1647],
    [1649, 1749],
    [1765, 1766],
    [1774, 1775],
    [1786, 1805],
    [1807, 1808],
    [1810, 1839],
    [1869, 1957],
    [1969, 1969],
    [1984, 2026],
    [2036, 2037],
    [2042, 2042],
    [2048, 2069],
    [2074, 2074],
    [2084, 2084],
    [2088, 2088],
    [2096, 2110],
    [2112, 2136],
    [2142, 2142],
    [2208, 2208],
    [2210, 2220],
    [8207, 8207],
    [64285, 64285],
    [64287, 64296],
    [64298, 64310],
    [64312, 64316],
    [64318, 64318],
    [64320, 64321],
    [64323, 64324],
    [64326, 64449],
    [64467, 64829],
    [64848, 64911],
    [64914, 64967],
    [65008, 65020],
    [65136, 65140],
    [65142, 65276],
    [67584, 67589],
    [67592, 67592],
    [67594, 67637],
    [67639, 67640],
    [67644, 67644],
    [67647, 67669],
    [67671, 67679],
    [67840, 67867],
    [67872, 67897],
    [67903, 67903],
    [67968, 68023],
    [68030, 68031],
    [68096, 68096],
    [68112, 68115],
    [68117, 68119],
    [68121, 68147],
    [68160, 68167],
    [68176, 68184],
    [68192, 68223],
    [68352, 68405],
    [68416, 68437],
    [68440, 68466],
    [68472, 68479],
    [68608, 68680],
    [126464, 126467],
    [126469, 126495],
    [126497, 126498],
    [126500, 126500],
    [126503, 126503],
    [126505, 126514],
    [126516, 126519],
    [126521, 126521],
    [126523, 126523],
    [126530, 126530],
    [126535, 126535],
    [126537, 126537],
    [126539, 126539],
    [126541, 126543],
    [126545, 126546],
    [126548, 126548],
    [126551, 126551],
    [126553, 126553],
    [126555, 126555],
    [126557, 126557],
    [126559, 126559],
    [126561, 126562],
    [126564, 126564],
    [126567, 126570],
    [126572, 126578],
    [126580, 126583],
    [126585, 126588],
    [126590, 126590],
    [126592, 126601],
    [126603, 126619],
    [126625, 126627],
    [126629, 126633],
    [126635, 126651],
    [1114109, 1114109]
  ];
  function m(T) {
    for (var N = 0; N < p.length; N++) {
      var H = p[N];
      if (T >= H[0] && T <= H[1])
        return !0;
    }
    return !1;
  }
  function g(T) {
    var N = [], H = "", $;
    if (!T || !T.childNodes)
      return "ltr";
    function j(B, R) {
      for (var K = R.childNodes.length - 1; K >= 0; K--)
        B.push(R.childNodes[K]);
    }
    function U(B) {
      if (!B || !B.length)
        return null;
      var R = B.pop(), K = R.textContent || R.innerText;
      if (K) {
        var Q = K.match(/^.*(\n|\r)/);
        return Q ? (B.length = 0, Q[0]) : K;
      }
      if (R.tagName === "ruby")
        return U(B);
      if (R.childNodes)
        return j(B, R), U(B);
    }
    for (j(N, T); H = U(N); )
      for (var V = 0; V < H.length; V++)
        if ($ = H.charCodeAt(V), m($))
          return "rtl";
    return "ltr";
  }
  function y(T) {
    if (typeof T.line == "number" && (T.snapToLines || T.line >= 0 && T.line <= 100))
      return T.line;
    if (!T.track || !T.track.textTrackList || !T.track.textTrackList.mediaElement)
      return -1;
    for (var N = T.track, H = N.textTrackList, $ = 0, j = 0; j < H.length && H[j] !== N; j++)
      H[j].mode === "showing" && $++;
    return ++$ * -1;
  }
  function b() {
  }
  b.prototype.applyStyles = function(T, N) {
    N = N || this.div;
    for (var H in T)
      T.hasOwnProperty(H) && (N.style[H] = T[H]);
  }, b.prototype.formatStyle = function(T, N) {
    return T === 0 ? 0 : T + N;
  };
  function E(T, N, H) {
    b.call(this), this.cue = N, this.cueDiv = f(T, N.text);
    var $ = {
      color: "rgba(255, 255, 255, 1)",
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline",
      writingMode: N.vertical === "" ? "horizontal-tb" : N.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext"
    };
    this.applyStyles($, this.cueDiv), this.div = T.document.createElement("div"), $ = {
      direction: g(this.cueDiv),
      writingMode: N.vertical === "" ? "horizontal-tb" : N.vertical === "lr" ? "vertical-lr" : "vertical-rl",
      unicodeBidi: "plaintext",
      textAlign: N.align === "middle" ? "center" : N.align,
      font: H.font,
      whiteSpace: "pre-line",
      position: "absolute"
    }, this.applyStyles($), this.div.appendChild(this.cueDiv);
    var j = 0;
    switch (N.positionAlign) {
      case "start":
      case "line-left":
        j = N.position;
        break;
      case "center":
        j = N.position - N.size / 2;
        break;
      case "end":
      case "line-right":
        j = N.position - N.size;
        break;
    }
    N.vertical === "" ? this.applyStyles({
      left: this.formatStyle(j, "%"),
      width: this.formatStyle(N.size, "%")
    }) : this.applyStyles({
      top: this.formatStyle(j, "%"),
      height: this.formatStyle(N.size, "%")
    }), this.move = function(U) {
      this.applyStyles({
        top: this.formatStyle(U.top, "px"),
        bottom: this.formatStyle(U.bottom, "px"),
        left: this.formatStyle(U.left, "px"),
        right: this.formatStyle(U.right, "px"),
        height: this.formatStyle(U.height, "px"),
        width: this.formatStyle(U.width, "px")
      });
    };
  }
  E.prototype = e(b.prototype), E.prototype.constructor = E;
  function v(T) {
    var N, H, $, j;
    if (T.div) {
      H = T.div.offsetHeight, $ = T.div.offsetWidth, j = T.div.offsetTop;
      var U = (U = T.div.childNodes) && (U = U[0]) && U.getClientRects && U.getClientRects();
      T = T.div.getBoundingClientRect(), N = U ? Math.max(U[0] && U[0].height || 0, T.height / U.length) : 0;
    }
    this.left = T.left, this.right = T.right, this.top = T.top || j, this.height = T.height || H, this.bottom = T.bottom || j + (T.height || H), this.width = T.width || $, this.lineHeight = N !== void 0 ? N : T.lineHeight;
  }
  v.prototype.move = function(T, N) {
    switch (N = N !== void 0 ? N : this.lineHeight, T) {
      case "+x":
        this.left += N, this.right += N;
        break;
      case "-x":
        this.left -= N, this.right -= N;
        break;
      case "+y":
        this.top += N, this.bottom += N;
        break;
      case "-y":
        this.top -= N, this.bottom -= N;
        break;
    }
  }, v.prototype.overlaps = function(T) {
    return this.left < T.right && this.right > T.left && this.top < T.bottom && this.bottom > T.top;
  }, v.prototype.overlapsAny = function(T) {
    for (var N = 0; N < T.length; N++)
      if (this.overlaps(T[N]))
        return !0;
    return !1;
  }, v.prototype.within = function(T) {
    return this.top >= T.top && this.bottom <= T.bottom && this.left >= T.left && this.right <= T.right;
  }, v.prototype.overlapsOppositeAxis = function(T, N) {
    switch (N) {
      case "+x":
        return this.left < T.left;
      case "-x":
        return this.right > T.right;
      case "+y":
        return this.top < T.top;
      case "-y":
        return this.bottom > T.bottom;
    }
  }, v.prototype.intersectPercentage = function(T) {
    var N = Math.max(0, Math.min(this.right, T.right) - Math.max(this.left, T.left)), H = Math.max(0, Math.min(this.bottom, T.bottom) - Math.max(this.top, T.top)), $ = N * H;
    return $ / (this.height * this.width);
  }, v.prototype.toCSSCompatValues = function(T) {
    return {
      top: this.top - T.top,
      bottom: T.bottom - this.bottom,
      left: this.left - T.left,
      right: T.right - this.right,
      height: this.height,
      width: this.width
    };
  }, v.getSimpleBoxPosition = function(T) {
    var N = T.div ? T.div.offsetHeight : T.tagName ? T.offsetHeight : 0, H = T.div ? T.div.offsetWidth : T.tagName ? T.offsetWidth : 0, $ = T.div ? T.div.offsetTop : T.tagName ? T.offsetTop : 0;
    T = T.div ? T.div.getBoundingClientRect() : T.tagName ? T.getBoundingClientRect() : T;
    var j = {
      left: T.left,
      right: T.right,
      top: T.top || $,
      height: T.height || N,
      bottom: T.bottom || $ + (T.height || N),
      width: T.width || H
    };
    return j;
  };
  function _(T, N, H, $) {
    function j(Z, ye) {
      for (var he, Ee = new v(Z), be = 1, ve = 0; ve < ye.length; ve++) {
        for (; Z.overlapsOppositeAxis(H, ye[ve]) || Z.within(H) && Z.overlapsAny($); )
          Z.move(ye[ve]);
        if (Z.within(H))
          return Z;
        var Ce = Z.intersectPercentage(H);
        be > Ce && (he = new v(Z), be = Ce), Z = new v(Ee);
      }
      return he || Ee;
    }
    var U = new v(N), V = N.cue, B = y(V), R = [];
    if (V.snapToLines) {
      var K;
      switch (V.vertical) {
        case "":
          R = ["+y", "-y"], K = "height";
          break;
        case "rl":
          R = ["+x", "-x"], K = "width";
          break;
        case "lr":
          R = ["-x", "+x"], K = "width";
          break;
      }
      var Q = U.lineHeight, P = Q * Math.round(B), I = H[K] + Q, G = R[0];
      Math.abs(P) > I && (P = P < 0 ? -1 : 1, P *= Math.ceil(I / Q) * Q), B < 0 && (P += V.vertical === "" ? H.height : H.width, R = R.reverse()), U.move(G, P);
    } else {
      var te = U.lineHeight / H.height * 100;
      switch (V.lineAlign) {
        case "center":
          B -= te / 2;
          break;
        case "end":
          B -= te;
          break;
      }
      switch (V.vertical) {
        case "":
          N.applyStyles({
            top: N.formatStyle(B, "%")
          });
          break;
        case "rl":
          N.applyStyles({
            left: N.formatStyle(B, "%")
          });
          break;
        case "lr":
          N.applyStyles({
            right: N.formatStyle(B, "%")
          });
          break;
      }
      R = ["+y", "-x", "+x", "-y"], U = new v(N);
    }
    var ee = j(U, R);
    N.move(ee.toCSSCompatValues(H));
  }
  function D() {
  }
  D.StringDecoder = function() {
    return {
      decode: function(T) {
        if (!T)
          return "";
        if (typeof T != "string")
          throw new Error("Error - expected string data.");
        return decodeURIComponent(encodeURIComponent(T));
      }
    };
  }, D.convertCueToDOMTree = function(T, N) {
    return !T || !N ? null : f(T, N);
  };
  var S = 0.05, M = "sans-serif", O = "1.5%";
  return D.processCues = function(T, N, H) {
    if (!T || !N || !H)
      return null;
    for (; H.firstChild; )
      H.removeChild(H.firstChild);
    var $ = T.document.createElement("div");
    $.style.position = "absolute", $.style.left = "0", $.style.right = "0", $.style.top = "0", $.style.bottom = "0", $.style.margin = O, H.appendChild($);
    function j(Q) {
      for (var P = 0; P < Q.length; P++)
        if (Q[P].hasBeenReset || !Q[P].displayState)
          return !0;
      return !1;
    }
    if (!j(N)) {
      for (var U = 0; U < N.length; U++)
        $.appendChild(N[U].displayState);
      return;
    }
    var V = [], B = v.getSimpleBoxPosition($), R = Math.round(B.height * S * 100) / 100, K = {
      font: R + "px " + M
    };
    (function() {
      for (var Q, P, I = 0; I < N.length; I++)
        P = N[I], Q = new E(T, P, K), $.appendChild(Q.div), _(T, Q, B, V), P.displayState = Q.div, V.push(v.getSimpleBoxPosition(Q));
    })();
  }, D.Parser = function(T, N, H) {
    H || (H = N, N = {}), N || (N = {}), this.window = T, this.vttjs = N, this.state = "INITIAL", this.buffer = "", this.decoder = H || new TextDecoder("utf8"), this.regionList = [];
  }, D.Parser.prototype = {
    // If the error is a ParsingError then report it to the consumer if
    // possible. If it's not a ParsingError then throw it like normal.
    reportOrThrowError: function(T) {
      if (T instanceof n)
        this.onparsingerror && this.onparsingerror(T);
      else
        throw T;
    },
    parse: function(T) {
      var N = this;
      T && (N.buffer += N.decoder.decode(T, { stream: !0 }));
      function H() {
        for (var Q = N.buffer, P = 0; P < Q.length && Q[P] !== "\r" && Q[P] !== `
`; )
          ++P;
        var I = Q.substr(0, P);
        return Q[P] === "\r" && ++P, Q[P] === `
` && ++P, N.buffer = Q.substr(P), I;
      }
      function $(Q) {
        var P = new i();
        if (s(Q, function(G, te) {
          switch (G) {
            case "id":
              P.set(G, te);
              break;
            case "width":
              P.percent(G, te);
              break;
            case "lines":
              P.integer(G, te);
              break;
            case "regionanchor":
            case "viewportanchor":
              var ee = te.split(",");
              if (ee.length !== 2)
                break;
              var Z = new i();
              if (Z.percent("x", ee[0]), Z.percent("y", ee[1]), !Z.has("x") || !Z.has("y"))
                break;
              P.set(G + "X", Z.get("x")), P.set(G + "Y", Z.get("y"));
              break;
            case "scroll":
              P.alt(G, te, ["up"]);
              break;
          }
        }, /=/, /\s/), P.has("id")) {
          var I = new (N.vttjs.VTTRegion || N.window.VTTRegion)();
          I.width = P.get("width", 100), I.lines = P.get("lines", 3), I.regionAnchorX = P.get("regionanchorX", 0), I.regionAnchorY = P.get("regionanchorY", 100), I.viewportAnchorX = P.get("viewportanchorX", 0), I.viewportAnchorY = P.get("viewportanchorY", 100), I.scroll = P.get("scroll", ""), N.onregion && N.onregion(I), N.regionList.push({
            id: P.get("id"),
            region: I
          });
        }
      }
      function j(Q) {
        var P = new i();
        s(Q, function(I, G) {
          switch (I) {
            case "MPEGT":
              P.integer(I + "S", G);
              break;
            case "LOCA":
              P.set(I + "L", r(G));
              break;
          }
        }, /[^\d]:/, /,/), N.ontimestampmap && N.ontimestampmap({
          MPEGTS: P.get("MPEGTS"),
          LOCAL: P.get("LOCAL")
        });
      }
      function U(Q) {
        Q.match(/X-TIMESTAMP-MAP/) ? s(Q, function(P, I) {
          switch (P) {
            case "X-TIMESTAMP-MAP":
              j(I);
              break;
          }
        }, /=/) : s(Q, function(P, I) {
          switch (P) {
            case "Region":
              $(I);
              break;
          }
        }, /:/);
      }
      try {
        var V;
        if (N.state === "INITIAL") {
          if (!/\r\n|\n/.test(N.buffer))
            return this;
          V = H();
          var B = V.match(/^WEBVTT([ \t].*)?$/);
          if (!B || !B[0])
            throw new n(n.Errors.BadSignature);
          N.state = "HEADER";
        }
        for (var R = !1; N.buffer; ) {
          if (!/\r\n|\n/.test(N.buffer))
            return this;
          switch (R ? R = !1 : V = H(), N.state) {
            case "HEADER":
              /:/.test(V) ? U(V) : V || (N.state = "ID");
              continue;
            case "NOTE":
              V || (N.state = "ID");
              continue;
            case "ID":
              if (/^NOTE($|[ \t])/.test(V)) {
                N.state = "NOTE";
                break;
              }
              if (!V)
                continue;
              N.cue = new (N.vttjs.VTTCue || N.window.VTTCue)(0, 0, "");
              try {
                N.cue.align = "center";
              } catch {
                N.cue.align = "middle";
              }
              if (N.state = "CUE", V.indexOf("-->") === -1) {
                N.cue.id = V;
                continue;
              }
            // Process line as start of a cue.
            /*falls through*/
            case "CUE":
              try {
                a(V, N.cue, N.regionList);
              } catch (Q) {
                N.reportOrThrowError(Q), N.cue = null, N.state = "BADCUE";
                continue;
              }
              N.state = "CUETEXT";
              continue;
            case "CUETEXT":
              var K = V.indexOf("-->") !== -1;
              if (!V || K && (R = !0)) {
                N.oncue && N.oncue(N.cue), N.cue = null, N.state = "ID";
                continue;
              }
              N.cue.text && (N.cue.text += `
`), N.cue.text += V.replace(/\u2028/g, `
`).replace(/u2029/g, `
`);
              continue;
            case "BADCUE":
              V || (N.state = "ID");
              continue;
          }
        }
      } catch (Q) {
        N.reportOrThrowError(Q), N.state === "CUETEXT" && N.cue && N.oncue && N.oncue(N.cue), N.cue = null, N.state = N.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    },
    flush: function() {
      var T = this;
      try {
        if (T.buffer += T.decoder.decode(), (T.cue || T.state === "HEADER") && (T.buffer += `

`, T.parse()), T.state === "INITIAL")
          throw new n(n.Errors.BadSignature);
      } catch (N) {
        T.reportOrThrowError(N);
      }
      return T.onflush && T.onflush(), this;
    }
  }, $A = D, $A;
}
var HA, hx;
function x4e() {
  if (hx) return HA;
  hx = 1;
  var t = "auto", e = {
    "": 1,
    lr: 1,
    rl: 1
  }, n = {
    start: 1,
    center: 1,
    end: 1,
    left: 1,
    right: 1,
    auto: 1,
    "line-left": 1,
    "line-right": 1
  };
  function r(a) {
    if (typeof a != "string")
      return !1;
    var o = e[a.toLowerCase()];
    return o ? a.toLowerCase() : !1;
  }
  function i(a) {
    if (typeof a != "string")
      return !1;
    var o = n[a.toLowerCase()];
    return o ? a.toLowerCase() : !1;
  }
  function s(a, o, u) {
    this.hasBeenReset = !1;
    var c = "", d = !1, l = a, f = o, p = u, m = null, g = "", y = !0, b = "auto", E = "start", v = "auto", _ = "auto", D = 100, S = "center";
    Object.defineProperties(this, {
      id: {
        enumerable: !0,
        get: function() {
          return c;
        },
        set: function(M) {
          c = "" + M;
        }
      },
      pauseOnExit: {
        enumerable: !0,
        get: function() {
          return d;
        },
        set: function(M) {
          d = !!M;
        }
      },
      startTime: {
        enumerable: !0,
        get: function() {
          return l;
        },
        set: function(M) {
          if (typeof M != "number")
            throw new TypeError("Start time must be set to a number.");
          l = M, this.hasBeenReset = !0;
        }
      },
      endTime: {
        enumerable: !0,
        get: function() {
          return f;
        },
        set: function(M) {
          if (typeof M != "number")
            throw new TypeError("End time must be set to a number.");
          f = M, this.hasBeenReset = !0;
        }
      },
      text: {
        enumerable: !0,
        get: function() {
          return p;
        },
        set: function(M) {
          p = "" + M, this.hasBeenReset = !0;
        }
      },
      region: {
        enumerable: !0,
        get: function() {
          return m;
        },
        set: function(M) {
          m = M, this.hasBeenReset = !0;
        }
      },
      vertical: {
        enumerable: !0,
        get: function() {
          return g;
        },
        set: function(M) {
          var O = r(M);
          if (O === !1)
            throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
          g = O, this.hasBeenReset = !0;
        }
      },
      snapToLines: {
        enumerable: !0,
        get: function() {
          return y;
        },
        set: function(M) {
          y = !!M, this.hasBeenReset = !0;
        }
      },
      line: {
        enumerable: !0,
        get: function() {
          return b;
        },
        set: function(M) {
          if (typeof M != "number" && M !== t)
            throw new SyntaxError("Line: an invalid number or illegal string was specified.");
          b = M, this.hasBeenReset = !0;
        }
      },
      lineAlign: {
        enumerable: !0,
        get: function() {
          return E;
        },
        set: function(M) {
          var O = i(M);
          O ? (E = O, this.hasBeenReset = !0) : console.warn("lineAlign: an invalid or illegal string was specified.");
        }
      },
      position: {
        enumerable: !0,
        get: function() {
          return v;
        },
        set: function(M) {
          if (M < 0 || M > 100)
            throw new Error("Position must be between 0 and 100.");
          v = M, this.hasBeenReset = !0;
        }
      },
      positionAlign: {
        enumerable: !0,
        get: function() {
          return _;
        },
        set: function(M) {
          var O = i(M);
          O ? (_ = O, this.hasBeenReset = !0) : console.warn("positionAlign: an invalid or illegal string was specified.");
        }
      },
      size: {
        enumerable: !0,
        get: function() {
          return D;
        },
        set: function(M) {
          if (M < 0 || M > 100)
            throw new Error("Size must be between 0 and 100.");
          D = M, this.hasBeenReset = !0;
        }
      },
      align: {
        enumerable: !0,
        get: function() {
          return S;
        },
        set: function(M) {
          var O = i(M);
          if (!O)
            throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
          S = O, this.hasBeenReset = !0;
        }
      }
    }), this.displayState = void 0;
  }
  return s.prototype.getCueAsHTML = function() {
    return WebVTT.convertCueToDOMTree(window, this.text);
  }, HA = s, HA;
}
var jA, px;
function w4e() {
  if (px) return jA;
  px = 1;
  var t = {
    "": !0,
    up: !0
  };
  function e(i) {
    if (typeof i != "string")
      return !1;
    var s = t[i.toLowerCase()];
    return s ? i.toLowerCase() : !1;
  }
  function n(i) {
    return typeof i == "number" && i >= 0 && i <= 100;
  }
  function r() {
    var i = 100, s = 3, a = 0, o = 100, u = 0, c = 100, d = "";
    Object.defineProperties(this, {
      width: {
        enumerable: !0,
        get: function() {
          return i;
        },
        set: function(l) {
          if (!n(l))
            throw new Error("Width must be between 0 and 100.");
          i = l;
        }
      },
      lines: {
        enumerable: !0,
        get: function() {
          return s;
        },
        set: function(l) {
          if (typeof l != "number")
            throw new TypeError("Lines must be set to a number.");
          s = l;
        }
      },
      regionAnchorY: {
        enumerable: !0,
        get: function() {
          return o;
        },
        set: function(l) {
          if (!n(l))
            throw new Error("RegionAnchorX must be between 0 and 100.");
          o = l;
        }
      },
      regionAnchorX: {
        enumerable: !0,
        get: function() {
          return a;
        },
        set: function(l) {
          if (!n(l))
            throw new Error("RegionAnchorY must be between 0 and 100.");
          a = l;
        }
      },
      viewportAnchorY: {
        enumerable: !0,
        get: function() {
          return c;
        },
        set: function(l) {
          if (!n(l))
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          c = l;
        }
      },
      viewportAnchorX: {
        enumerable: !0,
        get: function() {
          return u;
        },
        set: function(l) {
          if (!n(l))
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          u = l;
        }
      },
      scroll: {
        enumerable: !0,
        get: function() {
          return d;
        },
        set: function(l) {
          var f = e(l);
          f === !1 ? console.warn("Scroll: an invalid or illegal string was specified.") : d = f;
        }
      }
    });
  }
  return jA = r, jA;
}
var mx;
function C4e() {
  if (mx) return UA.exports;
  mx = 1;
  var t = vg(), e = UA.exports = {
    WebVTT: E4e(),
    VTTCue: x4e(),
    VTTRegion: w4e()
  };
  t.vttjs = e, t.WebVTT = e.WebVTT;
  var n = e.VTTCue, r = e.VTTRegion, i = t.VTTCue, s = t.VTTRegion;
  return e.shim = function() {
    t.VTTCue = n, t.VTTRegion = r;
  }, e.restore = function() {
    t.VTTCue = i, t.VTTRegion = s;
  }, t.VTTCue || e.shim(), UA.exports;
}
var S4e = C4e();
const gx = /* @__PURE__ */ Fr(S4e);
function fr() {
  return fr = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, fr.apply(null, arguments);
}
var Ax = "https://example.com", Tg = function(e, n) {
  if (/^[a-z]+:/i.test(n))
    return n;
  /^data:/.test(e) && (e = pe.location && pe.location.href || "");
  var r = /^\/\//.test(e), i = !pe.location && !/\/\//i.test(e);
  e = new pe.URL(e, pe.location || Ax);
  var s = new URL(n, e);
  return i ? s.href.slice(Ax.length) : r ? s.href.slice(s.protocol.length) : s.href;
}, oT = /* @__PURE__ */ function() {
  function t() {
    this.listeners = {};
  }
  var e = t.prototype;
  return e.on = function(r, i) {
    this.listeners[r] || (this.listeners[r] = []), this.listeners[r].push(i);
  }, e.off = function(r, i) {
    if (!this.listeners[r])
      return !1;
    var s = this.listeners[r].indexOf(i);
    return this.listeners[r] = this.listeners[r].slice(0), this.listeners[r].splice(s, 1), s > -1;
  }, e.trigger = function(r) {
    var i = this.listeners[r];
    if (i)
      if (arguments.length === 2)
        for (var s = i.length, a = 0; a < s; ++a)
          i[a].call(this, arguments[1]);
      else
        for (var o = Array.prototype.slice.call(arguments, 1), u = i.length, c = 0; c < u; ++c)
          i[c].apply(this, o);
  }, e.dispose = function() {
    this.listeners = {};
  }, e.pipe = function(r) {
    this.on("data", function(i) {
      r.push(i);
    });
  }, t;
}(), I4e = function(e) {
  return pe.atob ? pe.atob(e) : Buffer.from(e, "base64").toString("binary");
};
function dD(t) {
  for (var e = I4e(t), n = new Uint8Array(e.length), r = 0; r < e.length; r++)
    n[r] = e.charCodeAt(r);
  return n;
}
/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */
class k4e extends oT {
  constructor() {
    super(), this.buffer = "";
  }
  /**
   * Add new data to be parsed.
   *
   * @param {string} data the text to process
   */
  push(e) {
    let n;
    for (this.buffer += e, n = this.buffer.indexOf(`
`); n > -1; n = this.buffer.indexOf(`
`))
      this.trigger("data", this.buffer.substring(0, n)), this.buffer = this.buffer.substring(n + 1);
  }
}
const D4e = "	", zA = function(t) {
  const e = /([0-9.]*)?@?([0-9.]*)?/.exec(t || ""), n = {};
  return e[1] && (n.length = parseInt(e[1], 10)), e[2] && (n.offset = parseInt(e[2], 10)), n;
}, M4e = function() {
  const n = "(?:" + "[^=]*" + ")=(?:" + '"[^"]*"|[^,]*' + ")";
  return new RegExp("(?:^|,)(" + n + ")");
}, ai = function(t) {
  const e = {};
  if (!t)
    return e;
  const n = t.split(M4e());
  let r = n.length, i;
  for (; r--; )
    n[r] !== "" && (i = /([^=]*)=(.*)/.exec(n[r]).slice(1), i[0] = i[0].replace(/^\s+|\s+$/g, ""), i[1] = i[1].replace(/^\s+|\s+$/g, ""), i[1] = i[1].replace(/^['"](.*)['"]$/g, "$1"), e[i[0]] = i[1]);
  return e;
}, bx = (t) => {
  const e = t.split("x"), n = {};
  return e[0] && (n.width = parseInt(e[0], 10)), e[1] && (n.height = parseInt(e[1], 10)), n;
};
class O4e extends oT {
  constructor() {
    super(), this.customParsers = [], this.tagMappers = [];
  }
  /**
   * Parses an additional line of input.
   *
   * @param {string} line a single line of an M3U8 file to parse
   */
  push(e) {
    let n, r;
    if (e = e.trim(), e.length === 0)
      return;
    if (e[0] !== "#") {
      this.trigger("data", {
        type: "uri",
        uri: e
      });
      return;
    }
    this.tagMappers.reduce((s, a) => {
      const o = a(e);
      return o === e ? s : s.concat([o]);
    }, [e]).forEach((s) => {
      for (let a = 0; a < this.customParsers.length; a++)
        if (this.customParsers[a].call(this, s))
          return;
      if (s.indexOf("#EXT") !== 0) {
        this.trigger("data", {
          type: "comment",
          text: s.slice(1)
        });
        return;
      }
      if (s = s.replace("\r", ""), n = /^#EXTM3U/.exec(s), n) {
        this.trigger("data", {
          type: "tag",
          tagType: "m3u"
        });
        return;
      }
      if (n = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "inf"
        }, n[1] && (r.duration = parseFloat(n[1])), n[2] && (r.title = n[2]), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "targetduration"
        }, n[1] && (r.duration = parseInt(n[1], 10)), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-VERSION:([0-9.]*)?/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "version"
        }, n[1] && (r.version = parseInt(n[1], 10)), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "media-sequence"
        }, n[1] && (r.number = parseInt(n[1], 10)), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "discontinuity-sequence"
        }, n[1] && (r.number = parseInt(n[1], 10)), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "playlist-type"
        }, n[1] && (r.playlistType = n[1]), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-BYTERANGE:(.*)?$/.exec(s), n) {
        r = fr(zA(n[1]), {
          type: "tag",
          tagType: "byterange"
        }), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "allow-cache"
        }, n[1] && (r.allowed = !/NO/.test(n[1])), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-MAP:(.*)$/.exec(s), n) {
        if (r = {
          type: "tag",
          tagType: "map"
        }, n[1]) {
          const a = ai(n[1]);
          a.URI && (r.uri = a.URI), a.BYTERANGE && (r.byterange = zA(a.BYTERANGE));
        }
        this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-STREAM-INF:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "stream-inf"
        }, n[1] && (r.attributes = ai(n[1]), r.attributes.RESOLUTION && (r.attributes.RESOLUTION = bx(r.attributes.RESOLUTION)), r.attributes.BANDWIDTH && (r.attributes.BANDWIDTH = parseInt(r.attributes.BANDWIDTH, 10)), r.attributes["FRAME-RATE"] && (r.attributes["FRAME-RATE"] = parseFloat(r.attributes["FRAME-RATE"])), r.attributes["PROGRAM-ID"] && (r.attributes["PROGRAM-ID"] = parseInt(r.attributes["PROGRAM-ID"], 10))), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-MEDIA:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "media"
        }, n[1] && (r.attributes = ai(n[1])), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-ENDLIST/.exec(s), n) {
        this.trigger("data", {
          type: "tag",
          tagType: "endlist"
        });
        return;
      }
      if (n = /^#EXT-X-DISCONTINUITY/.exec(s), n) {
        this.trigger("data", {
          type: "tag",
          tagType: "discontinuity"
        });
        return;
      }
      if (n = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "program-date-time"
        }, n[1] && (r.dateTimeString = n[1], r.dateTimeObject = new Date(n[1])), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-KEY:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "key"
        }, n[1] && (r.attributes = ai(n[1]), r.attributes.IV && (r.attributes.IV.substring(0, 2).toLowerCase() === "0x" && (r.attributes.IV = r.attributes.IV.substring(2)), r.attributes.IV = r.attributes.IV.match(/.{8}/g), r.attributes.IV[0] = parseInt(r.attributes.IV[0], 16), r.attributes.IV[1] = parseInt(r.attributes.IV[1], 16), r.attributes.IV[2] = parseInt(r.attributes.IV[2], 16), r.attributes.IV[3] = parseInt(r.attributes.IV[3], 16), r.attributes.IV = new Uint32Array(r.attributes.IV))), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-START:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "start"
        }, n[1] && (r.attributes = ai(n[1]), r.attributes["TIME-OFFSET"] = parseFloat(r.attributes["TIME-OFFSET"]), r.attributes.PRECISE = /YES/.test(r.attributes.PRECISE)), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "cue-out-cont"
        }, n[1] ? r.data = n[1] : r.data = "", this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-CUE-OUT:(.*)?$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "cue-out"
        }, n[1] ? r.data = n[1] : r.data = "", this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-CUE-IN:?(.*)?$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "cue-in"
        }, n[1] ? r.data = n[1] : r.data = "", this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-SKIP:(.*)$/.exec(s), n && n[1]) {
        r = {
          type: "tag",
          tagType: "skip"
        }, r.attributes = ai(n[1]), r.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (r.attributes["SKIPPED-SEGMENTS"] = parseInt(r.attributes["SKIPPED-SEGMENTS"], 10)), r.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (r.attributes["RECENTLY-REMOVED-DATERANGES"] = r.attributes["RECENTLY-REMOVED-DATERANGES"].split(D4e)), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-PART:(.*)$/.exec(s), n && n[1]) {
        r = {
          type: "tag",
          tagType: "part"
        }, r.attributes = ai(n[1]), ["DURATION"].forEach(function(a) {
          r.attributes.hasOwnProperty(a) && (r.attributes[a] = parseFloat(r.attributes[a]));
        }), ["INDEPENDENT", "GAP"].forEach(function(a) {
          r.attributes.hasOwnProperty(a) && (r.attributes[a] = /YES/.test(r.attributes[a]));
        }), r.attributes.hasOwnProperty("BYTERANGE") && (r.attributes.byterange = zA(r.attributes.BYTERANGE)), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(s), n && n[1]) {
        r = {
          type: "tag",
          tagType: "server-control"
        }, r.attributes = ai(n[1]), ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(a) {
          r.attributes.hasOwnProperty(a) && (r.attributes[a] = parseFloat(r.attributes[a]));
        }), ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(a) {
          r.attributes.hasOwnProperty(a) && (r.attributes[a] = /YES/.test(r.attributes[a]));
        }), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-PART-INF:(.*)$/.exec(s), n && n[1]) {
        r = {
          type: "tag",
          tagType: "part-inf"
        }, r.attributes = ai(n[1]), ["PART-TARGET"].forEach(function(a) {
          r.attributes.hasOwnProperty(a) && (r.attributes[a] = parseFloat(r.attributes[a]));
        }), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(s), n && n[1]) {
        r = {
          type: "tag",
          tagType: "preload-hint"
        }, r.attributes = ai(n[1]), ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(a) {
          if (r.attributes.hasOwnProperty(a)) {
            r.attributes[a] = parseInt(r.attributes[a], 10);
            const o = a === "BYTERANGE-LENGTH" ? "length" : "offset";
            r.attributes.byterange = r.attributes.byterange || {}, r.attributes.byterange[o] = r.attributes[a], delete r.attributes[a];
          }
        }), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(s), n && n[1]) {
        r = {
          type: "tag",
          tagType: "rendition-report"
        }, r.attributes = ai(n[1]), ["LAST-MSN", "LAST-PART"].forEach(function(a) {
          r.attributes.hasOwnProperty(a) && (r.attributes[a] = parseInt(r.attributes[a], 10));
        }), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-DATERANGE:(.*)$/.exec(s), n && n[1]) {
        r = {
          type: "tag",
          tagType: "daterange"
        }, r.attributes = ai(n[1]), ["ID", "CLASS"].forEach(function(o) {
          r.attributes.hasOwnProperty(o) && (r.attributes[o] = String(r.attributes[o]));
        }), ["START-DATE", "END-DATE"].forEach(function(o) {
          r.attributes.hasOwnProperty(o) && (r.attributes[o] = new Date(r.attributes[o]));
        }), ["DURATION", "PLANNED-DURATION"].forEach(function(o) {
          r.attributes.hasOwnProperty(o) && (r.attributes[o] = parseFloat(r.attributes[o]));
        }), ["END-ON-NEXT"].forEach(function(o) {
          r.attributes.hasOwnProperty(o) && (r.attributes[o] = /YES/i.test(r.attributes[o]));
        }), ["SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN"].forEach(function(o) {
          r.attributes.hasOwnProperty(o) && (r.attributes[o] = r.attributes[o].toString(16));
        });
        const a = /^X-([A-Z]+-)+[A-Z]+$/;
        for (const o in r.attributes) {
          if (!a.test(o))
            continue;
          const u = /[0-9A-Fa-f]{6}/g.test(r.attributes[o]), c = /^\d+(\.\d+)?$/.test(r.attributes[o]);
          r.attributes[o] = u ? r.attributes[o].toString(16) : c ? parseFloat(r.attributes[o]) : String(r.attributes[o]);
        }
        this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(s), n) {
        this.trigger("data", {
          type: "tag",
          tagType: "independent-segments"
        });
        return;
      }
      if (n = /^#EXT-X-I-FRAMES-ONLY/.exec(s), n) {
        this.trigger("data", {
          type: "tag",
          tagType: "i-frames-only"
        });
        return;
      }
      if (n = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "content-steering"
        }, r.attributes = ai(n[1]), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "i-frame-playlist"
        }, r.attributes = ai(n[1]), r.attributes.URI && (r.uri = r.attributes.URI), r.attributes.BANDWIDTH && (r.attributes.BANDWIDTH = parseInt(r.attributes.BANDWIDTH, 10)), r.attributes.RESOLUTION && (r.attributes.RESOLUTION = bx(r.attributes.RESOLUTION)), r.attributes["AVERAGE-BANDWIDTH"] && (r.attributes["AVERAGE-BANDWIDTH"] = parseInt(r.attributes["AVERAGE-BANDWIDTH"], 10)), r.attributes["FRAME-RATE"] && (r.attributes["FRAME-RATE"] = parseFloat(r.attributes["FRAME-RATE"])), this.trigger("data", r);
        return;
      }
      if (n = /^#EXT-X-DEFINE:(.*)$/.exec(s), n) {
        r = {
          type: "tag",
          tagType: "define"
        }, r.attributes = ai(n[1]), this.trigger("data", r);
        return;
      }
      this.trigger("data", {
        type: "tag",
        data: s.slice(4)
      });
    });
  }
  /**
   * Add a parser for custom headers
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.customType   the custom type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  addParser({
    expression: e,
    customType: n,
    dataParser: r,
    segment: i
  }) {
    typeof r != "function" && (r = (s) => s), this.customParsers.push((s) => {
      if (e.exec(s))
        return this.trigger("data", {
          type: "custom",
          data: r(s),
          customType: n,
          segment: i
        }), !0;
    });
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  addTagMapper({
    expression: e,
    map: n
  }) {
    const r = (i) => e.test(i) ? n(i) : i;
    this.tagMappers.push(r);
  }
}
const N4e = (t) => t.toLowerCase().replace(/-(\w)/g, (e) => e[1].toUpperCase()), no = function(t) {
  const e = {};
  return Object.keys(t).forEach(function(n) {
    e[N4e(n)] = t[n];
  }), e;
}, qA = function(t) {
  const {
    serverControl: e,
    targetDuration: n,
    partTargetDuration: r
  } = t;
  if (!e)
    return;
  const i = "#EXT-X-SERVER-CONTROL", s = "holdBack", a = "partHoldBack", o = n && n * 3, u = r && r * 2;
  n && !e.hasOwnProperty(s) && (e[s] = o, this.trigger("info", {
    message: `${i} defaulting HOLD-BACK to targetDuration * 3 (${o}).`
  })), o && e[s] < o && (this.trigger("warn", {
    message: `${i} clamping HOLD-BACK (${e[s]}) to targetDuration * 3 (${o})`
  }), e[s] = o), r && !e.hasOwnProperty(a) && (e[a] = r * 3, this.trigger("info", {
    message: `${i} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${e[a]}).`
  })), r && e[a] < u && (this.trigger("warn", {
    message: `${i} clamping PART-HOLD-BACK (${e[a]}) to partTargetDuration * 2 (${u}).`
  }), e[a] = u);
};
let L4e = class extends oT {
  constructor(e = {}) {
    super(), this.lineStream = new k4e(), this.parseStream = new O4e(), this.lineStream.pipe(this.parseStream), this.mainDefinitions = e.mainDefinitions || {}, this.params = new URL(e.uri, "https://a.com").searchParams, this.lastProgramDateTime = null;
    const n = this, r = [];
    let i = {}, s, a, o = !1;
    const u = function() {
    }, c = {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    }, d = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    let l = 0;
    this.manifest = {
      allowCache: !0,
      discontinuityStarts: [],
      dateRanges: [],
      iFramePlaylists: [],
      segments: []
    };
    let f = 0, p = 0;
    const m = {};
    this.on("end", () => {
      i.uri || !i.parts && !i.preloadHints || (!i.map && s && (i.map = s), !i.key && a && (i.key = a), !i.timeline && typeof l == "number" && (i.timeline = l), this.manifest.preloadSegment = i);
    }), this.parseStream.on("data", function(g) {
      let y, b;
      if (n.manifest.definitions) {
        for (const E in n.manifest.definitions)
          if (g.uri && (g.uri = g.uri.replace(`{$${E}}`, n.manifest.definitions[E])), g.attributes)
            for (const v in g.attributes)
              typeof g.attributes[v] == "string" && (g.attributes[v] = g.attributes[v].replace(`{$${E}}`, n.manifest.definitions[E]));
      }
      ({
        tag() {
          ({
            version() {
              g.version && (this.manifest.version = g.version);
            },
            "allow-cache"() {
              this.manifest.allowCache = g.allowed, "allowed" in g || (this.trigger("info", {
                message: "defaulting allowCache to YES"
              }), this.manifest.allowCache = !0);
            },
            byterange() {
              const E = {};
              "length" in g && (i.byterange = E, E.length = g.length, "offset" in g || (g.offset = f)), "offset" in g && (i.byterange = E, E.offset = g.offset), f = E.offset + E.length;
            },
            endlist() {
              this.manifest.endList = !0;
            },
            inf() {
              "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", {
                message: "defaulting media sequence to zero"
              })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", {
                message: "defaulting discontinuity sequence to zero"
              })), g.title && (i.title = g.title), g.duration > 0 && (i.duration = g.duration), g.duration === 0 && (i.duration = 0.01, this.trigger("info", {
                message: "updating zero segment duration to a small value"
              })), this.manifest.segments = r;
            },
            key() {
              if (!g.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (g.attributes.METHOD === "NONE") {
                a = null;
                return;
              }
              if (!g.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (g.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: g.attributes
                };
                return;
              }
              if (g.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: g.attributes.URI
                };
                return;
              }
              if (g.attributes.KEYFORMAT === d) {
                if (["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(g.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (g.attributes.METHOD === "SAMPLE-AES-CENC" && this.trigger("warn", {
                  message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                }), g.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(g.attributes.KEYID && g.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {}, this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: g.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: g.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: dD(g.attributes.URI.split(",")[1])
                };
                return;
              }
              g.attributes.METHOD || this.trigger("warn", {
                message: "defaulting key method to AES-128"
              }), a = {
                method: g.attributes.METHOD || "AES-128",
                uri: g.attributes.URI
              }, typeof g.attributes.IV < "u" && (a.iv = g.attributes.IV);
            },
            "media-sequence"() {
              if (!isFinite(g.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + g.number
                });
                return;
              }
              this.manifest.mediaSequence = g.number;
            },
            "discontinuity-sequence"() {
              if (!isFinite(g.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + g.number
                });
                return;
              }
              this.manifest.discontinuitySequence = g.number, l = g.number;
            },
            "playlist-type"() {
              if (!/VOD|EVENT/.test(g.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + g.playlist
                });
                return;
              }
              this.manifest.playlistType = g.playlistType;
            },
            map() {
              s = {}, g.uri && (s.uri = g.uri), g.byterange && (s.byterange = g.byterange), a && (s.key = a);
            },
            "stream-inf"() {
              if (this.manifest.playlists = r, this.manifest.mediaGroups = this.manifest.mediaGroups || c, !g.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              i.attributes || (i.attributes = {}), fr(i.attributes, g.attributes);
            },
            media() {
              if (this.manifest.mediaGroups = this.manifest.mediaGroups || c, !(g.attributes && g.attributes.TYPE && g.attributes["GROUP-ID"] && g.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              const E = this.manifest.mediaGroups[g.attributes.TYPE];
              E[g.attributes["GROUP-ID"]] = E[g.attributes["GROUP-ID"]] || {}, y = E[g.attributes["GROUP-ID"]], b = {
                default: /yes/i.test(g.attributes.DEFAULT)
              }, b.default ? b.autoselect = !0 : b.autoselect = /yes/i.test(g.attributes.AUTOSELECT), g.attributes.LANGUAGE && (b.language = g.attributes.LANGUAGE), g.attributes.URI && (b.uri = g.attributes.URI), g.attributes["INSTREAM-ID"] && (b.instreamId = g.attributes["INSTREAM-ID"]), g.attributes.CHARACTERISTICS && (b.characteristics = g.attributes.CHARACTERISTICS), g.attributes.FORCED && (b.forced = /yes/i.test(g.attributes.FORCED)), y[g.attributes.NAME] = b;
            },
            discontinuity() {
              l += 1, i.discontinuity = !0, this.manifest.discontinuityStarts.push(r.length);
            },
            "program-date-time"() {
              typeof this.manifest.dateTimeString > "u" && (this.manifest.dateTimeString = g.dateTimeString, this.manifest.dateTimeObject = g.dateTimeObject), i.dateTimeString = g.dateTimeString, i.dateTimeObject = g.dateTimeObject;
              const {
                lastProgramDateTime: E
              } = this;
              this.lastProgramDateTime = new Date(g.dateTimeString).getTime(), E === null && this.manifest.segments.reduceRight((v, _) => (_.programDateTime = v - _.duration * 1e3, _.programDateTime), this.lastProgramDateTime);
            },
            targetduration() {
              if (!isFinite(g.duration) || g.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + g.duration
                });
                return;
              }
              this.manifest.targetDuration = g.duration, qA.call(this, this.manifest);
            },
            start() {
              if (!g.attributes || isNaN(g.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: g.attributes["TIME-OFFSET"],
                precise: g.attributes.PRECISE
              };
            },
            "cue-out"() {
              i.cueOut = g.data;
            },
            "cue-out-cont"() {
              i.cueOutCont = g.data;
            },
            "cue-in"() {
              i.cueIn = g.data;
            },
            skip() {
              this.manifest.skip = no(g.attributes), this.warnOnMissingAttributes_("#EXT-X-SKIP", g.attributes, ["SKIPPED-SEGMENTS"]);
            },
            part() {
              o = !0;
              const E = this.manifest.segments.length, v = no(g.attributes);
              i.parts = i.parts || [], i.parts.push(v), v.byterange && (v.byterange.hasOwnProperty("offset") || (v.byterange.offset = p), p = v.byterange.offset + v.byterange.length);
              const _ = i.parts.length - 1;
              this.warnOnMissingAttributes_(`#EXT-X-PART #${_} for segment #${E}`, g.attributes, ["URI", "DURATION"]), this.manifest.renditionReports && this.manifest.renditionReports.forEach((D, S) => {
                D.hasOwnProperty("lastPart") || this.trigger("warn", {
                  message: `#EXT-X-RENDITION-REPORT #${S} lacks required attribute(s): LAST-PART`
                });
              });
            },
            "server-control"() {
              const E = this.manifest.serverControl = no(g.attributes);
              E.hasOwnProperty("canBlockReload") || (E.canBlockReload = !1, this.trigger("info", {
                message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
              })), qA.call(this, this.manifest), E.canSkipDateranges && !E.hasOwnProperty("canSkipUntil") && this.trigger("warn", {
                message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
              });
            },
            "preload-hint"() {
              const E = this.manifest.segments.length, v = no(g.attributes), _ = v.type && v.type === "PART";
              i.preloadHints = i.preloadHints || [], i.preloadHints.push(v), v.byterange && (v.byterange.hasOwnProperty("offset") || (v.byterange.offset = _ ? p : 0, _ && (p = v.byterange.offset + v.byterange.length)));
              const D = i.preloadHints.length - 1;
              if (this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${D} for segment #${E}`, g.attributes, ["TYPE", "URI"]), !!v.type)
                for (let S = 0; S < i.preloadHints.length - 1; S++) {
                  const M = i.preloadHints[S];
                  M.type && M.type === v.type && this.trigger("warn", {
                    message: `#EXT-X-PRELOAD-HINT #${D} for segment #${E} has the same TYPE ${v.type} as preload hint #${S}`
                  });
                }
            },
            "rendition-report"() {
              const E = no(g.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [], this.manifest.renditionReports.push(E);
              const v = this.manifest.renditionReports.length - 1, _ = ["LAST-MSN", "URI"];
              o && _.push("LAST-PART"), this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${v}`, g.attributes, _);
            },
            "part-inf"() {
              this.manifest.partInf = no(g.attributes), this.warnOnMissingAttributes_("#EXT-X-PART-INF", g.attributes, ["PART-TARGET"]), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), qA.call(this, this.manifest);
            },
            daterange() {
              this.manifest.dateRanges.push(no(g.attributes));
              const E = this.manifest.dateRanges.length - 1;
              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${E}`, g.attributes, ["ID", "START-DATE"]);
              const v = this.manifest.dateRanges[E];
              v.endDate && v.startDate && new Date(v.endDate) < new Date(v.startDate) && this.trigger("warn", {
                message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"
              }), v.duration && v.duration < 0 && this.trigger("warn", {
                message: "EXT-X-DATERANGE DURATION must not be negative"
              }), v.plannedDuration && v.plannedDuration < 0 && this.trigger("warn", {
                message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative"
              });
              const _ = !!v.endOnNext;
              if (_ && !v.class && this.trigger("warn", {
                message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"
              }), _ && (v.duration || v.endDate) && this.trigger("warn", {
                message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"
              }), v.duration && v.endDate) {
                const S = v.startDate.getTime() + v.duration * 1e3;
                this.manifest.dateRanges[E].endDate = new Date(S);
              }
              if (!m[v.id])
                m[v.id] = v;
              else {
                for (const S in m[v.id])
                  if (v[S] && JSON.stringify(m[v.id][S]) !== JSON.stringify(v[S])) {
                    this.trigger("warn", {
                      message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"
                    });
                    break;
                  }
                const D = this.manifest.dateRanges.findIndex((S) => S.id === v.id);
                this.manifest.dateRanges[D] = fr(this.manifest.dateRanges[D], v), m[v.id] = fr(m[v.id], v), this.manifest.dateRanges.pop();
              }
            },
            "independent-segments"() {
              this.manifest.independentSegments = !0;
            },
            "i-frames-only"() {
              this.manifest.iFramesOnly = !0, this.requiredCompatibilityversion(this.manifest.version, 4);
            },
            "content-steering"() {
              this.manifest.contentSteering = no(g.attributes), this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING", g.attributes, ["SERVER-URI"]);
            },
            /** @this {Parser} */
            define() {
              this.manifest.definitions = this.manifest.definitions || {};
              const E = (v, _) => {
                if (v in this.manifest.definitions) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: Duplicate name ${v}`
                  });
                  return;
                }
                this.manifest.definitions[v] = _;
              };
              if ("QUERYPARAM" in g.attributes) {
                if ("NAME" in g.attributes || "IMPORT" in g.attributes) {
                  this.trigger("error", {
                    message: "EXT-X-DEFINE: Invalid attributes"
                  });
                  return;
                }
                const v = this.params.get(g.attributes.QUERYPARAM);
                if (!v) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No query param ${g.attributes.QUERYPARAM}`
                  });
                  return;
                }
                E(g.attributes.QUERYPARAM, decodeURIComponent(v));
                return;
              }
              if ("NAME" in g.attributes) {
                if ("IMPORT" in g.attributes) {
                  this.trigger("error", {
                    message: "EXT-X-DEFINE: Invalid attributes"
                  });
                  return;
                }
                if (!("VALUE" in g.attributes) || typeof g.attributes.VALUE != "string") {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No value for ${g.attributes.NAME}`
                  });
                  return;
                }
                E(g.attributes.NAME, g.attributes.VALUE);
                return;
              }
              if ("IMPORT" in g.attributes) {
                if (!this.mainDefinitions[g.attributes.IMPORT]) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No value ${g.attributes.IMPORT} to import, or IMPORT used on main playlist`
                  });
                  return;
                }
                E(g.attributes.IMPORT, this.mainDefinitions[g.attributes.IMPORT]);
                return;
              }
              this.trigger("error", {
                message: "EXT-X-DEFINE: No attribute"
              });
            },
            "i-frame-playlist"() {
              this.manifest.iFramePlaylists.push({
                attributes: g.attributes,
                uri: g.uri,
                timeline: l
              }), this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF", g.attributes, ["BANDWIDTH", "URI"]);
            }
          }[g.tagType] || u).call(n);
        },
        uri() {
          i.uri = g.uri, r.push(i), this.manifest.targetDuration && !("duration" in i) && (this.trigger("warn", {
            message: "defaulting segment duration to the target duration"
          }), i.duration = this.manifest.targetDuration), a && (i.key = a), i.timeline = l, s && (i.map = s), p = 0, this.lastProgramDateTime !== null && (i.programDateTime = this.lastProgramDateTime, this.lastProgramDateTime += i.duration * 1e3), i = {};
        },
        comment() {
        },
        custom() {
          g.segment ? (i.custom = i.custom || {}, i.custom[g.customType] = g.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[g.customType] = g.data);
        }
      })[g.type].call(n);
    });
  }
  requiredCompatibilityversion(e, n) {
    (e < n || !e) && this.trigger("warn", {
      message: `manifest must be at least version ${n}`
    });
  }
  warnOnMissingAttributes_(e, n, r) {
    const i = [];
    r.forEach(function(s) {
      n.hasOwnProperty(s) || i.push(s);
    }), i.length && this.trigger("warn", {
      message: `${e} lacks required attribute(s): ${i.join(", ")}`
    });
  }
  /**
   * Parse the input string and update the manifest object.
   *
   * @param {string} chunk a potentially incomplete portion of the manifest
   */
  push(e) {
    this.lineStream.push(e);
  }
  /**
   * Flush any remaining input. This can be handy if the last line of an M3U8
   * manifest did not contain a trailing newline but the file has been
   * completely received.
   */
  end() {
    this.lineStream.push(`
`), this.manifest.dateRanges.length && this.lastProgramDateTime === null && this.trigger("warn", {
      message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"
    }), this.lastProgramDateTime = null, this.trigger("end");
  }
  /**
   * Add an additional parser for non-standard tags
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.customType   the custom type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  addParser(e) {
    this.parseStream.addParser(e);
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  addTagMapper(e) {
    this.parseStream.addTagMapper(e);
  }
};
var Su = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
}, P4e = ["video", "audio", "text"], yx = ["Video", "Audio", "Text"], fD = function(e) {
  return e && e.replace(/avc1\.(\d+)\.(\d+)/i, function(n, r, i) {
    var s = ("00" + Number(r).toString(16)).slice(-2), a = ("00" + Number(i).toString(16)).slice(-2);
    return "avc1." + s + "00" + a;
  });
}, Gs = function(e) {
  e === void 0 && (e = "");
  var n = e.split(","), r = [];
  return n.forEach(function(i) {
    i = i.trim();
    var s;
    P4e.forEach(function(a) {
      var o = Su[a].exec(i.toLowerCase());
      if (!(!o || o.length <= 1)) {
        s = a;
        var u = i.substring(0, o[1].length), c = i.replace(u, "");
        r.push({
          type: u,
          details: c,
          mediaType: a
        });
      }
    }), s || r.push({
      type: i,
      details: "",
      mediaType: "unknown"
    });
  }), r;
}, R4e = function(e, n) {
  if (!e.mediaGroups.AUDIO || !n)
    return null;
  var r = e.mediaGroups.AUDIO[n];
  if (!r)
    return null;
  for (var i in r) {
    var s = r[i];
    if (s.default && s.playlists)
      return Gs(s.playlists[0].attributes.CODECS);
  }
  return null;
}, hD = function(e) {
  return e === void 0 && (e = ""), Su.audio.test(e.trim().toLowerCase());
}, B4e = function(e) {
  return e === void 0 && (e = ""), Su.text.test(e.trim().toLowerCase());
}, uc = function(e) {
  if (!(!e || typeof e != "string")) {
    var n = e.toLowerCase().split(",").map(function(s) {
      return fD(s.trim());
    }), r = "video";
    n.length === 1 && hD(n[0]) ? r = "audio" : n.length === 1 && B4e(n[0]) && (r = "application");
    var i = "mp4";
    return n.every(function(s) {
      return Su.mp4.test(s);
    }) ? i = "mp4" : n.every(function(s) {
      return Su.webm.test(s);
    }) ? i = "webm" : n.every(function(s) {
      return Su.ogg.test(s);
    }) && (i = "ogg"), r + "/" + i + ';codecs="' + e + '"';
  }
}, mf = function(e, n) {
  return e === void 0 && (e = ""), n === void 0 && (n = !1), pe.MediaSource && pe.MediaSource.isTypeSupported && pe.MediaSource.isTypeSupported(uc(e)) || n && pe.ManagedMediaSource && pe.ManagedMediaSource.isTypeSupported && pe.ManagedMediaSource.isTypeSupported(uc(e)) || !1;
}, VA = function(e) {
  return e === void 0 && (e = ""), e.toLowerCase().split(",").every(function(n) {
    n = n.trim();
    for (var r = 0; r < yx.length; r++) {
      var i = yx[r];
      if (Su["muxer" + i].test(n))
        return !0;
    }
    return !1;
  });
}, vx = "mp4a.40.2", F4e = "avc1.4d400d", U4e = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i, $4e = /^application\/dash\+xml/i, pD = function(e) {
  return U4e.test(e) ? "hls" : $4e.test(e) ? "dash" : e === "application/vnd.videojs.vhs+json" ? "vhs-json" : null;
}, H4e = function(e) {
  return e.toString(2).length;
}, j4e = function(e) {
  return Math.ceil(H4e(e) / 8);
}, mD = function(e) {
  return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer;
}, z4e = function(e) {
  return mD(e);
}, kt = function(e) {
  return e instanceof Uint8Array ? e : (!Array.isArray(e) && !z4e(e) && !(e instanceof ArrayBuffer) && (typeof e != "number" || typeof e == "number" && e !== e ? e = 0 : e = [e]), new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0));
}, Rr = pe.BigInt || Number, zb = [Rr("0x1"), Rr("0x100"), Rr("0x10000"), Rr("0x1000000"), Rr("0x100000000"), Rr("0x10000000000"), Rr("0x1000000000000"), Rr("0x100000000000000"), Rr("0x10000000000000000")];
(function() {
  var t = new Uint16Array([65484]), e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  return e[0] === 255 ? "big" : e[0] === 204 ? "little" : "unknown";
})();
var q4e = function(e, n) {
  var r = n === void 0 ? {} : n, i = r.signed, s = i === void 0 ? !1 : i, a = r.le, o = a === void 0 ? !1 : a;
  e = kt(e);
  var u = o ? "reduce" : "reduceRight", c = e[u] ? e[u] : Array.prototype[u], d = c.call(e, function(f, p, m) {
    var g = o ? m : Math.abs(m + 1 - e.length);
    return f + Rr(p) * zb[g];
  }, Rr(0));
  if (s) {
    var l = zb[e.length] / Rr(2) - Rr(1);
    d = Rr(d), d > l && (d -= l, d -= l, d -= Rr(2));
  }
  return Number(d);
}, V4e = function(e, n) {
  var r = {}, i = r.le, s = i === void 0 ? !1 : i;
  (typeof e != "bigint" && typeof e != "number" || typeof e == "number" && e !== e) && (e = 0), e = Rr(e);
  for (var a = j4e(e), o = new Uint8Array(new ArrayBuffer(a)), u = 0; u < a; u++) {
    var c = s ? u : Math.abs(u + 1 - o.length);
    o[c] = Number(e / zb[u] & Rr(255)), e < 0 && (o[c] = Math.abs(~o[c]), o[c] -= u === 0 ? 1 : 2);
  }
  return o;
}, gD = function(e, n) {
  if (typeof e != "string" && e && typeof e.toString == "function" && (e = e.toString()), typeof e != "string")
    return new Uint8Array();
  n || (e = unescape(encodeURIComponent(e)));
  for (var r = new Uint8Array(e.length), i = 0; i < e.length; i++)
    r[i] = e.charCodeAt(i);
  return r;
}, W4e = function() {
  for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
    n[r] = arguments[r];
  if (n = n.filter(function(o) {
    return o && (o.byteLength || o.length) && typeof o != "string";
  }), n.length <= 1)
    return kt(n[0]);
  var i = n.reduce(function(o, u, c) {
    return o + (u.byteLength || u.length);
  }, 0), s = new Uint8Array(i), a = 0;
  return n.forEach(function(o) {
    o = kt(o), s.set(o, a), a += o.byteLength;
  }), s;
}, Yn = function(e, n, r) {
  var i = r === void 0 ? {} : r, s = i.offset, a = s === void 0 ? 0 : s, o = i.mask, u = o === void 0 ? [] : o;
  e = kt(e), n = kt(n);
  var c = n.every ? n.every : Array.prototype.every;
  return n.length && e.length - a >= n.length && // ie 11 doesn't support every on uin8
  c.call(n, function(d, l) {
    var f = u[l] ? u[l] & e[a + l] : e[a + l];
    return d === f;
  });
}, Q4e = function(e, n, r) {
  n.forEach(function(i) {
    for (var s in e.mediaGroups[i])
      for (var a in e.mediaGroups[i][s]) {
        var o = e.mediaGroups[i][s][a];
        r(o, i, s, a);
      }
  });
}, Md = {}, wa = {}, Zo = {}, Tx;
function _g() {
  if (Tx) return Zo;
  Tx = 1;
  function t(s, a, o) {
    if (o === void 0 && (o = Array.prototype), s && typeof o.find == "function")
      return o.find.call(s, a);
    for (var u = 0; u < s.length; u++)
      if (Object.prototype.hasOwnProperty.call(s, u)) {
        var c = s[u];
        if (a.call(void 0, c, u, s))
          return c;
      }
  }
  function e(s, a) {
    return a === void 0 && (a = Object), a && typeof a.freeze == "function" ? a.freeze(s) : s;
  }
  function n(s, a) {
    if (s === null || typeof s != "object")
      throw new TypeError("target is not an object");
    for (var o in a)
      Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o]);
    return s;
  }
  var r = e({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(s) {
      return s === r.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), i = e({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(s) {
      return s === i.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return Zo.assign = n, Zo.find = t, Zo.freeze = e, Zo.MIME_TYPE = r, Zo.NAMESPACE = i, Zo;
}
var _x;
function AD() {
  if (_x) return wa;
  _x = 1;
  var t = _g(), e = t.find, n = t.NAMESPACE;
  function r(Y) {
    return Y !== "";
  }
  function i(Y) {
    return Y ? Y.split(/[\t\n\f\r ]+/).filter(r) : [];
  }
  function s(Y, J) {
    return Y.hasOwnProperty(J) || (Y[J] = !0), Y;
  }
  function a(Y) {
    if (!Y) return [];
    var J = i(Y);
    return Object.keys(J.reduce(s, {}));
  }
  function o(Y) {
    return function(J) {
      return Y && Y.indexOf(J) !== -1;
    };
  }
  function u(Y, J) {
    for (var me in Y)
      Object.prototype.hasOwnProperty.call(Y, me) && (J[me] = Y[me]);
  }
  function c(Y, J) {
    var me = Y.prototype;
    if (!(me instanceof J)) {
      let Oe = function() {
      };
      Oe.prototype = J.prototype, Oe = new Oe(), u(me, Oe), Y.prototype = me = Oe;
    }
    me.constructor != Y && (typeof Y != "function" && console.error("unknown Class:" + Y), me.constructor = Y);
  }
  var d = {}, l = d.ELEMENT_NODE = 1, f = d.ATTRIBUTE_NODE = 2, p = d.TEXT_NODE = 3, m = d.CDATA_SECTION_NODE = 4, g = d.ENTITY_REFERENCE_NODE = 5, y = d.ENTITY_NODE = 6, b = d.PROCESSING_INSTRUCTION_NODE = 7, E = d.COMMENT_NODE = 8, v = d.DOCUMENT_NODE = 9, _ = d.DOCUMENT_TYPE_NODE = 10, D = d.DOCUMENT_FRAGMENT_NODE = 11, S = d.NOTATION_NODE = 12, M = {}, O = {};
  M.INDEX_SIZE_ERR = (O[1] = "Index size error", 1), M.DOMSTRING_SIZE_ERR = (O[2] = "DOMString size error", 2);
  var T = M.HIERARCHY_REQUEST_ERR = (O[3] = "Hierarchy request error", 3);
  M.WRONG_DOCUMENT_ERR = (O[4] = "Wrong document", 4), M.INVALID_CHARACTER_ERR = (O[5] = "Invalid character", 5), M.NO_DATA_ALLOWED_ERR = (O[6] = "No data allowed", 6), M.NO_MODIFICATION_ALLOWED_ERR = (O[7] = "No modification allowed", 7);
  var N = M.NOT_FOUND_ERR = (O[8] = "Not found", 8);
  M.NOT_SUPPORTED_ERR = (O[9] = "Not supported", 9);
  var H = M.INUSE_ATTRIBUTE_ERR = (O[10] = "Attribute in use", 10);
  M.INVALID_STATE_ERR = (O[11] = "Invalid state", 11), M.SYNTAX_ERR = (O[12] = "Syntax error", 12), M.INVALID_MODIFICATION_ERR = (O[13] = "Invalid modification", 13), M.NAMESPACE_ERR = (O[14] = "Invalid namespace", 14), M.INVALID_ACCESS_ERR = (O[15] = "Invalid access", 15);
  function $(Y, J) {
    if (J instanceof Error)
      var me = J;
    else
      me = this, Error.call(this, O[Y]), this.message = O[Y], Error.captureStackTrace && Error.captureStackTrace(this, $);
    return me.code = Y, J && (this.message = this.message + ": " + J), me;
  }
  $.prototype = Error.prototype, u(M, $);
  function j() {
  }
  j.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(Y) {
      return Y >= 0 && Y < this.length ? this[Y] : null;
    },
    toString: function(Y, J) {
      for (var me = [], Oe = 0; Oe < this.length; Oe++)
        zt(this[Oe], me, Y, J);
      return me.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(Y) {
      return Array.prototype.filter.call(this, Y);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(Y) {
      return Array.prototype.indexOf.call(this, Y);
    }
  };
  function U(Y, J) {
    this._node = Y, this._refresh = J, V(this);
  }
  function V(Y) {
    var J = Y._node._inc || Y._node.ownerDocument._inc;
    if (Y._inc !== J) {
      var me = Y._refresh(Y._node);
      if (jn(Y, "length", me.length), !Y.$$length || me.length < Y.$$length)
        for (var Oe = me.length; Oe in Y; Oe++)
          Object.prototype.hasOwnProperty.call(Y, Oe) && delete Y[Oe];
      u(me, Y), Y._inc = J;
    }
  }
  U.prototype.item = function(Y) {
    return V(this), this[Y] || null;
  }, c(U, j);
  function B() {
  }
  function R(Y, J) {
    for (var me = Y.length; me--; )
      if (Y[me] === J)
        return me;
  }
  function K(Y, J, me, Oe) {
    if (Oe ? J[R(J, Oe)] = me : J[J.length++] = me, Y) {
      me.ownerElement = Y;
      var rt = Y.ownerDocument;
      rt && (Oe && ye(rt, Y, Oe), Z(rt, Y, me));
    }
  }
  function Q(Y, J, me) {
    var Oe = R(J, me);
    if (Oe >= 0) {
      for (var rt = J.length - 1; Oe < rt; )
        J[Oe] = J[++Oe];
      if (J.length = rt, Y) {
        var ht = Y.ownerDocument;
        ht && (ye(ht, Y, me), me.ownerElement = null);
      }
    } else
      throw new $(N, new Error(Y.tagName + "@" + me));
  }
  B.prototype = {
    length: 0,
    item: j.prototype.item,
    getNamedItem: function(Y) {
      for (var J = this.length; J--; ) {
        var me = this[J];
        if (me.nodeName == Y)
          return me;
      }
    },
    setNamedItem: function(Y) {
      var J = Y.ownerElement;
      if (J && J != this._ownerElement)
        throw new $(H);
      var me = this.getNamedItem(Y.nodeName);
      return K(this._ownerElement, this, Y, me), me;
    },
    /* returns Node */
    setNamedItemNS: function(Y) {
      var J = Y.ownerElement, me;
      if (J && J != this._ownerElement)
        throw new $(H);
      return me = this.getNamedItemNS(Y.namespaceURI, Y.localName), K(this._ownerElement, this, Y, me), me;
    },
    /* returns Node */
    removeNamedItem: function(Y) {
      var J = this.getNamedItem(Y);
      return Q(this._ownerElement, this, J), J;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(Y, J) {
      var me = this.getNamedItemNS(Y, J);
      return Q(this._ownerElement, this, me), me;
    },
    getNamedItemNS: function(Y, J) {
      for (var me = this.length; me--; ) {
        var Oe = this[me];
        if (Oe.localName == J && Oe.namespaceURI == Y)
          return Oe;
      }
      return null;
    }
  };
  function P() {
  }
  P.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(Y, J) {
      return !0;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(Y, J, me) {
      var Oe = new ee();
      if (Oe.implementation = this, Oe.childNodes = new j(), Oe.doctype = me || null, me && Oe.appendChild(me), J) {
        var rt = Oe.createElementNS(Y, J);
        Oe.appendChild(rt);
      }
      return Oe;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(Y, J, me) {
      var Oe = new At();
      return Oe.name = Y, Oe.nodeName = Y, Oe.publicId = J || "", Oe.systemId = me || "", Oe;
    }
  };
  function I() {
  }
  I.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(Y, J) {
      return ue(this, Y, J);
    },
    replaceChild: function(Y, J) {
      ue(this, Y, J, ne), J && this.removeChild(J);
    },
    removeChild: function(Y) {
      return Ee(this, Y);
    },
    appendChild: function(Y) {
      return this.insertBefore(Y, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(Y) {
      return Hn(this.ownerDocument || this, this, Y);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      for (var Y = this.firstChild; Y; ) {
        var J = Y.nextSibling;
        J && J.nodeType == p && Y.nodeType == p ? (this.removeChild(J), Y.appendData(J.data)) : (Y.normalize(), Y = J);
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(Y, J) {
      return this.ownerDocument.implementation.hasFeature(Y, J);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(Y) {
      for (var J = this; J; ) {
        var me = J._nsMap;
        if (me) {
          for (var Oe in me)
            if (Object.prototype.hasOwnProperty.call(me, Oe) && me[Oe] === Y)
              return Oe;
        }
        J = J.nodeType == f ? J.ownerDocument : J.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(Y) {
      for (var J = this; J; ) {
        var me = J._nsMap;
        if (me && Object.prototype.hasOwnProperty.call(me, Y))
          return me[Y];
        J = J.nodeType == f ? J.ownerDocument : J.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(Y) {
      var J = this.lookupPrefix(Y);
      return J == null;
    }
  };
  function G(Y) {
    return Y == "<" && "&lt;" || Y == ">" && "&gt;" || Y == "&" && "&amp;" || Y == '"' && "&quot;" || "&#" + Y.charCodeAt() + ";";
  }
  u(d, I), u(d, I.prototype);
  function te(Y, J) {
    if (J(Y))
      return !0;
    if (Y = Y.firstChild)
      do
        if (te(Y, J))
          return !0;
      while (Y = Y.nextSibling);
  }
  function ee() {
    this.ownerDocument = this;
  }
  function Z(Y, J, me) {
    Y && Y._inc++;
    var Oe = me.namespaceURI;
    Oe === n.XMLNS && (J._nsMap[me.prefix ? me.localName : ""] = me.value);
  }
  function ye(Y, J, me, Oe) {
    Y && Y._inc++;
    var rt = me.namespaceURI;
    rt === n.XMLNS && delete J._nsMap[me.prefix ? me.localName : ""];
  }
  function he(Y, J, me) {
    if (Y && Y._inc) {
      Y._inc++;
      var Oe = J.childNodes;
      if (me)
        Oe[Oe.length++] = me;
      else {
        for (var rt = J.firstChild, ht = 0; rt; )
          Oe[ht++] = rt, rt = rt.nextSibling;
        Oe.length = ht, delete Oe[Oe.length];
      }
    }
  }
  function Ee(Y, J) {
    var me = J.previousSibling, Oe = J.nextSibling;
    return me ? me.nextSibling = Oe : Y.firstChild = Oe, Oe ? Oe.previousSibling = me : Y.lastChild = me, J.parentNode = null, J.previousSibling = null, J.nextSibling = null, he(Y.ownerDocument, Y), J;
  }
  function be(Y) {
    return Y && (Y.nodeType === I.DOCUMENT_NODE || Y.nodeType === I.DOCUMENT_FRAGMENT_NODE || Y.nodeType === I.ELEMENT_NODE);
  }
  function ve(Y) {
    return Y && (Ne(Y) || qe(Y) || Ce(Y) || Y.nodeType === I.DOCUMENT_FRAGMENT_NODE || Y.nodeType === I.COMMENT_NODE || Y.nodeType === I.PROCESSING_INSTRUCTION_NODE);
  }
  function Ce(Y) {
    return Y && Y.nodeType === I.DOCUMENT_TYPE_NODE;
  }
  function Ne(Y) {
    return Y && Y.nodeType === I.ELEMENT_NODE;
  }
  function qe(Y) {
    return Y && Y.nodeType === I.TEXT_NODE;
  }
  function $e(Y, J) {
    var me = Y.childNodes || [];
    if (e(me, Ne) || Ce(J))
      return !1;
    var Oe = e(me, Ce);
    return !(J && Oe && me.indexOf(Oe) > me.indexOf(J));
  }
  function Xe(Y, J) {
    var me = Y.childNodes || [];
    function Oe(ht) {
      return Ne(ht) && ht !== J;
    }
    if (e(me, Oe))
      return !1;
    var rt = e(me, Ce);
    return !(J && rt && me.indexOf(rt) > me.indexOf(J));
  }
  function at(Y, J, me) {
    if (!be(Y))
      throw new $(T, "Unexpected parent node type " + Y.nodeType);
    if (me && me.parentNode !== Y)
      throw new $(N, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !ve(J) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      Ce(J) && Y.nodeType !== I.DOCUMENT_NODE
    )
      throw new $(
        T,
        "Unexpected node type " + J.nodeType + " for parent node type " + Y.nodeType
      );
  }
  function Ie(Y, J, me) {
    var Oe = Y.childNodes || [], rt = J.childNodes || [];
    if (J.nodeType === I.DOCUMENT_FRAGMENT_NODE) {
      var ht = rt.filter(Ne);
      if (ht.length > 1 || e(rt, qe))
        throw new $(T, "More than one element or text in fragment");
      if (ht.length === 1 && !$e(Y, me))
        throw new $(T, "Element in fragment can not be inserted before doctype");
    }
    if (Ne(J) && !$e(Y, me))
      throw new $(T, "Only one element can be added and only after doctype");
    if (Ce(J)) {
      if (e(Oe, Ce))
        throw new $(T, "Only one doctype is allowed");
      var qt = e(Oe, Ne);
      if (me && Oe.indexOf(qt) < Oe.indexOf(me))
        throw new $(T, "Doctype can only be inserted before an element");
      if (!me && qt)
        throw new $(T, "Doctype can not be appended since element is present");
    }
  }
  function ne(Y, J, me) {
    var Oe = Y.childNodes || [], rt = J.childNodes || [];
    if (J.nodeType === I.DOCUMENT_FRAGMENT_NODE) {
      var ht = rt.filter(Ne);
      if (ht.length > 1 || e(rt, qe))
        throw new $(T, "More than one element or text in fragment");
      if (ht.length === 1 && !Xe(Y, me))
        throw new $(T, "Element in fragment can not be inserted before doctype");
    }
    if (Ne(J) && !Xe(Y, me))
      throw new $(T, "Only one element can be added and only after doctype");
    if (Ce(J)) {
      if (e(Oe, function(mr) {
        return Ce(mr) && mr !== me;
      }))
        throw new $(T, "Only one doctype is allowed");
      var qt = e(Oe, Ne);
      if (me && Oe.indexOf(qt) < Oe.indexOf(me))
        throw new $(T, "Doctype can only be inserted before an element");
    }
  }
  function ue(Y, J, me, Oe) {
    at(Y, J, me), Y.nodeType === I.DOCUMENT_NODE && (Oe || Ie)(Y, J, me);
    var rt = J.parentNode;
    if (rt && rt.removeChild(J), J.nodeType === D) {
      var ht = J.firstChild;
      if (ht == null)
        return J;
      var qt = J.lastChild;
    } else
      ht = qt = J;
    var Bt = me ? me.previousSibling : Y.lastChild;
    ht.previousSibling = Bt, qt.nextSibling = me, Bt ? Bt.nextSibling = ht : Y.firstChild = ht, me == null ? Y.lastChild = qt : me.previousSibling = qt;
    do
      ht.parentNode = Y;
    while (ht !== qt && (ht = ht.nextSibling));
    return he(Y.ownerDocument || Y, Y), J.nodeType == D && (J.firstChild = J.lastChild = null), J;
  }
  function ie(Y, J) {
    return J.parentNode && J.parentNode.removeChild(J), J.parentNode = Y, J.previousSibling = Y.lastChild, J.nextSibling = null, J.previousSibling ? J.previousSibling.nextSibling = J : Y.firstChild = J, Y.lastChild = J, he(Y.ownerDocument, Y, J), J;
  }
  ee.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: v,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(Y, J) {
      if (Y.nodeType == D) {
        for (var me = Y.firstChild; me; ) {
          var Oe = me.nextSibling;
          this.insertBefore(me, J), me = Oe;
        }
        return Y;
      }
      return ue(this, Y, J), Y.ownerDocument = this, this.documentElement === null && Y.nodeType === l && (this.documentElement = Y), Y;
    },
    removeChild: function(Y) {
      return this.documentElement == Y && (this.documentElement = null), Ee(this, Y);
    },
    replaceChild: function(Y, J) {
      ue(this, Y, J, ne), Y.ownerDocument = this, J && this.removeChild(J), Ne(Y) && (this.documentElement = Y);
    },
    // Introduced in DOM Level 2:
    importNode: function(Y, J) {
      return wn(this, Y, J);
    },
    // Introduced in DOM Level 2:
    getElementById: function(Y) {
      var J = null;
      return te(this.documentElement, function(me) {
        if (me.nodeType == l && me.getAttribute("id") == Y)
          return J = me, !0;
      }), J;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(Y) {
      var J = a(Y);
      return new U(this, function(me) {
        var Oe = [];
        return J.length > 0 && te(me.documentElement, function(rt) {
          if (rt !== me && rt.nodeType === l) {
            var ht = rt.getAttribute("class");
            if (ht) {
              var qt = Y === ht;
              if (!qt) {
                var Bt = a(ht);
                qt = J.every(o(Bt));
              }
              qt && Oe.push(rt);
            }
          }
        }), Oe;
      });
    },
    //document factory method:
    createElement: function(Y) {
      var J = new Te();
      J.ownerDocument = this, J.nodeName = Y, J.tagName = Y, J.localName = Y, J.childNodes = new j();
      var me = J.attributes = new B();
      return me._ownerElement = J, J;
    },
    createDocumentFragment: function() {
      var Y = new jt();
      return Y.ownerDocument = this, Y.childNodes = new j(), Y;
    },
    createTextNode: function(Y) {
      var J = new Qe();
      return J.ownerDocument = this, J.appendData(Y), J;
    },
    createComment: function(Y) {
      var J = new xe();
      return J.ownerDocument = this, J.appendData(Y), J;
    },
    createCDATASection: function(Y) {
      var J = new Be();
      return J.ownerDocument = this, J.appendData(Y), J;
    },
    createProcessingInstruction: function(Y, J) {
      var me = new Tt();
      return me.ownerDocument = this, me.tagName = me.nodeName = me.target = Y, me.nodeValue = me.data = J, me;
    },
    createAttribute: function(Y) {
      var J = new je();
      return J.ownerDocument = this, J.name = Y, J.nodeName = Y, J.localName = Y, J.specified = !0, J;
    },
    createEntityReference: function(Y) {
      var J = new Xt();
      return J.ownerDocument = this, J.nodeName = Y, J;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(Y, J) {
      var me = new Te(), Oe = J.split(":"), rt = me.attributes = new B();
      return me.childNodes = new j(), me.ownerDocument = this, me.nodeName = J, me.tagName = J, me.namespaceURI = Y, Oe.length == 2 ? (me.prefix = Oe[0], me.localName = Oe[1]) : me.localName = J, rt._ownerElement = me, me;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(Y, J) {
      var me = new je(), Oe = J.split(":");
      return me.ownerDocument = this, me.nodeName = J, me.name = J, me.namespaceURI = Y, me.specified = !0, Oe.length == 2 ? (me.prefix = Oe[0], me.localName = Oe[1]) : me.localName = J, me;
    }
  }, c(ee, I);
  function Te() {
    this._nsMap = {};
  }
  Te.prototype = {
    nodeType: l,
    hasAttribute: function(Y) {
      return this.getAttributeNode(Y) != null;
    },
    getAttribute: function(Y) {
      var J = this.getAttributeNode(Y);
      return J && J.value || "";
    },
    getAttributeNode: function(Y) {
      return this.attributes.getNamedItem(Y);
    },
    setAttribute: function(Y, J) {
      var me = this.ownerDocument.createAttribute(Y);
      me.value = me.nodeValue = "" + J, this.setAttributeNode(me);
    },
    removeAttribute: function(Y) {
      var J = this.getAttributeNode(Y);
      J && this.removeAttributeNode(J);
    },
    //four real opeartion method
    appendChild: function(Y) {
      return Y.nodeType === D ? this.insertBefore(Y, null) : ie(this, Y);
    },
    setAttributeNode: function(Y) {
      return this.attributes.setNamedItem(Y);
    },
    setAttributeNodeNS: function(Y) {
      return this.attributes.setNamedItemNS(Y);
    },
    removeAttributeNode: function(Y) {
      return this.attributes.removeNamedItem(Y.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(Y, J) {
      var me = this.getAttributeNodeNS(Y, J);
      me && this.removeAttributeNode(me);
    },
    hasAttributeNS: function(Y, J) {
      return this.getAttributeNodeNS(Y, J) != null;
    },
    getAttributeNS: function(Y, J) {
      var me = this.getAttributeNodeNS(Y, J);
      return me && me.value || "";
    },
    setAttributeNS: function(Y, J, me) {
      var Oe = this.ownerDocument.createAttributeNS(Y, J);
      Oe.value = Oe.nodeValue = "" + me, this.setAttributeNode(Oe);
    },
    getAttributeNodeNS: function(Y, J) {
      return this.attributes.getNamedItemNS(Y, J);
    },
    getElementsByTagName: function(Y) {
      return new U(this, function(J) {
        var me = [];
        return te(J, function(Oe) {
          Oe !== J && Oe.nodeType == l && (Y === "*" || Oe.tagName == Y) && me.push(Oe);
        }), me;
      });
    },
    getElementsByTagNameNS: function(Y, J) {
      return new U(this, function(me) {
        var Oe = [];
        return te(me, function(rt) {
          rt !== me && rt.nodeType === l && (Y === "*" || rt.namespaceURI === Y) && (J === "*" || rt.localName == J) && Oe.push(rt);
        }), Oe;
      });
    }
  }, ee.prototype.getElementsByTagName = Te.prototype.getElementsByTagName, ee.prototype.getElementsByTagNameNS = Te.prototype.getElementsByTagNameNS, c(Te, I);
  function je() {
  }
  je.prototype.nodeType = f, c(je, I);
  function We() {
  }
  We.prototype = {
    data: "",
    substringData: function(Y, J) {
      return this.data.substring(Y, Y + J);
    },
    appendData: function(Y) {
      Y = this.data + Y, this.nodeValue = this.data = Y, this.length = Y.length;
    },
    insertData: function(Y, J) {
      this.replaceData(Y, 0, J);
    },
    appendChild: function(Y) {
      throw new Error(O[T]);
    },
    deleteData: function(Y, J) {
      this.replaceData(Y, J, "");
    },
    replaceData: function(Y, J, me) {
      var Oe = this.data.substring(0, Y), rt = this.data.substring(Y + J);
      me = Oe + me + rt, this.nodeValue = this.data = me, this.length = me.length;
    }
  }, c(We, I);
  function Qe() {
  }
  Qe.prototype = {
    nodeName: "#text",
    nodeType: p,
    splitText: function(Y) {
      var J = this.data, me = J.substring(Y);
      J = J.substring(0, Y), this.data = this.nodeValue = J, this.length = J.length;
      var Oe = this.ownerDocument.createTextNode(me);
      return this.parentNode && this.parentNode.insertBefore(Oe, this.nextSibling), Oe;
    }
  }, c(Qe, We);
  function xe() {
  }
  xe.prototype = {
    nodeName: "#comment",
    nodeType: E
  }, c(xe, We);
  function Be() {
  }
  Be.prototype = {
    nodeName: "#cdata-section",
    nodeType: m
  }, c(Be, We);
  function At() {
  }
  At.prototype.nodeType = _, c(At, I);
  function xt() {
  }
  xt.prototype.nodeType = S, c(xt, I);
  function Rt() {
  }
  Rt.prototype.nodeType = y, c(Rt, I);
  function Xt() {
  }
  Xt.prototype.nodeType = g, c(Xt, I);
  function jt() {
  }
  jt.prototype.nodeName = "#document-fragment", jt.prototype.nodeType = D, c(jt, I);
  function Tt() {
  }
  Tt.prototype.nodeType = b, c(Tt, I);
  function bn() {
  }
  bn.prototype.serializeToString = function(Y, J, me) {
    return Ve.call(Y, J, me);
  }, I.prototype.toString = Ve;
  function Ve(Y, J) {
    var me = [], Oe = this.nodeType == 9 && this.documentElement || this, rt = Oe.prefix, ht = Oe.namespaceURI;
    if (ht && rt == null) {
      var rt = Oe.lookupPrefix(ht);
      if (rt == null)
        var qt = [
          { namespace: ht, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return zt(this, me, Y, J, qt), me.join("");
  }
  function ut(Y, J, me) {
    var Oe = Y.prefix || "", rt = Y.namespaceURI;
    if (!rt || Oe === "xml" && rt === n.XML || rt === n.XMLNS)
      return !1;
    for (var ht = me.length; ht--; ) {
      var qt = me[ht];
      if (qt.prefix === Oe)
        return qt.namespace !== rt;
    }
    return !0;
  }
  function _t(Y, J, me) {
    Y.push(" ", J, '="', me.replace(/[<>&"\t\n\r]/g, G), '"');
  }
  function zt(Y, J, me, Oe, rt) {
    if (rt || (rt = []), Oe)
      if (Y = Oe(Y), Y) {
        if (typeof Y == "string") {
          J.push(Y);
          return;
        }
      } else
        return;
    switch (Y.nodeType) {
      case l:
        var ht = Y.attributes, qt = ht.length, Nn = Y.firstChild, Bt = Y.tagName;
        me = n.isHTML(Y.namespaceURI) || me;
        var mr = Bt;
        if (!me && !Y.prefix && Y.namespaceURI) {
          for (var wr, gn = 0; gn < ht.length; gn++)
            if (ht.item(gn).name === "xmlns") {
              wr = ht.item(gn).value;
              break;
            }
          if (!wr)
            for (var Kn = rt.length - 1; Kn >= 0; Kn--) {
              var Rn = rt[Kn];
              if (Rn.prefix === "" && Rn.namespace === Y.namespaceURI) {
                wr = Rn.namespace;
                break;
              }
            }
          if (wr !== Y.namespaceURI)
            for (var Kn = rt.length - 1; Kn >= 0; Kn--) {
              var Rn = rt[Kn];
              if (Rn.namespace === Y.namespaceURI) {
                Rn.prefix && (mr = Rn.prefix + ":" + Bt);
                break;
              }
            }
        }
        J.push("<", mr);
        for (var On = 0; On < qt; On++) {
          var $t = ht.item(On);
          $t.prefix == "xmlns" ? rt.push({ prefix: $t.localName, namespace: $t.value }) : $t.nodeName == "xmlns" && rt.push({ prefix: "", namespace: $t.value });
        }
        for (var On = 0; On < qt; On++) {
          var $t = ht.item(On);
          if (ut($t, me, rt)) {
            var ur = $t.prefix || "", Or = $t.namespaceURI;
            _t(J, ur ? "xmlns:" + ur : "xmlns", Or), rt.push({ prefix: ur, namespace: Or });
          }
          zt($t, J, me, Oe, rt);
        }
        if (Bt === mr && ut(Y, me, rt)) {
          var ur = Y.prefix || "", Or = Y.namespaceURI;
          _t(J, ur ? "xmlns:" + ur : "xmlns", Or), rt.push({ prefix: ur, namespace: Or });
        }
        if (Nn || me && !/^(?:meta|link|img|br|hr|input)$/i.test(Bt)) {
          if (J.push(">"), me && /^script$/i.test(Bt))
            for (; Nn; )
              Nn.data ? J.push(Nn.data) : zt(Nn, J, me, Oe, rt.slice()), Nn = Nn.nextSibling;
          else
            for (; Nn; )
              zt(Nn, J, me, Oe, rt.slice()), Nn = Nn.nextSibling;
          J.push("</", mr, ">");
        } else
          J.push("/>");
        return;
      case v:
      case D:
        for (var Nn = Y.firstChild; Nn; )
          zt(Nn, J, me, Oe, rt.slice()), Nn = Nn.nextSibling;
        return;
      case f:
        return _t(J, Y.name, Y.value);
      case p:
        return J.push(
          Y.data.replace(/[<&>]/g, G)
        );
      case m:
        return J.push("<![CDATA[", Y.data, "]]>");
      case E:
        return J.push("<!--", Y.data, "-->");
      case _:
        var Nr = Y.publicId, ii = Y.systemId;
        if (J.push("<!DOCTYPE ", Y.name), Nr)
          J.push(" PUBLIC ", Nr), ii && ii != "." && J.push(" ", ii), J.push(">");
        else if (ii && ii != ".")
          J.push(" SYSTEM ", ii, ">");
        else {
          var rn = Y.internalSubset;
          rn && J.push(" [", rn, "]"), J.push(">");
        }
        return;
      case b:
        return J.push("<?", Y.target, " ", Y.data, "?>");
      case g:
        return J.push("&", Y.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        J.push("??", Y.nodeName);
    }
  }
  function wn(Y, J, me) {
    var Oe;
    switch (J.nodeType) {
      case l:
        Oe = J.cloneNode(!1), Oe.ownerDocument = Y;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case D:
        break;
      case f:
        me = !0;
        break;
    }
    if (Oe || (Oe = J.cloneNode(!1)), Oe.ownerDocument = Y, Oe.parentNode = null, me)
      for (var rt = J.firstChild; rt; )
        Oe.appendChild(wn(Y, rt, me)), rt = rt.nextSibling;
    return Oe;
  }
  function Hn(Y, J, me) {
    var Oe = new J.constructor();
    for (var rt in J)
      if (Object.prototype.hasOwnProperty.call(J, rt)) {
        var ht = J[rt];
        typeof ht != "object" && ht != Oe[rt] && (Oe[rt] = ht);
      }
    switch (J.childNodes && (Oe.childNodes = new j()), Oe.ownerDocument = Y, Oe.nodeType) {
      case l:
        var qt = J.attributes, Bt = Oe.attributes = new B(), mr = qt.length;
        Bt._ownerElement = Oe;
        for (var wr = 0; wr < mr; wr++)
          Oe.setAttributeNode(Hn(Y, qt.item(wr), !0));
        break;
      case f:
        me = !0;
    }
    if (me)
      for (var gn = J.firstChild; gn; )
        Oe.appendChild(Hn(Y, gn, me)), gn = gn.nextSibling;
    return Oe;
  }
  function jn(Y, J, me) {
    Y[J] = me;
  }
  try {
    if (Object.defineProperty) {
      let Y = function(J) {
        switch (J.nodeType) {
          case l:
          case D:
            var me = [];
            for (J = J.firstChild; J; )
              J.nodeType !== 7 && J.nodeType !== 8 && me.push(Y(J)), J = J.nextSibling;
            return me.join("");
          default:
            return J.nodeValue;
        }
      };
      Object.defineProperty(U.prototype, "length", {
        get: function() {
          return V(this), this.$$length;
        }
      }), Object.defineProperty(I.prototype, "textContent", {
        get: function() {
          return Y(this);
        },
        set: function(J) {
          switch (this.nodeType) {
            case l:
            case D:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (J || String(J)) && this.appendChild(this.ownerDocument.createTextNode(J));
              break;
            default:
              this.data = J, this.value = J, this.nodeValue = J;
          }
        }
      }), jn = function(J, me, Oe) {
        J["$$" + me] = Oe;
      };
    }
  } catch {
  }
  return wa.DocumentType = At, wa.DOMException = $, wa.DOMImplementation = P, wa.Element = Te, wa.Node = I, wa.NodeList = j, wa.XMLSerializer = bn, wa;
}
var Od = {}, WA = {}, Ex;
function G4e() {
  return Ex || (Ex = 1, function(t) {
    var e = _g().freeze;
    t.XML_ENTITIES = e({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), t.HTML_ENTITIES = e({
      Aacute: "Á",
      aacute: "á",
      Abreve: "Ă",
      abreve: "ă",
      ac: "∾",
      acd: "∿",
      acE: "∾̳",
      Acirc: "Â",
      acirc: "â",
      acute: "´",
      Acy: "А",
      acy: "а",
      AElig: "Æ",
      aelig: "æ",
      af: "⁡",
      Afr: "𝔄",
      afr: "𝔞",
      Agrave: "À",
      agrave: "à",
      alefsym: "ℵ",
      aleph: "ℵ",
      Alpha: "Α",
      alpha: "α",
      Amacr: "Ā",
      amacr: "ā",
      amalg: "⨿",
      AMP: "&",
      amp: "&",
      And: "⩓",
      and: "∧",
      andand: "⩕",
      andd: "⩜",
      andslope: "⩘",
      andv: "⩚",
      ang: "∠",
      ange: "⦤",
      angle: "∠",
      angmsd: "∡",
      angmsdaa: "⦨",
      angmsdab: "⦩",
      angmsdac: "⦪",
      angmsdad: "⦫",
      angmsdae: "⦬",
      angmsdaf: "⦭",
      angmsdag: "⦮",
      angmsdah: "⦯",
      angrt: "∟",
      angrtvb: "⊾",
      angrtvbd: "⦝",
      angsph: "∢",
      angst: "Å",
      angzarr: "⍼",
      Aogon: "Ą",
      aogon: "ą",
      Aopf: "𝔸",
      aopf: "𝕒",
      ap: "≈",
      apacir: "⩯",
      apE: "⩰",
      ape: "≊",
      apid: "≋",
      apos: "'",
      ApplyFunction: "⁡",
      approx: "≈",
      approxeq: "≊",
      Aring: "Å",
      aring: "å",
      Ascr: "𝒜",
      ascr: "𝒶",
      Assign: "≔",
      ast: "*",
      asymp: "≈",
      asympeq: "≍",
      Atilde: "Ã",
      atilde: "ã",
      Auml: "Ä",
      auml: "ä",
      awconint: "∳",
      awint: "⨑",
      backcong: "≌",
      backepsilon: "϶",
      backprime: "‵",
      backsim: "∽",
      backsimeq: "⋍",
      Backslash: "∖",
      Barv: "⫧",
      barvee: "⊽",
      Barwed: "⌆",
      barwed: "⌅",
      barwedge: "⌅",
      bbrk: "⎵",
      bbrktbrk: "⎶",
      bcong: "≌",
      Bcy: "Б",
      bcy: "б",
      bdquo: "„",
      becaus: "∵",
      Because: "∵",
      because: "∵",
      bemptyv: "⦰",
      bepsi: "϶",
      bernou: "ℬ",
      Bernoullis: "ℬ",
      Beta: "Β",
      beta: "β",
      beth: "ℶ",
      between: "≬",
      Bfr: "𝔅",
      bfr: "𝔟",
      bigcap: "⋂",
      bigcirc: "◯",
      bigcup: "⋃",
      bigodot: "⨀",
      bigoplus: "⨁",
      bigotimes: "⨂",
      bigsqcup: "⨆",
      bigstar: "★",
      bigtriangledown: "▽",
      bigtriangleup: "△",
      biguplus: "⨄",
      bigvee: "⋁",
      bigwedge: "⋀",
      bkarow: "⤍",
      blacklozenge: "⧫",
      blacksquare: "▪",
      blacktriangle: "▴",
      blacktriangledown: "▾",
      blacktriangleleft: "◂",
      blacktriangleright: "▸",
      blank: "␣",
      blk12: "▒",
      blk14: "░",
      blk34: "▓",
      block: "█",
      bne: "=⃥",
      bnequiv: "≡⃥",
      bNot: "⫭",
      bnot: "⌐",
      Bopf: "𝔹",
      bopf: "𝕓",
      bot: "⊥",
      bottom: "⊥",
      bowtie: "⋈",
      boxbox: "⧉",
      boxDL: "╗",
      boxDl: "╖",
      boxdL: "╕",
      boxdl: "┐",
      boxDR: "╔",
      boxDr: "╓",
      boxdR: "╒",
      boxdr: "┌",
      boxH: "═",
      boxh: "─",
      boxHD: "╦",
      boxHd: "╤",
      boxhD: "╥",
      boxhd: "┬",
      boxHU: "╩",
      boxHu: "╧",
      boxhU: "╨",
      boxhu: "┴",
      boxminus: "⊟",
      boxplus: "⊞",
      boxtimes: "⊠",
      boxUL: "╝",
      boxUl: "╜",
      boxuL: "╛",
      boxul: "┘",
      boxUR: "╚",
      boxUr: "╙",
      boxuR: "╘",
      boxur: "└",
      boxV: "║",
      boxv: "│",
      boxVH: "╬",
      boxVh: "╫",
      boxvH: "╪",
      boxvh: "┼",
      boxVL: "╣",
      boxVl: "╢",
      boxvL: "╡",
      boxvl: "┤",
      boxVR: "╠",
      boxVr: "╟",
      boxvR: "╞",
      boxvr: "├",
      bprime: "‵",
      Breve: "˘",
      breve: "˘",
      brvbar: "¦",
      Bscr: "ℬ",
      bscr: "𝒷",
      bsemi: "⁏",
      bsim: "∽",
      bsime: "⋍",
      bsol: "\\",
      bsolb: "⧅",
      bsolhsub: "⟈",
      bull: "•",
      bullet: "•",
      bump: "≎",
      bumpE: "⪮",
      bumpe: "≏",
      Bumpeq: "≎",
      bumpeq: "≏",
      Cacute: "Ć",
      cacute: "ć",
      Cap: "⋒",
      cap: "∩",
      capand: "⩄",
      capbrcup: "⩉",
      capcap: "⩋",
      capcup: "⩇",
      capdot: "⩀",
      CapitalDifferentialD: "ⅅ",
      caps: "∩︀",
      caret: "⁁",
      caron: "ˇ",
      Cayleys: "ℭ",
      ccaps: "⩍",
      Ccaron: "Č",
      ccaron: "č",
      Ccedil: "Ç",
      ccedil: "ç",
      Ccirc: "Ĉ",
      ccirc: "ĉ",
      Cconint: "∰",
      ccups: "⩌",
      ccupssm: "⩐",
      Cdot: "Ċ",
      cdot: "ċ",
      cedil: "¸",
      Cedilla: "¸",
      cemptyv: "⦲",
      cent: "¢",
      CenterDot: "·",
      centerdot: "·",
      Cfr: "ℭ",
      cfr: "𝔠",
      CHcy: "Ч",
      chcy: "ч",
      check: "✓",
      checkmark: "✓",
      Chi: "Χ",
      chi: "χ",
      cir: "○",
      circ: "ˆ",
      circeq: "≗",
      circlearrowleft: "↺",
      circlearrowright: "↻",
      circledast: "⊛",
      circledcirc: "⊚",
      circleddash: "⊝",
      CircleDot: "⊙",
      circledR: "®",
      circledS: "Ⓢ",
      CircleMinus: "⊖",
      CirclePlus: "⊕",
      CircleTimes: "⊗",
      cirE: "⧃",
      cire: "≗",
      cirfnint: "⨐",
      cirmid: "⫯",
      cirscir: "⧂",
      ClockwiseContourIntegral: "∲",
      CloseCurlyDoubleQuote: "”",
      CloseCurlyQuote: "’",
      clubs: "♣",
      clubsuit: "♣",
      Colon: "∷",
      colon: ":",
      Colone: "⩴",
      colone: "≔",
      coloneq: "≔",
      comma: ",",
      commat: "@",
      comp: "∁",
      compfn: "∘",
      complement: "∁",
      complexes: "ℂ",
      cong: "≅",
      congdot: "⩭",
      Congruent: "≡",
      Conint: "∯",
      conint: "∮",
      ContourIntegral: "∮",
      Copf: "ℂ",
      copf: "𝕔",
      coprod: "∐",
      Coproduct: "∐",
      COPY: "©",
      copy: "©",
      copysr: "℗",
      CounterClockwiseContourIntegral: "∳",
      crarr: "↵",
      Cross: "⨯",
      cross: "✗",
      Cscr: "𝒞",
      cscr: "𝒸",
      csub: "⫏",
      csube: "⫑",
      csup: "⫐",
      csupe: "⫒",
      ctdot: "⋯",
      cudarrl: "⤸",
      cudarrr: "⤵",
      cuepr: "⋞",
      cuesc: "⋟",
      cularr: "↶",
      cularrp: "⤽",
      Cup: "⋓",
      cup: "∪",
      cupbrcap: "⩈",
      CupCap: "≍",
      cupcap: "⩆",
      cupcup: "⩊",
      cupdot: "⊍",
      cupor: "⩅",
      cups: "∪︀",
      curarr: "↷",
      curarrm: "⤼",
      curlyeqprec: "⋞",
      curlyeqsucc: "⋟",
      curlyvee: "⋎",
      curlywedge: "⋏",
      curren: "¤",
      curvearrowleft: "↶",
      curvearrowright: "↷",
      cuvee: "⋎",
      cuwed: "⋏",
      cwconint: "∲",
      cwint: "∱",
      cylcty: "⌭",
      Dagger: "‡",
      dagger: "†",
      daleth: "ℸ",
      Darr: "↡",
      dArr: "⇓",
      darr: "↓",
      dash: "‐",
      Dashv: "⫤",
      dashv: "⊣",
      dbkarow: "⤏",
      dblac: "˝",
      Dcaron: "Ď",
      dcaron: "ď",
      Dcy: "Д",
      dcy: "д",
      DD: "ⅅ",
      dd: "ⅆ",
      ddagger: "‡",
      ddarr: "⇊",
      DDotrahd: "⤑",
      ddotseq: "⩷",
      deg: "°",
      Del: "∇",
      Delta: "Δ",
      delta: "δ",
      demptyv: "⦱",
      dfisht: "⥿",
      Dfr: "𝔇",
      dfr: "𝔡",
      dHar: "⥥",
      dharl: "⇃",
      dharr: "⇂",
      DiacriticalAcute: "´",
      DiacriticalDot: "˙",
      DiacriticalDoubleAcute: "˝",
      DiacriticalGrave: "`",
      DiacriticalTilde: "˜",
      diam: "⋄",
      Diamond: "⋄",
      diamond: "⋄",
      diamondsuit: "♦",
      diams: "♦",
      die: "¨",
      DifferentialD: "ⅆ",
      digamma: "ϝ",
      disin: "⋲",
      div: "÷",
      divide: "÷",
      divideontimes: "⋇",
      divonx: "⋇",
      DJcy: "Ђ",
      djcy: "ђ",
      dlcorn: "⌞",
      dlcrop: "⌍",
      dollar: "$",
      Dopf: "𝔻",
      dopf: "𝕕",
      Dot: "¨",
      dot: "˙",
      DotDot: "⃜",
      doteq: "≐",
      doteqdot: "≑",
      DotEqual: "≐",
      dotminus: "∸",
      dotplus: "∔",
      dotsquare: "⊡",
      doublebarwedge: "⌆",
      DoubleContourIntegral: "∯",
      DoubleDot: "¨",
      DoubleDownArrow: "⇓",
      DoubleLeftArrow: "⇐",
      DoubleLeftRightArrow: "⇔",
      DoubleLeftTee: "⫤",
      DoubleLongLeftArrow: "⟸",
      DoubleLongLeftRightArrow: "⟺",
      DoubleLongRightArrow: "⟹",
      DoubleRightArrow: "⇒",
      DoubleRightTee: "⊨",
      DoubleUpArrow: "⇑",
      DoubleUpDownArrow: "⇕",
      DoubleVerticalBar: "∥",
      DownArrow: "↓",
      Downarrow: "⇓",
      downarrow: "↓",
      DownArrowBar: "⤓",
      DownArrowUpArrow: "⇵",
      DownBreve: "̑",
      downdownarrows: "⇊",
      downharpoonleft: "⇃",
      downharpoonright: "⇂",
      DownLeftRightVector: "⥐",
      DownLeftTeeVector: "⥞",
      DownLeftVector: "↽",
      DownLeftVectorBar: "⥖",
      DownRightTeeVector: "⥟",
      DownRightVector: "⇁",
      DownRightVectorBar: "⥗",
      DownTee: "⊤",
      DownTeeArrow: "↧",
      drbkarow: "⤐",
      drcorn: "⌟",
      drcrop: "⌌",
      Dscr: "𝒟",
      dscr: "𝒹",
      DScy: "Ѕ",
      dscy: "ѕ",
      dsol: "⧶",
      Dstrok: "Đ",
      dstrok: "đ",
      dtdot: "⋱",
      dtri: "▿",
      dtrif: "▾",
      duarr: "⇵",
      duhar: "⥯",
      dwangle: "⦦",
      DZcy: "Џ",
      dzcy: "џ",
      dzigrarr: "⟿",
      Eacute: "É",
      eacute: "é",
      easter: "⩮",
      Ecaron: "Ě",
      ecaron: "ě",
      ecir: "≖",
      Ecirc: "Ê",
      ecirc: "ê",
      ecolon: "≕",
      Ecy: "Э",
      ecy: "э",
      eDDot: "⩷",
      Edot: "Ė",
      eDot: "≑",
      edot: "ė",
      ee: "ⅇ",
      efDot: "≒",
      Efr: "𝔈",
      efr: "𝔢",
      eg: "⪚",
      Egrave: "È",
      egrave: "è",
      egs: "⪖",
      egsdot: "⪘",
      el: "⪙",
      Element: "∈",
      elinters: "⏧",
      ell: "ℓ",
      els: "⪕",
      elsdot: "⪗",
      Emacr: "Ē",
      emacr: "ē",
      empty: "∅",
      emptyset: "∅",
      EmptySmallSquare: "◻",
      emptyv: "∅",
      EmptyVerySmallSquare: "▫",
      emsp: " ",
      emsp13: " ",
      emsp14: " ",
      ENG: "Ŋ",
      eng: "ŋ",
      ensp: " ",
      Eogon: "Ę",
      eogon: "ę",
      Eopf: "𝔼",
      eopf: "𝕖",
      epar: "⋕",
      eparsl: "⧣",
      eplus: "⩱",
      epsi: "ε",
      Epsilon: "Ε",
      epsilon: "ε",
      epsiv: "ϵ",
      eqcirc: "≖",
      eqcolon: "≕",
      eqsim: "≂",
      eqslantgtr: "⪖",
      eqslantless: "⪕",
      Equal: "⩵",
      equals: "=",
      EqualTilde: "≂",
      equest: "≟",
      Equilibrium: "⇌",
      equiv: "≡",
      equivDD: "⩸",
      eqvparsl: "⧥",
      erarr: "⥱",
      erDot: "≓",
      Escr: "ℰ",
      escr: "ℯ",
      esdot: "≐",
      Esim: "⩳",
      esim: "≂",
      Eta: "Η",
      eta: "η",
      ETH: "Ð",
      eth: "ð",
      Euml: "Ë",
      euml: "ë",
      euro: "€",
      excl: "!",
      exist: "∃",
      Exists: "∃",
      expectation: "ℰ",
      ExponentialE: "ⅇ",
      exponentiale: "ⅇ",
      fallingdotseq: "≒",
      Fcy: "Ф",
      fcy: "ф",
      female: "♀",
      ffilig: "ﬃ",
      fflig: "ﬀ",
      ffllig: "ﬄ",
      Ffr: "𝔉",
      ffr: "𝔣",
      filig: "ﬁ",
      FilledSmallSquare: "◼",
      FilledVerySmallSquare: "▪",
      fjlig: "fj",
      flat: "♭",
      fllig: "ﬂ",
      fltns: "▱",
      fnof: "ƒ",
      Fopf: "𝔽",
      fopf: "𝕗",
      ForAll: "∀",
      forall: "∀",
      fork: "⋔",
      forkv: "⫙",
      Fouriertrf: "ℱ",
      fpartint: "⨍",
      frac12: "½",
      frac13: "⅓",
      frac14: "¼",
      frac15: "⅕",
      frac16: "⅙",
      frac18: "⅛",
      frac23: "⅔",
      frac25: "⅖",
      frac34: "¾",
      frac35: "⅗",
      frac38: "⅜",
      frac45: "⅘",
      frac56: "⅚",
      frac58: "⅝",
      frac78: "⅞",
      frasl: "⁄",
      frown: "⌢",
      Fscr: "ℱ",
      fscr: "𝒻",
      gacute: "ǵ",
      Gamma: "Γ",
      gamma: "γ",
      Gammad: "Ϝ",
      gammad: "ϝ",
      gap: "⪆",
      Gbreve: "Ğ",
      gbreve: "ğ",
      Gcedil: "Ģ",
      Gcirc: "Ĝ",
      gcirc: "ĝ",
      Gcy: "Г",
      gcy: "г",
      Gdot: "Ġ",
      gdot: "ġ",
      gE: "≧",
      ge: "≥",
      gEl: "⪌",
      gel: "⋛",
      geq: "≥",
      geqq: "≧",
      geqslant: "⩾",
      ges: "⩾",
      gescc: "⪩",
      gesdot: "⪀",
      gesdoto: "⪂",
      gesdotol: "⪄",
      gesl: "⋛︀",
      gesles: "⪔",
      Gfr: "𝔊",
      gfr: "𝔤",
      Gg: "⋙",
      gg: "≫",
      ggg: "⋙",
      gimel: "ℷ",
      GJcy: "Ѓ",
      gjcy: "ѓ",
      gl: "≷",
      gla: "⪥",
      glE: "⪒",
      glj: "⪤",
      gnap: "⪊",
      gnapprox: "⪊",
      gnE: "≩",
      gne: "⪈",
      gneq: "⪈",
      gneqq: "≩",
      gnsim: "⋧",
      Gopf: "𝔾",
      gopf: "𝕘",
      grave: "`",
      GreaterEqual: "≥",
      GreaterEqualLess: "⋛",
      GreaterFullEqual: "≧",
      GreaterGreater: "⪢",
      GreaterLess: "≷",
      GreaterSlantEqual: "⩾",
      GreaterTilde: "≳",
      Gscr: "𝒢",
      gscr: "ℊ",
      gsim: "≳",
      gsime: "⪎",
      gsiml: "⪐",
      Gt: "≫",
      GT: ">",
      gt: ">",
      gtcc: "⪧",
      gtcir: "⩺",
      gtdot: "⋗",
      gtlPar: "⦕",
      gtquest: "⩼",
      gtrapprox: "⪆",
      gtrarr: "⥸",
      gtrdot: "⋗",
      gtreqless: "⋛",
      gtreqqless: "⪌",
      gtrless: "≷",
      gtrsim: "≳",
      gvertneqq: "≩︀",
      gvnE: "≩︀",
      Hacek: "ˇ",
      hairsp: " ",
      half: "½",
      hamilt: "ℋ",
      HARDcy: "Ъ",
      hardcy: "ъ",
      hArr: "⇔",
      harr: "↔",
      harrcir: "⥈",
      harrw: "↭",
      Hat: "^",
      hbar: "ℏ",
      Hcirc: "Ĥ",
      hcirc: "ĥ",
      hearts: "♥",
      heartsuit: "♥",
      hellip: "…",
      hercon: "⊹",
      Hfr: "ℌ",
      hfr: "𝔥",
      HilbertSpace: "ℋ",
      hksearow: "⤥",
      hkswarow: "⤦",
      hoarr: "⇿",
      homtht: "∻",
      hookleftarrow: "↩",
      hookrightarrow: "↪",
      Hopf: "ℍ",
      hopf: "𝕙",
      horbar: "―",
      HorizontalLine: "─",
      Hscr: "ℋ",
      hscr: "𝒽",
      hslash: "ℏ",
      Hstrok: "Ħ",
      hstrok: "ħ",
      HumpDownHump: "≎",
      HumpEqual: "≏",
      hybull: "⁃",
      hyphen: "‐",
      Iacute: "Í",
      iacute: "í",
      ic: "⁣",
      Icirc: "Î",
      icirc: "î",
      Icy: "И",
      icy: "и",
      Idot: "İ",
      IEcy: "Е",
      iecy: "е",
      iexcl: "¡",
      iff: "⇔",
      Ifr: "ℑ",
      ifr: "𝔦",
      Igrave: "Ì",
      igrave: "ì",
      ii: "ⅈ",
      iiiint: "⨌",
      iiint: "∭",
      iinfin: "⧜",
      iiota: "℩",
      IJlig: "Ĳ",
      ijlig: "ĳ",
      Im: "ℑ",
      Imacr: "Ī",
      imacr: "ī",
      image: "ℑ",
      ImaginaryI: "ⅈ",
      imagline: "ℐ",
      imagpart: "ℑ",
      imath: "ı",
      imof: "⊷",
      imped: "Ƶ",
      Implies: "⇒",
      in: "∈",
      incare: "℅",
      infin: "∞",
      infintie: "⧝",
      inodot: "ı",
      Int: "∬",
      int: "∫",
      intcal: "⊺",
      integers: "ℤ",
      Integral: "∫",
      intercal: "⊺",
      Intersection: "⋂",
      intlarhk: "⨗",
      intprod: "⨼",
      InvisibleComma: "⁣",
      InvisibleTimes: "⁢",
      IOcy: "Ё",
      iocy: "ё",
      Iogon: "Į",
      iogon: "į",
      Iopf: "𝕀",
      iopf: "𝕚",
      Iota: "Ι",
      iota: "ι",
      iprod: "⨼",
      iquest: "¿",
      Iscr: "ℐ",
      iscr: "𝒾",
      isin: "∈",
      isindot: "⋵",
      isinE: "⋹",
      isins: "⋴",
      isinsv: "⋳",
      isinv: "∈",
      it: "⁢",
      Itilde: "Ĩ",
      itilde: "ĩ",
      Iukcy: "І",
      iukcy: "і",
      Iuml: "Ï",
      iuml: "ï",
      Jcirc: "Ĵ",
      jcirc: "ĵ",
      Jcy: "Й",
      jcy: "й",
      Jfr: "𝔍",
      jfr: "𝔧",
      jmath: "ȷ",
      Jopf: "𝕁",
      jopf: "𝕛",
      Jscr: "𝒥",
      jscr: "𝒿",
      Jsercy: "Ј",
      jsercy: "ј",
      Jukcy: "Є",
      jukcy: "є",
      Kappa: "Κ",
      kappa: "κ",
      kappav: "ϰ",
      Kcedil: "Ķ",
      kcedil: "ķ",
      Kcy: "К",
      kcy: "к",
      Kfr: "𝔎",
      kfr: "𝔨",
      kgreen: "ĸ",
      KHcy: "Х",
      khcy: "х",
      KJcy: "Ќ",
      kjcy: "ќ",
      Kopf: "𝕂",
      kopf: "𝕜",
      Kscr: "𝒦",
      kscr: "𝓀",
      lAarr: "⇚",
      Lacute: "Ĺ",
      lacute: "ĺ",
      laemptyv: "⦴",
      lagran: "ℒ",
      Lambda: "Λ",
      lambda: "λ",
      Lang: "⟪",
      lang: "⟨",
      langd: "⦑",
      langle: "⟨",
      lap: "⪅",
      Laplacetrf: "ℒ",
      laquo: "«",
      Larr: "↞",
      lArr: "⇐",
      larr: "←",
      larrb: "⇤",
      larrbfs: "⤟",
      larrfs: "⤝",
      larrhk: "↩",
      larrlp: "↫",
      larrpl: "⤹",
      larrsim: "⥳",
      larrtl: "↢",
      lat: "⪫",
      lAtail: "⤛",
      latail: "⤙",
      late: "⪭",
      lates: "⪭︀",
      lBarr: "⤎",
      lbarr: "⤌",
      lbbrk: "❲",
      lbrace: "{",
      lbrack: "[",
      lbrke: "⦋",
      lbrksld: "⦏",
      lbrkslu: "⦍",
      Lcaron: "Ľ",
      lcaron: "ľ",
      Lcedil: "Ļ",
      lcedil: "ļ",
      lceil: "⌈",
      lcub: "{",
      Lcy: "Л",
      lcy: "л",
      ldca: "⤶",
      ldquo: "“",
      ldquor: "„",
      ldrdhar: "⥧",
      ldrushar: "⥋",
      ldsh: "↲",
      lE: "≦",
      le: "≤",
      LeftAngleBracket: "⟨",
      LeftArrow: "←",
      Leftarrow: "⇐",
      leftarrow: "←",
      LeftArrowBar: "⇤",
      LeftArrowRightArrow: "⇆",
      leftarrowtail: "↢",
      LeftCeiling: "⌈",
      LeftDoubleBracket: "⟦",
      LeftDownTeeVector: "⥡",
      LeftDownVector: "⇃",
      LeftDownVectorBar: "⥙",
      LeftFloor: "⌊",
      leftharpoondown: "↽",
      leftharpoonup: "↼",
      leftleftarrows: "⇇",
      LeftRightArrow: "↔",
      Leftrightarrow: "⇔",
      leftrightarrow: "↔",
      leftrightarrows: "⇆",
      leftrightharpoons: "⇋",
      leftrightsquigarrow: "↭",
      LeftRightVector: "⥎",
      LeftTee: "⊣",
      LeftTeeArrow: "↤",
      LeftTeeVector: "⥚",
      leftthreetimes: "⋋",
      LeftTriangle: "⊲",
      LeftTriangleBar: "⧏",
      LeftTriangleEqual: "⊴",
      LeftUpDownVector: "⥑",
      LeftUpTeeVector: "⥠",
      LeftUpVector: "↿",
      LeftUpVectorBar: "⥘",
      LeftVector: "↼",
      LeftVectorBar: "⥒",
      lEg: "⪋",
      leg: "⋚",
      leq: "≤",
      leqq: "≦",
      leqslant: "⩽",
      les: "⩽",
      lescc: "⪨",
      lesdot: "⩿",
      lesdoto: "⪁",
      lesdotor: "⪃",
      lesg: "⋚︀",
      lesges: "⪓",
      lessapprox: "⪅",
      lessdot: "⋖",
      lesseqgtr: "⋚",
      lesseqqgtr: "⪋",
      LessEqualGreater: "⋚",
      LessFullEqual: "≦",
      LessGreater: "≶",
      lessgtr: "≶",
      LessLess: "⪡",
      lesssim: "≲",
      LessSlantEqual: "⩽",
      LessTilde: "≲",
      lfisht: "⥼",
      lfloor: "⌊",
      Lfr: "𝔏",
      lfr: "𝔩",
      lg: "≶",
      lgE: "⪑",
      lHar: "⥢",
      lhard: "↽",
      lharu: "↼",
      lharul: "⥪",
      lhblk: "▄",
      LJcy: "Љ",
      ljcy: "љ",
      Ll: "⋘",
      ll: "≪",
      llarr: "⇇",
      llcorner: "⌞",
      Lleftarrow: "⇚",
      llhard: "⥫",
      lltri: "◺",
      Lmidot: "Ŀ",
      lmidot: "ŀ",
      lmoust: "⎰",
      lmoustache: "⎰",
      lnap: "⪉",
      lnapprox: "⪉",
      lnE: "≨",
      lne: "⪇",
      lneq: "⪇",
      lneqq: "≨",
      lnsim: "⋦",
      loang: "⟬",
      loarr: "⇽",
      lobrk: "⟦",
      LongLeftArrow: "⟵",
      Longleftarrow: "⟸",
      longleftarrow: "⟵",
      LongLeftRightArrow: "⟷",
      Longleftrightarrow: "⟺",
      longleftrightarrow: "⟷",
      longmapsto: "⟼",
      LongRightArrow: "⟶",
      Longrightarrow: "⟹",
      longrightarrow: "⟶",
      looparrowleft: "↫",
      looparrowright: "↬",
      lopar: "⦅",
      Lopf: "𝕃",
      lopf: "𝕝",
      loplus: "⨭",
      lotimes: "⨴",
      lowast: "∗",
      lowbar: "_",
      LowerLeftArrow: "↙",
      LowerRightArrow: "↘",
      loz: "◊",
      lozenge: "◊",
      lozf: "⧫",
      lpar: "(",
      lparlt: "⦓",
      lrarr: "⇆",
      lrcorner: "⌟",
      lrhar: "⇋",
      lrhard: "⥭",
      lrm: "‎",
      lrtri: "⊿",
      lsaquo: "‹",
      Lscr: "ℒ",
      lscr: "𝓁",
      Lsh: "↰",
      lsh: "↰",
      lsim: "≲",
      lsime: "⪍",
      lsimg: "⪏",
      lsqb: "[",
      lsquo: "‘",
      lsquor: "‚",
      Lstrok: "Ł",
      lstrok: "ł",
      Lt: "≪",
      LT: "<",
      lt: "<",
      ltcc: "⪦",
      ltcir: "⩹",
      ltdot: "⋖",
      lthree: "⋋",
      ltimes: "⋉",
      ltlarr: "⥶",
      ltquest: "⩻",
      ltri: "◃",
      ltrie: "⊴",
      ltrif: "◂",
      ltrPar: "⦖",
      lurdshar: "⥊",
      luruhar: "⥦",
      lvertneqq: "≨︀",
      lvnE: "≨︀",
      macr: "¯",
      male: "♂",
      malt: "✠",
      maltese: "✠",
      Map: "⤅",
      map: "↦",
      mapsto: "↦",
      mapstodown: "↧",
      mapstoleft: "↤",
      mapstoup: "↥",
      marker: "▮",
      mcomma: "⨩",
      Mcy: "М",
      mcy: "м",
      mdash: "—",
      mDDot: "∺",
      measuredangle: "∡",
      MediumSpace: " ",
      Mellintrf: "ℳ",
      Mfr: "𝔐",
      mfr: "𝔪",
      mho: "℧",
      micro: "µ",
      mid: "∣",
      midast: "*",
      midcir: "⫰",
      middot: "·",
      minus: "−",
      minusb: "⊟",
      minusd: "∸",
      minusdu: "⨪",
      MinusPlus: "∓",
      mlcp: "⫛",
      mldr: "…",
      mnplus: "∓",
      models: "⊧",
      Mopf: "𝕄",
      mopf: "𝕞",
      mp: "∓",
      Mscr: "ℳ",
      mscr: "𝓂",
      mstpos: "∾",
      Mu: "Μ",
      mu: "μ",
      multimap: "⊸",
      mumap: "⊸",
      nabla: "∇",
      Nacute: "Ń",
      nacute: "ń",
      nang: "∠⃒",
      nap: "≉",
      napE: "⩰̸",
      napid: "≋̸",
      napos: "ŉ",
      napprox: "≉",
      natur: "♮",
      natural: "♮",
      naturals: "ℕ",
      nbsp: " ",
      nbump: "≎̸",
      nbumpe: "≏̸",
      ncap: "⩃",
      Ncaron: "Ň",
      ncaron: "ň",
      Ncedil: "Ņ",
      ncedil: "ņ",
      ncong: "≇",
      ncongdot: "⩭̸",
      ncup: "⩂",
      Ncy: "Н",
      ncy: "н",
      ndash: "–",
      ne: "≠",
      nearhk: "⤤",
      neArr: "⇗",
      nearr: "↗",
      nearrow: "↗",
      nedot: "≐̸",
      NegativeMediumSpace: "​",
      NegativeThickSpace: "​",
      NegativeThinSpace: "​",
      NegativeVeryThinSpace: "​",
      nequiv: "≢",
      nesear: "⤨",
      nesim: "≂̸",
      NestedGreaterGreater: "≫",
      NestedLessLess: "≪",
      NewLine: `
`,
      nexist: "∄",
      nexists: "∄",
      Nfr: "𝔑",
      nfr: "𝔫",
      ngE: "≧̸",
      nge: "≱",
      ngeq: "≱",
      ngeqq: "≧̸",
      ngeqslant: "⩾̸",
      nges: "⩾̸",
      nGg: "⋙̸",
      ngsim: "≵",
      nGt: "≫⃒",
      ngt: "≯",
      ngtr: "≯",
      nGtv: "≫̸",
      nhArr: "⇎",
      nharr: "↮",
      nhpar: "⫲",
      ni: "∋",
      nis: "⋼",
      nisd: "⋺",
      niv: "∋",
      NJcy: "Њ",
      njcy: "њ",
      nlArr: "⇍",
      nlarr: "↚",
      nldr: "‥",
      nlE: "≦̸",
      nle: "≰",
      nLeftarrow: "⇍",
      nleftarrow: "↚",
      nLeftrightarrow: "⇎",
      nleftrightarrow: "↮",
      nleq: "≰",
      nleqq: "≦̸",
      nleqslant: "⩽̸",
      nles: "⩽̸",
      nless: "≮",
      nLl: "⋘̸",
      nlsim: "≴",
      nLt: "≪⃒",
      nlt: "≮",
      nltri: "⋪",
      nltrie: "⋬",
      nLtv: "≪̸",
      nmid: "∤",
      NoBreak: "⁠",
      NonBreakingSpace: " ",
      Nopf: "ℕ",
      nopf: "𝕟",
      Not: "⫬",
      not: "¬",
      NotCongruent: "≢",
      NotCupCap: "≭",
      NotDoubleVerticalBar: "∦",
      NotElement: "∉",
      NotEqual: "≠",
      NotEqualTilde: "≂̸",
      NotExists: "∄",
      NotGreater: "≯",
      NotGreaterEqual: "≱",
      NotGreaterFullEqual: "≧̸",
      NotGreaterGreater: "≫̸",
      NotGreaterLess: "≹",
      NotGreaterSlantEqual: "⩾̸",
      NotGreaterTilde: "≵",
      NotHumpDownHump: "≎̸",
      NotHumpEqual: "≏̸",
      notin: "∉",
      notindot: "⋵̸",
      notinE: "⋹̸",
      notinva: "∉",
      notinvb: "⋷",
      notinvc: "⋶",
      NotLeftTriangle: "⋪",
      NotLeftTriangleBar: "⧏̸",
      NotLeftTriangleEqual: "⋬",
      NotLess: "≮",
      NotLessEqual: "≰",
      NotLessGreater: "≸",
      NotLessLess: "≪̸",
      NotLessSlantEqual: "⩽̸",
      NotLessTilde: "≴",
      NotNestedGreaterGreater: "⪢̸",
      NotNestedLessLess: "⪡̸",
      notni: "∌",
      notniva: "∌",
      notnivb: "⋾",
      notnivc: "⋽",
      NotPrecedes: "⊀",
      NotPrecedesEqual: "⪯̸",
      NotPrecedesSlantEqual: "⋠",
      NotReverseElement: "∌",
      NotRightTriangle: "⋫",
      NotRightTriangleBar: "⧐̸",
      NotRightTriangleEqual: "⋭",
      NotSquareSubset: "⊏̸",
      NotSquareSubsetEqual: "⋢",
      NotSquareSuperset: "⊐̸",
      NotSquareSupersetEqual: "⋣",
      NotSubset: "⊂⃒",
      NotSubsetEqual: "⊈",
      NotSucceeds: "⊁",
      NotSucceedsEqual: "⪰̸",
      NotSucceedsSlantEqual: "⋡",
      NotSucceedsTilde: "≿̸",
      NotSuperset: "⊃⃒",
      NotSupersetEqual: "⊉",
      NotTilde: "≁",
      NotTildeEqual: "≄",
      NotTildeFullEqual: "≇",
      NotTildeTilde: "≉",
      NotVerticalBar: "∤",
      npar: "∦",
      nparallel: "∦",
      nparsl: "⫽⃥",
      npart: "∂̸",
      npolint: "⨔",
      npr: "⊀",
      nprcue: "⋠",
      npre: "⪯̸",
      nprec: "⊀",
      npreceq: "⪯̸",
      nrArr: "⇏",
      nrarr: "↛",
      nrarrc: "⤳̸",
      nrarrw: "↝̸",
      nRightarrow: "⇏",
      nrightarrow: "↛",
      nrtri: "⋫",
      nrtrie: "⋭",
      nsc: "⊁",
      nsccue: "⋡",
      nsce: "⪰̸",
      Nscr: "𝒩",
      nscr: "𝓃",
      nshortmid: "∤",
      nshortparallel: "∦",
      nsim: "≁",
      nsime: "≄",
      nsimeq: "≄",
      nsmid: "∤",
      nspar: "∦",
      nsqsube: "⋢",
      nsqsupe: "⋣",
      nsub: "⊄",
      nsubE: "⫅̸",
      nsube: "⊈",
      nsubset: "⊂⃒",
      nsubseteq: "⊈",
      nsubseteqq: "⫅̸",
      nsucc: "⊁",
      nsucceq: "⪰̸",
      nsup: "⊅",
      nsupE: "⫆̸",
      nsupe: "⊉",
      nsupset: "⊃⃒",
      nsupseteq: "⊉",
      nsupseteqq: "⫆̸",
      ntgl: "≹",
      Ntilde: "Ñ",
      ntilde: "ñ",
      ntlg: "≸",
      ntriangleleft: "⋪",
      ntrianglelefteq: "⋬",
      ntriangleright: "⋫",
      ntrianglerighteq: "⋭",
      Nu: "Ν",
      nu: "ν",
      num: "#",
      numero: "№",
      numsp: " ",
      nvap: "≍⃒",
      nVDash: "⊯",
      nVdash: "⊮",
      nvDash: "⊭",
      nvdash: "⊬",
      nvge: "≥⃒",
      nvgt: ">⃒",
      nvHarr: "⤄",
      nvinfin: "⧞",
      nvlArr: "⤂",
      nvle: "≤⃒",
      nvlt: "<⃒",
      nvltrie: "⊴⃒",
      nvrArr: "⤃",
      nvrtrie: "⊵⃒",
      nvsim: "∼⃒",
      nwarhk: "⤣",
      nwArr: "⇖",
      nwarr: "↖",
      nwarrow: "↖",
      nwnear: "⤧",
      Oacute: "Ó",
      oacute: "ó",
      oast: "⊛",
      ocir: "⊚",
      Ocirc: "Ô",
      ocirc: "ô",
      Ocy: "О",
      ocy: "о",
      odash: "⊝",
      Odblac: "Ő",
      odblac: "ő",
      odiv: "⨸",
      odot: "⊙",
      odsold: "⦼",
      OElig: "Œ",
      oelig: "œ",
      ofcir: "⦿",
      Ofr: "𝔒",
      ofr: "𝔬",
      ogon: "˛",
      Ograve: "Ò",
      ograve: "ò",
      ogt: "⧁",
      ohbar: "⦵",
      ohm: "Ω",
      oint: "∮",
      olarr: "↺",
      olcir: "⦾",
      olcross: "⦻",
      oline: "‾",
      olt: "⧀",
      Omacr: "Ō",
      omacr: "ō",
      Omega: "Ω",
      omega: "ω",
      Omicron: "Ο",
      omicron: "ο",
      omid: "⦶",
      ominus: "⊖",
      Oopf: "𝕆",
      oopf: "𝕠",
      opar: "⦷",
      OpenCurlyDoubleQuote: "“",
      OpenCurlyQuote: "‘",
      operp: "⦹",
      oplus: "⊕",
      Or: "⩔",
      or: "∨",
      orarr: "↻",
      ord: "⩝",
      order: "ℴ",
      orderof: "ℴ",
      ordf: "ª",
      ordm: "º",
      origof: "⊶",
      oror: "⩖",
      orslope: "⩗",
      orv: "⩛",
      oS: "Ⓢ",
      Oscr: "𝒪",
      oscr: "ℴ",
      Oslash: "Ø",
      oslash: "ø",
      osol: "⊘",
      Otilde: "Õ",
      otilde: "õ",
      Otimes: "⨷",
      otimes: "⊗",
      otimesas: "⨶",
      Ouml: "Ö",
      ouml: "ö",
      ovbar: "⌽",
      OverBar: "‾",
      OverBrace: "⏞",
      OverBracket: "⎴",
      OverParenthesis: "⏜",
      par: "∥",
      para: "¶",
      parallel: "∥",
      parsim: "⫳",
      parsl: "⫽",
      part: "∂",
      PartialD: "∂",
      Pcy: "П",
      pcy: "п",
      percnt: "%",
      period: ".",
      permil: "‰",
      perp: "⊥",
      pertenk: "‱",
      Pfr: "𝔓",
      pfr: "𝔭",
      Phi: "Φ",
      phi: "φ",
      phiv: "ϕ",
      phmmat: "ℳ",
      phone: "☎",
      Pi: "Π",
      pi: "π",
      pitchfork: "⋔",
      piv: "ϖ",
      planck: "ℏ",
      planckh: "ℎ",
      plankv: "ℏ",
      plus: "+",
      plusacir: "⨣",
      plusb: "⊞",
      pluscir: "⨢",
      plusdo: "∔",
      plusdu: "⨥",
      pluse: "⩲",
      PlusMinus: "±",
      plusmn: "±",
      plussim: "⨦",
      plustwo: "⨧",
      pm: "±",
      Poincareplane: "ℌ",
      pointint: "⨕",
      Popf: "ℙ",
      popf: "𝕡",
      pound: "£",
      Pr: "⪻",
      pr: "≺",
      prap: "⪷",
      prcue: "≼",
      prE: "⪳",
      pre: "⪯",
      prec: "≺",
      precapprox: "⪷",
      preccurlyeq: "≼",
      Precedes: "≺",
      PrecedesEqual: "⪯",
      PrecedesSlantEqual: "≼",
      PrecedesTilde: "≾",
      preceq: "⪯",
      precnapprox: "⪹",
      precneqq: "⪵",
      precnsim: "⋨",
      precsim: "≾",
      Prime: "″",
      prime: "′",
      primes: "ℙ",
      prnap: "⪹",
      prnE: "⪵",
      prnsim: "⋨",
      prod: "∏",
      Product: "∏",
      profalar: "⌮",
      profline: "⌒",
      profsurf: "⌓",
      prop: "∝",
      Proportion: "∷",
      Proportional: "∝",
      propto: "∝",
      prsim: "≾",
      prurel: "⊰",
      Pscr: "𝒫",
      pscr: "𝓅",
      Psi: "Ψ",
      psi: "ψ",
      puncsp: " ",
      Qfr: "𝔔",
      qfr: "𝔮",
      qint: "⨌",
      Qopf: "ℚ",
      qopf: "𝕢",
      qprime: "⁗",
      Qscr: "𝒬",
      qscr: "𝓆",
      quaternions: "ℍ",
      quatint: "⨖",
      quest: "?",
      questeq: "≟",
      QUOT: '"',
      quot: '"',
      rAarr: "⇛",
      race: "∽̱",
      Racute: "Ŕ",
      racute: "ŕ",
      radic: "√",
      raemptyv: "⦳",
      Rang: "⟫",
      rang: "⟩",
      rangd: "⦒",
      range: "⦥",
      rangle: "⟩",
      raquo: "»",
      Rarr: "↠",
      rArr: "⇒",
      rarr: "→",
      rarrap: "⥵",
      rarrb: "⇥",
      rarrbfs: "⤠",
      rarrc: "⤳",
      rarrfs: "⤞",
      rarrhk: "↪",
      rarrlp: "↬",
      rarrpl: "⥅",
      rarrsim: "⥴",
      Rarrtl: "⤖",
      rarrtl: "↣",
      rarrw: "↝",
      rAtail: "⤜",
      ratail: "⤚",
      ratio: "∶",
      rationals: "ℚ",
      RBarr: "⤐",
      rBarr: "⤏",
      rbarr: "⤍",
      rbbrk: "❳",
      rbrace: "}",
      rbrack: "]",
      rbrke: "⦌",
      rbrksld: "⦎",
      rbrkslu: "⦐",
      Rcaron: "Ř",
      rcaron: "ř",
      Rcedil: "Ŗ",
      rcedil: "ŗ",
      rceil: "⌉",
      rcub: "}",
      Rcy: "Р",
      rcy: "р",
      rdca: "⤷",
      rdldhar: "⥩",
      rdquo: "”",
      rdquor: "”",
      rdsh: "↳",
      Re: "ℜ",
      real: "ℜ",
      realine: "ℛ",
      realpart: "ℜ",
      reals: "ℝ",
      rect: "▭",
      REG: "®",
      reg: "®",
      ReverseElement: "∋",
      ReverseEquilibrium: "⇋",
      ReverseUpEquilibrium: "⥯",
      rfisht: "⥽",
      rfloor: "⌋",
      Rfr: "ℜ",
      rfr: "𝔯",
      rHar: "⥤",
      rhard: "⇁",
      rharu: "⇀",
      rharul: "⥬",
      Rho: "Ρ",
      rho: "ρ",
      rhov: "ϱ",
      RightAngleBracket: "⟩",
      RightArrow: "→",
      Rightarrow: "⇒",
      rightarrow: "→",
      RightArrowBar: "⇥",
      RightArrowLeftArrow: "⇄",
      rightarrowtail: "↣",
      RightCeiling: "⌉",
      RightDoubleBracket: "⟧",
      RightDownTeeVector: "⥝",
      RightDownVector: "⇂",
      RightDownVectorBar: "⥕",
      RightFloor: "⌋",
      rightharpoondown: "⇁",
      rightharpoonup: "⇀",
      rightleftarrows: "⇄",
      rightleftharpoons: "⇌",
      rightrightarrows: "⇉",
      rightsquigarrow: "↝",
      RightTee: "⊢",
      RightTeeArrow: "↦",
      RightTeeVector: "⥛",
      rightthreetimes: "⋌",
      RightTriangle: "⊳",
      RightTriangleBar: "⧐",
      RightTriangleEqual: "⊵",
      RightUpDownVector: "⥏",
      RightUpTeeVector: "⥜",
      RightUpVector: "↾",
      RightUpVectorBar: "⥔",
      RightVector: "⇀",
      RightVectorBar: "⥓",
      ring: "˚",
      risingdotseq: "≓",
      rlarr: "⇄",
      rlhar: "⇌",
      rlm: "‏",
      rmoust: "⎱",
      rmoustache: "⎱",
      rnmid: "⫮",
      roang: "⟭",
      roarr: "⇾",
      robrk: "⟧",
      ropar: "⦆",
      Ropf: "ℝ",
      ropf: "𝕣",
      roplus: "⨮",
      rotimes: "⨵",
      RoundImplies: "⥰",
      rpar: ")",
      rpargt: "⦔",
      rppolint: "⨒",
      rrarr: "⇉",
      Rrightarrow: "⇛",
      rsaquo: "›",
      Rscr: "ℛ",
      rscr: "𝓇",
      Rsh: "↱",
      rsh: "↱",
      rsqb: "]",
      rsquo: "’",
      rsquor: "’",
      rthree: "⋌",
      rtimes: "⋊",
      rtri: "▹",
      rtrie: "⊵",
      rtrif: "▸",
      rtriltri: "⧎",
      RuleDelayed: "⧴",
      ruluhar: "⥨",
      rx: "℞",
      Sacute: "Ś",
      sacute: "ś",
      sbquo: "‚",
      Sc: "⪼",
      sc: "≻",
      scap: "⪸",
      Scaron: "Š",
      scaron: "š",
      sccue: "≽",
      scE: "⪴",
      sce: "⪰",
      Scedil: "Ş",
      scedil: "ş",
      Scirc: "Ŝ",
      scirc: "ŝ",
      scnap: "⪺",
      scnE: "⪶",
      scnsim: "⋩",
      scpolint: "⨓",
      scsim: "≿",
      Scy: "С",
      scy: "с",
      sdot: "⋅",
      sdotb: "⊡",
      sdote: "⩦",
      searhk: "⤥",
      seArr: "⇘",
      searr: "↘",
      searrow: "↘",
      sect: "§",
      semi: ";",
      seswar: "⤩",
      setminus: "∖",
      setmn: "∖",
      sext: "✶",
      Sfr: "𝔖",
      sfr: "𝔰",
      sfrown: "⌢",
      sharp: "♯",
      SHCHcy: "Щ",
      shchcy: "щ",
      SHcy: "Ш",
      shcy: "ш",
      ShortDownArrow: "↓",
      ShortLeftArrow: "←",
      shortmid: "∣",
      shortparallel: "∥",
      ShortRightArrow: "→",
      ShortUpArrow: "↑",
      shy: "­",
      Sigma: "Σ",
      sigma: "σ",
      sigmaf: "ς",
      sigmav: "ς",
      sim: "∼",
      simdot: "⩪",
      sime: "≃",
      simeq: "≃",
      simg: "⪞",
      simgE: "⪠",
      siml: "⪝",
      simlE: "⪟",
      simne: "≆",
      simplus: "⨤",
      simrarr: "⥲",
      slarr: "←",
      SmallCircle: "∘",
      smallsetminus: "∖",
      smashp: "⨳",
      smeparsl: "⧤",
      smid: "∣",
      smile: "⌣",
      smt: "⪪",
      smte: "⪬",
      smtes: "⪬︀",
      SOFTcy: "Ь",
      softcy: "ь",
      sol: "/",
      solb: "⧄",
      solbar: "⌿",
      Sopf: "𝕊",
      sopf: "𝕤",
      spades: "♠",
      spadesuit: "♠",
      spar: "∥",
      sqcap: "⊓",
      sqcaps: "⊓︀",
      sqcup: "⊔",
      sqcups: "⊔︀",
      Sqrt: "√",
      sqsub: "⊏",
      sqsube: "⊑",
      sqsubset: "⊏",
      sqsubseteq: "⊑",
      sqsup: "⊐",
      sqsupe: "⊒",
      sqsupset: "⊐",
      sqsupseteq: "⊒",
      squ: "□",
      Square: "□",
      square: "□",
      SquareIntersection: "⊓",
      SquareSubset: "⊏",
      SquareSubsetEqual: "⊑",
      SquareSuperset: "⊐",
      SquareSupersetEqual: "⊒",
      SquareUnion: "⊔",
      squarf: "▪",
      squf: "▪",
      srarr: "→",
      Sscr: "𝒮",
      sscr: "𝓈",
      ssetmn: "∖",
      ssmile: "⌣",
      sstarf: "⋆",
      Star: "⋆",
      star: "☆",
      starf: "★",
      straightepsilon: "ϵ",
      straightphi: "ϕ",
      strns: "¯",
      Sub: "⋐",
      sub: "⊂",
      subdot: "⪽",
      subE: "⫅",
      sube: "⊆",
      subedot: "⫃",
      submult: "⫁",
      subnE: "⫋",
      subne: "⊊",
      subplus: "⪿",
      subrarr: "⥹",
      Subset: "⋐",
      subset: "⊂",
      subseteq: "⊆",
      subseteqq: "⫅",
      SubsetEqual: "⊆",
      subsetneq: "⊊",
      subsetneqq: "⫋",
      subsim: "⫇",
      subsub: "⫕",
      subsup: "⫓",
      succ: "≻",
      succapprox: "⪸",
      succcurlyeq: "≽",
      Succeeds: "≻",
      SucceedsEqual: "⪰",
      SucceedsSlantEqual: "≽",
      SucceedsTilde: "≿",
      succeq: "⪰",
      succnapprox: "⪺",
      succneqq: "⪶",
      succnsim: "⋩",
      succsim: "≿",
      SuchThat: "∋",
      Sum: "∑",
      sum: "∑",
      sung: "♪",
      Sup: "⋑",
      sup: "⊃",
      sup1: "¹",
      sup2: "²",
      sup3: "³",
      supdot: "⪾",
      supdsub: "⫘",
      supE: "⫆",
      supe: "⊇",
      supedot: "⫄",
      Superset: "⊃",
      SupersetEqual: "⊇",
      suphsol: "⟉",
      suphsub: "⫗",
      suplarr: "⥻",
      supmult: "⫂",
      supnE: "⫌",
      supne: "⊋",
      supplus: "⫀",
      Supset: "⋑",
      supset: "⊃",
      supseteq: "⊇",
      supseteqq: "⫆",
      supsetneq: "⊋",
      supsetneqq: "⫌",
      supsim: "⫈",
      supsub: "⫔",
      supsup: "⫖",
      swarhk: "⤦",
      swArr: "⇙",
      swarr: "↙",
      swarrow: "↙",
      swnwar: "⤪",
      szlig: "ß",
      Tab: "	",
      target: "⌖",
      Tau: "Τ",
      tau: "τ",
      tbrk: "⎴",
      Tcaron: "Ť",
      tcaron: "ť",
      Tcedil: "Ţ",
      tcedil: "ţ",
      Tcy: "Т",
      tcy: "т",
      tdot: "⃛",
      telrec: "⌕",
      Tfr: "𝔗",
      tfr: "𝔱",
      there4: "∴",
      Therefore: "∴",
      therefore: "∴",
      Theta: "Θ",
      theta: "θ",
      thetasym: "ϑ",
      thetav: "ϑ",
      thickapprox: "≈",
      thicksim: "∼",
      ThickSpace: "  ",
      thinsp: " ",
      ThinSpace: " ",
      thkap: "≈",
      thksim: "∼",
      THORN: "Þ",
      thorn: "þ",
      Tilde: "∼",
      tilde: "˜",
      TildeEqual: "≃",
      TildeFullEqual: "≅",
      TildeTilde: "≈",
      times: "×",
      timesb: "⊠",
      timesbar: "⨱",
      timesd: "⨰",
      tint: "∭",
      toea: "⤨",
      top: "⊤",
      topbot: "⌶",
      topcir: "⫱",
      Topf: "𝕋",
      topf: "𝕥",
      topfork: "⫚",
      tosa: "⤩",
      tprime: "‴",
      TRADE: "™",
      trade: "™",
      triangle: "▵",
      triangledown: "▿",
      triangleleft: "◃",
      trianglelefteq: "⊴",
      triangleq: "≜",
      triangleright: "▹",
      trianglerighteq: "⊵",
      tridot: "◬",
      trie: "≜",
      triminus: "⨺",
      TripleDot: "⃛",
      triplus: "⨹",
      trisb: "⧍",
      tritime: "⨻",
      trpezium: "⏢",
      Tscr: "𝒯",
      tscr: "𝓉",
      TScy: "Ц",
      tscy: "ц",
      TSHcy: "Ћ",
      tshcy: "ћ",
      Tstrok: "Ŧ",
      tstrok: "ŧ",
      twixt: "≬",
      twoheadleftarrow: "↞",
      twoheadrightarrow: "↠",
      Uacute: "Ú",
      uacute: "ú",
      Uarr: "↟",
      uArr: "⇑",
      uarr: "↑",
      Uarrocir: "⥉",
      Ubrcy: "Ў",
      ubrcy: "ў",
      Ubreve: "Ŭ",
      ubreve: "ŭ",
      Ucirc: "Û",
      ucirc: "û",
      Ucy: "У",
      ucy: "у",
      udarr: "⇅",
      Udblac: "Ű",
      udblac: "ű",
      udhar: "⥮",
      ufisht: "⥾",
      Ufr: "𝔘",
      ufr: "𝔲",
      Ugrave: "Ù",
      ugrave: "ù",
      uHar: "⥣",
      uharl: "↿",
      uharr: "↾",
      uhblk: "▀",
      ulcorn: "⌜",
      ulcorner: "⌜",
      ulcrop: "⌏",
      ultri: "◸",
      Umacr: "Ū",
      umacr: "ū",
      uml: "¨",
      UnderBar: "_",
      UnderBrace: "⏟",
      UnderBracket: "⎵",
      UnderParenthesis: "⏝",
      Union: "⋃",
      UnionPlus: "⊎",
      Uogon: "Ų",
      uogon: "ų",
      Uopf: "𝕌",
      uopf: "𝕦",
      UpArrow: "↑",
      Uparrow: "⇑",
      uparrow: "↑",
      UpArrowBar: "⤒",
      UpArrowDownArrow: "⇅",
      UpDownArrow: "↕",
      Updownarrow: "⇕",
      updownarrow: "↕",
      UpEquilibrium: "⥮",
      upharpoonleft: "↿",
      upharpoonright: "↾",
      uplus: "⊎",
      UpperLeftArrow: "↖",
      UpperRightArrow: "↗",
      Upsi: "ϒ",
      upsi: "υ",
      upsih: "ϒ",
      Upsilon: "Υ",
      upsilon: "υ",
      UpTee: "⊥",
      UpTeeArrow: "↥",
      upuparrows: "⇈",
      urcorn: "⌝",
      urcorner: "⌝",
      urcrop: "⌎",
      Uring: "Ů",
      uring: "ů",
      urtri: "◹",
      Uscr: "𝒰",
      uscr: "𝓊",
      utdot: "⋰",
      Utilde: "Ũ",
      utilde: "ũ",
      utri: "▵",
      utrif: "▴",
      uuarr: "⇈",
      Uuml: "Ü",
      uuml: "ü",
      uwangle: "⦧",
      vangrt: "⦜",
      varepsilon: "ϵ",
      varkappa: "ϰ",
      varnothing: "∅",
      varphi: "ϕ",
      varpi: "ϖ",
      varpropto: "∝",
      vArr: "⇕",
      varr: "↕",
      varrho: "ϱ",
      varsigma: "ς",
      varsubsetneq: "⊊︀",
      varsubsetneqq: "⫋︀",
      varsupsetneq: "⊋︀",
      varsupsetneqq: "⫌︀",
      vartheta: "ϑ",
      vartriangleleft: "⊲",
      vartriangleright: "⊳",
      Vbar: "⫫",
      vBar: "⫨",
      vBarv: "⫩",
      Vcy: "В",
      vcy: "в",
      VDash: "⊫",
      Vdash: "⊩",
      vDash: "⊨",
      vdash: "⊢",
      Vdashl: "⫦",
      Vee: "⋁",
      vee: "∨",
      veebar: "⊻",
      veeeq: "≚",
      vellip: "⋮",
      Verbar: "‖",
      verbar: "|",
      Vert: "‖",
      vert: "|",
      VerticalBar: "∣",
      VerticalLine: "|",
      VerticalSeparator: "❘",
      VerticalTilde: "≀",
      VeryThinSpace: " ",
      Vfr: "𝔙",
      vfr: "𝔳",
      vltri: "⊲",
      vnsub: "⊂⃒",
      vnsup: "⊃⃒",
      Vopf: "𝕍",
      vopf: "𝕧",
      vprop: "∝",
      vrtri: "⊳",
      Vscr: "𝒱",
      vscr: "𝓋",
      vsubnE: "⫋︀",
      vsubne: "⊊︀",
      vsupnE: "⫌︀",
      vsupne: "⊋︀",
      Vvdash: "⊪",
      vzigzag: "⦚",
      Wcirc: "Ŵ",
      wcirc: "ŵ",
      wedbar: "⩟",
      Wedge: "⋀",
      wedge: "∧",
      wedgeq: "≙",
      weierp: "℘",
      Wfr: "𝔚",
      wfr: "𝔴",
      Wopf: "𝕎",
      wopf: "𝕨",
      wp: "℘",
      wr: "≀",
      wreath: "≀",
      Wscr: "𝒲",
      wscr: "𝓌",
      xcap: "⋂",
      xcirc: "◯",
      xcup: "⋃",
      xdtri: "▽",
      Xfr: "𝔛",
      xfr: "𝔵",
      xhArr: "⟺",
      xharr: "⟷",
      Xi: "Ξ",
      xi: "ξ",
      xlArr: "⟸",
      xlarr: "⟵",
      xmap: "⟼",
      xnis: "⋻",
      xodot: "⨀",
      Xopf: "𝕏",
      xopf: "𝕩",
      xoplus: "⨁",
      xotime: "⨂",
      xrArr: "⟹",
      xrarr: "⟶",
      Xscr: "𝒳",
      xscr: "𝓍",
      xsqcup: "⨆",
      xuplus: "⨄",
      xutri: "△",
      xvee: "⋁",
      xwedge: "⋀",
      Yacute: "Ý",
      yacute: "ý",
      YAcy: "Я",
      yacy: "я",
      Ycirc: "Ŷ",
      ycirc: "ŷ",
      Ycy: "Ы",
      ycy: "ы",
      yen: "¥",
      Yfr: "𝔜",
      yfr: "𝔶",
      YIcy: "Ї",
      yicy: "ї",
      Yopf: "𝕐",
      yopf: "𝕪",
      Yscr: "𝒴",
      yscr: "𝓎",
      YUcy: "Ю",
      yucy: "ю",
      Yuml: "Ÿ",
      yuml: "ÿ",
      Zacute: "Ź",
      zacute: "ź",
      Zcaron: "Ž",
      zcaron: "ž",
      Zcy: "З",
      zcy: "з",
      Zdot: "Ż",
      zdot: "ż",
      zeetrf: "ℨ",
      ZeroWidthSpace: "​",
      Zeta: "Ζ",
      zeta: "ζ",
      Zfr: "ℨ",
      zfr: "𝔷",
      ZHcy: "Ж",
      zhcy: "ж",
      zigrarr: "⇝",
      Zopf: "ℤ",
      zopf: "𝕫",
      Zscr: "𝒵",
      zscr: "𝓏",
      zwj: "‍",
      zwnj: "‌"
    }), t.entityMap = t.HTML_ENTITIES;
  }(WA)), WA;
}
var Dp = {}, xx;
function Y4e() {
  if (xx) return Dp;
  xx = 1;
  var t = _g().NAMESPACE, e = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, n = new RegExp("[\\-\\.0-9" + e.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), r = new RegExp("^" + e.source + n.source + "*(?::" + e.source + n.source + "*)?$"), i = 0, s = 1, a = 2, o = 3, u = 4, c = 5, d = 6, l = 7;
  function f(T, N) {
    this.message = T, this.locator = N, Error.captureStackTrace && Error.captureStackTrace(this, f);
  }
  f.prototype = new Error(), f.prototype.name = f.name;
  function p() {
  }
  p.prototype = {
    parse: function(T, N, H) {
      var $ = this.domBuilder;
      $.startDocument(), _(N, N = {}), m(
        T,
        N,
        H,
        $,
        this.errorHandler
      ), $.endDocument();
    }
  };
  function m(T, N, H, $, j) {
    function U(Te) {
      if (Te > 65535) {
        Te -= 65536;
        var je = 55296 + (Te >> 10), We = 56320 + (Te & 1023);
        return String.fromCharCode(je, We);
      } else
        return String.fromCharCode(Te);
    }
    function V(Te) {
      var je = Te.slice(1, -1);
      return Object.hasOwnProperty.call(H, je) ? H[je] : je.charAt(0) === "#" ? U(parseInt(je.substr(1).replace("x", "0x"))) : (j.error("entity not found:" + Te), Te);
    }
    function B(Te) {
      if (Te > ee) {
        var je = T.substring(ee, Te).replace(/&#?\w+;/g, V);
        I && R(ee), $.characters(je, 0, Te - ee), ee = Te;
      }
    }
    function R(Te, je) {
      for (; Te >= Q && (je = P.exec(T)); )
        K = je.index, Q = K + je[0].length, I.lineNumber++;
      I.columnNumber = Te - K + 1;
    }
    for (var K = 0, Q = 0, P = /.*(?:\r\n?|\n)|.*$/g, I = $.locator, G = [{ currentNSMap: N }], te = {}, ee = 0; ; ) {
      try {
        var Z = T.indexOf("<", ee);
        if (Z < 0) {
          if (!T.substr(ee).match(/^\s*$/)) {
            var ye = $.doc, he = ye.createTextNode(T.substr(ee));
            ye.appendChild(he), $.currentElement = he;
          }
          return;
        }
        switch (Z > ee && B(Z), T.charAt(Z + 1)) {
          case "/":
            var at = T.indexOf(">", Z + 3), Ee = T.substring(Z + 2, at).replace(/[ \t\n\r]+$/g, ""), be = G.pop();
            at < 0 ? (Ee = T.substring(Z + 2).replace(/[\s<].*/, ""), j.error("end tag name: " + Ee + " is not complete:" + be.tagName), at = Z + 1 + Ee.length) : Ee.match(/\s</) && (Ee = Ee.replace(/[\s<].*/, ""), j.error("end tag name: " + Ee + " maybe not complete"), at = Z + 1 + Ee.length);
            var ve = be.localNSMap, Ce = be.tagName == Ee, Ne = Ce || be.tagName && be.tagName.toLowerCase() == Ee.toLowerCase();
            if (Ne) {
              if ($.endElement(be.uri, be.localName, Ee), ve)
                for (var qe in ve)
                  Object.prototype.hasOwnProperty.call(ve, qe) && $.endPrefixMapping(qe);
              Ce || j.fatalError("end tag name: " + Ee + " is not match the current start tagName:" + be.tagName);
            } else
              G.push(be);
            at++;
            break;
          // end elment
          case "?":
            I && R(Z), at = S(T, Z, $);
            break;
          case "!":
            I && R(Z), at = D(T, Z, $, j);
            break;
          default:
            I && R(Z);
            var $e = new M(), Xe = G[G.length - 1].currentNSMap, at = y(T, Z, $e, Xe, V, j), Ie = $e.length;
            if (!$e.closed && v(T, at, $e.tagName, te) && ($e.closed = !0, H.nbsp || j.warning("unclosed xml attribute")), I && Ie) {
              for (var ne = g(I, {}), ue = 0; ue < Ie; ue++) {
                var ie = $e[ue];
                R(ie.offset), ie.locator = g(I, {});
              }
              $.locator = ne, b($e, $, Xe) && G.push($e), $.locator = I;
            } else
              b($e, $, Xe) && G.push($e);
            t.isHTML($e.uri) && !$e.closed ? at = E(T, at, $e.tagName, V, $) : at++;
        }
      } catch (Te) {
        if (Te instanceof f)
          throw Te;
        j.error("element parse error: " + Te), at = -1;
      }
      at > ee ? ee = at : B(Math.max(Z, ee) + 1);
    }
  }
  function g(T, N) {
    return N.lineNumber = T.lineNumber, N.columnNumber = T.columnNumber, N;
  }
  function y(T, N, H, $, j, U) {
    function V(I, G, te) {
      H.attributeNames.hasOwnProperty(I) && U.fatalError("Attribute " + I + " redefined"), H.addValue(
        I,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        G.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, j),
        te
      );
    }
    for (var B, R, K = ++N, Q = i; ; ) {
      var P = T.charAt(K);
      switch (P) {
        case "=":
          if (Q === s)
            B = T.slice(N, K), Q = o;
          else if (Q === a)
            Q = o;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (Q === o || Q === s)
            if (Q === s && (U.warning('attribute value must after "="'), B = T.slice(N, K)), N = K + 1, K = T.indexOf(P, N), K > 0)
              R = T.slice(N, K), V(B, R, N - 1), Q = c;
            else
              throw new Error("attribute value no end '" + P + "' match");
          else if (Q == u)
            R = T.slice(N, K), V(B, R, N), U.warning('attribute "' + B + '" missed start quot(' + P + ")!!"), N = K + 1, Q = c;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (Q) {
            case i:
              H.setTagName(T.slice(N, K));
            case c:
            case d:
            case l:
              Q = l, H.closed = !0;
            case u:
            case s:
              break;
            case a:
              H.closed = !0;
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return U.error("unexpected end of input"), Q == i && H.setTagName(T.slice(N, K)), K;
        case ">":
          switch (Q) {
            case i:
              H.setTagName(T.slice(N, K));
            case c:
            case d:
            case l:
              break;
            //normal
            case u:
            //Compatible state
            case s:
              R = T.slice(N, K), R.slice(-1) === "/" && (H.closed = !0, R = R.slice(0, -1));
            case a:
              Q === a && (R = B), Q == u ? (U.warning('attribute "' + R + '" missed quot(")!'), V(B, R, N)) : ((!t.isHTML($[""]) || !R.match(/^(?:disabled|checked|selected)$/i)) && U.warning('attribute "' + R + '" missed value!! "' + R + '" instead!!'), V(R, R, N));
              break;
            case o:
              throw new Error("attribute value missed!!");
          }
          return K;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "":
          P = " ";
        default:
          if (P <= " ")
            switch (Q) {
              case i:
                H.setTagName(T.slice(N, K)), Q = d;
                break;
              case s:
                B = T.slice(N, K), Q = a;
                break;
              case u:
                var R = T.slice(N, K);
                U.warning('attribute "' + R + '" missed quot(")!!'), V(B, R, N);
              case c:
                Q = d;
                break;
            }
          else
            switch (Q) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case a:
                H.tagName, (!t.isHTML($[""]) || !B.match(/^(?:disabled|checked|selected)$/i)) && U.warning('attribute "' + B + '" missed value!! "' + B + '" instead2!!'), V(B, B, N), N = K, Q = s;
                break;
              case c:
                U.warning('attribute space is required"' + B + '"!!');
              case d:
                Q = s, N = K;
                break;
              case o:
                Q = u, N = K;
                break;
              case l:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      K++;
    }
  }
  function b(T, N, H) {
    for (var $ = T.tagName, j = null, P = T.length; P--; ) {
      var U = T[P], V = U.qName, B = U.value, I = V.indexOf(":");
      if (I > 0)
        var R = U.prefix = V.slice(0, I), K = V.slice(I + 1), Q = R === "xmlns" && K;
      else
        K = V, R = null, Q = V === "xmlns" && "";
      U.localName = K, Q !== !1 && (j == null && (j = {}, _(H, H = {})), H[Q] = j[Q] = B, U.uri = t.XMLNS, N.startPrefixMapping(Q, B));
    }
    for (var P = T.length; P--; ) {
      U = T[P];
      var R = U.prefix;
      R && (R === "xml" && (U.uri = t.XML), R !== "xmlns" && (U.uri = H[R || ""]));
    }
    var I = $.indexOf(":");
    I > 0 ? (R = T.prefix = $.slice(0, I), K = T.localName = $.slice(I + 1)) : (R = null, K = T.localName = $);
    var G = T.uri = H[R || ""];
    if (N.startElement(G, K, $, T), T.closed) {
      if (N.endElement(G, K, $), j)
        for (R in j)
          Object.prototype.hasOwnProperty.call(j, R) && N.endPrefixMapping(R);
    } else
      return T.currentNSMap = H, T.localNSMap = j, !0;
  }
  function E(T, N, H, $, j) {
    if (/^(?:script|textarea)$/i.test(H)) {
      var U = T.indexOf("</" + H + ">", N), V = T.substring(N + 1, U);
      if (/[&<]/.test(V))
        return /^script$/i.test(H) ? (j.characters(V, 0, V.length), U) : (V = V.replace(/&#?\w+;/g, $), j.characters(V, 0, V.length), U);
    }
    return N + 1;
  }
  function v(T, N, H, $) {
    var j = $[H];
    return j == null && (j = T.lastIndexOf("</" + H + ">"), j < N && (j = T.lastIndexOf("</" + H)), $[H] = j), j < N;
  }
  function _(T, N) {
    for (var H in T)
      Object.prototype.hasOwnProperty.call(T, H) && (N[H] = T[H]);
  }
  function D(T, N, H, $) {
    var j = T.charAt(N + 2);
    switch (j) {
      case "-":
        if (T.charAt(N + 3) === "-") {
          var U = T.indexOf("-->", N + 4);
          return U > N ? (H.comment(T, N + 4, U - N - 4), U + 3) : ($.error("Unclosed comment"), -1);
        } else
          return -1;
      default:
        if (T.substr(N + 3, 6) == "CDATA[") {
          var U = T.indexOf("]]>", N + 9);
          return H.startCDATA(), H.characters(T, N + 9, U - N - 9), H.endCDATA(), U + 3;
        }
        var V = O(T, N), B = V.length;
        if (B > 1 && /!doctype/i.test(V[0][0])) {
          var R = V[1][0], K = !1, Q = !1;
          B > 3 && (/^public$/i.test(V[2][0]) ? (K = V[3][0], Q = B > 4 && V[4][0]) : /^system$/i.test(V[2][0]) && (Q = V[3][0]));
          var P = V[B - 1];
          return H.startDTD(R, K, Q), H.endDTD(), P.index + P[0].length;
        }
    }
    return -1;
  }
  function S(T, N, H) {
    var $ = T.indexOf("?>", N);
    if ($) {
      var j = T.substring(N, $).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      return j ? (j[0].length, H.processingInstruction(j[1], j[2]), $ + 2) : -1;
    }
    return -1;
  }
  function M() {
    this.attributeNames = {};
  }
  M.prototype = {
    setTagName: function(T) {
      if (!r.test(T))
        throw new Error("invalid tagName:" + T);
      this.tagName = T;
    },
    addValue: function(T, N, H) {
      if (!r.test(T))
        throw new Error("invalid attribute:" + T);
      this.attributeNames[T] = this.length, this[this.length++] = { qName: T, value: N, offset: H };
    },
    length: 0,
    getLocalName: function(T) {
      return this[T].localName;
    },
    getLocator: function(T) {
      return this[T].locator;
    },
    getQName: function(T) {
      return this[T].qName;
    },
    getURI: function(T) {
      return this[T].uri;
    },
    getValue: function(T) {
      return this[T].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function O(T, N) {
    var H, $ = [], j = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    for (j.lastIndex = N, j.exec(T); H = j.exec(T); )
      if ($.push(H), H[1]) return $;
  }
  return Dp.XMLReader = p, Dp.ParseError = f, Dp;
}
var wx;
function X4e() {
  if (wx) return Od;
  wx = 1;
  var t = _g(), e = AD(), n = G4e(), r = Y4e(), i = e.DOMImplementation, s = t.NAMESPACE, a = r.ParseError, o = r.XMLReader;
  function u(y) {
    return y.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
  }
  function c(y) {
    this.options = y || { locator: {} };
  }
  c.prototype.parseFromString = function(y, b) {
    var E = this.options, v = new o(), _ = E.domBuilder || new l(), D = E.errorHandler, S = E.locator, M = E.xmlns || {}, O = /\/x?html?$/.test(b), T = O ? n.HTML_ENTITIES : n.XML_ENTITIES;
    S && _.setDocumentLocator(S), v.errorHandler = d(D, _, S), v.domBuilder = E.domBuilder || _, O && (M[""] = s.HTML), M.xml = M.xml || s.XML;
    var N = E.normalizeLineEndings || u;
    return y && typeof y == "string" ? v.parse(
      N(y),
      M,
      T
    ) : v.errorHandler.error("invalid doc source"), _.doc;
  };
  function d(y, b, E) {
    if (!y) {
      if (b instanceof l)
        return b;
      y = b;
    }
    var v = {}, _ = y instanceof Function;
    E = E || {};
    function D(S) {
      var M = y[S];
      !M && _ && (M = y.length == 2 ? function(O) {
        y(S, O);
      } : y), v[S] = M && function(O) {
        M("[xmldom " + S + "]	" + O + p(E));
      } || function() {
      };
    }
    return D("warning"), D("error"), D("fatalError"), v;
  }
  function l() {
    this.cdata = !1;
  }
  function f(y, b) {
    b.lineNumber = y.lineNumber, b.columnNumber = y.columnNumber;
  }
  l.prototype = {
    startDocument: function() {
      this.doc = new i().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
    },
    startElement: function(y, b, E, v) {
      var _ = this.doc, D = _.createElementNS(y, E || b), S = v.length;
      g(this, D), this.currentElement = D, this.locator && f(this.locator, D);
      for (var M = 0; M < S; M++) {
        var y = v.getURI(M), O = v.getValue(M), E = v.getQName(M), T = _.createAttributeNS(y, E);
        this.locator && f(v.getLocator(M), T), T.value = T.nodeValue = O, D.setAttributeNode(T);
      }
    },
    endElement: function(y, b, E) {
      var v = this.currentElement;
      v.tagName, this.currentElement = v.parentNode;
    },
    startPrefixMapping: function(y, b) {
    },
    endPrefixMapping: function(y) {
    },
    processingInstruction: function(y, b) {
      var E = this.doc.createProcessingInstruction(y, b);
      this.locator && f(this.locator, E), g(this, E);
    },
    ignorableWhitespace: function(y, b, E) {
    },
    characters: function(y, b, E) {
      if (y = m.apply(this, arguments), y) {
        if (this.cdata)
          var v = this.doc.createCDATASection(y);
        else
          var v = this.doc.createTextNode(y);
        this.currentElement ? this.currentElement.appendChild(v) : /^\s*$/.test(y) && this.doc.appendChild(v), this.locator && f(this.locator, v);
      }
    },
    skippedEntity: function(y) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(y) {
      (this.locator = y) && (y.lineNumber = 0);
    },
    //LexicalHandler
    comment: function(y, b, E) {
      y = m.apply(this, arguments);
      var v = this.doc.createComment(y);
      this.locator && f(this.locator, v), g(this, v);
    },
    startCDATA: function() {
      this.cdata = !0;
    },
    endCDATA: function() {
      this.cdata = !1;
    },
    startDTD: function(y, b, E) {
      var v = this.doc.implementation;
      if (v && v.createDocumentType) {
        var _ = v.createDocumentType(y, b, E);
        this.locator && f(this.locator, _), g(this, _), this.doc.doctype = _;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(y) {
      console.warn("[xmldom warning]	" + y, p(this.locator));
    },
    error: function(y) {
      console.error("[xmldom error]	" + y, p(this.locator));
    },
    fatalError: function(y) {
      throw new a(y, this.locator);
    }
  };
  function p(y) {
    if (y)
      return `
@` + (y.systemId || "") + "#[line:" + y.lineNumber + ",col:" + y.columnNumber + "]";
  }
  function m(y, b, E) {
    return typeof y == "string" ? y.substr(b, E) : y.length >= b + E || b ? new java.lang.String(y, b, E) + "" : y;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(y) {
    l.prototype[y] = function() {
      return null;
    };
  });
  function g(y, b) {
    y.currentElement ? y.currentElement.appendChild(b) : y.doc.appendChild(b);
  }
  return Od.__DOMHandler = l, Od.normalizeLineEndings = u, Od.DOMParser = c, Od;
}
var Cx;
function K4e() {
  if (Cx) return Md;
  Cx = 1;
  var t = AD();
  return Md.DOMImplementation = t.DOMImplementation, Md.XMLSerializer = t.XMLSerializer, Md.DOMParser = X4e().DOMParser, Md;
}
var Z4e = K4e();
/*! @name mpd-parser @version 1.3.1 @license Apache-2.0 */
const Sx = (t) => !!t && typeof t == "object", Dr = (...t) => t.reduce((e, n) => (typeof n != "object" || Object.keys(n).forEach((r) => {
  Array.isArray(e[r]) && Array.isArray(n[r]) ? e[r] = e[r].concat(n[r]) : Sx(e[r]) && Sx(n[r]) ? e[r] = Dr(e[r], n[r]) : e[r] = n[r];
}), e), {}), bD = (t) => Object.keys(t).map((e) => t[e]), J4e = (t, e) => {
  const n = [];
  for (let r = t; r < e; r++)
    n.push(r);
  return n;
}, lc = (t) => t.reduce((e, n) => e.concat(n), []), yD = (t) => {
  if (!t.length)
    return [];
  const e = [];
  for (let n = 0; n < t.length; n++)
    e.push(t[n]);
  return e;
}, exe = (t, e) => t.reduce((n, r, i) => (r[e] && n.push(i), n), []), txe = (t, e) => bD(t.reduce((n, r) => (r.forEach((i) => {
  n[e(i)] = i;
}), n), {}));
var cc = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
};
const Qf = ({
  baseUrl: t = "",
  source: e = "",
  range: n = "",
  indexRange: r = ""
}) => {
  const i = {
    uri: e,
    resolvedUri: Tg(t || "", e)
  };
  if (n || r) {
    const a = (n || r).split("-");
    let o = pe.BigInt ? pe.BigInt(a[0]) : parseInt(a[0], 10), u = pe.BigInt ? pe.BigInt(a[1]) : parseInt(a[1], 10);
    o < Number.MAX_SAFE_INTEGER && typeof o == "bigint" && (o = Number(o)), u < Number.MAX_SAFE_INTEGER && typeof u == "bigint" && (u = Number(u));
    let c;
    typeof u == "bigint" || typeof o == "bigint" ? c = pe.BigInt(u) - pe.BigInt(o) + pe.BigInt(1) : c = u - o + 1, typeof c == "bigint" && c < Number.MAX_SAFE_INTEGER && (c = Number(c)), i.byterange = {
      length: c,
      offset: o
    };
  }
  return i;
}, nxe = (t) => {
  let e;
  return typeof t.offset == "bigint" || typeof t.length == "bigint" ? e = pe.BigInt(t.offset) + pe.BigInt(t.length) - pe.BigInt(1) : e = t.offset + t.length - 1, `${t.offset}-${e}`;
}, Ix = (t) => (t && typeof t != "number" && (t = parseInt(t, 10)), isNaN(t) ? null : t), rxe = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static(t) {
    const {
      duration: e,
      timescale: n = 1,
      sourceDuration: r,
      periodDuration: i
    } = t, s = Ix(t.endNumber), a = e / n;
    return typeof s == "number" ? {
      start: 0,
      end: s
    } : typeof i == "number" ? {
      start: 0,
      end: i / a
    } : {
      start: 0,
      end: r / a
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic(t) {
    const {
      NOW: e,
      clientOffset: n,
      availabilityStartTime: r,
      timescale: i = 1,
      duration: s,
      periodStart: a = 0,
      minimumUpdatePeriod: o = 0,
      timeShiftBufferDepth: u = 1 / 0
    } = t, c = Ix(t.endNumber), d = (e + n) / 1e3, l = r + a, p = d + o - l, m = Math.ceil(p * i / s), g = Math.floor((d - l - u) * i / s), y = Math.floor((d - l) * i / s);
    return {
      start: Math.max(0, g),
      end: typeof c == "number" ? c : Math.min(m, y)
    };
  }
}, ixe = (t) => (e) => {
  const {
    duration: n,
    timescale: r = 1,
    periodStart: i,
    startNumber: s = 1
  } = t;
  return {
    number: s + e,
    duration: n / r,
    timeline: i,
    time: e * n
  };
}, uT = (t) => {
  const {
    type: e,
    duration: n,
    timescale: r = 1,
    periodDuration: i,
    sourceDuration: s
  } = t, {
    start: a,
    end: o
  } = rxe[e](t), u = J4e(a, o).map(ixe(t));
  if (e === "static") {
    const c = u.length - 1, d = typeof i == "number" ? i : s;
    u[c].duration = d - n / r * c;
  }
  return u;
}, vD = (t) => {
  const {
    baseUrl: e,
    initialization: n = {},
    sourceDuration: r,
    indexRange: i = "",
    periodStart: s,
    presentationTime: a,
    number: o = 0,
    duration: u
  } = t;
  if (!e)
    throw new Error(cc.NO_BASE_URL);
  const c = Qf({
    baseUrl: e,
    source: n.sourceURL,
    range: n.range
  }), d = Qf({
    baseUrl: e,
    source: e,
    indexRange: i
  });
  if (d.map = c, u) {
    const l = uT(t);
    l.length && (d.duration = l[0].duration, d.timeline = l[0].timeline);
  } else r && (d.duration = r, d.timeline = s);
  return d.presentationTime = a || s, d.number = o, [d];
}, lT = (t, e, n) => {
  const r = t.sidx.map ? t.sidx.map : null, i = t.sidx.duration, s = t.timeline || 0, a = t.sidx.byterange, o = a.offset + a.length, u = e.timescale, c = e.references.filter((y) => y.referenceType !== 1), d = [], l = t.endList ? "static" : "dynamic", f = t.sidx.timeline;
  let p = f, m = t.mediaSequence || 0, g;
  typeof e.firstOffset == "bigint" ? g = pe.BigInt(o) + e.firstOffset : g = o + e.firstOffset;
  for (let y = 0; y < c.length; y++) {
    const b = e.references[y], E = b.referencedSize, v = b.subsegmentDuration;
    let _;
    typeof g == "bigint" ? _ = g + pe.BigInt(E) - pe.BigInt(1) : _ = g + E - 1;
    const D = `${g}-${_}`, M = vD({
      baseUrl: n,
      timescale: u,
      timeline: s,
      periodStart: f,
      presentationTime: p,
      number: m,
      duration: v,
      sourceDuration: i,
      indexRange: D,
      type: l
    })[0];
    r && (M.map = r), d.push(M), typeof g == "bigint" ? g += pe.BigInt(E) : g += E, p += v / u, m++;
  }
  return t.segments = d, t;
}, sxe = ["AUDIO", "SUBTITLES"], axe = 1 / 60, TD = (t) => txe(t, ({
  timeline: e
}) => e).sort((e, n) => e.timeline > n.timeline ? 1 : -1), oxe = (t, e) => {
  for (let n = 0; n < t.length; n++)
    if (t[n].attributes.NAME === e)
      return t[n];
  return null;
}, kx = (t) => {
  let e = [];
  return Q4e(t, sxe, (n, r, i, s) => {
    e = e.concat(n.playlists || []);
  }), e;
}, Dx = ({
  playlist: t,
  mediaSequence: e
}) => {
  t.mediaSequence = e, t.segments.forEach((n, r) => {
    n.number = t.mediaSequence + r;
  });
}, uxe = ({
  oldPlaylists: t,
  newPlaylists: e,
  timelineStarts: n
}) => {
  e.forEach((r) => {
    r.discontinuitySequence = n.findIndex(function({
      timeline: u
    }) {
      return u === r.timeline;
    });
    const i = oxe(t, r.attributes.NAME);
    if (!i || r.sidx)
      return;
    const s = r.segments[0], a = i.segments.findIndex(function(u) {
      return Math.abs(u.presentationTime - s.presentationTime) < axe;
    });
    if (a === -1) {
      Dx({
        playlist: r,
        mediaSequence: i.mediaSequence + i.segments.length
      }), r.segments[0].discontinuity = !0, r.discontinuityStarts.unshift(0), (!i.segments.length && r.timeline > i.timeline || i.segments.length && r.timeline > i.segments[i.segments.length - 1].timeline) && r.discontinuitySequence--;
      return;
    }
    i.segments[a].discontinuity && !s.discontinuity && (s.discontinuity = !0, r.discontinuityStarts.unshift(0), r.discontinuitySequence--), Dx({
      playlist: r,
      mediaSequence: i.segments[a].number
    });
  });
}, lxe = ({
  oldManifest: t,
  newManifest: e
}) => {
  const n = t.playlists.concat(kx(t)), r = e.playlists.concat(kx(e));
  return e.timelineStarts = TD([t.timelineStarts, e.timelineStarts]), uxe({
    oldPlaylists: n,
    newPlaylists: r,
    timelineStarts: e.timelineStarts
  }), e;
}, Eg = (t) => t && t.uri + "-" + nxe(t.byterange), QA = (t) => {
  const e = t.reduce(function(r, i) {
    return r[i.attributes.baseUrl] || (r[i.attributes.baseUrl] = []), r[i.attributes.baseUrl].push(i), r;
  }, {});
  let n = [];
  return Object.values(e).forEach((r) => {
    const i = bD(r.reduce((s, a) => {
      const o = a.attributes.id + (a.attributes.lang || "");
      return s[o] ? (a.segments && (a.segments[0] && (a.segments[0].discontinuity = !0), s[o].segments.push(...a.segments)), a.attributes.contentProtection && (s[o].attributes.contentProtection = a.attributes.contentProtection)) : (s[o] = a, s[o].attributes.timelineStarts = []), s[o].attributes.timelineStarts.push({
        // Although they represent the same number, it's important to have both to make it
        // compatible with HLS potentially having a similar attribute.
        start: a.attributes.periodStart,
        timeline: a.attributes.periodStart
      }), s;
    }, {}));
    n = n.concat(i);
  }), n.map((r) => (r.discontinuityStarts = exe(r.segments || [], "discontinuity"), r));
}, cT = (t, e) => {
  const n = Eg(t.sidx), r = n && e[n] && e[n].sidx;
  return r && lT(t, r, t.sidx.resolvedUri), t;
}, cxe = (t, e = {}) => {
  if (!Object.keys(e).length)
    return t;
  for (const n in t)
    t[n] = cT(t[n], e);
  return t;
}, dxe = ({
  attributes: t,
  segments: e,
  sidx: n,
  mediaSequence: r,
  discontinuitySequence: i,
  discontinuityStarts: s
}, a) => {
  const o = {
    attributes: {
      NAME: t.id,
      BANDWIDTH: t.bandwidth,
      CODECS: t.codecs,
      "PROGRAM-ID": 1
    },
    uri: "",
    endList: t.type === "static",
    timeline: t.periodStart,
    resolvedUri: t.baseUrl || "",
    targetDuration: t.duration,
    discontinuitySequence: i,
    discontinuityStarts: s,
    timelineStarts: t.timelineStarts,
    mediaSequence: r,
    segments: e
  };
  return t.contentProtection && (o.contentProtection = t.contentProtection), t.serviceLocation && (o.attributes.serviceLocation = t.serviceLocation), n && (o.sidx = n), a && (o.attributes.AUDIO = "audio", o.attributes.SUBTITLES = "subs"), o;
}, fxe = ({
  attributes: t,
  segments: e,
  mediaSequence: n,
  discontinuityStarts: r,
  discontinuitySequence: i
}) => {
  typeof e > "u" && (e = [{
    uri: t.baseUrl,
    timeline: t.periodStart,
    resolvedUri: t.baseUrl || "",
    duration: t.sourceDuration,
    number: 0
  }], t.duration = t.sourceDuration);
  const s = {
    NAME: t.id,
    BANDWIDTH: t.bandwidth,
    "PROGRAM-ID": 1
  };
  t.codecs && (s.CODECS = t.codecs);
  const a = {
    attributes: s,
    uri: "",
    endList: t.type === "static",
    timeline: t.periodStart,
    resolvedUri: t.baseUrl || "",
    targetDuration: t.duration,
    timelineStarts: t.timelineStarts,
    discontinuityStarts: r,
    discontinuitySequence: i,
    mediaSequence: n,
    segments: e
  };
  return t.serviceLocation && (a.attributes.serviceLocation = t.serviceLocation), a;
}, hxe = (t, e = {}, n = !1) => {
  let r;
  const i = t.reduce((s, a) => {
    const o = a.attributes.role && a.attributes.role.value || "", u = a.attributes.lang || "";
    let c = a.attributes.label || "main";
    if (u && !a.attributes.label) {
      const l = o ? ` (${o})` : "";
      c = `${a.attributes.lang}${l}`;
    }
    s[c] || (s[c] = {
      language: u,
      autoselect: !0,
      default: o === "main",
      playlists: [],
      uri: ""
    });
    const d = cT(dxe(a, n), e);
    return s[c].playlists.push(d), typeof r > "u" && o === "main" && (r = a, r.default = !0), s;
  }, {});
  if (!r) {
    const s = Object.keys(i)[0];
    i[s].default = !0;
  }
  return i;
}, pxe = (t, e = {}) => t.reduce((n, r) => {
  const i = r.attributes.label || r.attributes.lang || "text", s = r.attributes.lang || "und";
  return n[i] || (n[i] = {
    language: s,
    default: !1,
    autoselect: !1,
    playlists: [],
    uri: ""
  }), n[i].playlists.push(cT(fxe(r), e)), n;
}, {}), mxe = (t) => t.reduce((e, n) => (n && n.forEach((r) => {
  const {
    channel: i,
    language: s
  } = r;
  e[s] = {
    autoselect: !1,
    default: !1,
    instreamId: i,
    language: s
  }, r.hasOwnProperty("aspectRatio") && (e[s].aspectRatio = r.aspectRatio), r.hasOwnProperty("easyReader") && (e[s].easyReader = r.easyReader), r.hasOwnProperty("3D") && (e[s]["3D"] = r["3D"]);
}), e), {}), gxe = ({
  attributes: t,
  segments: e,
  sidx: n,
  discontinuityStarts: r
}) => {
  const i = {
    attributes: {
      NAME: t.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: t.width,
        height: t.height
      },
      CODECS: t.codecs,
      BANDWIDTH: t.bandwidth,
      "PROGRAM-ID": 1
    },
    uri: "",
    endList: t.type === "static",
    timeline: t.periodStart,
    resolvedUri: t.baseUrl || "",
    targetDuration: t.duration,
    discontinuityStarts: r,
    timelineStarts: t.timelineStarts,
    segments: e
  };
  return t.frameRate && (i.attributes["FRAME-RATE"] = t.frameRate), t.contentProtection && (i.contentProtection = t.contentProtection), t.serviceLocation && (i.attributes.serviceLocation = t.serviceLocation), n && (i.sidx = n), i;
}, Axe = ({
  attributes: t
}) => t.mimeType === "video/mp4" || t.mimeType === "video/webm" || t.contentType === "video", bxe = ({
  attributes: t
}) => t.mimeType === "audio/mp4" || t.mimeType === "audio/webm" || t.contentType === "audio", yxe = ({
  attributes: t
}) => t.mimeType === "text/vtt" || t.contentType === "text", vxe = (t, e) => {
  t.forEach((n) => {
    n.mediaSequence = 0, n.discontinuitySequence = e.findIndex(function({
      timeline: r
    }) {
      return r === n.timeline;
    }), n.segments && n.segments.forEach((r, i) => {
      r.number = i;
    });
  });
}, Mx = (t) => t ? Object.keys(t).reduce((e, n) => {
  const r = t[n];
  return e.concat(r.playlists);
}, []) : [], Txe = ({
  dashPlaylists: t,
  locations: e,
  contentSteering: n,
  sidxMapping: r = {},
  previousManifest: i,
  eventStream: s
}) => {
  if (!t.length)
    return {};
  const {
    sourceDuration: a,
    type: o,
    suggestedPresentationDelay: u,
    minimumUpdatePeriod: c
  } = t[0].attributes, d = QA(t.filter(Axe)).map(gxe), l = QA(t.filter(bxe)), f = QA(t.filter(yxe)), p = t.map((_) => _.attributes.captionServices).filter(Boolean), m = {
    allowCache: !0,
    discontinuityStarts: [],
    segments: [],
    endList: !0,
    mediaGroups: {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    },
    uri: "",
    duration: a,
    playlists: cxe(d, r)
  };
  c >= 0 && (m.minimumUpdatePeriod = c * 1e3), e && (m.locations = e), n && (m.contentSteering = n), o === "dynamic" && (m.suggestedPresentationDelay = u), s && s.length > 0 && (m.eventStream = s);
  const g = m.playlists.length === 0, y = l.length ? hxe(l, r, g) : null, b = f.length ? pxe(f, r) : null, E = d.concat(Mx(y), Mx(b)), v = E.map(({
    timelineStarts: _
  }) => _);
  return m.timelineStarts = TD(v), vxe(E, m.timelineStarts), y && (m.mediaGroups.AUDIO.audio = y), b && (m.mediaGroups.SUBTITLES.subs = b), p.length && (m.mediaGroups["CLOSED-CAPTIONS"].cc = mxe(p)), i ? lxe({
    oldManifest: i,
    newManifest: m
  }) : m;
}, _xe = (t, e, n) => {
  const {
    NOW: r,
    clientOffset: i,
    availabilityStartTime: s,
    timescale: a = 1,
    periodStart: o = 0,
    minimumUpdatePeriod: u = 0
  } = t, c = (r + i) / 1e3, d = s + o, f = c + u - d;
  return Math.ceil((f * a - e) / n);
}, _D = (t, e) => {
  const {
    type: n,
    minimumUpdatePeriod: r = 0,
    media: i = "",
    sourceDuration: s,
    timescale: a = 1,
    startNumber: o = 1,
    periodStart: u
  } = t, c = [];
  let d = -1;
  for (let l = 0; l < e.length; l++) {
    const f = e[l], p = f.d, m = f.r || 0, g = f.t || 0;
    d < 0 && (d = g), g && g > d && (d = g);
    let y;
    if (m < 0) {
      const v = l + 1;
      v === e.length ? n === "dynamic" && r > 0 && i.indexOf("$Number$") > 0 ? y = _xe(t, d, p) : y = (s * a - d) / p : y = (e[v].t - d) / p;
    } else
      y = m + 1;
    const b = o + c.length + y;
    let E = o + c.length;
    for (; E < b; )
      c.push({
        number: E,
        duration: p / a,
        time: d,
        timeline: u
      }), d += p, E++;
  }
  return c;
}, Exe = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, xxe = (t) => (e, n, r, i) => {
  if (e === "$$")
    return "$";
  if (typeof t[n] > "u")
    return e;
  const s = "" + t[n];
  return n === "RepresentationID" || (r ? i = parseInt(i, 10) : i = 1, s.length >= i) ? s : `${new Array(i - s.length + 1).join("0")}${s}`;
}, Ox = (t, e) => t.replace(Exe, xxe(e)), wxe = (t, e) => !t.duration && !e ? [{
  number: t.startNumber || 1,
  duration: t.sourceDuration,
  time: 0,
  timeline: t.periodStart
}] : t.duration ? uT(t) : _D(t, e), Cxe = (t, e) => {
  const n = {
    RepresentationID: t.id,
    Bandwidth: t.bandwidth || 0
  }, {
    initialization: r = {
      sourceURL: "",
      range: ""
    }
  } = t, i = Qf({
    baseUrl: t.baseUrl,
    source: Ox(r.sourceURL, n),
    range: r.range
  });
  return wxe(t, e).map((a) => {
    n.Number = a.number, n.Time = a.time;
    const o = Ox(t.media || "", n), u = t.timescale || 1, c = t.presentationTimeOffset || 0, d = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      t.periodStart + (a.time - c) / u
    );
    return {
      uri: o,
      timeline: a.timeline,
      duration: a.duration,
      resolvedUri: Tg(t.baseUrl || "", o),
      map: i,
      number: a.number,
      presentationTime: d
    };
  });
}, Sxe = (t, e) => {
  const {
    baseUrl: n,
    initialization: r = {}
  } = t, i = Qf({
    baseUrl: n,
    source: r.sourceURL,
    range: r.range
  }), s = Qf({
    baseUrl: n,
    source: e.media,
    range: e.mediaRange
  });
  return s.map = i, s;
}, Ixe = (t, e) => {
  const {
    duration: n,
    segmentUrls: r = [],
    periodStart: i
  } = t;
  if (!n && !e || n && e)
    throw new Error(cc.SEGMENT_TIME_UNSPECIFIED);
  const s = r.map((u) => Sxe(t, u));
  let a;
  return n && (a = uT(t)), e && (a = _D(t, e)), a.map((u, c) => {
    if (s[c]) {
      const d = s[c], l = t.timescale || 1, f = t.presentationTimeOffset || 0;
      return d.timeline = u.timeline, d.duration = u.duration, d.number = u.number, d.presentationTime = i + (u.time - f) / l, d;
    }
  }).filter((u) => u);
}, kxe = ({
  attributes: t,
  segmentInfo: e
}) => {
  let n, r;
  e.template ? (r = Cxe, n = Dr(t, e.template)) : e.base ? (r = vD, n = Dr(t, e.base)) : e.list && (r = Ixe, n = Dr(t, e.list));
  const i = {
    attributes: t
  };
  if (!r)
    return i;
  const s = r(n, e.segmentTimeline);
  if (n.duration) {
    const {
      duration: a,
      timescale: o = 1
    } = n;
    n.duration = a / o;
  } else s.length ? n.duration = s.reduce((a, o) => Math.max(a, Math.ceil(o.duration)), 0) : n.duration = 0;
  return i.attributes = n, i.segments = s, e.base && n.indexRange && (i.sidx = s[0], i.segments = []), i;
}, Dxe = (t) => t.map(kxe), Xn = (t, e) => yD(t.childNodes).filter(({
  tagName: n
}) => n === e), yh = (t) => t.textContent.trim(), Mxe = (t) => parseFloat(t.split("/").reduce((e, n) => e / n)), wl = (t) => {
  const o = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(t);
  if (!o)
    return 0;
  const [u, c, d, l, f, p] = o.slice(1);
  return parseFloat(u || 0) * 31536e3 + parseFloat(c || 0) * 2592e3 + parseFloat(d || 0) * 86400 + parseFloat(l || 0) * 3600 + parseFloat(f || 0) * 60 + parseFloat(p || 0);
}, Oxe = (t) => (/^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(t) && (t += "Z"), Date.parse(t)), Nx = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration(t) {
    return wl(t);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime(t) {
    return Oxe(t) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod(t) {
    return wl(t);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay(t) {
    return wl(t);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type(t) {
    return t;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth(t) {
    return wl(t);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start(t) {
    return wl(t);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the frame rate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed frame rate
   */
  frameRate(t) {
    return Mxe(t);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration(t) {
    const e = parseInt(t, 10);
    return isNaN(e) ? wl(t) : e;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r(t) {
    return parseInt(t, 10);
  },
  /**
   * Specifies the presentationTime.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTime
   */
  presentationTime(t) {
    return parseInt(t, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT(t) {
    return t;
  }
}, br = (t) => t && t.attributes ? yD(t.attributes).reduce((e, n) => {
  const r = Nx[n.name] || Nx.DEFAULT;
  return e[n.name] = r(n.value), e;
}, {}) : {}, Nxe = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime",
  // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme
  "urn:mpeg:dash:mp4protection:2011": "mp4protection"
}, xg = (t, e) => e.length ? lc(t.map(function(n) {
  return e.map(function(r) {
    const i = yh(r), s = Tg(n.baseUrl, i), a = Dr(br(r), {
      baseUrl: s
    });
    return s !== i && !a.serviceLocation && n.serviceLocation && (a.serviceLocation = n.serviceLocation), a;
  });
})) : t, dT = (t) => {
  const e = Xn(t, "SegmentTemplate")[0], n = Xn(t, "SegmentList")[0], r = n && Xn(n, "SegmentURL").map((l) => Dr({
    tag: "SegmentURL"
  }, br(l))), i = Xn(t, "SegmentBase")[0], s = n || e, a = s && Xn(s, "SegmentTimeline")[0], o = n || i || e, u = o && Xn(o, "Initialization")[0], c = e && br(e);
  c && u ? c.initialization = u && br(u) : c && c.initialization && (c.initialization = {
    sourceURL: c.initialization
  });
  const d = {
    template: c,
    segmentTimeline: a && Xn(a, "S").map((l) => br(l)),
    list: n && Dr(br(n), {
      segmentUrls: r,
      initialization: br(u)
    }),
    base: i && Dr(br(i), {
      initialization: br(u)
    })
  };
  return Object.keys(d).forEach((l) => {
    d[l] || delete d[l];
  }), d;
}, Lxe = (t, e, n) => (r) => {
  const i = Xn(r, "BaseURL"), s = xg(e, i), a = Dr(t, br(r)), o = dT(r);
  return s.map((u) => ({
    segmentInfo: Dr(n, o),
    attributes: Dr(a, u)
  }));
}, Pxe = (t) => t.reduce((e, n) => {
  const r = br(n);
  r.schemeIdUri && (r.schemeIdUri = r.schemeIdUri.toLowerCase());
  const i = Nxe[r.schemeIdUri];
  if (i) {
    e[i] = {
      attributes: r
    };
    const s = Xn(n, "cenc:pssh")[0];
    if (s) {
      const a = yh(s);
      e[i].pssh = a && dD(a);
    }
  }
  return e;
}, {}), Rxe = (t) => {
  if (t.schemeIdUri === "urn:scte:dash:cc:cea-608:2015")
    return (typeof t.value != "string" ? [] : t.value.split(";")).map((n) => {
      let r, i;
      return i = n, /^CC\d=/.test(n) ? [r, i] = n.split("=") : /^CC\d$/.test(n) && (r = n), {
        channel: r,
        language: i
      };
    });
  if (t.schemeIdUri === "urn:scte:dash:cc:cea-708:2015")
    return (typeof t.value != "string" ? [] : t.value.split(";")).map((n) => {
      const r = {
        // service or channel number 1-63
        channel: void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        language: void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        aspectRatio: 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        easyReader: 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(n)) {
        const [i, s = ""] = n.split("=");
        r.channel = i, r.language = n, s.split(",").forEach((a) => {
          const [o, u] = a.split(":");
          o === "lang" ? r.language = u : o === "er" ? r.easyReader = Number(u) : o === "war" ? r.aspectRatio = Number(u) : o === "3D" && (r["3D"] = Number(u));
        });
      } else
        r.language = n;
      return r.channel && (r.channel = "SERVICE" + r.channel), r;
    });
}, Bxe = (t) => lc(Xn(t.node, "EventStream").map((e) => {
  const n = br(e), r = n.schemeIdUri;
  return Xn(e, "Event").map((i) => {
    const s = br(i), a = s.presentationTime || 0, o = n.timescale || 1, u = s.duration || 0, c = a / o + t.attributes.start;
    return {
      schemeIdUri: r,
      value: n.value,
      id: s.id,
      start: c,
      end: c + u / o,
      messageData: yh(i) || s.messageData,
      contentEncoding: n.contentEncoding,
      presentationTimeOffset: n.presentationTimeOffset || 0
    };
  });
})), Fxe = (t, e, n) => (r) => {
  const i = br(r), s = xg(e, Xn(r, "BaseURL")), a = Xn(r, "Role")[0], o = {
    role: br(a)
  };
  let u = Dr(t, i, o);
  const c = Xn(r, "Accessibility")[0], d = Rxe(br(c));
  d && (u = Dr(u, {
    captionServices: d
  }));
  const l = Xn(r, "Label")[0];
  if (l && l.childNodes.length) {
    const y = l.childNodes[0].nodeValue.trim();
    u = Dr(u, {
      label: y
    });
  }
  const f = Pxe(Xn(r, "ContentProtection"));
  Object.keys(f).length && (u = Dr(u, {
    contentProtection: f
  }));
  const p = dT(r), m = Xn(r, "Representation"), g = Dr(n, p);
  return lc(m.map(Lxe(u, s, g)));
}, Uxe = (t, e) => (n, r) => {
  const i = xg(e, Xn(n.node, "BaseURL")), s = Dr(t, {
    periodStart: n.attributes.start
  });
  typeof n.attributes.duration == "number" && (s.periodDuration = n.attributes.duration);
  const a = Xn(n.node, "AdaptationSet"), o = dT(n.node);
  return lc(a.map(Fxe(s, i, o)));
}, $xe = (t, e) => {
  if (t.length > 1 && e({
    type: "warn",
    message: "The MPD manifest should contain no more than one ContentSteering tag"
  }), !t.length)
    return null;
  const n = Dr({
    serverURL: yh(t[0])
  }, br(t[0]));
  return n.queryBeforeStart = n.queryBeforeStart === "true", n;
}, Hxe = ({
  attributes: t,
  priorPeriodAttributes: e,
  mpdType: n
}) => typeof t.start == "number" ? t.start : e && typeof e.start == "number" && typeof e.duration == "number" ? e.start + e.duration : !e && n === "static" ? 0 : null, jxe = (t, e = {}) => {
  const {
    manifestUri: n = "",
    NOW: r = Date.now(),
    clientOffset: i = 0,
    // TODO: For now, we are expecting an eventHandler callback function
    // to be passed into the mpd parser as an option.
    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.
    // This will support new features including a standardized event handler.
    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.
    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9
    eventHandler: s = function() {
    }
  } = e, a = Xn(t, "Period");
  if (!a.length)
    throw new Error(cc.INVALID_NUMBER_OF_PERIOD);
  const o = Xn(t, "Location"), u = br(t), c = xg([{
    baseUrl: n
  }], Xn(t, "BaseURL")), d = Xn(t, "ContentSteering");
  u.type = u.type || "static", u.sourceDuration = u.mediaPresentationDuration || 0, u.NOW = r, u.clientOffset = i, o.length && (u.locations = o.map(yh));
  const l = [];
  return a.forEach((f, p) => {
    const m = br(f), g = l[p - 1];
    m.start = Hxe({
      attributes: m,
      priorPeriodAttributes: g ? g.attributes : null,
      mpdType: u.type
    }), l.push({
      node: f,
      attributes: m
    });
  }), {
    locations: u.locations,
    contentSteeringInfo: $xe(d, s),
    // TODO: There are occurences where this `representationInfo` array contains undesired
    // duplicates. This generally occurs when there are multiple BaseURL nodes that are
    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the
    // parent BaseURL and a child BaseURL, and the value does not resolve,
    // we end up returning the child BaseURL multiple times.
    // We need to determine a way to remove these duplicates in a safe way.
    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527
    representationInfo: lc(l.map(Uxe(u, c))),
    eventStream: lc(l.map(Bxe))
  };
}, ED = (t) => {
  if (t === "")
    throw new Error(cc.DASH_EMPTY_MANIFEST);
  const e = new Z4e.DOMParser();
  let n, r;
  try {
    n = e.parseFromString(t, "application/xml"), r = n && n.documentElement.tagName === "MPD" ? n.documentElement : null;
  } catch {
  }
  if (!r || r && r.getElementsByTagName("parsererror").length > 0)
    throw new Error(cc.DASH_INVALID_XML);
  return r;
}, zxe = (t) => {
  const e = Xn(t, "UTCTiming")[0];
  if (!e)
    return null;
  const n = br(e);
  switch (n.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      n.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      n.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      n.method = "DIRECT", n.value = Date.parse(n.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(cc.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return n;
}, qxe = (t, e = {}) => {
  const n = jxe(ED(t), e), r = Dxe(n.representationInfo);
  return Txe({
    dashPlaylists: r,
    locations: n.locations,
    contentSteering: n.contentSteeringInfo,
    sidxMapping: e.sidxMapping,
    previousManifest: e.previousManifest,
    eventStream: n.eventStream
  });
}, Vxe = (t) => zxe(ED(t));
var GA, Lx;
function Wxe() {
  if (Lx) return GA;
  Lx = 1;
  var t = Math.pow(2, 32), e = function(n) {
    var r = new DataView(n.buffer, n.byteOffset, n.byteLength), i;
    return r.getBigUint64 ? (i = r.getBigUint64(0), i < Number.MAX_SAFE_INTEGER ? Number(i) : i) : r.getUint32(0) * t + r.getUint32(4);
  };
  return GA = {
    getUint64: e,
    MAX_UINT32: t
  }, GA;
}
var YA, Px;
function Qxe() {
  if (Px) return YA;
  Px = 1;
  var t = Wxe().getUint64, e = function(n) {
    var r = new DataView(n.buffer, n.byteOffset, n.byteLength), i = {
      version: n[0],
      flags: new Uint8Array(n.subarray(1, 4)),
      references: [],
      referenceId: r.getUint32(4),
      timescale: r.getUint32(8)
    }, s = 12;
    i.version === 0 ? (i.earliestPresentationTime = r.getUint32(s), i.firstOffset = r.getUint32(s + 4), s += 8) : (i.earliestPresentationTime = t(n.subarray(s)), i.firstOffset = t(n.subarray(s + 8)), s += 16), s += 2;
    var a = r.getUint16(s);
    for (s += 2; a > 0; s += 12, a--)
      i.references.push({
        referenceType: (n[s] & 128) >>> 7,
        referencedSize: r.getUint32(s) & 2147483647,
        subsegmentDuration: r.getUint32(s + 4),
        startsWithSap: !!(n[s + 8] & 128),
        sapType: (n[s + 8] & 112) >>> 4,
        sapDeltaTime: r.getUint32(s + 8) & 268435455
      });
    return i;
  };
  return YA = e, YA;
}
var Gxe = Qxe();
const Yxe = /* @__PURE__ */ Fr(Gxe);
var Xxe = kt([73, 68, 51]), Kxe = function(e, n) {
  n === void 0 && (n = 0), e = kt(e);
  var r = e[n + 5], i = e[n + 6] << 21 | e[n + 7] << 14 | e[n + 8] << 7 | e[n + 9], s = (r & 16) >> 4;
  return s ? i + 20 : i + 10;
}, Gd = function t(e, n) {
  return n === void 0 && (n = 0), e = kt(e), e.length - n < 10 || !Yn(e, Xxe, {
    offset: n
  }) ? n : (n += Kxe(e, n), t(e, n));
}, Rx = function(e) {
  return typeof e == "string" ? gD(e) : e;
}, Zxe = function(e) {
  return Array.isArray(e) ? e.map(function(n) {
    return Rx(n);
  }) : [Rx(e)];
}, Jxe = function t(e, n, r) {
  r === void 0 && (r = !1), n = Zxe(n), e = kt(e);
  var i = [];
  if (!n.length)
    return i;
  for (var s = 0; s < e.length; ) {
    var a = (e[s] << 24 | e[s + 1] << 16 | e[s + 2] << 8 | e[s + 3]) >>> 0, o = e.subarray(s + 4, s + 8);
    if (a === 0)
      break;
    var u = s + a;
    if (u > e.length) {
      if (r)
        break;
      u = e.length;
    }
    var c = e.subarray(s + 8, u);
    Yn(o, n[0]) && (n.length === 1 ? i.push(c) : i.push.apply(i, t(c, n.slice(1), r))), s = u;
  }
  return i;
}, Mp = {
  EBML: kt([26, 69, 223, 163]),
  DocType: kt([66, 130]),
  Segment: kt([24, 83, 128, 103]),
  SegmentInfo: kt([21, 73, 169, 102]),
  Tracks: kt([22, 84, 174, 107]),
  Track: kt([174]),
  TrackNumber: kt([215]),
  DefaultDuration: kt([35, 227, 131]),
  TrackEntry: kt([174]),
  TrackType: kt([131]),
  FlagDefault: kt([136]),
  CodecID: kt([134]),
  CodecPrivate: kt([99, 162]),
  VideoTrack: kt([224]),
  AudioTrack: kt([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: kt([31, 67, 182, 117]),
  Timestamp: kt([231]),
  TimestampScale: kt([42, 215, 177]),
  BlockGroup: kt([160]),
  BlockDuration: kt([155]),
  Block: kt([161]),
  SimpleBlock: kt([163])
}, qb = [128, 64, 32, 16, 8, 4, 2, 1], ewe = function(e) {
  for (var n = 1, r = 0; r < qb.length && !(e & qb[r]); r++)
    n++;
  return n;
}, i0 = function(e, n, r, i) {
  r === void 0 && (r = !0), i === void 0 && (i = !1);
  var s = ewe(e[n]), a = e.subarray(n, n + s);
  return r && (a = Array.prototype.slice.call(e, n, n + s), a[0] ^= qb[s - 1]), {
    length: s,
    value: q4e(a, {
      signed: i
    }),
    bytes: a
  };
}, Bx = function t(e) {
  return typeof e == "string" ? e.match(/.{1,2}/g).map(function(n) {
    return t(n);
  }) : typeof e == "number" ? V4e(e) : e;
}, twe = function(e) {
  return Array.isArray(e) ? e.map(function(n) {
    return Bx(n);
  }) : [Bx(e)];
}, nwe = function t(e, n, r) {
  if (r >= n.length)
    return n.length;
  var i = i0(n, r, !1);
  if (Yn(e.bytes, i.bytes))
    return r;
  var s = i0(n, r + i.length);
  return t(e, n, r + s.length + s.value + i.length);
}, Fx = function t(e, n) {
  n = twe(n), e = kt(e);
  var r = [];
  if (!n.length)
    return r;
  for (var i = 0; i < e.length; ) {
    var s = i0(e, i, !1), a = i0(e, i + s.length), o = i + s.length + a.length;
    a.value === 127 && (a.value = nwe(s, e, o), a.value !== e.length && (a.value -= o));
    var u = o + a.value > e.length ? e.length : o + a.value, c = e.subarray(o, u);
    Yn(n[0], s.bytes) && (n.length === 1 ? r.push(c) : r = r.concat(t(c, n.slice(1))));
    var d = s.length + a.length + c.length;
    i += d;
  }
  return r;
}, rwe = kt([0, 0, 0, 1]), iwe = kt([0, 0, 1]), swe = kt([0, 0, 3]), awe = function(e) {
  for (var n = [], r = 1; r < e.length - 2; )
    Yn(e.subarray(r, r + 3), swe) && (n.push(r + 2), r++), r++;
  if (n.length === 0)
    return e;
  var i = e.length - n.length, s = new Uint8Array(i), a = 0;
  for (r = 0; r < i; a++, r++)
    a === n[0] && (a++, n.shift()), s[r] = e[a];
  return s;
}, xD = function(e, n, r, i) {
  e = kt(e), r = [].concat(r);
  for (var s = 0, a, o = 0; s < e.length && (o < i || a); ) {
    var u = void 0;
    if (Yn(e.subarray(s), rwe) ? u = 4 : Yn(e.subarray(s), iwe) && (u = 3), !u) {
      s++;
      continue;
    }
    if (o++, a)
      return awe(e.subarray(a, s));
    var c = void 0;
    n === "h264" ? c = e[s + u] & 31 : n === "h265" && (c = e[s + u] >> 1 & 63), r.indexOf(c) !== -1 && (a = s + u), s += u + (n === "h264" ? 1 : 2);
  }
  return e.subarray(0, 0);
}, owe = function(e, n, r) {
  return xD(e, "h264", n, r);
}, uwe = function(e, n, r) {
  return xD(e, "h265", n, r);
}, oi = {
  // "webm" string literal in hex
  webm: kt([119, 101, 98, 109]),
  // "matroska" string literal in hex
  matroska: kt([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  flac: kt([102, 76, 97, 67]),
  // "OggS" string literal in hex
  ogg: kt([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  ac3: kt([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  riff: kt([82, 73, 70, 70]),
  // "AVI" string literal in hex
  avi: kt([65, 86, 73]),
  // "WAVE" string literal in hex
  wav: kt([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": kt([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  mp4: kt([102, 116, 121, 112]),
  // "styp" string literal in hex
  fmp4: kt([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  mov: kt([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  moov: kt([109, 111, 111, 118]),
  // moof string literal in hex
  moof: kt([109, 111, 111, 102])
}, dc = {
  aac: function(e) {
    var n = Gd(e);
    return Yn(e, [255, 16], {
      offset: n,
      mask: [255, 22]
    });
  },
  mp3: function(e) {
    var n = Gd(e);
    return Yn(e, [255, 2], {
      offset: n,
      mask: [255, 6]
    });
  },
  webm: function(e) {
    var n = Fx(e, [Mp.EBML, Mp.DocType])[0];
    return Yn(n, oi.webm);
  },
  mkv: function(e) {
    var n = Fx(e, [Mp.EBML, Mp.DocType])[0];
    return Yn(n, oi.matroska);
  },
  mp4: function(e) {
    if (dc["3gp"](e) || dc.mov(e))
      return !1;
    if (Yn(e, oi.mp4, {
      offset: 4
    }) || Yn(e, oi.fmp4, {
      offset: 4
    }) || Yn(e, oi.moof, {
      offset: 4
    }) || Yn(e, oi.moov, {
      offset: 4
    }))
      return !0;
  },
  mov: function(e) {
    return Yn(e, oi.mov, {
      offset: 4
    });
  },
  "3gp": function(e) {
    return Yn(e, oi["3gp"], {
      offset: 4
    });
  },
  ac3: function(e) {
    var n = Gd(e);
    return Yn(e, oi.ac3, {
      offset: n
    });
  },
  ts: function(e) {
    if (e.length < 189 && e.length >= 1)
      return e[0] === 71;
    for (var n = 0; n + 188 < e.length && n < 188; ) {
      if (e[n] === 71 && e[n + 188] === 71)
        return !0;
      n += 1;
    }
    return !1;
  },
  flac: function(e) {
    var n = Gd(e);
    return Yn(e, oi.flac, {
      offset: n
    });
  },
  ogg: function(e) {
    return Yn(e, oi.ogg);
  },
  avi: function(e) {
    return Yn(e, oi.riff) && Yn(e, oi.avi, {
      offset: 8
    });
  },
  wav: function(e) {
    return Yn(e, oi.riff) && Yn(e, oi.wav, {
      offset: 8
    });
  },
  h264: function(e) {
    return owe(e, 7, 3).length;
  },
  h265: function(e) {
    return uwe(e, [32, 33], 3).length;
  }
}, Vb = Object.keys(dc).filter(function(t) {
  return t !== "ts" && t !== "h264" && t !== "h265";
}).concat(["ts", "h264", "h265"]);
Vb.forEach(function(t) {
  var e = dc[t];
  dc[t] = function(n) {
    return e(kt(n));
  };
});
var lwe = dc, fT = function(e) {
  e = kt(e);
  for (var n = 0; n < Vb.length; n++) {
    var r = Vb[n];
    if (lwe[r](e))
      return r;
  }
  return "";
}, cwe = function(e) {
  return Jxe(e, ["moof"]).length > 0;
}, XA, Ux;
function dwe() {
  if (Ux) return XA;
  Ux = 1;
  var t = 9e4, e, n, r, i, s, a, o;
  return e = function(u) {
    return u * t;
  }, n = function(u, c) {
    return u * c;
  }, r = function(u) {
    return u / t;
  }, i = function(u, c) {
    return u / c;
  }, s = function(u, c) {
    return e(i(u, c));
  }, a = function(u, c) {
    return n(r(u), c);
  }, o = function(u, c, d) {
    return r(d ? u : u - c);
  }, XA = {
    ONE_SECOND_IN_TS: t,
    secondsToVideoTs: e,
    secondsToAudioTs: n,
    videoTsToSeconds: r,
    audioTsToSeconds: i,
    audioTsToVideoTs: s,
    videoTsToAudioTs: a,
    metadataTsToSeconds: o
  }, XA;
}
var gu = dwe();
/**
 * @license
 * Video.js 8.23.3 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
var Wb = "8.23.3";
const Oa = {}, Oo = function(t, e) {
  return Oa[t] = Oa[t] || [], e && (Oa[t] = Oa[t].concat(e)), Oa[t];
}, fwe = function(t, e) {
  Oo(t, e);
}, wD = function(t, e) {
  const n = Oo(t).indexOf(e);
  return n <= -1 ? !1 : (Oa[t] = Oa[t].slice(), Oa[t].splice(n, 1), !0);
}, hwe = function(t, e) {
  Oo(t, [].concat(e).map((n) => {
    const r = (...i) => (wD(t, r), n(...i));
    return r;
  }));
}, s0 = {
  prefixed: !0
}, bm = [
  ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
  // WebKit
  ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"]
], $x = bm[0];
let Yd;
for (let t = 0; t < bm.length; t++)
  if (bm[t][1] in ot) {
    Yd = bm[t];
    break;
  }
if (Yd) {
  for (let t = 0; t < Yd.length; t++)
    s0[$x[t]] = Yd[t];
  s0.prefixed = Yd[0] !== $x[0];
}
let Ti = [];
const pwe = (t, e, n) => (r, i, s) => {
  const a = e.levels[i], o = new RegExp(`^(${a})$`);
  let u = t;
  if (r !== "log" && s.unshift(r.toUpperCase() + ":"), n && (u = `%c${t}`, s.unshift(n)), s.unshift(u + ":"), Ti) {
    Ti.push([].concat(s));
    const d = Ti.length - 1e3;
    Ti.splice(0, d > 0 ? d : 0);
  }
  if (!pe.console)
    return;
  let c = pe.console[r];
  !c && r === "debug" && (c = pe.console.info || pe.console.log), !(!c || !a || !o.test(r)) && c[Array.isArray(s) ? "apply" : "call"](pe.console, s);
};
function Qb(t, e = ":", n = "") {
  let r = "info", i;
  function s(...a) {
    i("log", r, a);
  }
  return i = pwe(t, s, n), s.createLogger = (a, o, u) => {
    const c = o !== void 0 ? o : e, d = u !== void 0 ? u : n, l = `${t} ${c} ${a}`;
    return Qb(l, c, d);
  }, s.createNewLogger = (a, o, u) => Qb(a, o, u), s.levels = {
    all: "debug|log|warn|error",
    off: "",
    debug: "debug|log|warn|error",
    info: "log|warn|error",
    warn: "warn|error",
    error: "error",
    DEFAULT: r
  }, s.level = (a) => {
    if (typeof a == "string") {
      if (!s.levels.hasOwnProperty(a))
        throw new Error(`"${a}" in not a valid log level`);
      r = a;
    }
    return r;
  }, s.history = () => Ti ? [].concat(Ti) : [], s.history.filter = (a) => (Ti || []).filter((o) => new RegExp(`.*${a}.*`).test(o[0])), s.history.clear = () => {
    Ti && (Ti.length = 0);
  }, s.history.disable = () => {
    Ti !== null && (Ti.length = 0, Ti = null);
  }, s.history.enable = () => {
    Ti === null && (Ti = []);
  }, s.error = (...a) => i("error", r, a), s.warn = (...a) => i("warn", r, a), s.debug = (...a) => i("debug", r, a), s;
}
const Kt = Qb("VIDEOJS"), CD = Kt.createLogger, mwe = Object.prototype.toString, SD = function(t) {
  return fa(t) ? Object.keys(t) : [];
};
function Vl(t, e) {
  SD(t).forEach((n) => e(t[n], n));
}
function ID(t, e, n = 0) {
  return SD(t).reduce((r, i) => e(r, t[i], i), n);
}
function fa(t) {
  return !!t && typeof t == "object";
}
function fc(t) {
  return fa(t) && mwe.call(t) === "[object Object]" && t.constructor === Object;
}
function Dn(...t) {
  const e = {};
  return t.forEach((n) => {
    n && Vl(n, (r, i) => {
      if (!fc(r)) {
        e[i] = r;
        return;
      }
      fc(e[i]) || (e[i] = {}), e[i] = Dn(e[i], r);
    });
  }), e;
}
function kD(t = {}) {
  const e = [];
  for (const n in t)
    if (t.hasOwnProperty(n)) {
      const r = t[n];
      e.push(r);
    }
  return e;
}
function wg(t, e, n, r = !0) {
  const i = (a) => Object.defineProperty(t, e, {
    value: a,
    enumerable: !0,
    writable: !0
  }), s = {
    configurable: !0,
    enumerable: !0,
    get() {
      const a = n();
      return i(a), a;
    }
  };
  return r && (s.set = i), Object.defineProperty(t, e, s);
}
var gwe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  each: Vl,
  reduce: ID,
  isObject: fa,
  isPlain: fc,
  merge: Dn,
  values: kD,
  defineLazyProperty: wg
});
let hT = !1, DD = null, Ns = !1, MD, OD = !1, Wl = !1, Ql = !1, ha = !1, pT = null, Cg = null;
const Awe = !!(pe.cast && pe.cast.framework && pe.cast.framework.CastReceiverContext);
let ND = null, a0 = !1, Sg = !1, o0 = !1, Ig = !1, u0 = !1, l0 = !1, c0 = !1;
const Gf = !!($c() && ("ontouchstart" in pe || pe.navigator.maxTouchPoints || pe.DocumentTouch && pe.document instanceof pe.DocumentTouch)), ro = pe.navigator && pe.navigator.userAgentData;
ro && ro.platform && ro.brands && (Ns = ro.platform === "Android", Wl = !!ro.brands.find((t) => t.brand === "Microsoft Edge"), Ql = !!ro.brands.find((t) => t.brand === "Chromium"), ha = !Wl && Ql, pT = Cg = (ro.brands.find((t) => t.brand === "Chromium") || {}).version || null, Sg = ro.platform === "Windows");
if (!Ql) {
  const t = pe.navigator && pe.navigator.userAgent || "";
  hT = /iPod/i.test(t), DD = function() {
    const e = t.match(/OS (\d+)_/i);
    return e && e[1] ? e[1] : null;
  }(), Ns = /Android/i.test(t), MD = function() {
    const e = t.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
    if (!e)
      return null;
    const n = e[1] && parseFloat(e[1]), r = e[2] && parseFloat(e[2]);
    return n && r ? parseFloat(e[1] + "." + e[2]) : n || null;
  }(), OD = /Firefox/i.test(t), Wl = /Edg/i.test(t), Ql = /Chrome/i.test(t) || /CriOS/i.test(t), ha = !Wl && Ql, pT = Cg = function() {
    const e = t.match(/(Chrome|CriOS)\/(\d+)/);
    return e && e[2] ? parseFloat(e[2]) : null;
  }(), ND = function() {
    const e = /MSIE\s(\d+)\.\d/.exec(t);
    let n = e && parseFloat(e[1]);
    return !n && /Trident\/7.0/i.test(t) && /rv:11.0/.test(t) && (n = 11), n;
  }(), u0 = /Tizen/i.test(t), l0 = /Web0S/i.test(t), c0 = u0 || l0, a0 = /Safari/i.test(t) && !ha && !Ns && !Wl && !c0, Sg = /Windows/i.test(t), o0 = /iPad/i.test(t) || a0 && Gf && !/iPhone/i.test(t), Ig = /iPhone/i.test(t) && !o0;
}
const ei = Ig || o0 || hT, kg = (a0 || ei) && !ha;
var LD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get IS_IPOD() {
    return hT;
  },
  get IOS_VERSION() {
    return DD;
  },
  get IS_ANDROID() {
    return Ns;
  },
  get ANDROID_VERSION() {
    return MD;
  },
  get IS_FIREFOX() {
    return OD;
  },
  get IS_EDGE() {
    return Wl;
  },
  get IS_CHROMIUM() {
    return Ql;
  },
  get IS_CHROME() {
    return ha;
  },
  get CHROMIUM_VERSION() {
    return pT;
  },
  get CHROME_VERSION() {
    return Cg;
  },
  IS_CHROMECAST_RECEIVER: Awe,
  get IE_VERSION() {
    return ND;
  },
  get IS_SAFARI() {
    return a0;
  },
  get IS_WINDOWS() {
    return Sg;
  },
  get IS_IPAD() {
    return o0;
  },
  get IS_IPHONE() {
    return Ig;
  },
  get IS_TIZEN() {
    return u0;
  },
  get IS_WEBOS() {
    return l0;
  },
  get IS_SMART_TV() {
    return c0;
  },
  TOUCH_ENABLED: Gf,
  IS_IOS: ei,
  IS_ANY_SAFARI: kg
});
function Hx(t) {
  return typeof t == "string" && !!t.trim();
}
function bwe(t) {
  if (t.indexOf(" ") >= 0)
    throw new Error("class has illegal whitespace characters");
}
function $c() {
  return ot === pe.document;
}
function Hc(t) {
  return fa(t) && t.nodeType === 1;
}
function PD() {
  try {
    return pe.parent !== pe.self;
  } catch {
    return !0;
  }
}
function RD(t) {
  return function(e, n) {
    if (!Hx(e))
      return ot[t](null);
    Hx(n) && (n = ot.querySelector(n));
    const r = Hc(n) ? n : ot;
    return r[t] && r[t](e);
  };
}
function Nt(t = "div", e = {}, n = {}, r) {
  const i = ot.createElement(t);
  return Object.getOwnPropertyNames(e).forEach(function(s) {
    const a = e[s];
    s === "textContent" ? Uo(i, a) : (i[s] !== a || s === "tabIndex") && (i[s] = a);
  }), Object.getOwnPropertyNames(n).forEach(function(s) {
    i.setAttribute(s, n[s]);
  }), r && mT(i, r), i;
}
function Uo(t, e) {
  return typeof t.textContent > "u" ? t.innerText = e : t.textContent = e, t;
}
function Gb(t, e) {
  e.firstChild ? e.insertBefore(t, e.firstChild) : e.appendChild(t);
}
function gf(t, e) {
  return bwe(e), t.classList.contains(e);
}
function Iu(t, ...e) {
  return t.classList.add(...e.reduce((n, r) => n.concat(r.split(/\s+/)), [])), t;
}
function Dg(t, ...e) {
  return t ? (t.classList.remove(...e.reduce((n, r) => n.concat(r.split(/\s+/)), [])), t) : (Kt.warn("removeClass was called with an element that doesn't exist"), null);
}
function BD(t, e, n) {
  return typeof n == "function" && (n = n(t, e)), typeof n != "boolean" && (n = void 0), e.split(/\s+/).forEach((r) => t.classList.toggle(r, n)), t;
}
function FD(t, e) {
  Object.getOwnPropertyNames(e).forEach(function(n) {
    const r = e[n];
    r === null || typeof r > "u" || r === !1 ? t.removeAttribute(n) : t.setAttribute(n, r === !0 ? "" : r);
  });
}
function mo(t) {
  const e = {}, n = ["autoplay", "controls", "playsinline", "loop", "muted", "default", "defaultMuted"];
  if (t && t.attributes && t.attributes.length > 0) {
    const r = t.attributes;
    for (let i = r.length - 1; i >= 0; i--) {
      const s = r[i].name;
      let a = r[i].value;
      n.includes(s) && (a = a !== null), e[s] = a;
    }
  }
  return e;
}
function UD(t, e) {
  return t.getAttribute(e);
}
function hc(t, e, n) {
  t.setAttribute(e, n);
}
function Mg(t, e) {
  t.removeAttribute(e);
}
function $D() {
  ot.body.focus(), ot.onselectstart = function() {
    return !1;
  };
}
function HD() {
  ot.onselectstart = function() {
    return !0;
  };
}
function pc(t) {
  if (t && t.getBoundingClientRect && t.parentNode) {
    const e = t.getBoundingClientRect(), n = {};
    return ["bottom", "height", "left", "right", "top", "width"].forEach((r) => {
      e[r] !== void 0 && (n[r] = e[r]);
    }), n.height || (n.height = parseFloat(mc(t, "height"))), n.width || (n.width = parseFloat(mc(t, "width"))), n;
  }
}
function Yf(t) {
  if (!t || t && !t.offsetParent)
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  const e = t.offsetWidth, n = t.offsetHeight;
  let r = 0, i = 0;
  for (; t.offsetParent && t !== ot[s0.fullscreenElement]; )
    r += t.offsetLeft, i += t.offsetTop, t = t.offsetParent;
  return {
    left: r,
    top: i,
    width: e,
    height: n
  };
}
function Og(t, e) {
  const n = {
    x: 0,
    y: 0
  };
  if (ei) {
    let d = t;
    for (; d && d.nodeName.toLowerCase() !== "html"; ) {
      const l = mc(d, "transform");
      if (/^matrix/.test(l)) {
        const f = l.slice(7, -1).split(/,\s/).map(Number);
        n.x += f[4], n.y += f[5];
      } else if (/^matrix3d/.test(l)) {
        const f = l.slice(9, -1).split(/,\s/).map(Number);
        n.x += f[12], n.y += f[13];
      }
      if (d.assignedSlot && d.assignedSlot.parentElement && pe.WebKitCSSMatrix) {
        const f = pe.getComputedStyle(d.assignedSlot.parentElement).transform, p = new pe.WebKitCSSMatrix(f);
        n.x += p.m41, n.y += p.m42;
      }
      d = d.parentNode || d.host;
    }
  }
  const r = {}, i = Yf(e.target), s = Yf(t), a = s.width, o = s.height;
  let u = e.offsetY - (s.top - i.top), c = e.offsetX - (s.left - i.left);
  return e.changedTouches && (c = e.changedTouches[0].pageX - s.left, u = e.changedTouches[0].pageY + s.top, ei && (c -= n.x, u -= n.y)), r.y = 1 - Math.max(0, Math.min(1, u / o)), r.x = Math.max(0, Math.min(1, c / a)), r;
}
function jD(t) {
  return fa(t) && t.nodeType === 3;
}
function Ng(t) {
  for (; t.firstChild; )
    t.removeChild(t.firstChild);
  return t;
}
function zD(t) {
  return typeof t == "function" && (t = t()), (Array.isArray(t) ? t : [t]).map((e) => {
    if (typeof e == "function" && (e = e()), Hc(e) || jD(e))
      return e;
    if (typeof e == "string" && /\S/.test(e))
      return ot.createTextNode(e);
  }).filter((e) => e);
}
function mT(t, e) {
  return zD(e).forEach((n) => t.appendChild(n)), t;
}
function qD(t, e) {
  return mT(Ng(t), e);
}
function Xf(t) {
  return t.button === void 0 && t.buttons === void 0 || t.button === 0 && t.buttons === void 0 || t.type === "mouseup" && t.button === 0 && t.buttons === 0 || t.type === "mousedown" && t.button === 0 && t.buttons === 0 ? !0 : !(t.button !== 0 || t.buttons !== 1);
}
const No = RD("querySelector"), VD = RD("querySelectorAll");
function mc(t, e) {
  if (!t || !e)
    return "";
  if (typeof pe.getComputedStyle == "function") {
    let n;
    try {
      n = pe.getComputedStyle(t);
    } catch {
      return "";
    }
    return n ? n.getPropertyValue(e) || n[e] : "";
  }
  return "";
}
function WD(t) {
  [...ot.styleSheets].forEach((e) => {
    try {
      const n = [...e.cssRules].map((i) => i.cssText).join(""), r = ot.createElement("style");
      r.textContent = n, t.document.head.appendChild(r);
    } catch {
      const r = ot.createElement("link");
      r.rel = "stylesheet", r.type = e.type, r.media = e.media.mediaText, r.href = e.href, t.document.head.appendChild(r);
    }
  });
}
var QD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isReal: $c,
  isEl: Hc,
  isInFrame: PD,
  createEl: Nt,
  textContent: Uo,
  prependTo: Gb,
  hasClass: gf,
  addClass: Iu,
  removeClass: Dg,
  toggleClass: BD,
  setAttributes: FD,
  getAttributes: mo,
  getAttribute: UD,
  setAttribute: hc,
  removeAttribute: Mg,
  blockTextSelection: $D,
  unblockTextSelection: HD,
  getBoundingClientRect: pc,
  findPosition: Yf,
  getPointerPosition: Og,
  isTextNode: jD,
  emptyEl: Ng,
  normalizeContent: zD,
  appendContent: mT,
  insertContent: qD,
  isSingleLeftClick: Xf,
  $: No,
  $$: VD,
  computedStyle: mc,
  copyStyleSheetsToWindow: WD
});
let GD = !1, Yb;
const ywe = function() {
  if (Yb.options.autoSetup === !1)
    return;
  const t = Array.prototype.slice.call(ot.getElementsByTagName("video")), e = Array.prototype.slice.call(ot.getElementsByTagName("audio")), n = Array.prototype.slice.call(ot.getElementsByTagName("video-js")), r = t.concat(e, n);
  if (r && r.length > 0)
    for (let i = 0, s = r.length; i < s; i++) {
      const a = r[i];
      if (a && a.getAttribute)
        a.player === void 0 && a.getAttribute("data-setup") !== null && Yb(a);
      else {
        Xb(1);
        break;
      }
    }
  else GD || Xb(1);
};
function Xb(t, e) {
  $c() && (e && (Yb = e), pe.setTimeout(ywe, t));
}
function Kb() {
  GD = !0, pe.removeEventListener("load", Kb);
}
$c() && (ot.readyState === "complete" ? Kb() : pe.addEventListener("load", Kb));
const YD = function(t) {
  const e = ot.createElement("style");
  return e.className = t, e;
}, XD = function(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.textContent = e;
};
var di = /* @__PURE__ */ new WeakMap();
const vwe = 3;
let Twe = vwe;
function fs() {
  return Twe++;
}
function jx(t, e) {
  if (!di.has(t))
    return;
  const n = di.get(t);
  n.handlers[e].length === 0 && (delete n.handlers[e], t.removeEventListener ? t.removeEventListener(e, n.dispatcher, !1) : t.detachEvent && t.detachEvent("on" + e, n.dispatcher)), Object.getOwnPropertyNames(n.handlers).length <= 0 && (delete n.handlers, delete n.dispatcher, delete n.disabled), Object.getOwnPropertyNames(n).length === 0 && di.delete(t);
}
function gT(t, e, n, r) {
  n.forEach(function(i) {
    t(e, i, r);
  });
}
function Lg(t) {
  if (t.fixed_)
    return t;
  function e() {
    return !0;
  }
  function n() {
    return !1;
  }
  if (!t || !t.isPropagationStopped || !t.isImmediatePropagationStopped) {
    const r = t || pe.event;
    t = {};
    const i = ["layerX", "layerY", "keyLocation", "path", "webkitMovementX", "webkitMovementY", "mozPressure", "mozInputSource"];
    for (const s in r)
      i.includes(s) || s === "returnValue" && r.preventDefault || (t[s] = r[s]);
    if (t.target || (t.target = t.srcElement || ot), t.relatedTarget || (t.relatedTarget = t.fromElement === t.target ? t.toElement : t.fromElement), t.preventDefault = function() {
      r.preventDefault && r.preventDefault(), t.returnValue = !1, r.returnValue = !1, t.defaultPrevented = !0;
    }, t.defaultPrevented = !1, t.stopPropagation = function() {
      r.stopPropagation && r.stopPropagation(), t.cancelBubble = !0, r.cancelBubble = !0, t.isPropagationStopped = e;
    }, t.isPropagationStopped = n, t.stopImmediatePropagation = function() {
      r.stopImmediatePropagation && r.stopImmediatePropagation(), t.isImmediatePropagationStopped = e, t.stopPropagation();
    }, t.isImmediatePropagationStopped = n, t.clientX !== null && t.clientX !== void 0) {
      const s = ot.documentElement, a = ot.body;
      t.pageX = t.clientX + (s && s.scrollLeft || a && a.scrollLeft || 0) - (s && s.clientLeft || a && a.clientLeft || 0), t.pageY = t.clientY + (s && s.scrollTop || a && a.scrollTop || 0) - (s && s.clientTop || a && a.clientTop || 0);
    }
    t.which = t.charCode || t.keyCode, t.button !== null && t.button !== void 0 && (t.button = t.button & 1 ? 0 : t.button & 4 ? 1 : t.button & 2 ? 2 : 0);
  }
  return t.fixed_ = !0, t;
}
let Op;
const _we = function() {
  if (typeof Op != "boolean") {
    Op = !1;
    try {
      const t = Object.defineProperty({}, "passive", {
        get() {
          Op = !0;
        }
      });
      pe.addEventListener("test", null, t), pe.removeEventListener("test", null, t);
    } catch {
    }
  }
  return Op;
}, Ewe = ["touchstart", "touchmove"];
function Qi(t, e, n) {
  if (Array.isArray(e))
    return gT(Qi, t, e, n);
  di.has(t) || di.set(t, {});
  const r = di.get(t);
  if (r.handlers || (r.handlers = {}), r.handlers[e] || (r.handlers[e] = []), n.guid || (n.guid = fs()), r.handlers[e].push(n), r.dispatcher || (r.disabled = !1, r.dispatcher = function(i, s) {
    if (r.disabled)
      return;
    i = Lg(i);
    const a = r.handlers[i.type];
    if (a) {
      const o = a.slice(0);
      for (let u = 0, c = o.length; u < c && !i.isImmediatePropagationStopped(); u++)
        try {
          o[u].call(t, i, s);
        } catch (d) {
          Kt.error(d);
        }
    }
  }), r.handlers[e].length === 1)
    if (t.addEventListener) {
      let i = !1;
      _we() && Ewe.indexOf(e) > -1 && (i = {
        passive: !0
      }), t.addEventListener(e, r.dispatcher, i);
    } else t.attachEvent && t.attachEvent("on" + e, r.dispatcher);
}
function ti(t, e, n) {
  if (!di.has(t))
    return;
  const r = di.get(t);
  if (!r.handlers)
    return;
  if (Array.isArray(e))
    return gT(ti, t, e, n);
  const i = function(a, o) {
    r.handlers[o] = [], jx(a, o);
  };
  if (e === void 0) {
    for (const a in r.handlers)
      Object.prototype.hasOwnProperty.call(r.handlers || {}, a) && i(t, a);
    return;
  }
  const s = r.handlers[e];
  if (s) {
    if (!n) {
      i(t, e);
      return;
    }
    if (n.guid)
      for (let a = 0; a < s.length; a++)
        s[a].guid === n.guid && s.splice(a--, 1);
    jx(t, e);
  }
}
function jc(t, e, n) {
  const r = di.has(t) ? di.get(t) : {}, i = t.parentNode || t.ownerDocument;
  if (typeof e == "string" ? e = {
    type: e,
    target: t
  } : e.target || (e.target = t), e = Lg(e), r.dispatcher && r.dispatcher.call(t, e, n), i && !e.isPropagationStopped() && e.bubbles === !0)
    jc.call(null, i, e, n);
  else if (!i && !e.defaultPrevented && e.target && e.target[e.type]) {
    di.has(e.target) || di.set(e.target, {});
    const s = di.get(e.target);
    e.target[e.type] && (s.disabled = !0, typeof e.target[e.type] == "function" && e.target[e.type](), s.disabled = !1);
  }
  return !e.defaultPrevented;
}
function Pg(t, e, n) {
  if (Array.isArray(e))
    return gT(Pg, t, e, n);
  const r = function() {
    ti(t, e, r), n.apply(this, arguments);
  };
  r.guid = n.guid = n.guid || fs(), Qi(t, e, r);
}
function AT(t, e, n) {
  const r = function() {
    ti(t, e, r), n.apply(this, arguments);
  };
  r.guid = n.guid = n.guid || fs(), Qi(t, e, r);
}
var xwe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixEvent: Lg,
  on: Qi,
  off: ti,
  trigger: jc,
  one: Pg,
  any: AT
});
const hs = 30, Un = function(t, e, n) {
  e.guid || (e.guid = fs());
  const r = e.bind(t);
  return r.guid = n ? n + "_" + e.guid : e.guid, r;
}, pa = function(t, e) {
  let n = pe.performance.now();
  return function(...i) {
    const s = pe.performance.now();
    s - n >= e && (t(...i), n = s);
  };
}, KD = function(t, e, n, r = pe) {
  let i;
  const s = () => {
    r.clearTimeout(i), i = null;
  }, a = function() {
    const o = this, u = arguments;
    let c = function() {
      i = null, c = null, n || t.apply(o, u);
    };
    !i && n && t.apply(o, u), r.clearTimeout(i), i = r.setTimeout(c, e);
  };
  return a.cancel = s, a;
};
var wwe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  UPDATE_REFRESH_INTERVAL: hs,
  bind_: Un,
  throttle: pa,
  debounce: KD
});
let Nd;
class Gi {
  /**
   * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
   * function that will get called when an event with a certain name gets triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to call with `EventTarget`s
   */
  on(e, n) {
    const r = this.addEventListener;
    this.addEventListener = () => {
    }, Qi(this, e, n), this.addEventListener = r;
  }
  /**
   * Removes an `event listener` for a specific event from an instance of `EventTarget`.
   * This makes it so that the `event listener` will no longer get called when the
   * named event happens.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to remove.
   */
  off(e, n) {
    ti(this, e, n);
  }
  /**
   * This function will add an `event listener` that gets triggered only once. After the
   * first trigger it will get removed. This is like adding an `event listener`
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  one(e, n) {
    const r = this.addEventListener;
    this.addEventListener = () => {
    }, Pg(this, e, n), this.addEventListener = r;
  }
  /**
   * This function will add an `event listener` that gets triggered only once and is
   * removed from all events. This is like adding an array of `event listener`s
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
   * first time it is triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  any(e, n) {
    const r = this.addEventListener;
    this.addEventListener = () => {
    }, AT(this, e, n), this.addEventListener = r;
  }
  /**
   * This function causes an event to happen. This will then cause any `event listeners`
   * that are waiting for that event, to get called. If there are no `event listeners`
   * for an event then nothing will happen.
   *
   * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
   * Trigger will also call the `on` + `uppercaseEventName` function.
   *
   * Example:
   * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
   * `onClick` if it exists.
   *
   * @param {string|EventTarget~Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   */
  trigger(e) {
    const n = e.type || e;
    typeof e == "string" && (e = {
      type: n
    }), e = Lg(e), this.allowedEvents_[n] && this["on" + n] && this["on" + n](e), jc(this, e);
  }
  queueTrigger(e) {
    Nd || (Nd = /* @__PURE__ */ new Map());
    const n = e.type || e;
    let r = Nd.get(this);
    r || (r = /* @__PURE__ */ new Map(), Nd.set(this, r));
    const i = r.get(n);
    r.delete(n), pe.clearTimeout(i);
    const s = pe.setTimeout(() => {
      r.delete(n), r.size === 0 && (r = null, Nd.delete(this)), this.trigger(e);
    }, 0);
    r.set(n, s);
  }
}
Gi.prototype.allowedEvents_ = {};
Gi.prototype.addEventListener = Gi.prototype.on;
Gi.prototype.removeEventListener = Gi.prototype.off;
Gi.prototype.dispatchEvent = Gi.prototype.trigger;
const Rg = (t) => typeof t.name == "function" ? t.name() : typeof t.name == "string" ? t.name : t.name_ ? t.name_ : t.constructor && t.constructor.name ? t.constructor.name : typeof t, Ha = (t) => t instanceof Gi || !!t.eventBusEl_ && ["on", "one", "off", "trigger"].every((e) => typeof t[e] == "function"), Cwe = (t, e) => {
  Ha(t) ? e() : (t.eventedCallbacks || (t.eventedCallbacks = []), t.eventedCallbacks.push(e));
}, Zb = (t) => (
  // The regex here verifies that the `type` contains at least one non-
  // whitespace character.
  typeof t == "string" && /\S/.test(t) || Array.isArray(t) && !!t.length
), d0 = (t, e, n) => {
  if (!t || !t.nodeName && !Ha(t))
    throw new Error(`Invalid target for ${Rg(e)}#${n}; must be a DOM node or evented object.`);
}, ZD = (t, e, n) => {
  if (!Zb(t))
    throw new Error(`Invalid event type for ${Rg(e)}#${n}; must be a non-empty string or array.`);
}, JD = (t, e, n) => {
  if (typeof t != "function")
    throw new Error(`Invalid listener for ${Rg(e)}#${n}; must be a function.`);
}, KA = (t, e, n) => {
  const r = e.length < 3 || e[0] === t || e[0] === t.eventBusEl_;
  let i, s, a;
  return r ? (i = t.eventBusEl_, e.length >= 3 && e.shift(), [s, a] = e) : (i = e[0], s = e[1], a = e[2]), d0(i, t, n), ZD(s, t, n), JD(a, t, n), a = Un(t, a), {
    isTargetingSelf: r,
    target: i,
    type: s,
    listener: a
  };
}, Jo = (t, e, n, r) => {
  d0(t, t, e), t.nodeName ? xwe[e](t, n, r) : t[e](n, r);
}, Swe = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on(...t) {
    const {
      isTargetingSelf: e,
      target: n,
      type: r,
      listener: i
    } = KA(this, t, "on");
    if (Jo(n, "on", r, i), !e) {
      const s = () => this.off(n, r, i);
      s.guid = i.guid;
      const a = () => this.off("dispose", s);
      a.guid = i.guid, Jo(this, "on", "dispose", s), Jo(n, "on", "dispose", a);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one(...t) {
    const {
      isTargetingSelf: e,
      target: n,
      type: r,
      listener: i
    } = KA(this, t, "one");
    if (e)
      Jo(n, "one", r, i);
    else {
      const s = (...a) => {
        this.off(n, r, s), i.apply(null, a);
      };
      s.guid = i.guid, Jo(n, "one", r, s);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any(...t) {
    const {
      isTargetingSelf: e,
      target: n,
      type: r,
      listener: i
    } = KA(this, t, "any");
    if (e)
      Jo(n, "any", r, i);
    else {
      const s = (...a) => {
        this.off(n, r, s), i.apply(null, a);
      };
      s.guid = i.guid, Jo(n, "any", r, s);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off(t, e, n) {
    if (!t || Zb(t))
      ti(this.eventBusEl_, t, e);
    else {
      const r = t, i = e;
      d0(r, this, "off"), ZD(i, this, "off"), JD(n, this, "off"), n = Un(this, n), this.off("dispose", n), r.nodeName ? (ti(r, i, n), ti(r, "dispose", n)) : Ha(r) && (r.off(i, n), r.off("dispose", n));
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger(t, e) {
    d0(this.eventBusEl_, this, "trigger");
    const n = t && typeof t != "string" ? t.type : t;
    if (!Zb(n))
      throw new Error(`Invalid event type for ${Rg(this)}#trigger; must be a non-empty string or object with a type key that has a non-empty value.`);
    return jc(this.eventBusEl_, t, e);
  }
};
function bT(t, e = {}) {
  const {
    eventBusKey: n
  } = e;
  if (n) {
    if (!t[n].nodeName)
      throw new Error(`The eventBusKey "${n}" does not refer to an element.`);
    t.eventBusEl_ = t[n];
  } else
    t.eventBusEl_ = Nt("span", {
      className: "vjs-event-bus"
    });
  return Object.assign(t, Swe), t.eventedCallbacks && t.eventedCallbacks.forEach((r) => {
    r();
  }), t.on("dispose", () => {
    t.off(), [t, t.el_, t.eventBusEl_].forEach(function(r) {
      r && di.has(r) && di.delete(r);
    }), pe.setTimeout(() => {
      t.eventBusEl_ = null;
    }, 0);
  }), t;
}
const Iwe = {
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState(t) {
    typeof t == "function" && (t = t());
    let e;
    return Vl(t, (n, r) => {
      this.state[r] !== n && (e = e || {}, e[r] = {
        from: this.state[r],
        to: n
      }), this.state[r] = n;
    }), e && Ha(this) && this.trigger({
      changes: e,
      type: "statechanged"
    }), e;
  }
};
function e8(t, e) {
  return Object.assign(t, Iwe), t.state = Object.assign({}, t.state, e), typeof t.handleStateChanged == "function" && Ha(t) && t.on("statechanged", t.handleStateChanged), t;
}
const Af = function(t) {
  return typeof t != "string" ? t : t.replace(/./, (e) => e.toLowerCase());
}, or = function(t) {
  return typeof t != "string" ? t : t.replace(/./, (e) => e.toUpperCase());
}, t8 = function(t, e) {
  return or(t) === or(e);
};
var kwe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toLowerCase: Af,
  toTitleCase: or,
  titleCaseEquals: t8
});
class He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of component options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to initialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param  {string} [options.className]
   *         A class or space separated list of classes to add the component
   *
   * @param {ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  constructor(e, n, r) {
    if (!e && this.play ? this.player_ = e = this : this.player_ = e, this.isDisposed_ = !1, this.parentComponent_ = null, this.options_ = Dn({}, this.options_), n = this.options_ = Dn(this.options_, n), this.id_ = n.id || n.el && n.el.id, !this.id_) {
      const i = e && e.id && e.id() || "no_player";
      this.id_ = `${i}_component_${fs()}`;
    }
    this.name_ = n.name || null, n.el ? this.el_ = n.el : n.createEl !== !1 && (this.el_ = this.createEl()), n.className && this.el_ && n.className.split(" ").forEach((i) => this.addClass(i)), ["on", "off", "one", "any", "trigger"].forEach((i) => {
      this[i] = void 0;
    }), n.evented !== !1 && (bT(this, {
      eventBusKey: this.el_ ? "el_" : null
    }), this.handleLanguagechange = this.handleLanguagechange.bind(this), this.on(this.player_, "languagechange", this.handleLanguagechange)), e8(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, this.childNameIndex_ = {}, this.setTimeoutIds_ = /* @__PURE__ */ new Set(), this.setIntervalIds_ = /* @__PURE__ */ new Set(), this.rafIds_ = /* @__PURE__ */ new Set(), this.namedRafs_ = /* @__PURE__ */ new Map(), this.clearingTimersOnDispose_ = !1, n.initChildren !== !1 && this.initChildren(), this.ready(r), n.reportTouchActivity !== !1 && this.enableTouchActivity();
  }
  // `on`, `off`, `one`, `any` and `trigger` are here so tsc includes them in definitions.
  // They are replaced or removed in the constructor
  /**
   * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
   * function that will get called when an event with a certain name gets triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to call with `EventTarget`s
   */
  /**
   * Removes an `event listener` for a specific event from an instance of `EventTarget`.
   * This makes it so that the `event listener` will no longer get called when the
   * named event happens.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} [fn]
   *        The function to remove. If not specified, all listeners managed by Video.js will be removed.
   */
  /**
   * This function will add an `event listener` that gets triggered only once. After the
   * first trigger it will get removed. This is like adding an `event listener`
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  /**
   * This function will add an `event listener` that gets triggered only once and is
   * removed from all events. This is like adding an array of `event listener`s
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
   * first time it is triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  /**
   * This function causes an event to happen. This will then cause any `event listeners`
   * that are waiting for that event, to get called. If there are no `event listeners`
   * for an event then nothing will happen.
   *
   * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
   * Trigger will also call the `on` + `uppercaseEventName` function.
   *
   * Example:
   * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
   * `onClick` if it exists.
   *
   * @param {string|Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   *
   * @param {Object} [hash]
   *        Optionally extra argument to pass through to an event listener
   */
  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   *
   * @param {Object} options
   * @param {Element} options.originalEl element with which to replace player element
   */
  dispose(e = {}) {
    if (!this.isDisposed_) {
      if (this.readyQueue_ && (this.readyQueue_.length = 0), this.trigger({
        type: "dispose",
        bubbles: !1
      }), this.isDisposed_ = !0, this.children_)
        for (let n = this.children_.length - 1; n >= 0; n--)
          this.children_[n].dispose && this.children_[n].dispose();
      this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.parentComponent_ = null, this.el_ && (this.el_.parentNode && (e.restoreEl ? this.el_.parentNode.replaceChild(e.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)), this.el_ = null), this.player_ = null;
    }
  }
  /**
   * Determine whether or not this component has been disposed.
   *
   * @return {boolean}
   *         If the component has been disposed, will be `true`. Otherwise, `false`.
   */
  isDisposed() {
    return !!this.isDisposed_;
  }
  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */
  player() {
    return this.player_;
  }
  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:obj.merge}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   */
  options(e) {
    return e ? (this.options_ = Dn(this.options_, e), this.options_) : this.options_;
  }
  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */
  el() {
    return this.el_;
  }
  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, n, r) {
    return Nt(e, n, r);
  }
  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */
  localize(e, n, r = e) {
    const i = this.player_.language && this.player_.language(), s = this.player_.languages && this.player_.languages(), a = s && s[i], o = i && i.split("-")[0], u = s && s[o];
    let c = r;
    return a && a[e] ? c = a[e] : u && u[e] && (c = u[e]), n && (c = c.replace(/\{(\d+)\}/g, function(d, l) {
      const f = n[l - 1];
      let p = f;
      return typeof f > "u" && (p = d), p;
    })), c;
  }
  /**
   * Handles language change for the player in components. Should be overridden by sub-components.
   *
   * @abstract
   */
  handleLanguagechange() {
  }
  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */
  contentEl() {
    return this.contentEl_ || this.el_;
  }
  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */
  id() {
    return this.id_;
  }
  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */
  name() {
    return this.name_;
  }
  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */
  children() {
    return this.children_;
  }
  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */
  getChildById(e) {
    return this.childIndex_[e];
  }
  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */
  getChild(e) {
    if (e)
      return this.childNameIndex_[e];
  }
  /**
   * Returns the descendant `Component` following the givent
   * descendant `names`. For instance ['foo', 'bar', 'baz'] would
   * try to get 'foo' on the current component, 'bar' on the 'foo'
   * component and 'baz' on the 'bar' component and return undefined
   * if any of those don't exist.
   *
   * @param {...string[]|...string} names
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The descendant `Component` following the given descendant
   *         `names` or undefined.
   */
  getDescendant(...e) {
    e = e.reduce((r, i) => r.concat(i), []);
    let n = this;
    for (let r = 0; r < e.length; r++)
      if (n = n.getChild(e[r]), !n || !n.getChild)
        return;
    return n;
  }
  /**
   * Adds an SVG icon element to another element or component.
   *
   * @param {string} iconName
   *        The name of icon. A list of all the icon names can be found at 'sandbox/svg-icons.html'
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on. Defaults to the current Component's element.
   *
   * @return {Element}
   *        The newly created icon element.
   */
  setIcon(e, n = this.el()) {
    if (!this.player_.options_.experimentalSvgIcons)
      return;
    const r = "http://www.w3.org/2000/svg", i = Nt("span", {
      className: "vjs-icon-placeholder vjs-svg-icon"
    }, {
      "aria-hidden": "true"
    }), s = ot.createElementNS(r, "svg");
    s.setAttributeNS(null, "viewBox", "0 0 512 512");
    const a = ot.createElementNS(r, "use");
    return s.appendChild(a), a.setAttributeNS(null, "href", `#vjs-icon-${e}`), i.appendChild(s), this.iconIsSet_ ? n.replaceChild(i, n.querySelector(".vjs-icon-placeholder")) : n.appendChild(i), this.iconIsSet_ = !0, i;
  }
  /**
   * Add a child `Component` inside the current `Component`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */
  addChild(e, n = {}, r = this.children_.length) {
    let i, s;
    if (typeof e == "string") {
      s = or(e);
      const a = n.componentClass || s;
      n.name = s;
      const o = He.getComponent(a);
      if (!o)
        throw new Error(`Component ${a} does not exist`);
      if (typeof o != "function")
        return null;
      i = new o(this.player_ || this, n);
    } else
      i = e;
    if (i.parentComponent_ && i.parentComponent_.removeChild(i), this.children_.splice(r, 0, i), i.parentComponent_ = this, typeof i.id == "function" && (this.childIndex_[i.id()] = i), s = s || i.name && or(i.name()), s && (this.childNameIndex_[s] = i, this.childNameIndex_[Af(s)] = i), typeof i.el == "function" && i.el()) {
      let a = null;
      this.children_[r + 1] && (this.children_[r + 1].el_ ? a = this.children_[r + 1].el_ : Hc(this.children_[r + 1]) && (a = this.children_[r + 1])), this.contentEl().insertBefore(i.el(), a);
    }
    return i;
  }
  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {Component} component
   *        The child `Component` to remove.
   */
  removeChild(e) {
    if (typeof e == "string" && (e = this.getChild(e)), !e || !this.children_)
      return;
    let n = !1;
    for (let i = this.children_.length - 1; i >= 0; i--)
      if (this.children_[i] === e) {
        n = !0, this.children_.splice(i, 1);
        break;
      }
    if (!n)
      return;
    e.parentComponent_ = null, this.childIndex_[e.id()] = null, this.childNameIndex_[or(e.name())] = null, this.childNameIndex_[Af(e.name())] = null;
    const r = e.el();
    r && r.parentNode === this.contentEl() && this.contentEl().removeChild(e.el());
  }
  /**
   * Add and initialize default child `Component`s based upon options.
   */
  initChildren() {
    const e = this.options_.children;
    if (e) {
      const n = this.options_, r = (a) => {
        const o = a.name;
        let u = a.opts;
        if (n[o] !== void 0 && (u = n[o]), u === !1)
          return;
        u === !0 && (u = {}), u.playerOptions = this.options_.playerOptions;
        const c = this.addChild(o, u);
        c && (this[o] = c);
      };
      let i;
      const s = He.getComponent("Tech");
      Array.isArray(e) ? i = e : i = Object.keys(e), i.concat(Object.keys(this.options_).filter(function(a) {
        return !i.some(function(o) {
          return typeof o == "string" ? a === o : a === o.name;
        });
      })).map((a) => {
        let o, u;
        return typeof a == "string" ? (o = a, u = e[o] || this.options_[o] || {}) : (o = a.name, u = a), {
          name: o,
          opts: u
        };
      }).filter((a) => {
        const o = He.getComponent(a.opts.componentClass || or(a.name));
        return o && !s.isTech(o);
      }).forEach(r);
    }
  }
  /**
   * Builds the default DOM class name. Should be overridden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */
  buildCSSClass() {
    return "";
  }
  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @param {ReadyCallback} fn
   *        Function that gets called when the `Component` is ready.
   */
  ready(e, n = !1) {
    if (e) {
      if (!this.isReady_) {
        this.readyQueue_ = this.readyQueue_ || [], this.readyQueue_.push(e);
        return;
      }
      n ? e.call(this) : this.setTimeout(e, 1);
    }
  }
  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */
  triggerReady() {
    this.isReady_ = !0, this.setTimeout(function() {
      const e = this.readyQueue_;
      this.readyQueue_ = [], e && e.length > 0 && e.forEach(function(n) {
        n.call(this);
      }, this), this.trigger("ready");
    }, 1);
  }
  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */
  $(e, n) {
    return No(e, n || this.contentEl());
  }
  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */
  $$(e, n) {
    return VD(e, n || this.contentEl());
  }
  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */
  hasClass(e) {
    return gf(this.el_, e);
  }
  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {...string} classesToAdd
   *        One or more CSS class name to add.
   */
  addClass(...e) {
    Iu(this.el_, ...e);
  }
  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {...string} classesToRemove
   *        One or more CSS class name to remove.
   */
  removeClass(...e) {
    Dg(this.el_, ...e);
  }
  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove. Passed to DOMTokenList's toggle()
   *
   * @param  {boolean|Dom.PredicateCallback} [predicate]
   *         A boolean or function that returns a boolean. Passed to DOMTokenList's toggle().
   */
  toggleClass(e, n) {
    BD(this.el_, e, n);
  }
  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */
  show() {
    this.removeClass("vjs-hidden");
  }
  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */
  hide() {
    this.addClass("vjs-hidden");
  }
  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */
  lockShowing() {
    this.addClass("vjs-lock-showing");
  }
  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */
  unlockShowing() {
    this.removeClass("vjs-lock-showing");
  }
  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attribute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */
  getAttribute(e) {
    return UD(this.el_, e);
  }
  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */
  setAttribute(e, n) {
    hc(this.el_, e, n);
  }
  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */
  removeAttribute(e) {
    Mg(this.el_, e);
  }
  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|undefined}
   *         The width when getting, zero if there is no width
   */
  width(e, n) {
    return this.dimension("width", e, n);
  }
  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|undefined}
   *         The height when getting, zero if there is no height
   */
  height(e, n) {
    return this.dimension("height", e, n);
  }
  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */
  dimensions(e, n) {
    this.width(e, !0), this.height(n);
  }
  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number|undefined}
   *         The dimension when getting or 0 if unset
   */
  dimension(e, n, r) {
    if (n !== void 0) {
      (n === null || n !== n) && (n = 0), ("" + n).indexOf("%") !== -1 || ("" + n).indexOf("px") !== -1 ? this.el_.style[e] = n : n === "auto" ? this.el_.style[e] = "" : this.el_.style[e] = n + "px", r || this.trigger("componentresize");
      return;
    }
    if (!this.el_)
      return 0;
    const i = this.el_.style[e], s = i.indexOf("px");
    return parseInt(s !== -1 ? i.slice(0, s) : this.el_["offset" + or(e)], 10);
  }
  /**
   * Get the computed width or the height of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */
  currentDimension(e) {
    let n = 0;
    if (e !== "width" && e !== "height")
      throw new Error("currentDimension only accepts width or height value");
    if (n = mc(this.el_, e), n = parseFloat(n), n === 0 || isNaN(n)) {
      const r = `offset${or(e)}`;
      n = this.el_[r];
    }
    return n;
  }
  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */
  /**
   * Get an object that contains computed width and height values of the
   * component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {Component~DimensionObject}
   *         The computed dimensions of the component's element.
   */
  currentDimensions() {
    return {
      width: this.currentDimension("width"),
      height: this.currentDimension("height")
    };
  }
  /**
   * Get the computed width of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {number}
   *         The computed width of the component's element.
   */
  currentWidth() {
    return this.currentDimension("width");
  }
  /**
   * Get the computed height of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {number}
   *         The computed height of the component's element.
   */
  currentHeight() {
    return this.currentDimension("height");
  }
  /**
   * Retrieves the position and size information of the component's element.
   *
   * @return {Object} An object with `boundingClientRect` and `center` properties.
   *         - `boundingClientRect`: An object with properties `x`, `y`, `width`,
   *           `height`, `top`, `right`, `bottom`, and `left`, representing
   *           the bounding rectangle of the element.
   *         - `center`: An object with properties `x` and `y`, representing
   *           the center point of the element. `width` and `height` are set to 0.
   */
  getPositions() {
    const e = this.el_.getBoundingClientRect(), n = {
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      top: e.top,
      right: e.right,
      bottom: e.bottom,
      left: e.left
    }, r = {
      x: e.left + e.width / 2,
      y: e.top + e.height / 2,
      width: 0,
      height: 0,
      top: e.top + e.height / 2,
      right: e.left + e.width / 2,
      bottom: e.top + e.height / 2,
      left: e.left + e.width / 2
    };
    return {
      boundingClientRect: n,
      center: r
    };
  }
  /**
   * Set the focus to this component
   */
  focus() {
    this.el_.focus();
  }
  /**
   * Remove the focus from this component
   */
  blur() {
    this.el_.blur();
  }
  /**
   * When this Component receives a `keydown` event which it does not process,
   *  it passes the event to the Player for handling.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   */
  handleKeyDown(e) {
    this.player_ && (e.key !== "Tab" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled) && e.stopPropagation(), this.player_.handleKeyDown(e));
  }
  /**
   * Many components used to have a `handleKeyPress` method, which was poorly
   * named because it listened to a `keydown` event. This method name now
   * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`
   * will not see their method calls stop working.
   *
   * @param {KeyboardEvent} event
   *        The event that caused this function to be called.
   */
  handleKeyPress(e) {
    this.handleKeyDown(e);
  }
  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @protected
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */
  emitTapEvents() {
    let e = 0, n = null;
    const r = 10, i = 200;
    let s;
    this.on("touchstart", function(o) {
      o.touches.length === 1 && (n = {
        pageX: o.touches[0].pageX,
        pageY: o.touches[0].pageY
      }, e = pe.performance.now(), s = !0);
    }), this.on("touchmove", function(o) {
      if (o.touches.length > 1)
        s = !1;
      else if (n) {
        const u = o.touches[0].pageX - n.pageX, c = o.touches[0].pageY - n.pageY;
        Math.sqrt(u * u + c * c) > r && (s = !1);
      }
    });
    const a = function() {
      s = !1;
    };
    this.on("touchleave", a), this.on("touchcancel", a), this.on("touchend", function(o) {
      n = null, s === !0 && pe.performance.now() - e < i && (o.preventDefault(), this.trigger("tap"));
    });
  }
  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */
  enableTouchActivity() {
    if (!this.player() || !this.player().reportUserActivity)
      return;
    const e = Un(this.player(), this.player().reportUserActivity);
    let n;
    this.on("touchstart", function() {
      e(), this.clearInterval(n), n = this.setInterval(e, 250);
    });
    const r = function(i) {
      e(), this.clearInterval(n);
    };
    this.on("touchmove", e), this.on("touchend", r), this.on("touchcancel", r);
  }
  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */
  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can't use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose} instead.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */
  setTimeout(e, n) {
    var r;
    return e = Un(this, e), this.clearTimersOnDispose_(), r = pe.setTimeout(() => {
      this.setTimeoutIds_.has(r) && this.setTimeoutIds_.delete(r), e();
    }, n), this.setTimeoutIds_.add(r), r;
  }
  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */
  clearTimeout(e) {
    return this.setTimeoutIds_.has(e) && (this.setTimeoutIds_.delete(e), pe.clearTimeout(e)), e;
  }
  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */
  setInterval(e, n) {
    e = Un(this, e), this.clearTimersOnDispose_();
    const r = pe.setInterval(e, n);
    return this.setIntervalIds_.add(r), r;
  }
  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an interval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */
  clearInterval(e) {
    return this.setIntervalIds_.has(e) && (this.setIntervalIds_.delete(e), pe.clearInterval(e)), e;
  }
  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */
  requestAnimationFrame(e) {
    this.clearTimersOnDispose_();
    var n;
    return e = Un(this, e), n = pe.requestAnimationFrame(() => {
      this.rafIds_.has(n) && this.rafIds_.delete(n), e();
    }), this.rafIds_.add(n), n;
  }
  /**
   * Request an animation frame, but only one named animation
   * frame will be queued. Another will never be added until
   * the previous one finishes.
   *
   * @param {string} name
   *        The name to give this requestAnimationFrame
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   */
  requestNamedAnimationFrame(e, n) {
    this.namedRafs_.has(e) && this.cancelNamedAnimationFrame(e), this.clearTimersOnDispose_(), n = Un(this, n);
    const r = this.requestAnimationFrame(() => {
      n(), this.namedRafs_.has(e) && this.namedRafs_.delete(e);
    });
    return this.namedRafs_.set(e, r), e;
  }
  /**
   * Cancels a current named animation frame if it exists.
   *
   * @param {string} name
   *        The name of the requestAnimationFrame to cancel.
   */
  cancelNamedAnimationFrame(e) {
    this.namedRafs_.has(e) && (this.cancelAnimationFrame(this.namedRafs_.get(e)), this.namedRafs_.delete(e));
  }
  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */
  cancelAnimationFrame(e) {
    return this.rafIds_.has(e) && (this.rafIds_.delete(e), pe.cancelAnimationFrame(e)), e;
  }
  /**
   * A function to setup `requestAnimationFrame`, `setTimeout`,
   * and `setInterval`, clearing on dispose.
   *
   * > Previously each timer added and removed dispose listeners on it's own.
   * For better performance it was decided to batch them all, and use `Set`s
   * to track outstanding timer ids.
   *
   * @private
   */
  clearTimersOnDispose_() {
    this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0, this.one("dispose", () => {
      [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(([e, n]) => {
        this[e].forEach((r, i) => this[n](i));
      }), this.clearingTimersOnDispose_ = !1;
    }));
  }
  /**
    * Decide whether an element is actually disabled or not.
    *
    * @function isActuallyDisabled
    * @param element {Node}
    * @return {boolean}
    *
    * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}
    */
  getIsDisabled() {
    return !!this.el_.disabled;
  }
  /**
    * Decide whether the element is expressly inert or not.
    *
    * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}
    * @function isExpresslyInert
    * @param element {Node}
    * @return {boolean}
    */
  getIsExpresslyInert() {
    return this.el_.inert && !this.el_.ownerDocument.documentElement.inert;
  }
  /**
   * Determine whether or not this component can be considered as focusable component.
   *
   * @param {HTMLElement} el - The HTML element representing the component.
   * @return {boolean}
   *         If the component can be focused, will be `true`. Otherwise, `false`.
   */
  getIsFocusable(e) {
    return (e || this.el_).tabIndex >= 0 && !(this.getIsDisabled() || this.getIsExpresslyInert());
  }
  /**
   * Determine whether or not this component is currently visible/enabled/etc...
   *
   * @param {HTMLElement} el - The HTML element representing the component.
   * @return {boolean}
   *         If the component can is currently visible & enabled, will be `true`. Otherwise, `false`.
   */
  getIsAvailableToBeFocused(e) {
    function n(s) {
      const a = pe.getComputedStyle(s, null), o = a.getPropertyValue("visibility");
      return a.getPropertyValue("display") !== "none" && !["hidden", "collapse"].includes(o);
    }
    function r(s) {
      return !(!n(s.parentElement) || !n(s) || s.style.opacity === "0" || pe.getComputedStyle(s).height === "0px" || pe.getComputedStyle(s).width === "0px");
    }
    function i(s) {
      if (s.offsetWidth + s.offsetHeight + s.getBoundingClientRect().height + s.getBoundingClientRect().width === 0)
        return !1;
      const a = {
        x: s.getBoundingClientRect().left + s.offsetWidth / 2,
        y: s.getBoundingClientRect().top + s.offsetHeight / 2
      };
      if (a.x < 0 || a.x > (ot.documentElement.clientWidth || pe.innerWidth) || a.y < 0 || a.y > (ot.documentElement.clientHeight || pe.innerHeight))
        return !1;
      let o = ot.elementFromPoint(a.x, a.y);
      for (; o; ) {
        if (o === s)
          return !0;
        if (o.parentNode)
          o = o.parentNode;
        else
          return !1;
      }
    }
    return e || (e = this.el()), !!(i(e) && r(e) && (!e.parentElement || e.tabIndex >= 0));
  }
  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */
  static registerComponent(e, n) {
    if (typeof e != "string" || !e)
      throw new Error(`Illegal component name, "${e}"; must be a non-empty string.`);
    const r = He.getComponent("Tech"), i = r && r.isTech(n), s = He === n || He.prototype.isPrototypeOf(n.prototype);
    if (i || !s) {
      let o;
      throw i ? o = "techs must be registered using Tech.registerTech()" : o = "must be a Component subclass", new Error(`Illegal component, "${e}"; ${o}.`);
    }
    e = or(e), He.components_ || (He.components_ = {});
    const a = He.getComponent("Player");
    if (e === "Player" && a && a.players) {
      const o = a.players, u = Object.keys(o);
      if (o && u.length > 0) {
        for (let c = 0; c < u.length; c++)
          if (o[u[c]] !== null)
            throw new Error("Can not register Player component after player has been created.");
      }
    }
    return He.components_[e] = n, He.components_[Af(e)] = n, n;
  }
  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {typeof Component}
   *         The `Component` that got registered under the given name.
   */
  static getComponent(e) {
    if (!(!e || !He.components_))
      return He.components_[e];
  }
}
He.registerComponent("Component", He);
function Dwe(t, e, n) {
  if (typeof e != "number" || e < 0 || e > n)
    throw new Error(`Failed to execute '${t}' on 'TimeRanges': The index provided (${e}) is non-numeric or out of bounds (0-${n}).`);
}
function zx(t, e, n, r) {
  return Dwe(t, r, n.length - 1), n[r][e];
}
function ZA(t) {
  let e;
  return t === void 0 || t.length === 0 ? e = {
    length: 0,
    start() {
      throw new Error("This TimeRanges object is empty");
    },
    end() {
      throw new Error("This TimeRanges object is empty");
    }
  } : e = {
    length: t.length,
    start: zx.bind(null, "start", 0, t),
    end: zx.bind(null, "end", 1, t)
  }, pe.Symbol && pe.Symbol.iterator && (e[pe.Symbol.iterator] = () => (t || []).values()), e;
}
function Ds(t, e) {
  return Array.isArray(t) ? ZA(t) : t === void 0 || e === void 0 ? ZA() : ZA([[t, e]]);
}
const n8 = function(t, e) {
  t = t < 0 ? 0 : t;
  let n = Math.floor(t % 60), r = Math.floor(t / 60 % 60), i = Math.floor(t / 3600);
  const s = Math.floor(e / 60 % 60), a = Math.floor(e / 3600);
  return (isNaN(t) || t === 1 / 0) && (i = r = n = "-"), i = i > 0 || a > 0 ? i + ":" : "", r = ((i || s >= 10) && r < 10 ? "0" + r : r) + ":", n = n < 10 ? "0" + n : n, i + r + n;
};
let yT = n8;
function r8(t) {
  yT = t;
}
function i8() {
  yT = n8;
}
function Vu(t, e = t) {
  return yT(t, e);
}
var Mwe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTimeRanges: Ds,
  createTimeRange: Ds,
  setFormatTime: r8,
  resetFormatTime: i8,
  formatTime: Vu
});
function s8(t, e) {
  let n = 0, r, i;
  if (!e)
    return 0;
  (!t || !t.length) && (t = Ds(0, 0));
  for (let s = 0; s < t.length; s++)
    r = t.start(s), i = t.end(s), i > e && (i = e), n += i - r;
  return n / e;
}
function nr(t) {
  if (t instanceof nr)
    return t;
  typeof t == "number" ? this.code = t : typeof t == "string" ? this.message = t : fa(t) && (typeof t.code == "number" && (this.code = t.code), Object.assign(this, t)), this.message || (this.message = nr.defaultMessages[this.code] || "");
}
nr.prototype.code = 0;
nr.prototype.message = "";
nr.prototype.status = null;
nr.prototype.metadata = null;
nr.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
nr.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
nr.MEDIA_ERR_CUSTOM = 0;
nr.prototype.MEDIA_ERR_CUSTOM = 0;
nr.MEDIA_ERR_ABORTED = 1;
nr.prototype.MEDIA_ERR_ABORTED = 1;
nr.MEDIA_ERR_NETWORK = 2;
nr.prototype.MEDIA_ERR_NETWORK = 2;
nr.MEDIA_ERR_DECODE = 3;
nr.prototype.MEDIA_ERR_DECODE = 3;
nr.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
nr.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
nr.MEDIA_ERR_ENCRYPTED = 5;
nr.prototype.MEDIA_ERR_ENCRYPTED = 5;
function bf(t) {
  return t != null && typeof t.then == "function";
}
function ta(t) {
  bf(t) && t.then(null, (e) => {
  });
}
const Jb = function(t) {
  return ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce((n, r, i) => (t[r] && (n[r] = t[r]), n), {
    cues: t.cues && Array.prototype.map.call(t.cues, function(n) {
      return {
        startTime: n.startTime,
        endTime: n.endTime,
        text: n.text,
        id: n.id
      };
    })
  });
}, Owe = function(t) {
  const e = t.$$("track"), n = Array.prototype.map.call(e, (i) => i.track);
  return Array.prototype.map.call(e, function(i) {
    const s = Jb(i.track);
    return i.src && (s.src = i.src), s;
  }).concat(Array.prototype.filter.call(t.textTracks(), function(i) {
    return n.indexOf(i) === -1;
  }).map(Jb));
}, Nwe = function(t, e) {
  return t.forEach(function(n) {
    const r = e.addRemoteTextTrack(n).track;
    !n.src && n.cues && n.cues.forEach((i) => r.addCue(i));
  }), e.textTracks();
};
var ey = {
  textTracksToJson: Owe,
  jsonToTextTracks: Nwe,
  trackToJson: Jb
};
const JA = "vjs-modal-dialog";
class zc extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.pauseOnOpen=true]
   *        If `true`, playback will will be paused if playing when
   *        the modal opens, and resumed when it closes.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  constructor(e, n) {
    super(e, n), this.handleKeyDown_ = (r) => this.handleKeyDown(r), this.close_ = (r) => this.close(r), this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = !1, this.closeable(!this.options_.uncloseable), this.content(this.options_.content), this.contentEl_ = Nt("div", {
      className: `${JA}-content`
    }, {
      role: "document"
    }), this.descEl_ = Nt("p", {
      className: `${JA}-description vjs-control-text`,
      id: this.el().getAttribute("aria-describedby")
    }), Uo(this.descEl_, this.description()), this.el_.appendChild(this.descEl_), this.el_.appendChild(this.contentEl_);
  }
  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      "aria-describedby": `${this.id()}_description`,
      "aria-hidden": "true",
      "aria-label": this.label(),
      role: "dialog",
      "aria-live": "polite"
    });
  }
  dispose() {
    this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, super.dispose();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `${JA} vjs-hidden ${super.buildCSSClass()}`;
  }
  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */
  label() {
    return this.localize(this.options_.label || "Modal Window");
  }
  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */
  description() {
    let e = this.options_.description || this.localize("This is a modal window.");
    return this.closeable() && (e += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")), e;
  }
  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */
  open() {
    if (this.opened_) {
      this.options_.fillAlways && this.fill();
      return;
    }
    const e = this.player();
    this.trigger("beforemodalopen"), this.opened_ = !0, (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(), this.wasPlaying_ = !e.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && e.pause(), this.on("keydown", this.handleKeyDown_), this.hadControls_ = e.controls(), e.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0;
  }
  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */
  opened(e) {
    return typeof e == "boolean" && this[e ? "open" : "close"](), this.opened_;
  }
  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */
  close() {
    if (!this.opened_)
      return;
    const e = this.player();
    this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && e.play(), this.off("keydown", this.handleKeyDown_), this.hadControls_ && e.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger({
      type: "modalclose",
      bubbles: !0
    }), this.conditionalBlur_(), this.options_.temporary && this.dispose();
  }
  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */
  closeable(e) {
    if (typeof e == "boolean") {
      const n = this.closeable_ = !!e;
      let r = this.getChild("closeButton");
      if (n && !r) {
        const i = this.contentEl_;
        this.contentEl_ = this.el_, r = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        }), this.contentEl_ = i, this.on(r, "close", this.close_);
      }
      !n && r && (this.off(r, "close", this.close_), this.removeChild(r), r.dispose());
    }
    return this.closeable_;
  }
  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */
  fill() {
    this.fillWith(this.content());
  }
  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {ContentDescriptor} [content]
   *        The same rules apply to this as apply to the `content` option.
   */
  fillWith(e) {
    const n = this.contentEl(), r = n.parentNode, i = n.nextSibling;
    this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, r.removeChild(n), this.empty(), qD(n, e), this.trigger("modalfill"), i ? r.insertBefore(n, i) : r.appendChild(n);
    const s = this.getChild("closeButton");
    s && r.appendChild(s.el_), this.trigger("aftermodalfill");
  }
  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */
  empty() {
    this.trigger("beforemodalempty"), Ng(this.contentEl()), this.trigger("modalempty");
  }
  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {ContentDescriptor} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {ContentDescriptor}
   *         The current content of the modal dialog
   */
  content(e) {
    return typeof e < "u" && (this.content_ = e), this.content_;
  }
  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */
  conditionalFocus_() {
    const e = ot.activeElement, n = this.player_.el_;
    this.previouslyActiveEl_ = null, (n.contains(e) || n === e) && (this.previouslyActiveEl_ = e, this.focus());
  }
  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */
  conditionalBlur_() {
    this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null);
  }
  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    if (this.trigger({
      type: "modalKeydown",
      originalEvent: e,
      target: this,
      bubbles: !0
    }), e.stopPropagation(), e.key === "Escape" && this.closeable()) {
      e.preventDefault(), this.close();
      return;
    }
    if (e.key !== "Tab")
      return;
    const n = this.focusableEls_(), r = this.el_.querySelector(":focus");
    let i;
    for (let s = 0; s < n.length; s++)
      if (r === n[s]) {
        i = s;
        break;
      }
    ot.activeElement === this.el_ && (i = 0), e.shiftKey && i === 0 ? (n[n.length - 1].focus(), e.preventDefault()) : !e.shiftKey && i === n.length - 1 && (n[0].focus(), e.preventDefault());
  }
  /**
   * get all focusable elements
   *
   * @private
   */
  focusableEls_() {
    const e = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(e, (n) => (n instanceof pe.HTMLAnchorElement || n instanceof pe.HTMLAreaElement) && n.hasAttribute("href") || (n instanceof pe.HTMLInputElement || n instanceof pe.HTMLSelectElement || n instanceof pe.HTMLTextAreaElement || n instanceof pe.HTMLButtonElement) && !n.hasAttribute("disabled") || n instanceof pe.HTMLIFrameElement || n instanceof pe.HTMLObjectElement || n instanceof pe.HTMLEmbedElement || n.hasAttribute("tabindex") && n.getAttribute("tabindex") !== -1 || n.hasAttribute("contenteditable"));
  }
}
zc.prototype.options_ = {
  pauseOnOpen: !0,
  temporary: !0
};
He.registerComponent("ModalDialog", zc);
class Wu extends Gi {
  /**
   * Create an instance of this class
   *
   * @param { Track[] } tracks
   *        A list of tracks to initialize the list with.
   *
   * @abstract
   */
  constructor(e = []) {
    super(), this.tracks_ = [], Object.defineProperty(this, "length", {
      get() {
        return this.tracks_.length;
      }
    });
    for (let n = 0; n < e.length; n++)
      this.addTrack(e[n]);
  }
  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    const n = this.tracks_.length;
    "" + n in this || Object.defineProperty(this, n, {
      get() {
        return this.tracks_[n];
      }
    }), this.tracks_.indexOf(e) === -1 && (this.tracks_.push(e), this.trigger({
      track: e,
      type: "addtrack",
      target: this
    })), e.labelchange_ = () => {
      this.trigger({
        track: e,
        type: "labelchange",
        target: this
      });
    }, Ha(e) && e.addEventListener("labelchange", e.labelchange_);
  }
  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */
  removeTrack(e) {
    let n;
    for (let r = 0, i = this.length; r < i; r++)
      if (this[r] === e) {
        n = this[r], n.off && n.off(), this.tracks_.splice(r, 1);
        break;
      }
    n && this.trigger({
      track: n,
      type: "removetrack",
      target: this
    });
  }
  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {string} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */
  getTrackById(e) {
    let n = null;
    for (let r = 0, i = this.length; r < i; r++) {
      const s = this[r];
      if (s.id === e) {
        n = s;
        break;
      }
    }
    return n;
  }
}
Wu.prototype.allowedEvents_ = {
  change: "change",
  addtrack: "addtrack",
  removetrack: "removetrack",
  labelchange: "labelchange"
};
for (const t in Wu.prototype.allowedEvents_)
  Wu.prototype["on" + t] = null;
const e2 = function(t, e) {
  for (let n = 0; n < t.length; n++)
    !Object.keys(t[n]).length || e.id === t[n].id || (t[n].enabled = !1);
};
class a8 extends Wu {
  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  constructor(e = []) {
    for (let n = e.length - 1; n >= 0; n--)
      if (e[n].enabled) {
        e2(e, e[n]);
        break;
      }
    super(e), this.changing_ = !1;
  }
  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    e.enabled && e2(this, e), super.addTrack(e), e.addEventListener && (e.enabledChange_ = () => {
      this.changing_ || (this.changing_ = !0, e2(this, e), this.changing_ = !1, this.trigger("change"));
    }, e.addEventListener("enabledchange", e.enabledChange_));
  }
  removeTrack(e) {
    super.removeTrack(e), e.removeEventListener && e.enabledChange_ && (e.removeEventListener("enabledchange", e.enabledChange_), e.enabledChange_ = null);
  }
}
const t2 = function(t, e) {
  for (let n = 0; n < t.length; n++)
    !Object.keys(t[n]).length || e.id === t[n].id || (t[n].selected = !1);
};
class o8 extends Wu {
  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  constructor(e = []) {
    for (let n = e.length - 1; n >= 0; n--)
      if (e[n].selected) {
        t2(e, e[n]);
        break;
      }
    super(e), this.changing_ = !1, Object.defineProperty(this, "selectedIndex", {
      get() {
        for (let n = 0; n < this.length; n++)
          if (this[n].selected)
            return n;
        return -1;
      },
      set() {
      }
    });
  }
  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    e.selected && t2(this, e), super.addTrack(e), e.addEventListener && (e.selectedChange_ = () => {
      this.changing_ || (this.changing_ = !0, t2(this, e), this.changing_ = !1, this.trigger("change"));
    }, e.addEventListener("selectedchange", e.selectedChange_));
  }
  removeTrack(e) {
    super.removeTrack(e), e.removeEventListener && e.selectedChange_ && (e.removeEventListener("selectedchange", e.selectedChange_), e.selectedChange_ = null);
  }
}
class vT extends Wu {
  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */
  addTrack(e) {
    super.addTrack(e), this.queueChange_ || (this.queueChange_ = () => this.queueTrigger("change")), this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange")), e.addEventListener("modechange", this.queueChange_), ["metadata", "chapters"].indexOf(e.kind) === -1 && e.addEventListener("modechange", this.triggerSelectedlanguagechange_);
  }
  removeTrack(e) {
    super.removeTrack(e), e.removeEventListener && (this.queueChange_ && e.removeEventListener("modechange", this.queueChange_), this.selectedlanguagechange_ && e.removeEventListener("modechange", this.triggerSelectedlanguagechange_));
  }
  /**
   * Creates a serializable array of objects that contains serialized copies
   * of each text track.
   *
   * @return {Object[]} A serializable list of objects for the text track list
   */
  toJSON() {
    return this.tracks_.map((e) => e.toJSON());
  }
}
class Lwe {
  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  constructor(e = []) {
    this.trackElements_ = [], Object.defineProperty(this, "length", {
      get() {
        return this.trackElements_.length;
      }
    });
    for (let n = 0, r = e.length; n < r; n++)
      this.addTrackElement_(e[n]);
  }
  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */
  addTrackElement_(e) {
    const n = this.trackElements_.length;
    "" + n in this || Object.defineProperty(this, n, {
      get() {
        return this.trackElements_[n];
      }
    }), this.trackElements_.indexOf(e) === -1 && this.trackElements_.push(e);
  }
  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */
  getTrackElementByTrack_(e) {
    let n;
    for (let r = 0, i = this.trackElements_.length; r < i; r++)
      if (e === this.trackElements_[r].track) {
        n = this.trackElements_[r];
        break;
      }
    return n;
  }
  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */
  removeTrackElement_(e) {
    for (let n = 0, r = this.trackElements_.length; n < r; n++)
      if (e === this.trackElements_[n]) {
        this.trackElements_[n].track && typeof this.trackElements_[n].track.off == "function" && this.trackElements_[n].track.off(), typeof this.trackElements_[n].off == "function" && this.trackElements_[n].off(), this.trackElements_.splice(n, 1);
        break;
      }
  }
}
class f0 {
  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  constructor(e) {
    f0.prototype.setCues_.call(this, e), Object.defineProperty(this, "length", {
      get() {
        return this.length_;
      }
    });
  }
  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */
  setCues_(e) {
    const n = this.length || 0;
    let r = 0;
    const i = e.length;
    this.cues_ = e, this.length_ = e.length;
    const s = function(a) {
      "" + a in this || Object.defineProperty(this, "" + a, {
        get() {
          return this.cues_[a];
        }
      });
    };
    if (n < i)
      for (r = n; r < i; r++)
        s.call(this, r);
  }
  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */
  getCueById(e) {
    let n = null;
    for (let r = 0, i = this.length; r < i; r++) {
      const s = this[r];
      if (s.id === e) {
        n = s;
        break;
      }
    }
    return n;
  }
}
const Pwe = {
  alternative: "alternative",
  captions: "captions",
  main: "main",
  sign: "sign",
  subtitles: "subtitles",
  commentary: "commentary"
}, Rwe = {
  alternative: "alternative",
  descriptions: "descriptions",
  main: "main",
  "main-desc": "main-desc",
  translation: "translation",
  commentary: "commentary"
}, Bwe = {
  subtitles: "subtitles",
  captions: "captions",
  descriptions: "descriptions",
  chapters: "chapters",
  metadata: "metadata"
}, qx = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
};
class TT extends Gi {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  constructor(e = {}) {
    super();
    const n = {
      id: e.id || "vjs_track_" + fs(),
      kind: e.kind || "",
      language: e.language || ""
    };
    let r = e.label || "";
    for (const i in n)
      Object.defineProperty(this, i, {
        get() {
          return n[i];
        },
        set() {
        }
      });
    Object.defineProperty(this, "label", {
      get() {
        return r;
      },
      set(i) {
        i !== r && (r = i, this.trigger("labelchange"));
      }
    });
  }
}
const _T = function(t) {
  return new URL(t, ot.baseURI);
}, u8 = function(t) {
  return new URL(t, ot.baseURI).href;
}, ET = function(t) {
  if (typeof t == "string") {
    const n = t.split("?")[0].replace(/\/+$/, "").match(/\.([^.\/]+)$/);
    return n ? n[1].toLowerCase() : "";
  }
  return "";
}, Bg = function(t, e = pe.location) {
  return _T(t).origin !== e.origin;
};
var Fwe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  parseUrl: _T,
  getAbsoluteURL: u8,
  getFileExtension: ET,
  isCrossOrigin: Bg
});
const Vx = function(t, e) {
  const n = new pe.WebVTT.Parser(pe, pe.vttjs, pe.WebVTT.StringDecoder()), r = [];
  n.oncue = function(i) {
    e.addCue(i);
  }, n.onparsingerror = function(i) {
    r.push(i);
  }, n.onflush = function() {
    e.trigger({
      type: "loadeddata",
      target: e
    });
  }, n.parse(t), r.length > 0 && (pe.console && pe.console.groupCollapsed && pe.console.groupCollapsed(`Text Track parsing errors for ${e.src}`), r.forEach((i) => Kt.error(i)), pe.console && pe.console.groupEnd && pe.console.groupEnd()), n.flush();
}, Wx = function(t, e) {
  const n = {
    uri: t
  }, r = Bg(t);
  r && (n.cors = r);
  const i = e.tech_.crossOrigin() === "use-credentials";
  i && (n.withCredentials = i), cD(n, Un(this, function(s, a, o) {
    if (s)
      return Kt.error(s, a);
    e.loaded_ = !0, typeof pe.WebVTT != "function" ? e.tech_ && e.tech_.any(["vttjsloaded", "vttjserror"], (u) => {
      if (u.type === "vttjserror") {
        Kt.error(`vttjs failed to load, stopping trying to process ${e.src}`);
        return;
      }
      return Vx(o, e);
    }) : Vx(o, e);
  }));
};
class vh extends TT {
  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        version of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  constructor(e = {}) {
    if (!e.tech)
      throw new Error("A tech was not provided.");
    const n = Dn(e, {
      kind: Bwe[e.kind] || "subtitles",
      language: e.language || e.srclang || ""
    });
    let r = qx[n.mode] || "disabled";
    const i = n.default;
    (n.kind === "metadata" || n.kind === "chapters") && (r = "hidden"), super(n), this.tech_ = n.tech, this.cues_ = [], this.activeCues_ = [], this.preload_ = this.tech_.preloadTextTracks !== !1;
    const s = new f0(this.cues_), a = new f0(this.activeCues_);
    let o = !1;
    this.timeupdateHandler = Un(this, function(c = {}) {
      if (!this.tech_.isDisposed()) {
        if (!this.tech_.isReady_) {
          c.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler));
          return;
        }
        this.activeCues = this.activeCues, o && (this.trigger("cuechange"), o = !1), c.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler));
      }
    });
    const u = () => {
      this.stopTracking();
    };
    this.tech_.one("dispose", u), r !== "disabled" && this.startTracking(), Object.defineProperties(this, {
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      default: {
        get() {
          return i;
        },
        set() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get() {
          return r;
        },
        set(c) {
          qx[c] && r !== c && (r = c, !this.preload_ && r !== "disabled" && this.cues.length === 0 && Wx(this.src, this), this.stopTracking(), r !== "disabled" && this.startTracking(), this.trigger("modechange"));
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get() {
          return this.loaded_ ? s : null;
        },
        set() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get() {
          if (!this.loaded_)
            return null;
          if (this.cues.length === 0)
            return a;
          const c = this.tech_.currentTime(), d = [];
          for (let l = 0, f = this.cues.length; l < f; l++) {
            const p = this.cues[l];
            p.startTime <= c && p.endTime >= c && d.push(p);
          }
          if (o = !1, d.length !== this.activeCues_.length)
            o = !0;
          else
            for (let l = 0; l < d.length; l++)
              this.activeCues_.indexOf(d[l]) === -1 && (o = !0);
          return this.activeCues_ = d, a.setCues_(this.activeCues_), a;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set() {
        }
      }
    }), n.src ? (this.src = n.src, this.preload_ || (this.loaded_ = !0), (this.preload_ || n.kind !== "subtitles" && n.kind !== "captions") && Wx(this.src, this)) : this.loaded_ = !0;
  }
  startTracking() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler), this.tech_.on("timeupdate", this.timeupdateHandler);
  }
  stopTracking() {
    this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_), this.rvf_ = void 0), this.tech_.off("timeupdate", this.timeupdateHandler);
  }
  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */
  addCue(e) {
    let n = e;
    if (!("getCueAsHTML" in n)) {
      n = new pe.vttjs.VTTCue(e.startTime, e.endTime, e.text);
      for (const i in e)
        i in n || (n[i] = e[i]);
      n.id = e.id, n.originalCue_ = e;
    }
    const r = this.tech_.textTracks();
    for (let i = 0; i < r.length; i++)
      r[i] !== this && r[i].removeCue(n);
    this.cues_.push(n), this.cues.setCues_(this.cues_);
  }
  /**
   * Creates a copy of the text track and makes it serializable
   * by removing circular dependencies.
   *
   * @return {Object} The track information as a serializable object
   */
  toJSON() {
    return ey.trackToJson(this);
  }
  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */
  removeCue(e) {
    let n = this.cues_.length;
    for (; n--; ) {
      const r = this.cues_[n];
      if (r === e || r.originalCue_ && r.originalCue_ === e) {
        this.cues_.splice(n, 1), this.cues.setCues_(this.cues_);
        break;
      }
    }
  }
}
vh.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
class l8 extends TT {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  constructor(e = {}) {
    const n = Dn(e, {
      kind: Rwe[e.kind] || ""
    });
    super(n);
    let r = !1;
    Object.defineProperty(this, "enabled", {
      get() {
        return r;
      },
      set(i) {
        typeof i != "boolean" || i === r || (r = i, this.trigger("enabledchange"));
      }
    }), n.enabled && (this.enabled = n.enabled), this.loaded_ = !0;
  }
}
class c8 extends TT {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  constructor(e = {}) {
    const n = Dn(e, {
      kind: Pwe[e.kind] || ""
    });
    super(n);
    let r = !1;
    Object.defineProperty(this, "selected", {
      get() {
        return r;
      },
      set(i) {
        typeof i != "boolean" || i === r || (r = i, this.trigger("selectedchange"));
      }
    }), n.selected && (this.selected = n.selected);
  }
}
class qa extends Gi {
  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        version of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  constructor(e = {}) {
    super();
    let n;
    const r = new vh(e);
    this.kind = r.kind, this.src = r.src, this.srclang = r.language, this.label = r.label, this.default = r.default, Object.defineProperties(this, {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get() {
          return n;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get() {
          return r;
        }
      }
    }), n = qa.NONE, r.addEventListener("loadeddata", () => {
      n = qa.LOADED, this.trigger({
        type: "load",
        target: this
      });
    });
  }
}
qa.prototype.allowedEvents_ = {
  load: "load"
};
qa.NONE = 0;
qa.LOADING = 1;
qa.LOADED = 2;
qa.ERROR = 3;
const as = {
  audio: {
    ListClass: a8,
    TrackClass: l8,
    capitalName: "Audio"
  },
  video: {
    ListClass: o8,
    TrackClass: c8,
    capitalName: "Video"
  },
  text: {
    ListClass: vT,
    TrackClass: vh,
    capitalName: "Text"
  }
};
Object.keys(as).forEach(function(t) {
  as[t].getterName = `${t}Tracks`, as[t].privateName = `${t}Tracks_`;
});
const gc = {
  remoteText: {
    ListClass: vT,
    TrackClass: vh,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: Lwe,
    TrackClass: qa,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
}, ci = Object.assign({}, as, gc);
gc.names = Object.keys(gc);
as.names = Object.keys(as);
ci.names = [].concat(gc.names).concat(as.names);
function Uwe(t, e, n, r, i = {}) {
  const s = t.textTracks();
  i.kind = e, n && (i.label = n), r && (i.language = r), i.tech = t;
  const a = new ci.text.TrackClass(i);
  return s.addTrack(a), a;
}
class Ht extends He {
  /**
  * Create an instance of this Tech.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  *
  * @param {Function} [ready]
  *        Callback function to call when the `HTML5` Tech is ready.
  */
  constructor(e = {}, n = function() {
  }) {
    e.reportTouchActivity = !1, super(null, e, n), this.onDurationChange_ = (r) => this.onDurationChange(r), this.trackProgress_ = (r) => this.trackProgress(r), this.trackCurrentTime_ = (r) => this.trackCurrentTime(r), this.stopTrackingCurrentTime_ = (r) => this.stopTrackingCurrentTime(r), this.disposeSourceHandler_ = (r) => this.disposeSourceHandler(r), this.queuedHanders_ = /* @__PURE__ */ new Set(), this.hasStarted_ = !1, this.on("playing", function() {
      this.hasStarted_ = !0;
    }), this.on("loadstart", function() {
      this.hasStarted_ = !1;
    }), ci.names.forEach((r) => {
      const i = ci[r];
      e && e[i.getterName] && (this[i.privateName] = e[i.getterName]);
    }), this.featuresProgressEvents || this.manualProgressOn(), this.featuresTimeupdateEvents || this.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach((r) => {
      e[`native${r}Tracks`] === !1 && (this[`featuresNative${r}Tracks`] = !1);
    }), e.nativeCaptions === !1 || e.nativeTextTracks === !1 ? this.featuresNativeTextTracks = !1 : (e.nativeCaptions === !0 || e.nativeTextTracks === !0) && (this.featuresNativeTextTracks = !0), this.featuresNativeTextTracks || this.emulateTextTracks(), this.preloadTextTracks = e.preloadTextTracks !== !1, this.autoRemoteTextTracks_ = new ci.text.ListClass(), this.initTrackListeners(), e.nativeControlsForTouch || this.emitTapEvents(), this.constructor && (this.name_ = this.constructor.name || "Unknown Tech");
  }
  /**
   * A special function to trigger source set in a way that will allow player
   * to re-trigger if the player or tech are not ready yet.
   *
   * @fires Tech#sourceset
   * @param {string} src The source string at the time of the source changing.
   */
  triggerSourceset(e) {
    this.isReady_ || this.one("ready", () => this.setTimeout(() => this.triggerSourceset(e), 1)), this.trigger({
      src: e,
      type: "sourceset"
    });
  }
  /* Fallbacks for unsupported event types
  ================================================================================ */
  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */
  manualProgressOn() {
    this.on("durationchange", this.onDurationChange_), this.manualProgress = !0, this.one("ready", this.trackProgress_);
  }
  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */
  manualProgressOff() {
    this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange_);
  }
  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */
  trackProgress(e) {
    this.stopTrackingProgress(), this.progressInterval = this.setInterval(Un(this, function() {
      const n = this.bufferedPercent();
      this.bufferedPercent_ !== n && this.trigger("progress"), this.bufferedPercent_ = n, n === 1 && this.stopTrackingProgress();
    }), 500);
  }
  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */
  onDurationChange(e) {
    this.duration_ = this.duration();
  }
  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */
  buffered() {
    return Ds(0, 0);
  }
  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */
  bufferedPercent() {
    return s8(this.buffered(), this.duration_);
  }
  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */
  stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  }
  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */
  manualTimeUpdatesOn() {
    this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime_), this.on("pause", this.stopTrackingCurrentTime_);
  }
  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */
  manualTimeUpdatesOff() {
    this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime_), this.off("pause", this.stopTrackingCurrentTime_);
  }
  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */
  trackCurrentTime() {
    this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: !0
      });
    }, 250);
  }
  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */
  stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval), this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    });
  }
  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */
  dispose() {
    this.clearTracks(as.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), super.dispose();
  }
  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */
  clearTracks(e) {
    e = [].concat(e), e.forEach((n) => {
      const r = this[`${n}Tracks`]() || [];
      let i = r.length;
      for (; i--; ) {
        const s = r[i];
        n === "text" && this.removeRemoteTextTrack(s), r.removeTrack(s);
      }
    });
  }
  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */
  cleanupAutoTextTracks() {
    const e = this.autoRemoteTextTracks_ || [];
    let n = e.length;
    for (; n--; ) {
      const r = e[n];
      this.removeRemoteTextTrack(r);
    }
  }
  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */
  reset() {
  }
  /**
   * Get the value of `crossOrigin` from the tech.
   *
   * @abstract
   *
   * @see {Html5#crossOrigin}
   */
  crossOrigin() {
  }
  /**
   * Set the value of `crossOrigin` on the tech.
   *
   * @abstract
   *
   * @param {string} crossOrigin the crossOrigin value
   * @see {Html5#setCrossOrigin}
   */
  setCrossOrigin() {
  }
  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */
  error(e) {
    return e !== void 0 && (this.error_ = new nr(e), this.trigger("error")), this.error_;
  }
  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks whether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */
  played() {
    return this.hasStarted_ ? Ds(0, 0) : Ds();
  }
  /**
   * Start playback
   *
   * @abstract
   *
   * @see {Html5#play}
   */
  play() {
  }
  /**
   * Set whether we are scrubbing or not
   *
   * @abstract
   * @param {boolean} _isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   *
   * @see {Html5#setScrubbing}
   */
  setScrubbing(e) {
  }
  /**
   * Get whether we are scrubbing or not
   *
   * @abstract
   *
   * @see {Html5#scrubbing}
   */
  scrubbing() {
  }
  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @param {number} _seconds
   *        Set the current time of the media to this.
   * @fires Tech#timeupdate
   */
  setCurrentTime(e) {
    this.manualTimeUpdates && this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    });
  }
  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */
  initTrackListeners() {
    as.names.forEach((e) => {
      const n = as[e], r = () => {
        this.trigger(`${e}trackchange`);
      }, i = this[n.getterName]();
      i.addEventListener("removetrack", r), i.addEventListener("addtrack", r), this.on("dispose", () => {
        i.removeEventListener("removetrack", r), i.removeEventListener("addtrack", r);
      });
    });
  }
  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */
  addWebVttScript_() {
    if (!pe.WebVTT)
      if (ot.body.contains(this.el())) {
        if (!this.options_["vtt.js"] && fc(gx) && Object.keys(gx).length > 0) {
          this.trigger("vttjsloaded");
          return;
        }
        const e = ot.createElement("script");
        e.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", e.onload = () => {
          this.trigger("vttjsloaded");
        }, e.onerror = () => {
          this.trigger("vttjserror");
        }, this.on("dispose", () => {
          e.onload = null, e.onerror = null;
        }), pe.WebVTT = !0, this.el().parentNode.appendChild(e);
      } else
        this.ready(this.addWebVttScript_);
  }
  /**
   * Emulate texttracks
   *
   */
  emulateTextTracks() {
    const e = this.textTracks(), n = this.remoteTextTracks(), r = (o) => e.addTrack(o.track), i = (o) => e.removeTrack(o.track);
    n.on("addtrack", r), n.on("removetrack", i), this.addWebVttScript_();
    const s = () => this.trigger("texttrackchange"), a = () => {
      s();
      for (let o = 0; o < e.length; o++) {
        const u = e[o];
        u.removeEventListener("cuechange", s), u.mode === "showing" && u.addEventListener("cuechange", s);
      }
    };
    a(), e.addEventListener("change", a), e.addEventListener("addtrack", a), e.addEventListener("removetrack", a), this.on("dispose", function() {
      n.off("addtrack", r), n.off("removetrack", i), e.removeEventListener("change", a), e.removeEventListener("addtrack", a), e.removeEventListener("removetrack", a);
      for (let o = 0; o < e.length; o++)
        e[o].removeEventListener("cuechange", s);
    });
  }
  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */
  addTextTrack(e, n, r) {
    if (!e)
      throw new Error("TextTrack kind is required but was not provided");
    return Uwe(this, e, n, r);
  }
  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */
  createRemoteTextTrack(e) {
    const n = Dn(e, {
      tech: this
    });
    return new gc.remoteTextEl.TrackClass(n);
  }
  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=false]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   */
  addRemoteTextTrack(e = {}, n) {
    const r = this.createRemoteTextTrack(e);
    return typeof n != "boolean" && (n = !1), this.remoteTextTrackEls().addTrackElement_(r), this.remoteTextTracks().addTrack(r.track), n === !1 && this.ready(() => this.autoRemoteTextTracks_.addTrack(r.track)), r;
  }
  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */
  removeRemoteTextTrack(e) {
    const n = this.remoteTextTrackEls().getTrackElementByTrack_(e);
    this.remoteTextTrackEls().removeTrackElement_(n), this.remoteTextTracks().removeTrack(e), this.autoRemoteTextTracks_.removeTrack(e);
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */
  getVideoPlaybackQuality() {
    return {};
  }
  /**
   * Attempt to create a floating video window always on top of other windows
   * so that users may continue consuming media while they interact with other
   * content sites, or applications on their device.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @return {Promise|undefined}
   *         A promise with a Picture-in-Picture window if the browser supports
   *         Promises (or one was passed in as an option). It returns undefined
   *         otherwise.
   *
   * @abstract
   */
  requestPictureInPicture() {
    return Promise.reject();
  }
  /**
   * A method to check for the value of the 'disablePictureInPicture' <video> property.
   * Defaults to true, as it should be considered disabled if the tech does not support pip
   *
   * @abstract
   */
  disablePictureInPicture() {
    return !0;
  }
  /**
   * A method to set or unset the 'disablePictureInPicture' <video> property.
   *
   * @abstract
   */
  setDisablePictureInPicture() {
  }
  /**
   * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame
   *
   * @param {function} cb
   * @return {number} request id
   */
  requestVideoFrameCallback(e) {
    const n = fs();
    return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(n), this.one("playing", () => {
      this.queuedHanders_.has(n) && (this.queuedHanders_.delete(n), e());
    })) : this.requestNamedAnimationFrame(n, e), n;
  }
  /**
   * A fallback implementation of cancelVideoFrameCallback
   *
   * @param {number} id id of callback to be cancelled
   */
  cancelVideoFrameCallback(e) {
    this.queuedHanders_.has(e) ? this.queuedHanders_.delete(e) : this.cancelNamedAnimationFrame(e);
  }
  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */
  setPoster() {
  }
  /**
   * A method to check for the presence of the 'playsinline' <video> attribute.
   *
   * @abstract
   */
  playsinline() {
  }
  /**
   * A method to set or unset the 'playsinline' <video> attribute.
   *
   * @abstract
   */
  setPlaysinline() {
  }
  /**
   * Attempt to force override of native audio tracks.
   *
   * @param {boolean} override - If set to true native audio will be overridden,
   * otherwise native audio will potentially be used.
   *
   * @abstract
   */
  overrideNativeAudioTracks(e) {
  }
  /**
   * Attempt to force override of native video tracks.
   *
   * @param {boolean} override - If set to true native video will be overridden,
   * otherwise native video will potentially be used.
   *
   * @abstract
   */
  overrideNativeVideoTracks(e) {
  }
  /**
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} _type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */
  canPlayType(e) {
    return "";
  }
  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} _type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */
  static canPlayType(e) {
    return "";
  }
  /**
   * Check if the tech can support the given source
   *
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */
  static canPlaySource(e, n) {
    return Ht.canPlayType(e.type);
  }
  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */
  static isTech(e) {
    return e.prototype instanceof Ht || e instanceof Ht || e === Ht;
  }
  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */
  static registerTech(e, n) {
    if (Ht.techs_ || (Ht.techs_ = {}), !Ht.isTech(n))
      throw new Error(`Tech ${e} must be a Tech`);
    if (!Ht.canPlayType)
      throw new Error("Techs must have a static canPlayType method on them");
    if (!Ht.canPlaySource)
      throw new Error("Techs must have a static canPlaySource method on them");
    return e = or(e), Ht.techs_[e] = n, Ht.techs_[Af(e)] = n, e !== "Tech" && Ht.defaultTechOrder_.push(e), n;
  }
  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requested.
   */
  static getTech(e) {
    if (e) {
      if (Ht.techs_ && Ht.techs_[e])
        return Ht.techs_[e];
      if (e = or(e), pe && pe.videojs && pe.videojs[e])
        return Kt.warn(`The ${e} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`), pe.videojs[e];
    }
  }
}
ci.names.forEach(function(t) {
  const e = ci[t];
  Ht.prototype[e.getterName] = function() {
    return this[e.privateName] = this[e.privateName] || new e.ListClass(), this[e.privateName];
  };
});
Ht.prototype.featuresVolumeControl = !0;
Ht.prototype.featuresMuteControl = !0;
Ht.prototype.featuresFullscreenResize = !1;
Ht.prototype.featuresPlaybackRate = !1;
Ht.prototype.featuresProgressEvents = !1;
Ht.prototype.featuresSourceset = !1;
Ht.prototype.featuresTimeupdateEvents = !1;
Ht.prototype.featuresNativeTextTracks = !1;
Ht.prototype.featuresVideoFrameCallback = !1;
Ht.withSourceHandlers = function(t) {
  t.registerSourceHandler = function(n, r) {
    let i = t.sourceHandlers;
    i || (i = t.sourceHandlers = []), r === void 0 && (r = i.length), i.splice(r, 0, n);
  }, t.canPlayType = function(n) {
    const r = t.sourceHandlers || [];
    let i;
    for (let s = 0; s < r.length; s++)
      if (i = r[s].canPlayType(n), i)
        return i;
    return "";
  }, t.selectSourceHandler = function(n, r) {
    const i = t.sourceHandlers || [];
    let s;
    for (let a = 0; a < i.length; a++)
      if (s = i[a].canHandleSource(n, r), s)
        return i[a];
    return null;
  }, t.canPlaySource = function(n, r) {
    const i = t.selectSourceHandler(n, r);
    return i ? i.canHandleSource(n, r) : "";
  }, ["seekable", "seeking", "duration"].forEach(function(n) {
    const r = this[n];
    typeof r == "function" && (this[n] = function() {
      return this.sourceHandler_ && this.sourceHandler_[n] ? this.sourceHandler_[n].apply(this.sourceHandler_, arguments) : r.apply(this, arguments);
    });
  }, t.prototype), t.prototype.setSource = function(n) {
    let r = t.selectSourceHandler(n, this.options_);
    r || (t.nativeSourceHandler ? r = t.nativeSourceHandler : Kt.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler_), r !== t.nativeSourceHandler && (this.currentSource_ = n), this.sourceHandler_ = r.handleSource(n, this, this.options_), this.one("dispose", this.disposeSourceHandler_);
  }, t.prototype.disposeSourceHandler = function() {
    this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null);
  };
};
He.registerComponent("Tech", Ht);
Ht.registerTech("Tech", Ht);
Ht.defaultTechOrder_ = [];
const ku = {}, h0 = {}, p0 = {};
function $we(t, e) {
  ku[t] = ku[t] || [], ku[t].push(e);
}
function Hwe(t, e, n) {
  t.setTimeout(() => au(e, ku[e.type], n, t), 1);
}
function jwe(t, e) {
  t.forEach((n) => n.setTech && n.setTech(e));
}
function zwe(t, e, n) {
  return t.reduceRight(xT(n), e[n]());
}
function qwe(t, e, n, r) {
  return e[n](t.reduce(xT(n), r));
}
function Qx(t, e, n, r = null) {
  const i = "call" + or(n), s = t.reduce(xT(i), r), a = s === p0, o = a ? null : e[n](s);
  return Qwe(t, n, o, a), o;
}
const Vwe = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  muted: 1,
  played: 1,
  paused: 1,
  seekable: 1,
  volume: 1,
  ended: 1
}, Wwe = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
}, Gx = {
  play: 1,
  pause: 1
};
function xT(t) {
  return (e, n) => e === p0 ? p0 : n[t] ? n[t](e) : e;
}
function Qwe(t, e, n, r) {
  for (let i = t.length - 1; i >= 0; i--) {
    const s = t[i];
    s[e] && s[e](r, n);
  }
}
function Gwe(t) {
  h0.hasOwnProperty(t.id()) && delete h0[t.id()];
}
function Ywe(t, e) {
  const n = h0[t.id()];
  let r = null;
  if (n == null)
    return r = e(t), h0[t.id()] = [[e, r]], r;
  for (let i = 0; i < n.length; i++) {
    const [s, a] = n[i];
    s === e && (r = a);
  }
  return r === null && (r = e(t), n.push([e, r])), r;
}
function au(t = {}, e = [], n, r, i = [], s = !1) {
  const [a, ...o] = e;
  if (typeof a == "string")
    au(t, ku[a], n, r, i, s);
  else if (a) {
    const u = Ywe(r, a);
    if (!u.setSource)
      return i.push(u), au(t, o, n, r, i, s);
    u.setSource(Object.assign({}, t), function(c, d) {
      if (c)
        return au(t, o, n, r, i, s);
      i.push(u), au(d, t.type === d.type ? o : ku[d.type], n, r, i, s);
    });
  } else o.length ? au(t, o, n, r, i, s) : s ? n(t, i) : au(t, ku["*"], n, r, i, !0);
}
const Xwe = {
  opus: "video/ogg",
  ogv: "video/ogg",
  mp4: "video/mp4",
  mov: "video/mp4",
  m4v: "video/mp4",
  mkv: "video/x-matroska",
  m4a: "audio/mp4",
  mp3: "audio/mpeg",
  aac: "audio/aac",
  caf: "audio/x-caf",
  flac: "audio/flac",
  oga: "audio/ogg",
  wav: "audio/wav",
  m3u8: "application/x-mpegURL",
  mpd: "application/dash+xml",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  png: "image/png",
  svg: "image/svg+xml",
  webp: "image/webp"
}, m0 = function(t = "") {
  const e = ET(t);
  return Xwe[e.toLowerCase()] || "";
}, Kwe = (t, e) => {
  if (!e)
    return "";
  if (t.cache_.source.src === e && t.cache_.source.type)
    return t.cache_.source.type;
  const n = t.cache_.sources.filter((i) => i.src === e);
  if (n.length)
    return n[0].type;
  const r = t.$$("source");
  for (let i = 0; i < r.length; i++) {
    const s = r[i];
    if (s.type && s.src && s.src === e)
      return s.type;
  }
  return m0(e);
}, d8 = function(t) {
  if (Array.isArray(t)) {
    let e = [];
    t.forEach(function(n) {
      n = d8(n), Array.isArray(n) ? e = e.concat(n) : fa(n) && e.push(n);
    }), t = e;
  } else typeof t == "string" && t.trim() ? t = [Yx({
    src: t
  })] : fa(t) && typeof t.src == "string" && t.src && t.src.trim() ? t = [Yx(t)] : t = [];
  return t;
};
function Yx(t) {
  if (!t.type) {
    const e = m0(t.src);
    e && (t.type = e);
  }
  return t;
}
var Zwe = `<svg xmlns="http://www.w3.org/2000/svg">
  <defs>
    <symbol viewBox="0 0 48 48" id="vjs-icon-play">
      <path d="M16 10v28l22-14z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-pause">
      <path d="M12 38h8V10h-8v28zm16-28v28h8V10h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-audio">
      <path d="M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-captions">
      <path d="M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-subtitles">
      <path d="M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-enter">
      <path d="M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-exit">
      <path d="M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-play-circle">
      <path d="M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-mute">
      <path d="M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-low">
      <path d="M14 18v12h8l10 10V8L22 18h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-medium">
      <path d="M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-high">
      <path d="M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-spinner">
      <path d="M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z"></path>
    </symbol>
    <symbol viewBox="0 0 24 24" id="vjs-icon-hd">
      <path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-chapters">
      <path d="M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z"></path>
    </symbol>
    <symbol viewBox="0 0 40 40" id="vjs-icon-downloading">
      <path d="M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download">
      <path d="M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-done">
      <path d="M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-off">
      <path d="M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-share">
      <path d="M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cog">
      <path d="M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-square">
      <path d="M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle">
      <circle cx="24" cy="24" r="20"></circle>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-outline">
      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-inner-circle">
      <path d="M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cancel">
      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-replay">
      <path d="M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-repeat">
      <path d="M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-5">
      <path d="M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-10">
      <path d="M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-30">
      <path d="M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-5">
      <path d="M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-10">
      <path d="M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-30">
      <path d="M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z"></path>
    </symbol>
    <symbol viewBox="0 0 512 512" id="vjs-icon-audio-description">
      <g fill-rule="evenodd"><path d="M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57"></path><path d="M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z"></path></g>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-next-item">
      <path d="M12 36l17-12-17-12v24zm20-24v24h4V12h-4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-previous-item">
      <path d="M12 12h4v24h-4zm7 12l17 12V12z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-shuffle">
      <path d="M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cast">
      <path d="M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-picture-in-picture-enter">
      <path d="M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z"></path>
    </symbol>
    <symbol viewBox="0 0 22 18" id="vjs-icon-picture-in-picture-exit">
      <path d="M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z"></path>
      <path fill="none" d="M-1-3h24v24H-1z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-facebook">
      <path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-linkedin">
      <path d="M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z"></path>
    </symbol>
    <symbol viewBox="0 0 1200 1227" id="vjs-icon-twitter">
      <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.854V687.828Z"/>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-tumblr">
      <path d="M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-pinterest">
      <path d="M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z"></path>
    </symbol>
  </defs>
</svg>`;
const Xx = u0 ? 10009 : l0 ? 461 : 8, Cl = {
  codes: {
    play: 415,
    pause: 19,
    ff: 417,
    rw: 412,
    back: Xx
  },
  names: {
    415: "play",
    19: "pause",
    417: "ff",
    412: "rw",
    [Xx]: "back"
  },
  isEventKey(t, e) {
    return e = e.toLowerCase(), !!(this.names[t.keyCode] && this.names[t.keyCode] === e);
  },
  getEventName(t) {
    if (this.names[t.keyCode])
      return this.names[t.keyCode];
    if (this.codes[t.code]) {
      const e = this.codes[t.code];
      return this.names[e];
    }
    return null;
  }
}, Kx = 5;
class Jwe extends Gi {
  /**
   * Constructs a SpatialNavigation instance with initial settings.
   * Sets up the player instance, and prepares the spatial navigation system.
   *
   * @class
   * @param {Player} player - The Video.js player instance to which the spatial navigation is attached.
   */
  constructor(e) {
    super(), this.player_ = e, this.focusableComponents = [], this.isListening_ = !1, this.isPaused_ = !1, this.onKeyDown_ = this.onKeyDown_.bind(this), this.lastFocusedComponent_ = null;
  }
  /**
   * Starts the spatial navigation by adding a keydown event listener to the video container.
   * This method ensures that the event listener is added only once.
   */
  start() {
    this.isListening_ || (this.player_.on("keydown", this.onKeyDown_), this.player_.on("modalKeydown", this.onKeyDown_), this.player_.on("loadedmetadata", () => {
      this.focus(this.updateFocusableComponents()[0]);
    }), this.player_.on("modalclose", () => {
      this.refocusComponent();
    }), this.player_.on("focusin", this.handlePlayerFocus_.bind(this)), this.player_.on("focusout", this.handlePlayerBlur_.bind(this)), this.isListening_ = !0, this.player_.errorDisplay && this.player_.errorDisplay.on("aftermodalfill", () => {
      this.updateFocusableComponents(), this.focusableComponents.length && (this.focusableComponents.length > 1 ? this.focusableComponents[1].focus() : this.focusableComponents[0].focus());
    }));
  }
  /**
   * Stops the spatial navigation by removing the keydown event listener from the video container.
   * Also sets the `isListening_` flag to false.
   */
  stop() {
    this.player_.off("keydown", this.onKeyDown_), this.isListening_ = !1;
  }
  /**
   * Responds to keydown events for spatial navigation and media control.
   *
   * Determines if spatial navigation or media control is active and handles key inputs accordingly.
   *
   * @param {KeyboardEvent} event - The keydown event to be handled.
   */
  onKeyDown_(e) {
    const n = e.originalEvent ? e.originalEvent : e;
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(n.key)) {
      if (this.isPaused_)
        return;
      n.preventDefault();
      const r = n.key.substring(5).toLowerCase();
      this.move(r);
    } else if (Cl.isEventKey(n, "play") || Cl.isEventKey(n, "pause") || Cl.isEventKey(n, "ff") || Cl.isEventKey(n, "rw")) {
      n.preventDefault();
      const r = Cl.getEventName(n);
      this.performMediaAction_(r);
    } else Cl.isEventKey(n, "Back") && e.target && typeof e.target.closeable == "function" && e.target.closeable() && (n.preventDefault(), e.target.close());
  }
  /**
   * Performs media control actions based on the given key input.
   *
   * Controls the playback and seeking functionalities of the media player.
   *
   * @param {string} key - The key representing the media action to be performed.
   *   Accepted keys: 'play', 'pause', 'ff' (fast-forward), 'rw' (rewind).
   */
  performMediaAction_(e) {
    if (this.player_)
      switch (e) {
        case "play":
          this.player_.paused() && this.player_.play();
          break;
        case "pause":
          this.player_.paused() || this.player_.pause();
          break;
        case "ff":
          this.userSeek_(this.player_.currentTime() + Kx);
          break;
        case "rw":
          this.userSeek_(this.player_.currentTime() - Kx);
          break;
      }
  }
  /**
   * Prevent liveThreshold from causing seeks to seem like they
   * are not happening from a user perspective.
   *
   * @param {number} ct
   *        current time to seek to
   */
  userSeek_(e) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(e);
  }
  /**
   * Pauses the spatial navigation functionality.
   * This method sets a flag that can be used to temporarily disable the navigation logic.
   */
  pause() {
    this.isPaused_ = !0;
  }
  /**
   * Resumes the spatial navigation functionality if it has been paused.
   * This method resets the pause flag, re-enabling the navigation logic.
   */
  resume() {
    this.isPaused_ = !1;
  }
  /**
   * Handles Player Blur.
   *
   * @param {string|Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   *
   * Calls for handling of the Player Blur if:
   * *The next focused element is not a child of current focused element &
   * The next focused element is not a child of the Player.
   * *There is no next focused element
   */
  handlePlayerBlur_(e) {
    const n = e.relatedTarget;
    let r = null;
    const i = this.getCurrentComponent(e.target);
    n && (r = !!n.closest(".video-js"), n.classList.contains("vjs-text-track-settings") && !this.isPaused_ && this.searchForTrackSelect_()), (!e.currentTarget.contains(e.relatedTarget) && !r || !n) && (i && i.name() === "CloseButton" ? this.refocusComponent() : (this.pause(), i && i.el() && (this.lastFocusedComponent_ = i)));
  }
  /**
   * Handles the Player focus event.
   *
   * Calls for handling of the Player Focus if current element is focusable.
   */
  handlePlayerFocus_() {
    this.getCurrentComponent() && this.getCurrentComponent().getIsFocusable() && this.resume();
  }
  /**
   * Gets a set of focusable components.
   *
   * @return {Array}
   *         Returns an array of focusable components.
   */
  updateFocusableComponents() {
    const e = this.player_, n = [];
    function r(i) {
      for (const s of i)
        s.hasOwnProperty("el_") && s.getIsFocusable() && s.getIsAvailableToBeFocused(s.el()) && n.push(s), s.hasOwnProperty("children_") && s.children_.length > 0 && r(s.children_);
    }
    return e.children_.forEach((i) => {
      if (i.hasOwnProperty("el_"))
        if (i.getIsFocusable && i.getIsAvailableToBeFocused && i.getIsFocusable() && i.getIsAvailableToBeFocused(i.el())) {
          n.push(i);
          return;
        } else i.hasOwnProperty("children_") && i.children_.length > 0 ? r(i.children_) : i.hasOwnProperty("items") && i.items.length > 0 ? r(i.items) : this.findSuitableDOMChild(i) && n.push(i);
      if (i.name_ === "ErrorDisplay" && i.opened_) {
        const s = i.el_.querySelector(".vjs-errors-ok-button-container");
        s && s.querySelectorAll("button").forEach((o, u) => {
          n.push({
            name: () => "ModalButton" + (u + 1),
            el: () => o,
            getPositions: () => {
              const c = o.getBoundingClientRect(), d = {
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height,
                top: c.top,
                right: c.right,
                bottom: c.bottom,
                left: c.left
              }, l = {
                x: c.left + c.width / 2,
                y: c.top + c.height / 2,
                width: 0,
                height: 0,
                top: c.top + c.height / 2,
                right: c.left + c.width / 2,
                bottom: c.top + c.height / 2,
                left: c.left + c.width / 2
              };
              return {
                boundingClientRect: d,
                center: l
              };
            },
            // Asume that the following are always focusable
            getIsAvailableToBeFocused: () => !0,
            getIsFocusable: (c) => !0,
            focus: () => o.focus()
          });
        });
      }
    }), this.focusableComponents = n, this.focusableComponents;
  }
  /**
   * Finds a suitable child element within the provided component's DOM element.
   *
   * @param {Object} component - The component containing the DOM element to search within.
   * @return {HTMLElement|null} Returns the suitable child element if found, or null if not found.
   */
  findSuitableDOMChild(e) {
    function n(r) {
      if (e.getIsFocusable(r) && e.getIsAvailableToBeFocused(r))
        return r;
      for (let i = 0; i < r.children.length; i++) {
        const s = r.children[i], a = n(s);
        if (a)
          return a;
      }
      return null;
    }
    return e.el() ? n(e.el()) : null;
  }
  /**
   * Gets the currently focused component from the list of focusable components.
   * If a target element is provided, it uses that element to find the corresponding
   * component. If no target is provided, it defaults to using the document's currently
   * active element.
   *
   * @param {HTMLElement} [target] - The DOM element to check against the focusable components.
   *                                 If not provided, `document.activeElement` is used.
   * @return {Component|null} - Returns the focused component if found among the focusable components,
   *                            otherwise returns null if no matching component is found.
   */
  getCurrentComponent(e) {
    this.updateFocusableComponents();
    const n = e || document.activeElement;
    if (this.focusableComponents.length) {
      for (const r of this.focusableComponents)
        if (r.el() === n)
          return r;
    }
  }
  /**
   * Adds a component to the array of focusable components.
   *
   * @param {Component} component
   *        The `Component` to be added.
   */
  add(e) {
    const n = [...this.focusableComponents];
    e.hasOwnProperty("el_") && e.getIsFocusable() && e.getIsAvailableToBeFocused(e.el()) && n.push(e), this.focusableComponents = n, this.trigger({
      type: "focusableComponentsChanged",
      focusableComponents: this.focusableComponents
    });
  }
  /**
   * Removes component from the array of focusable components.
   *
   * @param {Component} component - The component to be removed from the focusable components array.
   */
  remove(e) {
    for (let n = 0; n < this.focusableComponents.length; n++)
      if (this.focusableComponents[n].name() === e.name()) {
        this.focusableComponents.splice(n, 1), this.trigger({
          type: "focusableComponentsChanged",
          focusableComponents: this.focusableComponents
        });
        return;
      }
  }
  /**
   * Clears array of focusable components.
   */
  clear() {
    this.focusableComponents.length > 0 && (this.focusableComponents = [], this.trigger({
      type: "focusableComponentsChanged",
      focusableComponents: this.focusableComponents
    }));
  }
  /**
   * Navigates to the next focusable component based on the specified direction.
   *
   * @param {string} direction 'up', 'down', 'left', 'right'
   */
  move(e) {
    const n = this.getCurrentComponent();
    if (!n)
      return;
    const r = n.getPositions(), i = this.focusableComponents.filter((a) => a !== n && this.isInDirection_(r.boundingClientRect, a.getPositions().boundingClientRect, e)), s = this.findBestCandidate_(r.center, i, e);
    s ? this.focus(s) : this.trigger({
      type: "endOfFocusableComponents",
      direction: e,
      focusedComponent: n
    });
  }
  /**
   * Finds the best candidate on the current center position,
   * the list of candidates, and the specified navigation direction.
   *
   * @param {Object} currentCenter The center position of the current focused component element.
   * @param {Array} candidates An array of candidate components to receive focus.
   * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
   * @return {Object|null} The component that is the best candidate for receiving focus.
   */
  findBestCandidate_(e, n, r) {
    let i = 1 / 0, s = null;
    for (const a of n) {
      const o = a.getPositions().center, u = this.calculateDistance_(e, o, r);
      u < i && (i = u, s = a);
    }
    return s;
  }
  /**
   * Determines if a target rectangle is in the specified navigation direction
   * relative to a source rectangle.
   *
   * @param {Object} srcRect The bounding rectangle of the source element.
   * @param {Object} targetRect The bounding rectangle of the target element.
   * @param {string} direction The navigation direction ('up', 'down', 'left', 'right').
   * @return {boolean} True if the target is in the specified direction relative to the source.
   */
  isInDirection_(e, n, r) {
    switch (r) {
      case "right":
        return n.left >= e.right;
      case "left":
        return n.right <= e.left;
      case "down":
        return n.top >= e.bottom;
      case "up":
        return n.bottom <= e.top;
      default:
        return !1;
    }
  }
  /**
   * Focus the last focused component saved before blur on player.
   */
  refocusComponent() {
    if (this.lastFocusedComponent_) {
      this.player_.userActive() || this.player_.userActive(!0), this.updateFocusableComponents();
      for (let e = 0; e < this.focusableComponents.length; e++)
        if (this.focusableComponents[e].name() === this.lastFocusedComponent_.name()) {
          this.focus(this.focusableComponents[e]);
          return;
        }
    } else
      this.focus(this.updateFocusableComponents()[0]);
  }
  /**
   * Focuses on a given component.
   * If the component is available to be focused, it focuses on the component.
   * If not, it attempts to find a suitable DOM child within the component and focuses on it.
   *
   * @param {Component} component - The component to be focused.
   */
  focus(e) {
    typeof e == "object" && (e.getIsAvailableToBeFocused(e.el()) ? e.focus() : this.findSuitableDOMChild(e) && this.findSuitableDOMChild(e).focus());
  }
  /**
   * Calculates the distance between two points, adjusting the calculation based on
   * the specified navigation direction.
   *
   * @param {Object} center1 The center point of the first element.
   * @param {Object} center2 The center point of the second element.
   * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
   * @return {number} The calculated distance between the two centers.
   */
  calculateDistance_(e, n, r) {
    const i = Math.abs(e.x - n.x), s = Math.abs(e.y - n.y);
    let a;
    switch (r) {
      case "right":
      case "left":
        a = i + s * 100;
        break;
      case "up":
        a = s * 2 + i * 0.5;
        break;
      case "down":
        a = s * 5 + i;
        break;
      default:
        a = i + s;
    }
    return a;
  }
  /**
   * This gets called by 'handlePlayerBlur_' if 'spatialNavigation' is enabled.
   * Searches for the first 'TextTrackSelect' inside of modal to focus.
   *
   * @private
   */
  searchForTrackSelect_() {
    const e = this;
    for (const n of e.updateFocusableComponents())
      if (n.constructor.name === "TextTrackSelect") {
        e.focus(n);
        break;
      }
  }
}
class eCe extends He {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function that is run when this component is ready.
   */
  constructor(e, n, r) {
    const i = Dn({
      createEl: !1
    }, n);
    if (super(e, i, r), !n.playerOptions.sources || n.playerOptions.sources.length === 0)
      for (let s = 0, a = n.playerOptions.techOrder; s < a.length; s++) {
        const o = or(a[s]);
        let u = Ht.getTech(o);
        if (o || (u = He.getComponent(o)), u && u.isSupported()) {
          e.loadTech_(o);
          break;
        }
      }
    else
      e.src(n.playerOptions.sources);
  }
}
He.registerComponent("MediaLoader", eCe);
class Fg extends He {
  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of component options.
   *
   * @param  {function} [options.clickHandler]
   *         The function to call when the button is clicked / activated
   *
   * @param  {string} [options.controlText]
   *         The text to set on the button
   *
   * @param  {string} [options.className]
   *         A class or space separated list of classes to add the component
   *
   */
  constructor(e, n) {
    super(e, n), this.options_.controlText && this.controlText(this.options_.controlText), this.handleMouseOver_ = (r) => this.handleMouseOver(r), this.handleMouseOut_ = (r) => this.handleMouseOut(r), this.handleClick_ = (r) => this.handleClick(r), this.handleKeyDown_ = (r) => this.handleKeyDown(r), this.emitTapEvents(), this.enable();
  }
  /**
   * Create the `ClickableComponent`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e = "div", n = {}, r = {}) {
    n = Object.assign({
      className: this.buildCSSClass(),
      tabIndex: 0
    }, n), e === "button" && Kt.error(`Creating a ClickableComponent with an HTML element of ${e} is not supported; use a Button instead.`), r = Object.assign({
      role: "button"
    }, r), this.tabIndex_ = n.tabIndex;
    const i = Nt(e, n, r);
    return this.player_.options_.experimentalSvgIcons || i.appendChild(Nt("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), this.createControlTextEl(i), i;
  }
  dispose() {
    this.controlTextEl_ = null, super.dispose();
  }
  /**
   * Create a control text element on this `ClickableComponent`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */
  createControlTextEl(e) {
    return this.controlTextEl_ = Nt("span", {
      className: "vjs-control-text"
    }, {
      // let the screen reader user know that the text of the element may change
      "aria-live": "polite"
    }), e && e.appendChild(this.controlTextEl_), this.controlText(this.controlText_, e), this.controlTextEl_;
  }
  /**
   * Get or set the localize text to use for the controls on the `ClickableComponent`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */
  controlText(e, n = this.el()) {
    if (e === void 0)
      return this.controlText_ || "Need Text";
    const r = this.localize(e);
    this.controlText_ = e, Uo(this.controlTextEl_, r), !this.nonIconControl && !this.player_.options_.noUITitleAttributes && n.setAttribute("title", r);
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-control vjs-button ${super.buildCSSClass()}`;
  }
  /**
   * Enable this `ClickableComponent`
   */
  enable() {
    this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), typeof this.tabIndex_ < "u" && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick_), this.on("keydown", this.handleKeyDown_));
  }
  /**
   * Disable this `ClickableComponent`
   */
  disable() {
    this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), typeof this.tabIndex_ < "u" && this.el_.removeAttribute("tabIndex"), this.off("mouseover", this.handleMouseOver_), this.off("mouseout", this.handleMouseOut_), this.off(["tap", "click"], this.handleClick_), this.off("keydown", this.handleKeyDown_);
  }
  /**
   * Handles language change in ClickableComponent for the player in components
   *
   *
   */
  handleLanguagechange() {
    this.controlText(this.controlText_);
  }
  /**
   * Event handler that is called when a `ClickableComponent` receives a
   * `click` or `tap` event.
   *
   * @param {Event} event
   *        The `tap` or `click` event that caused this function to be called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */
  handleClick(e) {
    this.options_.clickHandler && this.options_.clickHandler.call(this, arguments);
  }
  /**
   * Event handler that is called when a `ClickableComponent` receives a
   * `keydown` event.
   *
   * By default, if the key is Space or Enter, it will trigger a `click` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === " " || e.key === "Enter" ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e);
  }
}
He.registerComponent("ClickableComponent", Fg);
class ty extends Fg {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.update(), this.update_ = (r) => this.update(r), e.on("posterchange", this.update_);
  }
  /**
   * Clean up and dispose of the `PosterImage`.
   */
  dispose() {
    this.player().off("posterchange", this.update_), super.dispose();
  }
  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    return Nt("div", {
      className: "vjs-poster"
    });
  }
  /**
   * Get or set the `PosterImage`'s crossOrigin option.
   *
   * @param {string|null} [value]
   *        The value to set the crossOrigin to. If an argument is
   *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
   *
   * @return {string|null}
   *         - The current crossOrigin value of the `Player` when getting.
   *         - undefined when setting
   */
  crossOrigin(e) {
    if (typeof e > "u")
      return this.$("img") ? this.$("img").crossOrigin : this.player_.tech_ && this.player_.tech_.isReady_ ? this.player_.crossOrigin() : this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
    if (e !== null && e !== "anonymous" && e !== "use-credentials") {
      this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`);
      return;
    }
    this.$("img") && (this.$("img").crossOrigin = e);
  }
  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */
  update(e) {
    const n = this.player().poster();
    this.setSrc(n), n ? this.show() : this.hide();
  }
  /**
   * Set the source of the `PosterImage` depending on the display method. (Re)creates
   * the inner picture and img elementss when needed.
   *
   * @param {string} [url]
   *        The URL to the source for the `PosterImage`. If not specified or falsy,
   *        any source and ant inner picture/img are removed.
   */
  setSrc(e) {
    if (!e) {
      this.el_.textContent = "";
      return;
    }
    this.$("img") || this.el_.appendChild(Nt("picture", {
      className: "vjs-poster",
      // Don't want poster to be tabbable.
      tabIndex: -1
    }, {}, Nt("img", {
      loading: "lazy",
      crossOrigin: this.crossOrigin()
    }, {
      alt: ""
    }))), this.$("img").src = e;
  }
  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */
  handleClick(e) {
    this.player_.controls() && (this.player_.tech(!0) && this.player_.tech(!0).focus(), this.player_.paused() ? ta(this.player_.play()) : this.player_.pause());
  }
}
ty.prototype.crossorigin = ty.prototype.crossOrigin;
He.registerComponent("PosterImage", ty);
const Ki = "#222", Zx = "#ccc", tCe = {
  monospace: "monospace",
  sansSerif: "sans-serif",
  serif: "serif",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function n2(t, e) {
  let n;
  if (t.length === 4)
    n = t[1] + t[1] + t[2] + t[2] + t[3] + t[3];
  else if (t.length === 7)
    n = t.slice(1);
  else
    throw new Error("Invalid color code provided, " + t + "; must be formatted as e.g. #f0e or #f604e2.");
  return "rgba(" + parseInt(n.slice(0, 2), 16) + "," + parseInt(n.slice(2, 4), 16) + "," + parseInt(n.slice(4, 6), 16) + "," + e + ")";
}
function Qs(t, e, n) {
  try {
    t.style[e] = n;
  } catch {
    return;
  }
}
function Jx(t) {
  return t ? `${t}px` : "";
}
class nCe extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  constructor(e, n, r) {
    super(e, n, r);
    const i = (a) => this.updateDisplay(a), s = (a) => {
      this.updateDisplayOverlay(), this.updateDisplay(a);
    };
    e.on("loadstart", (a) => this.toggleDisplay(a)), e.on("useractive", i), e.on("userinactive", i), e.on("texttrackchange", i), e.on("loadedmetadata", (a) => {
      this.updateDisplayOverlay(), this.preselectTrack(a);
    }), e.ready(Un(this, function() {
      if (e.tech_ && e.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }
      e.on("fullscreenchange", s), e.on("playerresize", s);
      const a = pe.screen.orientation || pe, o = pe.screen.orientation ? "change" : "orientationchange";
      a.addEventListener(o, s), e.on("dispose", () => a.removeEventListener(o, s));
      const u = this.options_.playerOptions.tracks || [];
      for (let c = 0; c < u.length; c++)
        this.player_.addRemoteTextTrack(u[c], !0);
      this.preselectTrack();
    }));
  }
  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */
  preselectTrack() {
    const e = {
      captions: 1,
      subtitles: 1
    }, n = this.player_.textTracks(), r = this.player_.cache_.selectedLanguage;
    let i, s, a;
    for (let o = 0; o < n.length; o++) {
      const u = n[o];
      r && r.enabled && r.language && r.language === u.language && u.kind in e ? u.kind === r.kind ? a = u : a || (a = u) : r && !r.enabled ? (a = null, i = null, s = null) : u.default && (u.kind === "descriptions" && !i ? i = u : u.kind in e && !s && (s = u));
    }
    a ? a.mode = "showing" : s ? s.mode = "showing" : i && (i.mode = "showing");
  }
  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */
  toggleDisplay() {
    this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show();
  }
  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-text-track-display"
    }, {
      translate: "yes",
      "aria-live": "off",
      "aria-atomic": "true"
    });
  }
  /**
   * Clear all displayed {@link TextTrack}s.
   */
  clearDisplay() {
    typeof pe.WebVTT == "function" && pe.WebVTT.processCues(pe, [], this.el_);
  }
  /**
   * Update the displayed {@link TextTrack} when either a {@link Player#texttrackchange},
   * a {@link Player#fullscreenchange}, a {@link Player#useractive}, or a
   * {@link Player#userinactive} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   * @listens Player#useractive
   * @listens Player#userinactive
   */
  updateDisplay() {
    const e = this.player_.textTracks(), n = this.options_.allowMultipleShowingTracks;
    if (this.clearDisplay(), n) {
      const a = [];
      for (let o = 0; o < e.length; ++o) {
        const u = e[o];
        u.mode === "showing" && a.push(u);
      }
      this.updateForTrack(a);
      return;
    }
    let r = null, i = null, s = e.length;
    for (; s--; ) {
      const a = e[s];
      a.mode === "showing" && (a.kind === "descriptions" ? r = a : i = a);
    }
    if (i ? (this.getAttribute("aria-live") !== "off" && this.setAttribute("aria-live", "off"), this.updateForTrack(i)) : r && (this.getAttribute("aria-live") !== "assertive" && this.setAttribute("aria-live", "assertive"), this.updateForTrack(r)), !pe.CSS.supports("inset", "10px")) {
      const a = this.el_, o = a.querySelectorAll(".vjs-text-track-cue"), u = this.player_.controlBar.el_.getBoundingClientRect().height, c = this.player_.el_.getBoundingClientRect().height;
      a.style = "", Qs(a, "position", "relative"), Qs(a, "height", c - u + "px"), Qs(a, "top", "unset"), c0 ? Qs(a, "bottom", c + "px") : Qs(a, "bottom", "0px"), o.length > 0 && o.forEach((d) => {
        if (d.style.inset) {
          const l = d.style.inset.split(" ");
          l.length === 3 && Object.assign(d.style, {
            top: l[0],
            right: l[1],
            bottom: l[2],
            left: "unset"
          });
        }
      });
    }
  }
  /**
   * Updates the displayed TextTrack to be sure it overlays the video when a either
   * a {@link Player#texttrackchange} or a {@link Player#fullscreenchange} is fired.
   */
  updateDisplayOverlay() {
    if (!this.player_.videoHeight() || !pe.CSS.supports("inset-inline: 10px"))
      return;
    const e = this.player_.currentWidth(), n = this.player_.currentHeight(), r = e / n, i = this.player_.videoWidth() / this.player_.videoHeight();
    let s = 0, a = 0;
    Math.abs(r - i) > 0.1 && (r > i ? s = Math.round((e - n * i) / 2) : a = Math.round((n - e / i) / 2)), Qs(this.el_, "insetInline", Jx(s)), Qs(this.el_, "insetBlock", Jx(a));
  }
  /**
   * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.
   *
   * @param {TextTrack} track
   *        Text track object containing active cues to style.
   */
  updateDisplayState(e) {
    const n = this.player_.textTrackSettings.getValues(), r = e.activeCues;
    let i = r.length;
    for (; i--; ) {
      const s = r[i];
      if (!s)
        continue;
      const a = s.displayState;
      if (n.color && (a.firstChild.style.color = n.color), n.textOpacity && Qs(a.firstChild, "color", n2(n.color || "#fff", n.textOpacity)), n.backgroundColor && (a.firstChild.style.backgroundColor = n.backgroundColor), n.backgroundOpacity && Qs(a.firstChild, "backgroundColor", n2(n.backgroundColor || "#000", n.backgroundOpacity)), n.windowColor && (n.windowOpacity ? Qs(a, "backgroundColor", n2(n.windowColor, n.windowOpacity)) : a.style.backgroundColor = n.windowColor), n.edgeStyle && (n.edgeStyle === "dropshadow" ? a.firstChild.style.textShadow = `2px 2px 3px ${Ki}, 2px 2px 4px ${Ki}, 2px 2px 5px ${Ki}` : n.edgeStyle === "raised" ? a.firstChild.style.textShadow = `1px 1px ${Ki}, 2px 2px ${Ki}, 3px 3px ${Ki}` : n.edgeStyle === "depressed" ? a.firstChild.style.textShadow = `1px 1px ${Zx}, 0 1px ${Zx}, -1px -1px ${Ki}, 0 -1px ${Ki}` : n.edgeStyle === "uniform" && (a.firstChild.style.textShadow = `0 0 4px ${Ki}, 0 0 4px ${Ki}, 0 0 4px ${Ki}, 0 0 4px ${Ki}`)), n.fontPercent && n.fontPercent !== 1) {
        const o = pe.parseFloat(a.style.fontSize);
        a.style.fontSize = o * n.fontPercent + "px", a.style.height = "auto", a.style.top = "auto";
      }
      n.fontFamily && n.fontFamily !== "default" && (n.fontFamily === "small-caps" ? a.firstChild.style.fontVariant = "small-caps" : a.firstChild.style.fontFamily = tCe[n.fontFamily]);
    }
  }
  /**
   * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack|TextTrack[]} tracks
   *        Text track object or text track array to be added to the list.
   */
  updateForTrack(e) {
    if (Array.isArray(e) || (e = [e]), typeof pe.WebVTT != "function" || e.every((r) => !r.activeCues))
      return;
    const n = [];
    for (let r = 0; r < e.length; ++r) {
      const i = e[r];
      for (let s = 0; s < i.activeCues.length; ++s)
        n.push(i.activeCues[s]);
    }
    pe.WebVTT.processCues(pe, n, this.el_);
    for (let r = 0; r < e.length; ++r) {
      const i = e[r];
      for (let s = 0; s < i.activeCues.length; ++s) {
        const a = i.activeCues[s].displayState;
        Iu(a, "vjs-text-track-cue", "vjs-text-track-cue-" + (i.language ? i.language : r)), i.language && hc(a, "lang", i.language);
      }
      this.player_.textTrackSettings && this.updateDisplayState(i);
    }
  }
}
He.registerComponent("TextTrackDisplay", nCe);
class rCe extends He {
  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  createEl() {
    const e = this.player_.isAudio(), n = this.localize(e ? "Audio Player" : "Video Player"), r = Nt("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [n])
    }), i = super.createEl("div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    return i.appendChild(r), i;
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [this.player_.isAudio() ? "Audio Player" : "Video Player"]);
  }
}
He.registerComponent("LoadingSpinner", rCe);
class ni extends Fg {
  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, n = {}, r = {}) {
    e = "button", n = Object.assign({
      className: this.buildCSSClass()
    }, n), r = Object.assign({
      // Necessary since the default button type is "submit"
      type: "button"
    }, r);
    const i = Nt(e, n, r);
    return this.player_.options_.experimentalSvgIcons || i.appendChild(Nt("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), this.createControlTextEl(i), i;
  }
  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */
  addChild(e, n = {}) {
    const r = this.constructor.name;
    return Kt.warn(`Adding an actionable (user controllable) child to a Button (${r}) is not supported; use a ClickableComponent instead.`), He.prototype.addChild.call(this, e, n);
  }
  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */
  enable() {
    super.enable(), this.el_.removeAttribute("disabled");
  }
  /**
   * Disable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */
  disable() {
    super.disable(), this.el_.setAttribute("disabled", "disabled");
  }
  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {KeyboardEvent} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    if (e.key === " " || e.key === "Enter") {
      e.stopPropagation();
      return;
    }
    super.handleKeyDown(e);
  }
}
He.registerComponent("Button", ni);
class f8 extends ni {
  constructor(e, n) {
    super(e, n), this.mouseused_ = !1, this.setIcon("play"), this.on("mousedown", (r) => this.handleMouseDown(r));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */
  buildCSSClass() {
    return "vjs-big-play-button";
  }
  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {KeyboardEvent|MouseEvent|TouchEvent} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    const n = this.player_.play();
    if (e.type === "tap" || this.mouseused_ && "clientX" in e && "clientY" in e) {
      ta(n), this.player_.tech(!0) && this.player_.tech(!0).focus();
      return;
    }
    const r = this.player_.getChild("controlBar"), i = r && r.getChild("playToggle");
    if (!i) {
      this.player_.tech(!0).focus();
      return;
    }
    const s = () => i.focus();
    bf(n) ? n.then(s, () => {
    }) : this.setTimeout(s, 1);
  }
  /**
   * Event handler that is called when a `BigPlayButton` receives a
   * `keydown` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    this.mouseused_ = !1, super.handleKeyDown(e);
  }
  /**
   * Handle `mousedown` events on the `BigPlayButton`.
   *
   * @param {MouseEvent} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   */
  handleMouseDown(e) {
    this.mouseused_ = !0;
  }
}
f8.prototype.controlText_ = "Play Video";
He.registerComponent("BigPlayButton", f8);
class iCe extends ni {
  /**
  * Creates an instance of the this class.
  *
  * @param  {Player} player
  *         The `Player` that this class should be attached to.
  *
  * @param  {Object} [options]
  *         The key/value store of player options.
  */
  constructor(e, n) {
    super(e, n), this.setIcon("cancel"), this.controlText(n && n.controlText || this.localize("Close"));
  }
  /**
  * Builds the default DOM `className`.
  *
  * @return {string}
  *         The DOM `className` for this object.
  */
  buildCSSClass() {
    return `vjs-close-button ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when
   * this will be triggered
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */
  handleClick(e) {
    this.trigger({
      type: "close",
      bubbles: !1
    });
  }
  /**
   * Event handler that is called when a `CloseButton` receives a
   * `keydown` event.
   *
   * By default, if the key is Esc, it will trigger a `click` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === "Escape" ? (e.preventDefault(), e.stopPropagation(), this.trigger("click")) : super.handleKeyDown(e);
  }
}
He.registerComponent("CloseButton", iCe);
class h8 extends ni {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, n = {}) {
    super(e, n), n.replay = n.replay === void 0 || n.replay, this.setIcon("play"), this.on(e, "play", (r) => this.handlePlay(r)), this.on(e, "pause", (r) => this.handlePause(r)), n.replay && this.on(e, "ended", (r) => this.handleEnded(r));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-play-control ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player_.paused() ? ta(this.player_.play()) : this.player_.pause();
  }
  /**
   * This gets called once after the video has ended and the user seeks so that
   * we can change the replay button back to a play button.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#seeked
   */
  handleSeeked(e) {
    this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(e) : this.handlePlay(e);
  }
  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */
  handlePlay(e) {
    this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.setIcon("pause"), this.controlText("Pause");
  }
  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */
  handlePause(e) {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.setIcon("play"), this.controlText("Play");
  }
  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ended
   */
  handleEnded(e) {
    this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.setIcon("replay"), this.controlText("Replay"), this.one(this.player_, "seeked", (n) => this.handleSeeked(n));
  }
}
h8.prototype.controlText_ = "Play";
He.registerComponent("PlayToggle", h8);
class qc extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.on(e, ["timeupdate", "ended", "seeking"], (r) => this.update(r)), this.updateTextNode_();
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = this.buildCSSClass(), n = super.createEl("div", {
      className: `${e} vjs-time-control vjs-control`
    }), r = Nt("span", {
      className: "vjs-control-text",
      textContent: `${this.localize(this.labelText_)} `
    }, {
      role: "presentation"
    });
    return n.appendChild(r), this.contentEl_ = Nt("span", {
      className: `${e}-display`
    }, {
      // span elements have no implicit role, but some screen readers (notably VoiceOver)
      // treat them as a break between items in the DOM when using arrow keys
      // (or left-to-right swipes on iOS) to read contents of a page. Using
      // role='presentation' causes VoiceOver to NOT treat this span as a break.
      role: "presentation"
    }), n.appendChild(this.contentEl_), n;
  }
  dispose() {
    this.contentEl_ = null, this.textNode_ = null, super.dispose();
  }
  /**
   * Updates the displayed time according to the `updateContent` function which is defined in the child class.
   *
   * @param {Event} [event]
   *          The `timeupdate`, `ended` or `seeking` (if enableSmoothSeeking is true) event that caused this function to be called.
   */
  update(e) {
    !this.player_.options_.enableSmoothSeeking && e.type === "seeking" || this.updateContent(e);
  }
  /**
   * Updates the time display text node with a new time
   *
   * @param {number} [time=0] the time to update to
   *
   * @private
   */
  updateTextNode_(e = 0) {
    e = Vu(e), this.formattedTime_ !== e && (this.formattedTime_ = e, this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", () => {
      if (!this.contentEl_)
        return;
      let n = this.textNode_;
      n && this.contentEl_.firstChild !== n && (n = null, Kt.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.")), this.textNode_ = ot.createTextNode(this.formattedTime_), this.textNode_ && (n ? this.contentEl_.replaceChild(this.textNode_, n) : this.contentEl_.appendChild(this.textNode_));
    }));
  }
  /**
   * To be filled out in the child class, should update the displayed time
   * in accordance with the fact that the current time has changed.
   *
   * @param {Event} [event]
   *        The `timeupdate`  event that caused this to run.
   *
   * @listens Player#timeupdate
   */
  updateContent(e) {
  }
}
qc.prototype.labelText_ = "Time";
qc.prototype.controlText_ = "Time";
He.registerComponent("TimeDisplay", qc);
class wT extends qc {
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-current-time";
  }
  /**
   * Update current time display
   *
   * @param {Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */
  updateContent(e) {
    let n;
    this.player_.ended() ? n = this.player_.duration() : e && e.target && typeof e.target.pendingSeekTime == "function" ? n = e.target.pendingSeekTime() : n = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(), this.updateTextNode_(n);
  }
}
wT.prototype.labelText_ = "Current Time";
wT.prototype.controlText_ = "Current Time";
He.registerComponent("CurrentTimeDisplay", wT);
class CT extends qc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n);
    const r = (i) => this.updateContent(i);
    this.on(e, "durationchange", r), this.on(e, "loadstart", r), this.on(e, "loadedmetadata", r);
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-duration";
  }
  /**
   * Update duration time display.
   *
   * @param {Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */
  updateContent(e) {
    const n = this.player_.duration();
    this.updateTextNode_(n);
  }
}
CT.prototype.labelText_ = "Duration";
CT.prototype.controlText_ = "Duration";
He.registerComponent("DurationDisplay", CT);
class sCe extends He {
  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-time-control vjs-time-divider"
    }, {
      // this element and its contents can be hidden from assistive techs since
      // it is made extraneous by the announcement of the control text
      // for the current time and duration displays
      "aria-hidden": !0
    }), n = super.createEl("div"), r = super.createEl("span", {
      textContent: "/"
    });
    return n.appendChild(r), e.appendChild(n), e;
  }
}
He.registerComponent("TimeDivider", sCe);
class ST extends qc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.on(e, "durationchange", (r) => this.updateContent(r));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-remaining-time";
  }
  /**
   * Create the `Component`'s DOM element with the "minus" character prepend to the time
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl();
    return this.options_.displayNegative !== !1 && e.insertBefore(Nt("span", {}, {
      "aria-hidden": !0
    }, "-"), this.contentEl_), e;
  }
  /**
   * Update remaining time display.
   *
   * @param {Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */
  updateContent(e) {
    if (typeof this.player_.duration() != "number")
      return;
    let n;
    this.player_.ended() ? n = 0 : this.player_.remainingTimeDisplay ? n = this.player_.remainingTimeDisplay() : n = this.player_.remainingTime(), this.updateTextNode_(n);
  }
}
ST.prototype.labelText_ = "Remaining Time";
ST.prototype.controlText_ = "Remaining Time";
He.registerComponent("RemainingTimeDisplay", ST);
class aCe extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.updateShowing(), this.on(this.player(), "durationchange", (r) => this.updateShowing(r));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-live-control vjs-control"
    });
    return this.contentEl_ = Nt("div", {
      className: "vjs-live-display"
    }, {
      "aria-live": "off"
    }), this.contentEl_.appendChild(Nt("span", {
      className: "vjs-control-text",
      textContent: `${this.localize("Stream Type")} `
    })), this.contentEl_.appendChild(ot.createTextNode(this.localize("LIVE"))), e.appendChild(this.contentEl_), e;
  }
  dispose() {
    this.contentEl_ = null, super.dispose();
  }
  /**
   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
   * it accordingly
   *
   * @param {Event} [event]
   *        The {@link Player#durationchange} event that caused this function to run.
   *
   * @listens Player#durationchange
   */
  updateShowing(e) {
    this.player().duration() === 1 / 0 ? this.show() : this.hide();
  }
}
He.registerComponent("LiveDisplay", aCe);
class p8 extends ni {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.updateLiveEdgeStatus(), this.player_.liveTracker && (this.updateLiveEdgeStatusHandler_ = (r) => this.updateLiveEdgeStatus(r), this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    return this.setIcon("circle", e), this.textEl_ = Nt("span", {
      className: "vjs-seek-to-live-text",
      textContent: this.localize("LIVE")
    }, {
      "aria-hidden": "true"
    }), e.appendChild(this.textEl_), e;
  }
  /**
   * Update the state of this button if we are at the live edge
   * or not
   */
  updateLiveEdgeStatus() {
    !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live"));
  }
  /**
   * On click bring us as near to the live point as possible.
   * This requires that we wait for the next `live-seekable-change`
   * event which will happen every segment length seconds.
   */
  handleClick() {
    this.player_.liveTracker.seekToLiveEdge();
  }
  /**
   * Dispose of the element and stop tracking
   */
  dispose() {
    this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_), this.textEl_ = null, super.dispose();
  }
}
p8.prototype.controlText_ = "Seek to live, currently playing live";
He.registerComponent("SeekToLive", p8);
function Th(t, e, n) {
  return t = Number(t), Math.min(n, Math.max(e, isNaN(t) ? e : t));
}
var oCe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clamp: Th
});
class IT extends He {
  /**
  * Create an instance of this class
  *
  * @param {Player} player
  *        The `Player` that this class should be attached to.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  */
  constructor(e, n) {
    super(e, n), this.handleMouseDown_ = (r) => this.handleMouseDown(r), this.handleMouseUp_ = (r) => this.handleMouseUp(r), this.handleKeyDown_ = (r) => this.handleKeyDown(r), this.handleClick_ = (r) => this.handleClick(r), this.handleMouseMove_ = (r) => this.handleMouseMove(r), this.update_ = (r) => this.update(r), this.bar = this.getChild(this.options_.barName), this.vertical(!!this.options_.vertical), this.enable();
  }
  /**
   * Are controls are currently enabled for this slider or not.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */
  enabled() {
    return this.enabled_;
  }
  /**
   * Enable controls for this slider if they are disabled
   */
  enable() {
    this.enabled() || (this.on("mousedown", this.handleMouseDown_), this.on("touchstart", this.handleMouseDown_), this.on("keydown", this.handleKeyDown_), this.on("click", this.handleClick_), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0);
  }
  /**
   * Disable controls for this slider if they are enabled
   */
  disable() {
    if (!this.enabled())
      return;
    const e = this.bar.el_.ownerDocument;
    this.off("mousedown", this.handleMouseDown_), this.off("touchstart", this.handleMouseDown_), this.off("keydown", this.handleKeyDown_), this.off("click", this.handleClick_), this.off(this.player_, "controlsvisible", this.update_), this.off(e, "mousemove", this.handleMouseMove_), this.off(e, "mouseup", this.handleMouseUp_), this.off(e, "touchmove", this.handleMouseMove_), this.off(e, "touchend", this.handleMouseUp_), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1;
  }
  /**
   * Create the `Slider`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, n = {}, r = {}) {
    return n.className = n.className + " vjs-slider", n = Object.assign({
      tabIndex: 0
    }, n), r = Object.assign({
      role: "slider",
      "aria-valuenow": 0,
      "aria-valuemin": 0,
      "aria-valuemax": 100
    }, r), super.createEl(e, n, r);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {MouseEvent} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */
  handleMouseDown(e) {
    const n = this.bar.el_.ownerDocument;
    e.type === "mousedown" && e.preventDefault(), e.type === "touchstart" && !ha && e.preventDefault(), $D(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(n, "mousemove", this.handleMouseMove_), this.on(n, "mouseup", this.handleMouseUp_), this.on(n, "touchmove", this.handleMouseMove_), this.on(n, "touchend", this.handleMouseUp_), this.handleMouseMove(e, !0);
  }
  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {MouseEvent} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.
   *
   * @listens mousemove
   * @listens touchmove
   */
  handleMouseMove(e) {
  }
  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {MouseEvent} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */
  handleMouseUp(e) {
    const n = this.bar.el_.ownerDocument;
    HD(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(n, "mousemove", this.handleMouseMove_), this.off(n, "mouseup", this.handleMouseUp_), this.off(n, "touchmove", this.handleMouseMove_), this.off(n, "touchend", this.handleMouseUp_), this.update();
  }
  /**
   * Update the progress bar of the `Slider`.
   *
   * @return {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */
  update() {
    if (!this.el_ || !this.bar)
      return;
    const e = this.getProgress();
    return e === this.progress_ || (this.progress_ = e, this.requestNamedAnimationFrame("Slider#update", () => {
      const n = this.vertical() ? "height" : "width";
      this.bar.el().style[n] = (e * 100).toFixed(2) + "%";
    })), e;
  }
  /**
   * Get the percentage of the bar that should be filled
   * but clamped and rounded.
   *
   * @return {number}
   *         percentage filled that the slider is
   */
  getProgress() {
    return Number(Th(this.getPercent(), 0, 1).toFixed(4));
  }
  /**
   * Calculate distance for slider
   *
   * @param {Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - position.x for vertical `Slider`s
   *         - position.y for horizontal `Slider`s
   */
  calculateDistance(e) {
    const n = Og(this.el_, e);
    return this.vertical() ? n.y : n.x;
  }
  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, right, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {KeyboardEvent} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    const n = this.options_.playerOptions.spatialNavigation, r = n && n.enabled, i = n && n.horizontalSeek;
    r ? i && e.key === "ArrowLeft" || !i && e.key === "ArrowDown" ? (e.preventDefault(), e.stopPropagation(), this.stepBack()) : i && e.key === "ArrowRight" || !i && e.key === "ArrowUp" ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : (this.pendingSeekTime() && (this.pendingSeekTime(null), this.userSeek_(this.player_.currentTime())), super.handleKeyDown(e)) : e.key === "ArrowLeft" || e.key === "ArrowDown" ? (e.preventDefault(), e.stopPropagation(), this.stepBack()) : e.key === "ArrowUp" || e.key === "ArrowRight" ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : super.handleKeyDown(e);
  }
  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */
  handleClick(e) {
    e.stopPropagation(), e.preventDefault();
  }
  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */
  vertical(e) {
    if (e === void 0)
      return this.vertical_ || !1;
    this.vertical_ = !!e, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal");
  }
}
He.registerComponent("Slider", IT);
const r2 = (t, e) => Th(t / e * 100, 0, 100).toFixed(2) + "%";
class uCe extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.partEls_ = [], this.on(e, "progress", (r) => this.update(r));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-load-progress"
    }), n = Nt("span", {
      className: "vjs-control-text"
    }), r = Nt("span", {
      textContent: this.localize("Loaded")
    }), i = ot.createTextNode(": ");
    return this.percentageEl_ = Nt("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    }), e.appendChild(n), n.appendChild(r), n.appendChild(i), n.appendChild(this.percentageEl_), e;
  }
  dispose() {
    this.partEls_ = null, this.percentageEl_ = null, super.dispose();
  }
  /**
   * Update progress bar
   *
   * @param {Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */
  update(e) {
    this.requestNamedAnimationFrame("LoadProgressBar#update", () => {
      const n = this.player_.liveTracker, r = this.player_.buffered(), i = n && n.isLive() ? n.seekableEnd() : this.player_.duration(), s = this.player_.bufferedEnd(), a = this.partEls_, o = r2(s, i);
      this.percent_ !== o && (this.el_.style.width = o, Uo(this.percentageEl_, o), this.percent_ = o);
      for (let u = 0; u < r.length; u++) {
        const c = r.start(u), d = r.end(u);
        let l = a[u];
        l || (l = this.el_.appendChild(Nt()), a[u] = l), !(l.dataset.start === c && l.dataset.end === d) && (l.dataset.start = c, l.dataset.end = d, l.style.left = r2(c, s), l.style.width = r2(d - c, s));
      }
      for (let u = a.length; u > r.length; u--)
        this.el_.removeChild(a[u - 1]);
      a.length = r.length;
    });
  }
}
He.registerComponent("LoadProgressBar", uCe);
class lCe extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.update = pa(Un(this, this.update), hs);
  }
  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-time-tooltip"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */
  update(e, n, r) {
    const i = Yf(this.el_), s = pc(this.player_.el()), a = e.width * n;
    if (!s || !i)
      return;
    let o = e.left - s.left + a, u = e.width - a + (s.right - e.right);
    u || (u = e.width - a, o = a);
    let c = i.width / 2;
    o < c ? c += c - o : u < c && (c = u), c < 0 ? c = 0 : c > i.width && (c = i.width), c = Math.round(c), this.el_.style.right = `-${c}px`, this.write(r);
  }
  /**
   * Write the time to the tooltip DOM element.
   *
   * @param {string} content
   *        The formatted time for the tooltip.
   */
  write(e) {
    Uo(this.el_, e);
  }
  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   *
   * @param {number} time
   *        The time to update the tooltip to, not used during live playback
   *
   * @param {Function} cb
   *        A function that will be called during the request animation frame
   *        for tooltips that need to do additional animations from the default
   */
  updateTime(e, n, r, i) {
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", () => {
      let s;
      const a = this.player_.duration();
      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
        const o = this.player_.liveTracker.liveWindow(), u = o - n * o;
        s = (u < 1 ? "" : "-") + Vu(u, o);
      } else
        s = Vu(r, a);
      this.update(e, n, s), i && i();
    });
  }
}
He.registerComponent("TimeTooltip", lCe);
class kT extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.setIcon("circle"), this.update = pa(Un(this, this.update), hs);
  }
  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-play-progress vjs-slider-bar"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   *
   * @param {Event} [event]
   *        The `timeupdate` event that caused this function to run.
   */
  update(e, n, r) {
    const i = this.getChild("timeTooltip");
    if (!i)
      return;
    const s = r && r.target && typeof r.target.pendingSeekTime == "function" ? r.target.pendingSeekTime() : this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    i.updateTime(e, n, s);
  }
}
kT.prototype.options_ = {
  children: []
};
!ei && !Ns && kT.prototype.options_.children.push("timeTooltip");
He.registerComponent("PlayProgressBar", kT);
class m8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.update = pa(Un(this, this.update), hs);
  }
  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-mouse-display"
    });
  }
  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */
  update(e, n) {
    const r = n * this.player_.duration();
    this.getChild("timeTooltip").updateTime(e, n, r, () => {
      this.el_.style.left = `${e.width * n}px`;
    });
  }
}
m8.prototype.options_ = {
  children: ["timeTooltip"]
};
He.registerComponent("MouseTimeDisplay", m8);
class Ug extends IT {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   * @param {number} [options.stepSeconds=5]
   *        The number of seconds to increment on keyboard control
   * @param {number} [options.pageMultiplier=12]
   *        The multiplier of stepSeconds that PgUp/PgDown move the timeline.
   */
  constructor(e, n) {
    n = Dn(Ug.prototype.options_, n), n.children = [...n.children];
    const r = e.options_.disableSeekWhileScrubbingOnMobile && (ei || Ns) || e.options_.disableSeekWhileScrubbingOnSTV;
    (!ei && !Ns || r) && n.children.splice(1, 0, "mouseTimeDisplay"), super(e, n), this.shouldDisableSeekWhileScrubbing_ = r, this.pendingSeekTime_ = null, this.setEventHandlers_();
  }
  /**
   * Sets the event handlers
   *
   * @private
   */
  setEventHandlers_() {
    this.update_ = Un(this, this.update), this.update = pa(this.update_, hs), this.on(this.player_, ["durationchange", "timeupdate"], this.update), this.on(this.player_, ["ended"], this.update_), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.enableIntervalHandler_ = (e) => this.enableInterval_(e), this.disableIntervalHandler_ = (e) => this.disableInterval_(e), this.on(this.player_, ["playing"], this.enableIntervalHandler_), this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in ot && "visibilityState" in ot && this.on(ot, "visibilitychange", this.toggleVisibility_);
  }
  toggleVisibility_(e) {
    ot.visibilityState === "hidden" ? (this.cancelNamedAnimationFrame("SeekBar#update"), this.cancelNamedAnimationFrame("Slider#update"), this.disableInterval_(e)) : (!this.player_.ended() && !this.player_.paused() && this.enableInterval_(), this.update());
  }
  enableInterval_() {
    this.updateInterval || (this.updateInterval = this.setInterval(this.update, hs));
  }
  disableInterval_(e) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended" || this.updateInterval && (this.clearInterval(this.updateInterval), this.updateInterval = null);
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-progress-holder"
    }, {
      "aria-label": this.localize("Progress Bar")
    });
  }
  /**
   * This function updates the play progress bar and accessibility
   * attributes to whatever is passed in.
   *
   * @param {Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   *
   * @return {number}
   *          The current percent at a number from 0-1
   */
  update(e) {
    if (ot.visibilityState === "hidden")
      return;
    const n = super.update();
    return this.requestNamedAnimationFrame("SeekBar#update", () => {
      const r = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_(), i = this.player_.liveTracker;
      let s = this.player_.duration();
      i && i.isLive() && (s = this.player_.liveTracker.liveCurrentTime()), this.percent_ !== n && (this.el_.setAttribute("aria-valuenow", (n * 100).toFixed(2)), this.percent_ = n), (this.currentTime_ !== r || this.duration_ !== s) && (this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [Vu(r, s), Vu(s, s)], "{1} of {2}")), this.currentTime_ = r, this.duration_ = s), this.bar && this.bar.update(pc(this.el()), this.getProgress(), e);
    }), n;
  }
  /**
   * Prevent liveThreshold from causing seeks to seem like they
   * are not happening from a user perspective.
   *
   * @param {number} ct
   *        current time to seek to
   */
  userSeek_(e) {
    this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(), this.player_.currentTime(e);
  }
  /**
   * Get the value of current time but allows for smooth scrubbing,
   * when player can't keep up.
   *
   * @return {number}
   *         The current time value to display
   *
   * @private
   */
  getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  }
  /**
   * Getter and setter for pendingSeekTime.
   * Ensures the value is clamped between 0 and duration.
   *
   * @param {number|null} [time] - Optional. The new pending seek time, can be a number or null.
   * @return {number|null} - The current pending seek time.
   */
  pendingSeekTime(e) {
    if (e !== void 0)
      if (e !== null) {
        const n = this.player_.duration();
        this.pendingSeekTime_ = Math.max(0, Math.min(e, n));
      } else
        this.pendingSeekTime_ = null;
    return this.pendingSeekTime_;
  }
  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */
  getPercent() {
    if (this.pendingSeekTime() !== null)
      return this.pendingSeekTime() / this.player_.duration();
    const e = this.getCurrentTime_();
    let n;
    const r = this.player_.liveTracker;
    return r && r.isLive() ? (n = (e - r.seekableStart()) / r.liveWindow(), r.atLiveEdge() && (n = 1)) : n = e / this.player_.duration(), n;
  }
  /**
   * Handle mouse down on seek bar
   *
   * @param {MouseEvent} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */
  handleMouseDown(e) {
    Xf(e) && (e.stopPropagation(), this.videoWasPlaying = !this.player_.paused(), this.shouldDisableSeekWhileScrubbing_ || this.player_.pause(), super.handleMouseDown(e));
  }
  /**
   * Handle mouse move on seek bar
   *
   * @param {MouseEvent} event
   *        The `mousemove` event that caused this to run.
   * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false
   *
   * @listens mousemove
   */
  handleMouseMove(e, n = !1) {
    if (!Xf(e) || isNaN(this.player_.duration()))
      return;
    !n && !this.player_.scrubbing() && this.player_.scrubbing(!0);
    let r;
    const i = this.calculateDistance(e), s = this.player_.liveTracker;
    if (!s || !s.isLive())
      r = i * this.player_.duration(), r === this.player_.duration() && (r = r - 0.1);
    else {
      if (i >= 0.99) {
        s.seekToLiveEdge();
        return;
      }
      const a = s.seekableStart(), o = s.liveCurrentTime();
      if (r = a + i * s.liveWindow(), r >= o && (r = o), r <= a && (r = a + 0.1), r === 1 / 0)
        return;
    }
    this.shouldDisableSeekWhileScrubbing_ ? this.pendingSeekTime(r) : this.userSeek_(r), this.player_.options_.enableSmoothSeeking && this.update();
  }
  enable() {
    super.enable();
    const e = this.getChild("mouseTimeDisplay");
    e && e.show();
  }
  disable() {
    super.disable();
    const e = this.getChild("mouseTimeDisplay");
    e && e.hide();
  }
  /**
   * Handle mouse up on seek bar
   *
   * @param {MouseEvent} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */
  handleMouseUp(e) {
    super.handleMouseUp(e), e && e.stopPropagation(), this.player_.scrubbing(!1), this.pendingSeekTime() !== null && (this.userSeek_(this.pendingSeekTime()), this.pendingSeekTime(null)), this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    }), this.videoWasPlaying ? ta(this.player_.play()) : this.update_();
  }
  /**
   * Handles pending seek time when `disableSeekWhileScrubbingOnSTV` is enabled.
   *
   * @param {number} stepAmount - The number of seconds to step (positive for forward, negative for backward).
   */
  handlePendingSeek_(e) {
    this.player_.paused() || this.player_.pause();
    const n = this.pendingSeekTime() !== null ? this.pendingSeekTime() : this.player_.currentTime();
    this.pendingSeekTime(n + e), this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: !0
    });
  }
  /**
   * Move more quickly fast forward for keyboard-only users
   */
  stepForward() {
    this.shouldDisableSeekWhileScrubbing_ ? this.handlePendingSeek_(this.options().stepSeconds) : this.userSeek_(this.player_.currentTime() + this.options().stepSeconds);
  }
  /**
   * Move more quickly rewind for keyboard-only users
   */
  stepBack() {
    this.shouldDisableSeekWhileScrubbing_ ? this.handlePendingSeek_(-this.options().stepSeconds) : this.userSeek_(this.player_.currentTime() - this.options().stepSeconds);
  }
  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called
   *
   */
  handleAction(e) {
    this.pendingSeekTime() !== null && (this.userSeek_(this.pendingSeekTime()), this.pendingSeekTime(null)), this.player_.paused() ? this.player_.play() : this.player_.pause();
  }
  /**
   * Called when this SeekBar has focus and a key gets pressed down.
   * Supports the following keys:
   *
   *   Space or Enter key fire a click event
   *   Home key moves to start of the timeline
   *   End key moves to end of the timeline
   *   Digit "0" through "9" keys move to 0%, 10% ... 80%, 90% of the timeline
   *   PageDown key moves back a larger step than ArrowDown
   *   PageUp key moves forward a large step
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    const n = this.player_.liveTracker;
    if (e.key === " " || e.key === "Enter")
      e.preventDefault(), e.stopPropagation(), this.handleAction(e);
    else if (e.key === "Home")
      e.preventDefault(), e.stopPropagation(), this.userSeek_(0);
    else if (e.key === "End")
      e.preventDefault(), e.stopPropagation(), n && n.isLive() ? this.userSeek_(n.liveCurrentTime()) : this.userSeek_(this.player_.duration());
    else if (/^[0-9]$/.test(e.key)) {
      e.preventDefault(), e.stopPropagation();
      const r = parseInt(e.key, 10) * 0.1;
      n && n.isLive() ? this.userSeek_(n.seekableStart() + n.liveWindow() * r) : this.userSeek_(this.player_.duration() * r);
    } else e.key === "PageDown" ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() - this.options().stepSeconds * this.options().pageMultiplier)) : e.key === "PageUp" ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(this.player_.currentTime() + this.options().stepSeconds * this.options().pageMultiplier)) : super.handleKeyDown(e);
  }
  dispose() {
    this.disableInterval_(), this.off(this.player_, ["durationchange", "timeupdate"], this.update), this.off(this.player_, ["ended"], this.update_), this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update), this.off(this.player_, ["playing"], this.enableIntervalHandler_), this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_), "hidden" in ot && "visibilityState" in ot && this.off(ot, "visibilitychange", this.toggleVisibility_), super.dispose();
  }
}
Ug.prototype.options_ = {
  children: ["loadProgressBar", "playProgressBar"],
  barName: "playProgressBar",
  stepSeconds: 5,
  pageMultiplier: 12
};
He.registerComponent("SeekBar", Ug);
class g8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.handleMouseMove = pa(Un(this, this.handleMouseMove), hs), this.throttledHandleMouseSeek = pa(Un(this, this.handleMouseSeek), hs), this.handleMouseUpHandler_ = (r) => this.handleMouseUp(r), this.handleMouseDownHandler_ = (r) => this.handleMouseDown(r), this.enable();
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-progress-control vjs-control"
    });
  }
  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */
  handleMouseMove(e) {
    const n = this.getChild("seekBar");
    if (!n)
      return;
    const r = n.getChild("playProgressBar"), i = n.getChild("mouseTimeDisplay");
    if (!r && !i)
      return;
    const s = n.el(), a = Yf(s);
    let o = Og(s, e).x;
    o = Th(o, 0, 1), i && i.update(a, o), r && r.update(a, n.getProgress());
  }
  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */
  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */
  handleMouseSeek(e) {
    const n = this.getChild("seekBar");
    n && n.handleMouseMove(e);
  }
  /**
   * Are controls are currently enabled for this progress control.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */
  enabled() {
    return this.enabled_;
  }
  /**
   * Disable all controls on the progress control and its children
   */
  disable() {
    if (this.children().forEach((e) => e.disable && e.disable()), !!this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.off(this.el_, ["mousemove", "touchmove"], this.handleMouseMove), this.removeListenersAddedOnMousedownAndTouchstart(), this.addClass("disabled"), this.enabled_ = !1, this.player_.scrubbing())) {
      const e = this.getChild("seekBar");
      this.player_.scrubbing(!1), e.videoWasPlaying && ta(this.player_.play());
    }
  }
  /**
   * Enable all controls on the progress control and its children
   */
  enable() {
    this.children().forEach((e) => e.enable && e.enable()), !this.enabled() && (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_), this.on(this.el_, ["mousemove", "touchmove"], this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0);
  }
  /**
   * Cleanup listeners after the user finishes interacting with the progress controls
   */
  removeListenersAddedOnMousedownAndTouchstart() {
    const e = this.el_.ownerDocument;
    this.off(e, "mousemove", this.throttledHandleMouseSeek), this.off(e, "touchmove", this.throttledHandleMouseSeek), this.off(e, "mouseup", this.handleMouseUpHandler_), this.off(e, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseDown(e) {
    const n = this.el_.ownerDocument, r = this.getChild("seekBar");
    r && r.handleMouseDown(e), this.on(n, "mousemove", this.throttledHandleMouseSeek), this.on(n, "touchmove", this.throttledHandleMouseSeek), this.on(n, "mouseup", this.handleMouseUpHandler_), this.on(n, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */
  handleMouseUp(e) {
    const n = this.getChild("seekBar");
    n && n.handleMouseUp(e), this.removeListenersAddedOnMousedownAndTouchstart();
  }
}
g8.prototype.options_ = {
  children: ["seekBar"]
};
He.registerComponent("ProgressControl", g8);
class A8 extends ni {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @listens Player#enterpictureinpicture
   * @listens Player#leavepictureinpicture
   */
  constructor(e, n) {
    super(e, n), this.setIcon("picture-in-picture-enter"), this.on(e, ["enterpictureinpicture", "leavepictureinpicture"], (r) => this.handlePictureInPictureChange(r)), this.on(e, ["disablepictureinpicturechanged", "loadedmetadata"], (r) => this.handlePictureInPictureEnabledChange(r)), this.on(e, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], () => this.handlePictureInPictureAudioModeChange()), this.disable();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`;
  }
  /**
   * Displays or hides the button depending on the audio mode detection.
   * Exits picture-in-picture if it is enabled when switching to audio mode.
   */
  handlePictureInPictureAudioModeChange() {
    if (!(this.player_.currentType().substring(0, 5) === "audio" || this.player_.audioPosterMode() || this.player_.audioOnlyMode())) {
      this.show();
      return;
    }
    this.player_.isInPictureInPicture() && this.player_.exitPictureInPicture(), this.hide();
  }
  /**
   * Enables or disables button based on availability of a Picture-In-Picture mode.
   *
   * Enabled if
   * - `player.options().enableDocumentPictureInPicture` is true and
   *   window.documentPictureInPicture is available; or
   * - `player.disablePictureInPicture()` is false and
   *   element.requestPictureInPicture is available
   */
  handlePictureInPictureEnabledChange() {
    ot.pictureInPictureEnabled && this.player_.disablePictureInPicture() === !1 || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in pe ? this.enable() : this.disable();
  }
  /**
   * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.
   *
   * @param {Event} [event]
   *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be
   *        called.
   *
   * @listens Player#enterpictureinpicture
   * @listens Player#leavepictureinpicture
   */
  handlePictureInPictureChange(e) {
    this.player_.isInPictureInPicture() ? (this.setIcon("picture-in-picture-exit"), this.controlText("Exit Picture-in-Picture")) : (this.setIcon("picture-in-picture-enter"), this.controlText("Picture-in-Picture")), this.handlePictureInPictureEnabledChange();
  }
  /**
   * This gets called when an `PictureInPictureToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture();
  }
  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it only in browsers that support the Picture-in-Picture API.
   */
  show() {
    typeof ot.exitPictureInPicture == "function" && super.show();
  }
}
A8.prototype.controlText_ = "Picture-in-Picture";
He.registerComponent("PictureInPictureToggle", A8);
class b8 extends ni {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.setIcon("fullscreen-enter"), this.on(e, "fullscreenchange", (r) => this.handleFullscreenChange(r)), ot[e.fsApi_.fullscreenEnabled] === !1 && this.disable();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-fullscreen-control ${super.buildCSSClass()}`;
  }
  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */
  handleFullscreenChange(e) {
    this.player_.isFullscreen() ? (this.controlText("Exit Fullscreen"), this.setIcon("fullscreen-exit")) : (this.controlText("Fullscreen"), this.setIcon("fullscreen-enter"));
  }
  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen();
  }
}
b8.prototype.controlText_ = "Fullscreen";
He.registerComponent("FullscreenToggle", b8);
const cCe = function(t, e) {
  e.tech_ && !e.tech_.featuresVolumeControl && t.addClass("vjs-hidden"), t.on(e, "loadstart", function() {
    e.tech_.featuresVolumeControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden");
  });
};
class dCe extends He {
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl("div", {
      className: "vjs-volume-level"
    });
    return this.setIcon("circle", e), e.appendChild(super.createEl("span", {
      className: "vjs-control-text"
    })), e;
  }
}
He.registerComponent("VolumeLevel", dCe);
class fCe extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.update = pa(Un(this, this.update), hs);
  }
  /**
   * Create the volume tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-volume-tooltip"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Updates the position of the tooltip relative to the `VolumeBar` and
   * its content text.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   */
  update(e, n, r, i) {
    if (!r) {
      const s = pc(this.el_), a = pc(this.player_.el()), o = e.width * n;
      if (!a || !s)
        return;
      const u = e.left - a.left + o, c = e.width - o + (a.right - e.right);
      let d = s.width / 2;
      u < d ? d += d - u : c < d && (d = c), d < 0 ? d = 0 : d > s.width && (d = s.width), this.el_.style.right = `-${d}px`;
    }
    this.write(`${i}%`);
  }
  /**
   * Write the volume to the tooltip DOM element.
   *
   * @param {string} content
   *        The formatted volume for the tooltip.
   */
  write(e) {
    Uo(this.el_, e);
  }
  /**
   * Updates the position of the volume tooltip relative to the `VolumeBar`.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   * @param {number} volume
   *        The volume level to update the tooltip to
   *
   * @param {Function} cb
   *        A function that will be called during the request animation frame
   *        for tooltips that need to do additional animations from the default
   */
  updateVolume(e, n, r, i, s) {
    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", () => {
      this.update(e, n, r, i.toFixed(0)), s && s();
    });
  }
}
He.registerComponent("VolumeLevelTooltip", fCe);
class y8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.update = pa(Un(this, this.update), hs);
  }
  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-mouse-display"
    });
  }
  /**
   * Enquires updates to its own DOM as well as the DOM of its
   * {@link VolumeLevelTooltip} child.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   */
  update(e, n, r) {
    const i = 100 * n;
    this.getChild("volumeLevelTooltip").updateVolume(e, n, r, i, () => {
      r ? this.el_.style.bottom = `${e.height * n}px` : this.el_.style.left = `${e.width * n}px`;
    });
  }
}
y8.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
He.registerComponent("MouseVolumeLevelDisplay", y8);
class $g extends IT {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.on("slideractive", (r) => this.updateLastVolume_(r)), this.on(e, "volumechange", (r) => this.updateARIAAttributes(r)), e.ready(() => this.updateARIAAttributes());
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-volume-bar vjs-slider-bar"
    }, {
      "aria-label": this.localize("Volume Level"),
      "aria-live": "polite"
    });
  }
  /**
   * Handle mouse down on volume bar
   *
   * @param {Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */
  handleMouseDown(e) {
    Xf(e) && super.handleMouseDown(e);
  }
  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */
  handleMouseMove(e) {
    const n = this.getChild("mouseVolumeLevelDisplay");
    if (n) {
      const r = this.el(), i = pc(r), s = this.vertical();
      let a = Og(r, e);
      a = s ? a.y : a.x, a = Th(a, 0, 1), n.update(i, a, s);
    }
    Xf(e) && (this.checkMuted(), this.player_.volume(this.calculateDistance(e)));
  }
  /**
   * If the player is muted unmute it.
   */
  checkMuted() {
    this.player_.muted() && this.player_.muted(!1);
  }
  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */
  getPercent() {
    return this.player_.muted() ? 0 : this.player_.volume();
  }
  /**
   * Increase volume level for keyboard users
   */
  stepForward() {
    this.checkMuted(), this.player_.volume(this.player_.volume() + 0.1);
  }
  /**
   * Decrease volume level for keyboard users
   */
  stepBack() {
    this.checkMuted(), this.player_.volume(this.player_.volume() - 0.1);
  }
  /**
   * Update ARIA accessibility attributes
   *
   * @param {Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */
  updateARIAAttributes(e) {
    const n = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", n), this.el_.setAttribute("aria-valuetext", n + "%");
  }
  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */
  volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  }
  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */
  updateLastVolume_() {
    const e = this.player_.volume();
    this.one("sliderinactive", () => {
      this.player_.volume() === 0 && this.player_.lastVolume_(e);
    });
  }
}
$g.prototype.options_ = {
  children: ["volumeLevel"],
  barName: "volumeLevel"
};
!ei && !Ns && $g.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
$g.prototype.playerEvent = "volumechange";
He.registerComponent("VolumeBar", $g);
class v8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, n = {}) {
    n.vertical = n.vertical || !1, (typeof n.volumeBar > "u" || fc(n.volumeBar)) && (n.volumeBar = n.volumeBar || {}, n.volumeBar.vertical = n.vertical), super(e, n), cCe(this, e), this.throttledHandleMouseMove = pa(Un(this, this.handleMouseMove), hs), this.handleMouseUpHandler_ = (r) => this.handleMouseUp(r), this.on("mousedown", (r) => this.handleMouseDown(r)), this.on("touchstart", (r) => this.handleMouseDown(r)), this.on("mousemove", (r) => this.handleMouseMove(r)), this.on(this.volumeBar, ["focus", "slideractive"], () => {
      this.volumeBar.addClass("vjs-slider-active"), this.addClass("vjs-slider-active"), this.trigger("slideractive");
    }), this.on(this.volumeBar, ["blur", "sliderinactive"], () => {
      this.volumeBar.removeClass("vjs-slider-active"), this.removeClass("vjs-slider-active"), this.trigger("sliderinactive");
    });
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    let e = "vjs-volume-horizontal";
    return this.options_.vertical && (e = "vjs-volume-vertical"), super.createEl("div", {
      className: `vjs-volume-control vjs-control ${e}`
    });
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseDown(e) {
    const n = this.el_.ownerDocument;
    this.on(n, "mousemove", this.throttledHandleMouseMove), this.on(n, "touchmove", this.throttledHandleMouseMove), this.on(n, "mouseup", this.handleMouseUpHandler_), this.on(n, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */
  handleMouseUp(e) {
    const n = this.el_.ownerDocument;
    this.off(n, "mousemove", this.throttledHandleMouseMove), this.off(n, "touchmove", this.throttledHandleMouseMove), this.off(n, "mouseup", this.handleMouseUpHandler_), this.off(n, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseMove(e) {
    this.volumeBar.handleMouseMove(e);
  }
}
v8.prototype.options_ = {
  children: ["volumeBar"]
};
He.registerComponent("VolumeControl", v8);
const hCe = function(t, e) {
  e.tech_ && !e.tech_.featuresMuteControl && t.addClass("vjs-hidden"), t.on(e, "loadstart", function() {
    e.tech_.featuresMuteControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden");
  });
};
class T8 extends ni {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), hCe(this, e), this.on(e, ["loadstart", "volumechange"], (r) => this.update(r));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-mute-control ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    const n = this.player_.volume(), r = this.player_.lastVolume_();
    if (n === 0) {
      const i = r < 0.1 ? 0.1 : r;
      this.player_.volume(i), this.player_.muted(!1);
    } else
      this.player_.muted(!this.player_.muted());
  }
  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */
  update(e) {
    this.updateIcon_(), this.updateControlText_();
  }
  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */
  updateIcon_() {
    const e = this.player_.volume();
    let n = 3;
    this.setIcon("volume-high"), ei && this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted), e === 0 || this.player_.muted() ? (this.setIcon("volume-mute"), n = 0) : e < 0.33 ? (this.setIcon("volume-low"), n = 1) : e < 0.67 && (this.setIcon("volume-medium"), n = 2), Dg(this.el_, [0, 1, 2, 3].reduce((r, i) => r + `${i ? " " : ""}vjs-vol-${i}`, "")), Iu(this.el_, `vjs-vol-${n}`);
  }
  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */
  updateControlText_() {
    const n = this.player_.muted() || this.player_.volume() === 0 ? "Unmute" : "Mute";
    this.controlText() !== n && this.controlText(n);
  }
}
T8.prototype.controlText_ = "Mute";
He.registerComponent("MuteToggle", T8);
class _8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, n = {}) {
    typeof n.inline < "u" ? n.inline = n.inline : n.inline = !0, (typeof n.volumeControl > "u" || fc(n.volumeControl)) && (n.volumeControl = n.volumeControl || {}, n.volumeControl.vertical = !n.inline), super(e, n), this.handleKeyPressHandler_ = (r) => this.handleKeyPress(r), this.on(e, ["loadstart"], (r) => this.volumePanelState_(r)), this.on(this.muteToggle, "keyup", (r) => this.handleKeyPress(r)), this.on(this.volumeControl, "keyup", (r) => this.handleVolumeControlKeyUp(r)), this.on("keydown", (r) => this.handleKeyPress(r)), this.on("mouseover", (r) => this.handleMouseOver(r)), this.on("mouseout", (r) => this.handleMouseOut(r)), this.on(this.volumeControl, ["slideractive"], this.sliderActive_), this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_);
  }
  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */
  sliderActive_() {
    this.addClass("vjs-slider-active");
  }
  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */
  sliderInactive_() {
    this.removeClass("vjs-slider-active");
  }
  /**
   * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel
   * depending on MuteToggle and VolumeControl state
   *
   * @listens Player#loadstart
   * @private
   */
  volumePanelState_() {
    this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only");
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    let e = "vjs-volume-panel-horizontal";
    return this.options_.inline || (e = "vjs-volume-panel-vertical"), super.createEl("div", {
      className: `vjs-volume-panel vjs-control ${e}`
    });
  }
  /**
   * Dispose of the `volume-panel` and all child components.
   */
  dispose() {
    this.handleMouseOut(), super.dispose();
  }
  /**
   * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes
   * the volume panel and sets focus on `MuteToggle`.
   *
   * @param {Event} event
   *        The `keyup` event that caused this function to be called.
   *
   * @listens keyup
   */
  handleVolumeControlKeyUp(e) {
    e.key === "Escape" && this.muteToggle.focus();
  }
  /**
   * This gets called when a `VolumePanel` gains hover via a `mouseover` event.
   * Turns on listening for `mouseover` event. When they happen it
   * calls `this.handleMouseOver`.
   *
   * @param {Event} event
   *        The `mouseover` event that caused this function to be called.
   *
   * @listens mouseover
   */
  handleMouseOver(e) {
    this.addClass("vjs-hover"), Qi(ot, "keyup", this.handleKeyPressHandler_);
  }
  /**
   * This gets called when a `VolumePanel` gains hover via a `mouseout` event.
   * Turns on listening for `mouseout` event. When they happen it
   * calls `this.handleMouseOut`.
   *
   * @param {Event} event
   *        The `mouseout` event that caused this function to be called.
   *
   * @listens mouseout
   */
  handleMouseOut(e) {
    this.removeClass("vjs-hover"), ti(ot, "keyup", this.handleKeyPressHandler_);
  }
  /**
   * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,
   * looking for ESC, which hides the `VolumeControl`.
   *
   * @param {Event} event
   *        The keypress that triggered this event.
   *
   * @listens keydown | keyup
   */
  handleKeyPress(e) {
    e.key === "Escape" && this.handleMouseOut();
  }
}
_8.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
He.registerComponent("VolumePanel", _8);
class E8 extends ni {
  constructor(e, n) {
    super(e, n), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipForwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon(`forward-${this.skipTime}`), this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime.toLocaleString(e.language())])), this.show()) : this.hide();
  }
  getSkipForwardTime() {
    const e = this.options_.playerOptions;
    return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.forward;
  }
  buildCSSClass() {
    return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;
  }
  /**
   * On click, skips forward in the duration/seekable range by a configurable amount of seconds.
   * If the time left in the duration/seekable range is less than the configured 'skip forward' time,
   * skips to end of duration/seekable range.
   *
   * Handle a click on a `SkipForward` button
   *
   * @param {EventTarget~Event} event
   *        The `click` event that caused this function
   *        to be called
   */
  handleClick(e) {
    if (isNaN(this.player_.duration()))
      return;
    const n = this.player_.currentTime(), r = this.player_.liveTracker, i = r && r.isLive() ? r.seekableEnd() : this.player_.duration();
    let s;
    n + this.skipTime <= i ? s = n + this.skipTime : s = i, this.player_.currentTime(s);
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime]));
  }
}
E8.prototype.controlText_ = "Skip Forward";
He.registerComponent("SkipForward", E8);
class x8 extends ni {
  constructor(e, n) {
    super(e, n), this.validOptions = [5, 10, 30], this.skipTime = this.getSkipBackwardTime(), this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon(`replay-${this.skipTime}`), this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime.toLocaleString(e.language())])), this.show()) : this.hide();
  }
  getSkipBackwardTime() {
    const e = this.options_.playerOptions;
    return e.controlBar && e.controlBar.skipButtons && e.controlBar.skipButtons.backward;
  }
  buildCSSClass() {
    return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;
  }
  /**
   * On click, skips backward in the video by a configurable amount of seconds.
   * If the current time in the video is less than the configured 'skip backward' time,
   * skips to beginning of video or seekable range.
   *
   * Handle a click on a `SkipBackward` button
   *
   * @param {EventTarget~Event} event
   *        The `click` event that caused this function
   *        to be called
   */
  handleClick(e) {
    const n = this.player_.currentTime(), r = this.player_.liveTracker, i = r && r.isLive() && r.seekableStart();
    let s;
    i && n - this.skipTime <= i ? s = i : n >= this.skipTime ? s = n - this.skipTime : s = 0, this.player_.currentTime(s);
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime]));
  }
}
x8.prototype.controlText_ = "Skip Backward";
He.registerComponent("SkipBackward", x8);
class w8 extends He {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  constructor(e, n) {
    super(e, n), n && (this.menuButton_ = n.menuButton), this.focusedChild_ = -1, this.on("keydown", (r) => this.handleKeyDown(r)), this.boundHandleBlur_ = (r) => this.handleBlur(r), this.boundHandleTapClick_ = (r) => this.handleTapClick(r);
  }
  /**
   * Add event listeners to the {@link MenuItem}.
   *
   * @param {Object} component
   *        The instance of the `MenuItem` to add listeners to.
   *
   */
  addEventListenerForItem(e) {
    e instanceof He && (this.on(e, "blur", this.boundHandleBlur_), this.on(e, ["tap", "click"], this.boundHandleTapClick_));
  }
  /**
   * Remove event listeners from the {@link MenuItem}.
   *
   * @param {Object} component
   *        The instance of the `MenuItem` to remove listeners.
   *
   */
  removeEventListenerForItem(e) {
    e instanceof He && (this.off(e, "blur", this.boundHandleBlur_), this.off(e, ["tap", "click"], this.boundHandleTapClick_));
  }
  /**
   * This method will be called indirectly when the component has been added
   * before the component adds to the new menu instance by `addItem`.
   * In this case, the original menu instance will remove the component
   * by calling `removeChild`.
   *
   * @param {Object} component
   *        The instance of the `MenuItem`
   */
  removeChild(e) {
    typeof e == "string" && (e = this.getChild(e)), this.removeEventListenerForItem(e), super.removeChild(e);
  }
  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */
  addItem(e) {
    const n = this.addChild(e);
    n && this.addEventListenerForItem(n);
  }
  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */
  createEl() {
    const e = this.options_.contentElType || "ul";
    this.contentEl_ = Nt(e, {
      className: "vjs-menu-content"
    }), this.contentEl_.setAttribute("role", "menu");
    const n = super.createEl("div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    return n.appendChild(this.contentEl_), Qi(n, "click", function(r) {
      r.preventDefault(), r.stopImmediatePropagation();
    }), n;
  }
  dispose() {
    this.contentEl_ = null, this.boundHandleBlur_ = null, this.boundHandleTapClick_ = null, super.dispose();
  }
  /**
   * Called when a `MenuItem` loses focus.
   *
   * @param {Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */
  handleBlur(e) {
    const n = e.relatedTarget || ot.activeElement;
    if (!this.children().some((r) => r.el() === n)) {
      const r = this.menuButton_;
      r && r.buttonPressed_ && n !== r.el().firstChild && r.unpressButton();
    }
  }
  /**
   * Called when a `MenuItem` gets clicked or tapped.
   *
   * @param {Event} event
   *        The `click` or `tap` event that caused this function to be called.
   *
   * @listens click,tap
   */
  handleTapClick(e) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      const n = this.children();
      if (!Array.isArray(n))
        return;
      const r = n.filter((i) => i.el() === e.target)[0];
      if (!r)
        return;
      r.name() !== "CaptionSettingsMenuItem" && this.menuButton_.focus();
    }
  }
  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {KeyboardEvent} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === "ArrowLeft" || e.key === "ArrowDown" ? (e.preventDefault(), e.stopPropagation(), this.stepForward()) : (e.key === "ArrowRight" || e.key === "ArrowUp") && (e.preventDefault(), e.stopPropagation(), this.stepBack());
  }
  /**
   * Move to next (lower) menu item for keyboard users.
   */
  stepForward() {
    let e = 0;
    this.focusedChild_ !== void 0 && (e = this.focusedChild_ + 1), this.focus(e);
  }
  /**
   * Move to previous (higher) menu item for keyboard users.
   */
  stepBack() {
    let e = 0;
    this.focusedChild_ !== void 0 && (e = this.focusedChild_ - 1), this.focus(e);
  }
  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */
  focus(e = 0) {
    const n = this.children().slice();
    n.length && n[0].hasClass("vjs-menu-title") && n.shift(), n.length > 0 && (e < 0 ? e = 0 : e >= n.length && (e = n.length - 1), this.focusedChild_ = e, n[e].el_.focus());
  }
}
He.registerComponent("Menu", w8);
class DT extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, n = {}) {
    super(e, n), this.menuButton_ = new ni(e, n), this.menuButton_.controlText(this.controlText_), this.menuButton_.el_.setAttribute("aria-haspopup", "true");
    const r = ni.prototype.buildCSSClass();
    this.menuButton_.el_.className = this.buildCSSClass() + " " + r, this.menuButton_.removeClass("vjs-control"), this.addChild(this.menuButton_), this.update(), this.enabled_ = !0;
    const i = (s) => this.handleClick(s);
    this.handleMenuKeyUp_ = (s) => this.handleMenuKeyUp(s), this.on(this.menuButton_, "tap", i), this.on(this.menuButton_, "click", i), this.on(this.menuButton_, "keydown", (s) => this.handleKeyDown(s)), this.on(this.menuButton_, "mouseenter", () => {
      this.addClass("vjs-hover"), this.menu.show(), Qi(ot, "keyup", this.handleMenuKeyUp_);
    }), this.on("mouseleave", (s) => this.handleMouseLeave(s)), this.on("keydown", (s) => this.handleSubmenuKeyDown(s));
  }
  /**
   * Update the menu based on the current state of its items.
   */
  update() {
    const e = this.createMenu();
    this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = e, this.addChild(e), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? (this.hide(), this.menu.contentEl_.removeAttribute("role")) : (this.show(), this.menu.contentEl_.setAttribute("role", "menu"));
  }
  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */
  createMenu() {
    const e = new w8(this.player_, {
      menuButton: this
    });
    if (this.hideThreshold_ = 0, this.options_.title) {
      const n = Nt("li", {
        className: "vjs-menu-title",
        textContent: or(this.options_.title),
        tabIndex: -1
      }), r = new He(this.player_, {
        el: n
      });
      e.addItem(r);
    }
    if (this.items = this.createItems(), this.items)
      for (let n = 0; n < this.items.length; n++)
        e.addItem(this.items[n]);
    return e;
  }
  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */
  createItems() {
  }
  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildWrapperCSSClass()
    }, {});
  }
  /**
   * Overwrites the `setIcon` method from `Component`.
   * In this case, we want the icon to be appended to the menuButton.
   *
   * @param {string} name
   *         The icon name to be added.
   */
  setIcon(e) {
    super.setIcon(e, this.menuButton_.el_);
  }
  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */
  buildWrapperCSSClass() {
    let e = "vjs-menu-button";
    this.options_.inline === !0 ? e += "-inline" : e += "-popup";
    const n = ni.prototype.buildCSSClass();
    return `vjs-menu-button ${e} ${n} ${super.buildCSSClass()}`;
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    let e = "vjs-menu-button";
    return this.options_.inline === !0 ? e += "-inline" : e += "-popup", `vjs-menu-button ${e} ${super.buildCSSClass()}`;
  }
  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */
  controlText(e, n = this.menuButton_.el()) {
    return this.menuButton_.controlText(e, n);
  }
  /**
   * Dispose of the `menu-button` and all child components.
   */
  dispose() {
    this.handleMouseLeave(), super.dispose();
  }
  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.buttonPressed_ ? this.unpressButton() : this.pressButton();
  }
  /**
   * Handle `mouseleave` for `MenuButton`.
   *
   * @param {Event} event
   *        The `mouseleave` event that caused this function to be called.
   *
   * @listens mouseleave
   */
  handleMouseLeave(e) {
    this.removeClass("vjs-hover"), ti(ot, "keyup", this.handleMenuKeyUp_);
  }
  /**
   * Set the focus to the actual button, not to this element
   */
  focus() {
    this.menuButton_.focus();
  }
  /**
   * Remove the focus from the actual button, not this element
   */
  blur() {
    this.menuButton_.blur();
  }
  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyDown} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    e.key === "Escape" || e.key === "Tab" ? (this.buttonPressed_ && this.unpressButton(), !e.key === "Tab" && (e.preventDefault(), this.menuButton_.focus())) : (e.key === "Up" || e.key === "Down" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) && (this.buttonPressed_ || (e.preventDefault(), this.pressButton()));
  }
  /**
   * Handle a `keyup` event on a `MenuButton`. The listener for this is added in
   * the constructor.
   *
   * @param {Event} event
   *        Key press event
   *
   * @listens keyup
   */
  handleMenuKeyUp(e) {
    (e.key === "Escape" || e.key === "Tab") && this.removeClass("vjs-hover");
  }
  /**
   * This method name now delegates to `handleSubmenuKeyDown`. This means
   * anyone calling `handleSubmenuKeyPress` will not see their method calls
   * stop working.
   *
   * @param {Event} event
   *        The event that caused this function to be called.
   */
  handleSubmenuKeyPress(e) {
    this.handleSubmenuKeyDown(e);
  }
  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {Event} event
   *        Key press event
   *
   * @listens keydown
   */
  handleSubmenuKeyDown(e) {
    (e.key === "Escape" || e.key === "Tab") && (this.buttonPressed_ && this.unpressButton(), !e.key === "Tab" && (e.preventDefault(), this.menuButton_.focus()));
  }
  /**
   * Put the current `MenuButton` into a pressed state.
   */
  pressButton() {
    if (this.enabled_) {
      if (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), ei && PD())
        return;
      this.menu.focus();
    }
  }
  /**
   * Take the current `MenuButton` out of a pressed state.
   */
  unpressButton() {
    this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false"));
  }
  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */
  disable() {
    this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable();
  }
  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */
  enable() {
    this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable();
  }
}
He.registerComponent("MenuButton", DT);
class MT extends DT {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    const r = n.tracks;
    if (super(e, n), this.items.length <= 1 && this.hide(), !r)
      return;
    const i = Un(this, this.update);
    r.addEventListener("removetrack", i), r.addEventListener("addtrack", i), r.addEventListener("labelchange", i), this.player_.on("ready", i), this.player_.on("dispose", function() {
      r.removeEventListener("removetrack", i), r.removeEventListener("addtrack", i), r.removeEventListener("labelchange", i);
    });
  }
}
He.registerComponent("TrackButton", MT);
class _h extends Fg {
  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  constructor(e, n) {
    super(e, n), this.selectable = n.selectable, this.isSelected_ = n.selected || !1, this.multiSelectable = n.multiSelectable, this.selected(this.isSelected_), this.selectable ? this.multiSelectable ? this.el_.setAttribute("role", "menuitemcheckbox") : this.el_.setAttribute("role", "menuitemradio") : this.el_.setAttribute("role", "menuitem");
  }
  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(e, n, r) {
    this.nonIconControl = !0;
    const i = super.createEl("li", Object.assign({
      className: "vjs-menu-item",
      tabIndex: -1
    }, n), r), s = Nt("span", {
      className: "vjs-menu-item-text",
      textContent: this.localize(this.options_.label)
    });
    return this.player_.options_.experimentalSvgIcons ? i.appendChild(s) : i.replaceChild(s, i.querySelector(".vjs-icon-placeholder")), i;
  }
  /**
   * Ignore keys which are used by the menu, but pass any other ones up. See
   * {@link ClickableComponent#handleKeyDown} for instances where this is called.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    ["Tab", "Escape", "ArrowUp", "ArrowLeft", "ArrowRight", "ArrowDown"].includes(e.key) || super.handleKeyDown(e);
  }
  /**
   * Any click on a `MenuItem` puts it into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.selected(!0);
  }
  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */
  selected(e) {
    this.selectable && (e ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), this.isSelected_ = !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), this.isSelected_ = !1));
  }
}
He.registerComponent("MenuItem", _h);
class Eh extends _h {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    const r = n.track, i = e.textTracks();
    n.label = r.label || r.language || "Unknown", n.selected = r.mode === "showing", super(e, n), this.track = r, this.kinds = (n.kinds || [n.kind || this.track.kind]).filter(Boolean);
    const s = (...o) => {
      this.handleTracksChange.apply(this, o);
    }, a = (...o) => {
      this.handleSelectedLanguageChange.apply(this, o);
    };
    if (e.on(["loadstart", "texttrackchange"], s), i.addEventListener("change", s), i.addEventListener("selectedlanguagechange", a), this.on("dispose", function() {
      e.off(["loadstart", "texttrackchange"], s), i.removeEventListener("change", s), i.removeEventListener("selectedlanguagechange", a);
    }), i.onchange === void 0) {
      let o;
      this.on(["tap", "click"], function() {
        if (typeof pe.Event != "object")
          try {
            o = new pe.Event("change");
          } catch {
          }
        o || (o = ot.createEvent("Event"), o.initEvent("change", !0, !0)), i.dispatchEvent(o);
      });
    }
    this.handleTracksChange();
  }
  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    const n = this.track, r = this.player_.textTracks();
    if (super.handleClick(e), !!r)
      for (let i = 0; i < r.length; i++) {
        const s = r[i];
        this.kinds.indexOf(s.kind) !== -1 && (s === n ? s.mode !== "showing" && (s.mode = "showing") : s.mode !== "disabled" && (s.mode = "disabled"));
      }
  }
  /**
   * Handle text track list change
   *
   * @param {Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */
  handleTracksChange(e) {
    const n = this.track.mode === "showing";
    n !== this.isSelected_ && this.selected(n);
  }
  handleSelectedLanguageChange(e) {
    if (this.track.mode === "showing") {
      const n = this.player_.cache_.selectedLanguage;
      if (n && n.enabled && n.language === this.track.language && n.kind !== this.track.kind)
        return;
      this.player_.cache_.selectedLanguage = {
        enabled: !0,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  }
  dispose() {
    this.track = null, super.dispose();
  }
}
He.registerComponent("TextTrackMenuItem", Eh);
class C8 extends Eh {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    n.track = {
      player: e,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: n.kind,
      kinds: n.kinds,
      default: !1,
      mode: "disabled"
    }, n.kinds || (n.kinds = [n.kind]), n.label ? n.track.label = n.label : n.track.label = n.kinds.join(" and ") + " off", n.selectable = !0, n.multiSelectable = !1, super(e, n);
  }
  /**
   * Handle text track change
   *
   * @param {Event} event
   *        The event that caused this function to run
   */
  handleTracksChange(e) {
    const n = this.player().textTracks();
    let r = !0;
    for (let i = 0, s = n.length; i < s; i++) {
      const a = n[i];
      if (this.options_.kinds.indexOf(a.kind) > -1 && a.mode === "showing") {
        r = !1;
        break;
      }
    }
    r !== this.isSelected_ && this.selected(r);
  }
  handleSelectedLanguageChange(e) {
    const n = this.player().textTracks();
    let r = !0;
    for (let i = 0, s = n.length; i < s; i++) {
      const a = n[i];
      if (["captions", "descriptions", "subtitles"].indexOf(a.kind) > -1 && a.mode === "showing") {
        r = !1;
        break;
      }
    }
    r && (this.player_.cache_.selectedLanguage = {
      enabled: !1
    });
  }
  /**
   * Update control text and label on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label), super.handleLanguagechange();
  }
}
He.registerComponent("OffTextTrackMenuItem", C8);
class Vc extends MT {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, n = {}) {
    n.tracks = e.textTracks(), super(e, n);
  }
  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */
  createItems(e = [], n = Eh) {
    let r;
    this.label_ && (r = `${this.label_} off`), e.push(new C8(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label: r
    })), this.hideThreshold_ += 1;
    const i = this.player_.textTracks();
    Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]);
    for (let s = 0; s < i.length; s++) {
      const a = i[s];
      if (this.kinds_.indexOf(a.kind) > -1) {
        const o = new n(this.player_, {
          track: a,
          kinds: this.kinds_,
          kind: this.kind_,
          // MenuItem is selectable
          selectable: !0,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: !1
        });
        o.addClass(`vjs-${a.kind}-menu-item`), e.push(o);
      }
    }
    return e;
  }
}
He.registerComponent("TextTrackButton", Vc);
class S8 extends _h {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    const r = n.track, i = n.cue, s = e.currentTime();
    n.selectable = !0, n.multiSelectable = !1, n.label = i.text, n.selected = i.startTime <= s && s < i.endTime, super(e, n), this.track = r, this.cue = i;
  }
  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    super.handleClick(), this.player_.currentTime(this.cue.startTime);
  }
}
He.registerComponent("ChaptersTrackMenuItem", S8);
class OT extends Vc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this function is ready.
   */
  constructor(e, n, r) {
    super(e, n, r), this.setIcon("chapters"), this.selectCurrentItem_ = () => {
      this.items.forEach((i) => {
        i.selected(this.track_.activeCues[0] === i.cue);
      });
    };
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-chapters-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Update the menu based on the current state of its items.
   *
   * @param {Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */
  update(e) {
    if (e && e.track && e.track.kind !== "chapters")
      return;
    const n = this.findChaptersTrack();
    n !== this.track_ ? (this.setTrack(n), super.update()) : (!this.items || n && n.cues && n.cues.length !== this.items.length) && super.update();
  }
  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */
  setTrack(e) {
    if (this.track_ !== e) {
      if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) {
        const n = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        n && n.removeEventListener("load", this.updateHandler_), this.track_.removeEventListener("cuechange", this.selectCurrentItem_), this.track_ = null;
      }
      if (this.track_ = e, this.track_) {
        this.track_.mode = "hidden";
        const n = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
        n && n.addEventListener("load", this.updateHandler_), this.track_.addEventListener("cuechange", this.selectCurrentItem_);
      }
    }
  }
  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */
  findChaptersTrack() {
    const e = this.player_.textTracks() || [];
    for (let n = e.length - 1; n >= 0; n--) {
      const r = e[n];
      if (r.kind === this.kind_)
        return r;
    }
  }
  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */
  getMenuCaption() {
    return this.track_ && this.track_.label ? this.track_.label : this.localize(or(this.kind_));
  }
  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */
  createMenu() {
    return this.options_.title = this.getMenuCaption(), super.createMenu();
  }
  /**
   * Create a menu item for each text track
   *
   * @return  {TextTrackMenuItem[]}
   *         Array of menu items
   */
  createItems() {
    const e = [];
    if (!this.track_)
      return e;
    const n = this.track_.cues;
    if (!n)
      return e;
    for (let r = 0, i = n.length; r < i; r++) {
      const s = n[r], a = new S8(this.player_, {
        track: this.track_,
        cue: s
      });
      e.push(a);
    }
    return e;
  }
}
OT.prototype.kind_ = "chapters";
OT.prototype.controlText_ = "Chapters";
He.registerComponent("ChaptersButton", OT);
class NT extends Vc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, n, r) {
    super(e, n, r), this.setIcon("audio-description");
    const i = e.textTracks(), s = Un(this, this.handleTracksChange);
    i.addEventListener("change", s), this.on("dispose", function() {
      i.removeEventListener("change", s);
    });
  }
  /**
   * Handle text track change
   *
   * @param {Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */
  handleTracksChange(e) {
    const n = this.player().textTracks();
    let r = !1;
    for (let i = 0, s = n.length; i < s; i++) {
      const a = n[i];
      if (a.kind !== this.kind_ && a.mode === "showing") {
        r = !0;
        break;
      }
    }
    r ? this.disable() : this.enable();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-descriptions-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;
  }
}
NT.prototype.kind_ = "descriptions";
NT.prototype.controlText_ = "Descriptions";
He.registerComponent("DescriptionsButton", NT);
class LT extends Vc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, n, r) {
    super(e, n, r), this.setIcon("subtitles");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-subtitles-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;
  }
}
LT.prototype.kind_ = "subtitles";
LT.prototype.controlText_ = "Subtitles";
He.registerComponent("SubtitlesButton", LT);
class PT extends Eh {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    n.track = {
      player: e,
      kind: n.kind,
      label: n.kind + " settings",
      selectable: !1,
      default: !1,
      mode: "disabled"
    }, n.selectable = !1, n.name = "CaptionSettingsMenuItem", super(e, n), this.addClass("vjs-texttrack-settings"), this.controlText(", opens " + n.kind + " settings dialog");
  }
  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    this.player().getChild("textTrackSettings").open();
  }
  /**
   * Update control text and label on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings"), super.handleLanguagechange();
  }
}
He.registerComponent("CaptionSettingsMenuItem", PT);
class RT extends Vc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, n, r) {
    super(e, n, r), this.setIcon("captions");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-captions-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-captions-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */
  createItems() {
    const e = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (e.push(new PT(this.player_, {
      kind: this.kind_
    })), this.hideThreshold_ += 1), super.createItems(e);
  }
}
RT.prototype.kind_ = "captions";
RT.prototype.controlText_ = "Captions";
He.registerComponent("CaptionsButton", RT);
class I8 extends Eh {
  createEl(e, n, r) {
    const i = super.createEl(e, n, r), s = i.querySelector(".vjs-menu-item-text");
    return this.options_.track.kind === "captions" && (this.player_.options_.experimentalSvgIcons ? this.setIcon("captions", i) : s.appendChild(Nt("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), s.appendChild(Nt("span", {
      className: "vjs-control-text",
      // space added as the text will visually flow with the
      // label
      textContent: ` ${this.localize("Captions")}`
    }))), i;
  }
}
He.registerComponent("SubsCapsMenuItem", I8);
class BT extends Vc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(e, n = {}) {
    super(e, n), this.label_ = "subtitles", this.setIcon("subtitles"), ["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) > -1 && (this.label_ = "captions", this.setIcon("captions")), this.menuButton_.controlText(or(this.label_));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-subs-caps-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */
  createItems() {
    let e = [];
    return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (e.push(new PT(this.player_, {
      kind: this.label_
    })), this.hideThreshold_ += 1), e = super.createItems(e, I8), e;
  }
}
BT.prototype.kinds_ = ["captions", "subtitles"];
BT.prototype.controlText_ = "Subtitles";
He.registerComponent("SubsCapsButton", BT);
class k8 extends _h {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    const r = n.track, i = e.audioTracks();
    n.label = r.label || r.language || "Unknown", n.selected = r.enabled, super(e, n), this.track = r, this.addClass(`vjs-${r.kind}-menu-item`);
    const s = (...a) => {
      this.handleTracksChange.apply(this, a);
    };
    i.addEventListener("change", s), this.on("dispose", () => {
      i.removeEventListener("change", s);
    });
  }
  createEl(e, n, r) {
    const i = super.createEl(e, n, r), s = i.querySelector(".vjs-menu-item-text");
    return ["main-desc", "descriptions"].indexOf(this.options_.track.kind) >= 0 && (s.appendChild(Nt("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": !0
    })), s.appendChild(Nt("span", {
      className: "vjs-control-text",
      textContent: " " + this.localize("Descriptions")
    }))), i;
  }
  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    if (super.handleClick(e), this.track.enabled = !0, this.player_.tech_.featuresNativeAudioTracks) {
      const n = this.player_.audioTracks();
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        i !== this.track && (i.enabled = i === this.track);
      }
    }
  }
  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */
  handleTracksChange(e) {
    this.selected(this.track.enabled);
  }
}
He.registerComponent("AudioTrackMenuItem", k8);
class D8 extends MT {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(e, n = {}) {
    n.tracks = e.audioTracks(), super(e, n), this.setIcon("audio");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-audio-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-audio-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */
  createItems(e = []) {
    this.hideThreshold_ = 1;
    const n = this.player_.audioTracks();
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      e.push(new k8(this.player_, {
        track: i,
        // MenuItem is selectable
        selectable: !0,
        // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
        multiSelectable: !1
      }));
    }
    return e;
  }
}
D8.prototype.controlText_ = "Audio Track";
He.registerComponent("AudioTrackButton", D8);
class FT extends _h {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    const r = n.rate, i = parseFloat(r, 10);
    n.label = r, n.selected = i === e.playbackRate(), n.selectable = !0, n.multiSelectable = !1, super(e, n), this.label = r, this.rate = i, this.on(e, "ratechange", (s) => this.update(s));
  }
  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(e) {
    super.handleClick(), this.player().playbackRate(this.rate);
  }
  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */
  update(e) {
    this.selected(this.player().playbackRate() === this.rate);
  }
}
FT.prototype.contentElType = "button";
He.registerComponent("PlaybackRateMenuItem", FT);
class M8 extends DT {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_), this.updateVisibility(), this.updateLabel(), this.on(e, "loadstart", (r) => this.updateVisibility(r)), this.on(e, "ratechange", (r) => this.updateLabel(r)), this.on(e, "playbackrateschange", (r) => this.handlePlaybackRateschange(r));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const e = super.createEl();
    return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_, this.labelEl_ = Nt("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    }), e.appendChild(this.labelEl_), e;
  }
  dispose() {
    this.labelEl_ = null, super.dispose();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-playback-rate ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create the list of menu items. Specific to each subclass.
   *
   */
  createItems() {
    const e = this.playbackRates(), n = [];
    for (let r = e.length - 1; r >= 0; r--)
      n.push(new FT(this.player(), {
        rate: e[r] + "x"
      }));
    return n;
  }
  /**
   * On playbackrateschange, update the menu to account for the new items.
   *
   * @listens Player#playbackrateschange
   */
  handlePlaybackRateschange(e) {
    this.update();
  }
  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */
  playbackRates() {
    const e = this.player();
    return e.playbackRates && e.playbackRates() || [];
  }
  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */
  playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  }
  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */
  updateVisibility(e) {
    this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden");
  }
  /**
   * Update button label when rate changed
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */
  updateLabel(e) {
    this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x");
  }
}
M8.prototype.controlText_ = "Playback Rate";
He.registerComponent("PlaybackRateMenuButton", M8);
class O8 extends He {
  /**
  * Builds the default DOM `className`.
  *
  * @return {string}
  *         The DOM `className` for this object.
  */
  buildCSSClass() {
    return `vjs-spacer ${super.buildCSSClass()}`;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl(e = "div", n = {}, r = {}) {
    return n.className || (n.className = this.buildCSSClass()), super.createEl(e, n, r);
  }
}
He.registerComponent("Spacer", O8);
class pCe extends O8 {
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-custom-control-spacer ${super.buildCSSClass()}`;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: " "
    });
  }
}
He.registerComponent("CustomControlSpacer", pCe);
class N8 extends He {
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  }
}
N8.prototype.options_ = {
  children: ["playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "pictureInPictureToggle", "fullscreenToggle"]
};
He.registerComponent("ControlBar", N8);
class L8 extends zc {
  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  constructor(e, n) {
    super(e, n), this.on(e, "error", (r) => {
      this.open(r);
    });
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */
  buildCSSClass() {
    return `vjs-error-display ${super.buildCSSClass()}`;
  }
  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */
  content() {
    const e = this.player().error();
    return e ? this.localize(e.message) : "";
  }
}
L8.prototype.options_ = Object.assign({}, zc.prototype.options_, {
  pauseOnOpen: !1,
  fillAlways: !0,
  temporary: !1,
  uncloseable: !0
});
He.registerComponent("ErrorDisplay", L8);
class P8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.legendId]
   *        A text with part of an string to create atribute of aria-labelledby.
   *
   * @param {string} [options.id]
   *        A text with part of an string to create atribute of aria-labelledby.
   *
   * @param {Array} [options.SelectOptions]
   *        Array that contains the value & textContent of for each of the
   *        options elements.
   */
  constructor(e, n = {}) {
    super(e, n), this.el_.setAttribute("aria-labelledby", this.selectLabelledbyIds);
  }
  /**
   * Create the `TextTrackSelect`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return this.selectLabelledbyIds = [this.options_.legendId, this.options_.labelId].join(" ").trim(), Nt("select", {
      id: this.options_.id
    }, {}, this.options_.SelectOptions.map((n) => {
      const r = (this.options_.labelId ? this.options_.labelId : `vjs-track-option-${fs()}`) + "-" + n[1].replace(/\W+/g, ""), i = Nt("option", {
        id: r,
        value: this.localize(n[0]),
        textContent: this.localize(n[1])
      });
      return i.setAttribute("aria-labelledby", `${this.selectLabelledbyIds} ${r}`), i;
    }));
  }
}
He.registerComponent("TextTrackSelect", P8);
class Du extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.legendId]
   *        A text with part of an string to create atribute of aria-labelledby.
   *        It passes to 'TextTrackSelect'.
   *
   * @param {string} [options.id]
   *        A text with part of an string to create atribute of aria-labelledby.
   *        It passes to 'TextTrackSelect'.
   *
   * @param {string} [options.legendText]
   *        A text to use as the text content of the legend element.
   *
   * @param {Array} [options.selects]
   *        Array that contains the selects that are use to create 'selects'
   *        components.
   *
   * @param {Array} [options.SelectOptions]
   *        Array that contains the value & textContent of for each of the
   *        options elements, it passes to 'TextTrackSelect'.
   *
   * @param {string} [options.type]
   *        Conditions if some DOM elements will be added to the fieldset
   *        component.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the selects configurations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        These properties are use to configure the 'TextTrackSelect' Component.
   */
  constructor(e, n = {}) {
    super(e, n);
    const r = Nt("legend", {
      textContent: this.localize(this.options_.legendText),
      id: this.options_.legendId
    });
    this.el().appendChild(r);
    const i = this.options_.selects;
    for (const s of i) {
      const a = this.options_.selectConfigs[s], o = a.className, u = a.id.replace("%s", this.options_.id_);
      let c = null;
      const d = `vjs_select_${fs()}`;
      if (this.options_.type === "colors") {
        c = Nt("span", {
          className: o
        });
        const f = Nt("label", {
          id: u,
          className: "vjs-label",
          textContent: this.localize(a.label)
        });
        f.setAttribute("for", d), c.appendChild(f);
      }
      const l = new P8(e, {
        SelectOptions: a.options,
        legendId: this.options_.legendId,
        id: d,
        labelId: u
      });
      this.addChild(l), this.options_.type === "colors" && (c.appendChild(l.el()), this.el().appendChild(c));
    }
  }
  /**
   * Create the `TextTrackFieldset`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Nt("fieldset", {
      // Prefixing classes of elements within a player with "vjs-"
      // is a convention used in Video.js.
      className: this.options_.className
    });
  }
}
He.registerComponent("TextTrackFieldset", Du);
class R8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {Array} [options.fieldSets]
   *        Array that contains the configurations for the selects.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the select confugations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        it passes to 'TextTrackFieldset'.
   */
  constructor(e, n = {}) {
    super(e, n);
    const r = this.options_.textTrackComponentid, i = new Du(e, {
      id_: r,
      legendId: `captions-text-legend-${r}`,
      legendText: this.localize("Text"),
      className: "vjs-fg vjs-track-setting",
      selects: this.options_.fieldSets[0],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(i);
    const s = new Du(e, {
      id_: r,
      legendId: `captions-background-${r}`,
      legendText: this.localize("Text Background"),
      className: "vjs-bg vjs-track-setting",
      selects: this.options_.fieldSets[1],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(s);
    const a = new Du(e, {
      id_: r,
      legendId: `captions-window-${r}`,
      legendText: this.localize("Caption Area Background"),
      className: "vjs-window vjs-track-setting",
      selects: this.options_.fieldSets[2],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(a);
  }
  /**
   * Create the `TextTrackSettingsColors`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Nt("div", {
      className: "vjs-track-settings-colors"
    });
  }
}
He.registerComponent("TextTrackSettingsColors", R8);
class B8 extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {Array} [options.fieldSets]
   *        Array that contains the configurations for the selects.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the select confugations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        it passes to 'TextTrackFieldset'.
   */
  constructor(e, n = {}) {
    super(e, n);
    const r = this.options_.textTrackComponentid, i = new Du(e, {
      id_: r,
      legendId: `captions-font-size-${r}`,
      legendText: "Font Size",
      className: "vjs-font-percent vjs-track-setting",
      selects: this.options_.fieldSets[0],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(i);
    const s = new Du(e, {
      id_: r,
      legendId: `captions-edge-style-${r}`,
      legendText: this.localize("Text Edge Style"),
      className: "vjs-edge-style vjs-track-setting",
      selects: this.options_.fieldSets[1],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(s);
    const a = new Du(e, {
      id_: r,
      legendId: `captions-font-family-${r}`,
      legendText: this.localize("Font Family"),
      className: "vjs-font-family vjs-track-setting",
      selects: this.options_.fieldSets[2],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(a);
  }
  /**
   * Create the `TextTrackSettingsFont`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Nt("div", {
      className: "vjs-track-settings-font"
    });
  }
}
He.registerComponent("TextTrackSettingsFont", B8);
class F8 extends He {
  constructor(e, n = {}) {
    super(e, n);
    const r = new ni(e, {
      controlText: this.localize("restore all settings to the default values"),
      className: "vjs-default-button"
    });
    r.el().classList.remove("vjs-control", "vjs-button"), r.el().textContent = this.localize("Reset"), this.addChild(r);
    const i = this.localize("Done"), s = new ni(e, {
      controlText: i,
      className: "vjs-done-button"
    });
    s.el().classList.remove("vjs-control", "vjs-button"), s.el().textContent = i, this.addChild(s);
  }
  /**
   * Create the `TrackSettingsControls`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return Nt("div", {
      className: "vjs-track-settings-controls"
    });
  }
}
He.registerComponent("TrackSettingsControls", F8);
const i2 = "vjs-text-track-settings", ew = ["#000", "Black"], tw = ["#00F", "Blue"], nw = ["#0FF", "Cyan"], rw = ["#0F0", "Green"], iw = ["#F0F", "Magenta"], sw = ["#F00", "Red"], aw = ["#FFF", "White"], ow = ["#FF0", "Yellow"], s2 = ["1", "Opaque"], a2 = ["0.5", "Semi-Transparent"], uw = ["0", "Transparent"], go = {
  backgroundColor: {
    selector: ".vjs-bg-color > select",
    id: "captions-background-color-%s",
    label: "Color",
    options: [ew, aw, sw, rw, tw, ow, iw, nw],
    className: "vjs-bg-color"
  },
  backgroundOpacity: {
    selector: ".vjs-bg-opacity > select",
    id: "captions-background-opacity-%s",
    label: "Opacity",
    options: [s2, a2, uw],
    className: "vjs-bg-opacity vjs-opacity"
  },
  color: {
    selector: ".vjs-text-color > select",
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [aw, ew, sw, rw, tw, ow, iw, nw],
    className: "vjs-text-color"
  },
  edgeStyle: {
    selector: ".vjs-edge-style > select",
    id: "",
    label: "Text Edge Style",
    options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Drop shadow"]]
  },
  fontFamily: {
    selector: ".vjs-font-family > select",
    id: "",
    label: "Font Family",
    options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
  },
  fontPercent: {
    selector: ".vjs-font-percent > select",
    id: "",
    label: "Font Size",
    options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
    default: 2,
    parser: (t) => t === "1.00" ? null : Number(t)
  },
  textOpacity: {
    selector: ".vjs-text-opacity > select",
    id: "captions-foreground-opacity-%s",
    label: "Opacity",
    options: [s2, a2],
    className: "vjs-text-opacity vjs-opacity"
  },
  // Options for this object are defined below.
  windowColor: {
    selector: ".vjs-window-color > select",
    id: "captions-window-color-%s",
    label: "Color",
    className: "vjs-window-color"
  },
  // Options for this object are defined below.
  windowOpacity: {
    selector: ".vjs-window-opacity > select",
    id: "captions-window-opacity-%s",
    label: "Opacity",
    options: [uw, a2, s2],
    className: "vjs-window-opacity vjs-opacity"
  }
};
go.windowColor.options = go.backgroundColor.options;
function U8(t, e) {
  if (e && (t = e(t)), t && t !== "none")
    return t;
}
function mCe(t, e) {
  const n = t.options[t.options.selectedIndex].value;
  return U8(n, e);
}
function gCe(t, e, n) {
  if (e) {
    for (let r = 0; r < t.options.length; r++)
      if (U8(t.options[r].value, n) === e) {
        t.selectedIndex = r;
        break;
      }
  }
}
class ACe extends zc {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  constructor(e, n) {
    n.temporary = !1, super(e, n), this.updateDisplay = this.updateDisplay.bind(this), this.fill(), this.hasBeenOpened_ = this.hasBeenFilled_ = !0, this.renderModalComponents(e), this.endDialog = Nt("p", {
      className: "vjs-control-text",
      textContent: this.localize("End of dialog window.")
    }), this.el().appendChild(this.endDialog), this.setDefaults(), n.persistTextTrackSettings === void 0 && (this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings), this.bindFunctionsToSelectsAndButtons(), this.options_.persistTextTrackSettings && this.restoreSettings();
  }
  renderModalComponents(e) {
    const n = new R8(e, {
      textTrackComponentid: this.id_,
      selectConfigs: go,
      fieldSets: [["color", "textOpacity"], ["backgroundColor", "backgroundOpacity"], ["windowColor", "windowOpacity"]]
    });
    this.addChild(n);
    const r = new B8(e, {
      textTrackComponentid: this.id_,
      selectConfigs: go,
      fieldSets: [["fontPercent"], ["edgeStyle"], ["fontFamily"]]
    });
    this.addChild(r);
    const i = new F8(e);
    this.addChild(i);
  }
  bindFunctionsToSelectsAndButtons() {
    this.on(this.$(".vjs-done-button"), ["click", "tap"], () => {
      this.saveSettings(), this.close();
    }), this.on(this.$(".vjs-default-button"), ["click", "tap"], () => {
      this.setDefaults(), this.updateDisplay();
    }), Vl(go, (e) => {
      this.on(this.$(e.selector), "change", this.updateDisplay);
    });
  }
  dispose() {
    this.endDialog = null, super.dispose();
  }
  label() {
    return this.localize("Caption Settings Dialog");
  }
  description() {
    return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
  }
  buildCSSClass() {
    return super.buildCSSClass() + " vjs-text-track-settings";
  }
  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */
  getValues() {
    return ID(go, (e, n, r) => {
      const i = mCe(this.$(n.selector), n.parser);
      return i !== void 0 && (e[r] = i), e;
    }, {});
  }
  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */
  setValues(e) {
    Vl(go, (n, r) => {
      gCe(this.$(n.selector), e[r], n.parser);
    });
  }
  /**
   * Sets all `<select>` elements to their default values.
   */
  setDefaults() {
    Vl(go, (e) => {
      const n = e.hasOwnProperty("default") ? e.default : 0;
      this.$(e.selector).selectedIndex = n;
    });
  }
  /**
   * Restore texttrack settings from localStorage
   */
  restoreSettings() {
    let e;
    try {
      e = JSON.parse(pe.localStorage.getItem(i2));
    } catch (n) {
      Kt.warn(n);
    }
    e && this.setValues(e);
  }
  /**
   * Save text track settings to localStorage
   */
  saveSettings() {
    if (!this.options_.persistTextTrackSettings)
      return;
    const e = this.getValues();
    try {
      Object.keys(e).length ? pe.localStorage.setItem(i2, JSON.stringify(e)) : pe.localStorage.removeItem(i2);
    } catch (n) {
      Kt.warn(n);
    }
  }
  /**
   * Update display of text track settings
   */
  updateDisplay() {
    const e = this.player_.getChild("textTrackDisplay");
    e && e.updateDisplay();
  }
  /**
   * Repopulate dialog with new localizations on languagechange
   */
  handleLanguagechange() {
    this.fill(), this.renderModalComponents(this.player_), this.bindFunctionsToSelectsAndButtons();
  }
}
He.registerComponent("TextTrackSettings", ACe);
class bCe extends He {
  /**
   * Create the ResizeManager.
   *
   * @param {Object} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of ResizeManager options.
   *
   * @param {Object} [options.ResizeObserver]
   *        A polyfill for ResizeObserver can be passed in here.
   *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.
   */
  constructor(e, n) {
    let r = n.ResizeObserver || pe.ResizeObserver;
    n.ResizeObserver === null && (r = !1);
    const i = Dn({
      createEl: !r,
      reportTouchActivity: !1
    }, n);
    super(e, i), this.ResizeObserver = n.ResizeObserver || pe.ResizeObserver, this.loadListener_ = null, this.resizeObserver_ = null, this.debouncedHandler_ = KD(() => {
      this.resizeHandler();
    }, 100, !1, this), r ? (this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_), this.resizeObserver_.observe(e.el())) : (this.loadListener_ = () => {
      if (!this.el_ || !this.el_.contentWindow)
        return;
      const s = this.debouncedHandler_;
      let a = this.unloadListener_ = function() {
        ti(this, "resize", s), ti(this, "unload", a), a = null;
      };
      Qi(this.el_.contentWindow, "unload", a), Qi(this.el_.contentWindow, "resize", s);
    }, this.one("load", this.loadListener_));
  }
  createEl() {
    return super.createEl("iframe", {
      className: "vjs-resize-manager",
      tabIndex: -1,
      title: this.localize("No content")
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver
   *
   * @fires Player#playerresize
   */
  resizeHandler() {
    !this.player_ || !this.player_.trigger || this.player_.trigger("playerresize");
  }
  dispose() {
    this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.loadListener_ && this.off("load", this.loadListener_), this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null, super.dispose();
  }
}
He.registerComponent("ResizeManager", bCe);
const yCe = {
  trackingThreshold: 20,
  liveTolerance: 15
};
class vCe extends He {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {number} [options.trackingThreshold=20]
   *        Number of seconds of live window (seekableEnd - seekableStart) that
   *        media needs to have before the liveui will be shown.
   *
   * @param {number} [options.liveTolerance=15]
   *        Number of seconds behind live that we have to be
   *        before we will be considered non-live. Note that this will only
   *        be used when playing at the live edge. This allows large seekable end
   *        changes to not effect whether we are live or not.
   */
  constructor(e, n) {
    const r = Dn(yCe, n, {
      createEl: !1
    });
    super(e, r), this.trackLiveHandler_ = () => this.trackLive_(), this.handlePlay_ = (i) => this.handlePlay(i), this.handleFirstTimeupdate_ = (i) => this.handleFirstTimeupdate(i), this.handleSeeked_ = (i) => this.handleSeeked(i), this.seekToLiveEdge_ = (i) => this.seekToLiveEdge(i), this.reset_(), this.on(this.player_, "durationchange", (i) => this.handleDurationchange(i)), this.on(this.player_, "canplay", () => this.toggleTracking());
  }
  /**
   * all the functionality for tracking when seek end changes
   * and for tracking how far past seek end we should be
   */
  trackLive_() {
    const e = this.player_.seekable();
    if (!e || !e.length)
      return;
    const n = Number(pe.performance.now().toFixed(4)), r = this.lastTime_ === -1 ? 0 : (n - this.lastTime_) / 1e3;
    this.lastTime_ = n, this.pastSeekEnd_ = this.pastSeekEnd() + r;
    const i = this.liveCurrentTime(), s = this.player_.currentTime();
    let a = this.player_.paused() || this.seekedBehindLive_ || Math.abs(i - s) > this.options_.liveTolerance;
    (!this.timeupdateSeen_ || i === 1 / 0) && (a = !1), a !== this.behindLiveEdge_ && (this.behindLiveEdge_ = a, this.trigger("liveedgechange"));
  }
  /**
   * handle a durationchange event on the player
   * and start/stop tracking accordingly.
   */
  handleDurationchange() {
    this.toggleTracking();
  }
  /**
   * start/stop tracking
   */
  toggleTracking() {
    this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"), this.startTracking()) : (this.player_.removeClass("vjs-liveui"), this.stopTracking());
  }
  /**
   * start tracking live playback
   */
  startTracking() {
    this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()), this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, hs), this.trackLive_(), this.on(this.player_, ["play", "pause"], this.trackLiveHandler_), this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_), this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_)));
  }
  /**
   * handle the first timeupdate on the player if it wasn't already playing
   * when live tracker started tracking.
   */
  handleFirstTimeupdate() {
    this.timeupdateSeen_ = !0, this.on(this.player_, "seeked", this.handleSeeked_);
  }
  /**
   * Keep track of what time a seek starts, and listen for seeked
   * to find where a seek ends.
   */
  handleSeeked() {
    const e = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && e > 2, this.nextSeekedFromUser_ = !1, this.trackLive_();
  }
  /**
   * handle the first play on the player, and make sure that we seek
   * right to the live edge.
   */
  handlePlay() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  }
  /**
   * Stop tracking, and set all internal variables to
   * their initial value.
   */
  reset_() {
    this.lastTime_ = -1, this.pastSeekEnd_ = 0, this.lastSeekEnd_ = -1, this.behindLiveEdge_ = !0, this.timeupdateSeen_ = !1, this.seekedBehindLive_ = !1, this.nextSeekedFromUser_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.off(this.player_, ["play", "pause"], this.trackLiveHandler_), this.off(this.player_, "seeked", this.handleSeeked_), this.off(this.player_, "play", this.handlePlay_), this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_), this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  }
  /**
   * The next seeked event is from the user. Meaning that any seek
   * > 2s behind live will be considered behind live for real and
   * liveTolerance will be ignored.
   */
  nextSeekedFromUser() {
    this.nextSeekedFromUser_ = !0;
  }
  /**
   * stop tracking live playback
   */
  stopTracking() {
    this.isTracking() && (this.reset_(), this.trigger("liveedgechange"));
  }
  /**
   * A helper to get the player seekable end
   * so that we don't have to null check everywhere
   *
   * @return {number}
   *         The furthest seekable end or Infinity.
   */
  seekableEnd() {
    const e = this.player_.seekable(), n = [];
    let r = e ? e.length : 0;
    for (; r--; )
      n.push(e.end(r));
    return n.length ? n.sort()[n.length - 1] : 1 / 0;
  }
  /**
   * A helper to get the player seekable start
   * so that we don't have to null check everywhere
   *
   * @return {number}
   *         The earliest seekable start or 0.
   */
  seekableStart() {
    const e = this.player_.seekable(), n = [];
    let r = e ? e.length : 0;
    for (; r--; )
      n.push(e.start(r));
    return n.length ? n.sort()[0] : 0;
  }
  /**
   * Get the live time window aka
   * the amount of time between seekable start and
   * live current time.
   *
   * @return {number}
   *         The amount of seconds that are seekable in
   *         the live video.
   */
  liveWindow() {
    const e = this.liveCurrentTime();
    return e === 1 / 0 ? 0 : e - this.seekableStart();
  }
  /**
   * Determines if the player is live, only checks if this component
   * is tracking live playback or not
   *
   * @return {boolean}
   *         Whether liveTracker is tracking
   */
  isLive() {
    return this.isTracking();
  }
  /**
   * Determines if currentTime is at the live edge and won't fall behind
   * on each seekableendchange
   *
   * @return {boolean}
   *         Whether playback is at the live edge
   */
  atLiveEdge() {
    return !this.behindLiveEdge();
  }
  /**
   * get what we expect the live current time to be
   *
   * @return {number}
   *         The expected live current time
   */
  liveCurrentTime() {
    return this.pastSeekEnd() + this.seekableEnd();
  }
  /**
   * The number of seconds that have occurred after seekable end
   * changed. This will be reset to 0 once seekable end changes.
   *
   * @return {number}
   *         Seconds past the current seekable end
   */
  pastSeekEnd() {
    const e = this.seekableEnd();
    return this.lastSeekEnd_ !== -1 && e !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0), this.lastSeekEnd_ = e, this.pastSeekEnd_;
  }
  /**
   * If we are currently behind the live edge, aka currentTime will be
   * behind on a seekableendchange
   *
   * @return {boolean}
   *         If we are behind the live edge
   */
  behindLiveEdge() {
    return this.behindLiveEdge_;
  }
  /**
   * Whether live tracker is currently tracking or not.
   */
  isTracking() {
    return typeof this.trackingInterval_ == "number";
  }
  /**
   * Seek to the live edge if we are behind the live edge
   */
  seekToLiveEdge() {
    this.seekedBehindLive_ = !1, !this.atLiveEdge() && (this.nextSeekedFromUser_ = !1, this.player_.currentTime(this.liveCurrentTime()));
  }
  /**
   * Dispose of liveTracker
   */
  dispose() {
    this.stopTracking(), super.dispose();
  }
}
He.registerComponent("LiveTracker", vCe);
class TCe extends He {
  constructor(e, n) {
    super(e, n), this.on("statechanged", (r) => this.updateDom_()), this.updateDom_();
  }
  /**
   * Create the `TitleBar`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return this.els = {
      title: Nt("div", {
        className: "vjs-title-bar-title",
        id: `vjs-title-bar-title-${fs()}`
      }),
      description: Nt("div", {
        className: "vjs-title-bar-description",
        id: `vjs-title-bar-description-${fs()}`
      })
    }, Nt("div", {
      className: "vjs-title-bar"
    }, {}, kD(this.els));
  }
  /**
   * Updates the DOM based on the component's state object.
   */
  updateDom_() {
    const e = this.player_.tech_, n = e && e.el_, r = {
      title: "aria-labelledby",
      description: "aria-describedby"
    };
    ["title", "description"].forEach((i) => {
      const s = this.state[i], a = this.els[i], o = r[i];
      Ng(a), s && Uo(a, s), n && (n.removeAttribute(o), s && n.setAttribute(o, a.id));
    }), this.state.title || this.state.description ? this.show() : this.hide();
  }
  /**
   * Update the contents of the title bar component with new title and
   * description text.
   *
   * If both title and description are missing, the title bar will be hidden.
   *
   * If either title or description are present, the title bar will be visible.
   *
   * NOTE: Any previously set value will be preserved. To unset a previously
   * set value, you must pass an empty string or null.
   *
   * For example:
   *
   * ```
   * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'
   * update({description: 'bar2'}) // title: 'foo', description: 'bar2'
   * update({title: ''}) // title: '', description: 'bar2'
   * update({title: 'foo', description: null}) // title: 'foo', description: null
   * ```
   *
   * @param  {Object} [options={}]
   *         An options object. When empty, the title bar will be hidden.
   *
   * @param  {string} [options.title]
   *         A title to display in the title bar.
   *
   * @param  {string} [options.description]
   *         A description to display in the title bar.
   */
  update(e) {
    this.setState(e);
  }
  /**
   * Dispose the component.
   */
  dispose() {
    const e = this.player_.tech_, n = e && e.el_;
    n && (n.removeAttribute("aria-labelledby"), n.removeAttribute("aria-describedby")), super.dispose(), this.els = null;
  }
}
He.registerComponent("TitleBar", TCe);
const _Ce = {
  initialDisplay: 4e3,
  position: [],
  takeFocus: !1
};
class ECe extends ni {
  /**
   * TransientButton constructor
   *
   * @param {Player} player The button's player
   * @param {TransientButtonOptions} options Options for the transient button
   */
  constructor(e, n) {
    n = Dn(_Ce, n), super(e, n), this.controlText(n.controlText), this.hide(), this.on(this.player_, ["useractive", "userinactive"], (r) => {
      this.removeClass("force-display");
    });
  }
  /**
   * Return CSS class including position classes
   *
   * @return {string} CSS class list
   */
  buildCSSClass() {
    return `vjs-transient-button focus-visible ${this.options_.position.map((e) => `vjs-${e}`).join(" ")}`;
  }
  /**
   * Create the button element
   *
   * @return {HTMLButtonElement} The button element
   */
  createEl() {
    const e = Nt("button", {}, {
      type: "button",
      class: this.buildCSSClass()
    }, Nt("span"));
    return this.controlTextEl_ = e.querySelector("span"), e;
  }
  /**
   * Show the button. The button will remain visible for the `initialDisplay` time, default 4s,
   * and when there is user activity.
   */
  show() {
    super.show(), this.addClass("force-display"), this.options_.takeFocus && this.el().focus({
      preventScroll: !0
    }), this.forceDisplayTimeout = this.player_.setTimeout(() => {
      this.removeClass("force-display");
    }, this.options_.initialDisplay);
  }
  /**
   * Hide the display, even if during the `initialDisplay` time.
   */
  hide() {
    this.removeClass("force-display"), super.hide();
  }
  /**
   * Dispose the component
   */
  dispose() {
    this.player_.clearTimeout(this.forceDisplayTimeout), super.dispose();
  }
}
He.registerComponent("TransientButton", ECe);
const ny = (t) => {
  const e = t.el();
  if (e.hasAttribute("src"))
    return t.triggerSourceset(e.src), !0;
  const n = t.$$("source"), r = [];
  let i = "";
  if (!n.length)
    return !1;
  for (let s = 0; s < n.length; s++) {
    const a = n[s].src;
    a && r.indexOf(a) === -1 && r.push(a);
  }
  return r.length ? (r.length === 1 && (i = r[0]), t.triggerSourceset(i), !0) : !1;
}, xCe = Object.defineProperty({}, "innerHTML", {
  get() {
    return this.cloneNode(!0).innerHTML;
  },
  set(t) {
    const e = ot.createElement(this.nodeName.toLowerCase());
    e.innerHTML = t;
    const n = ot.createDocumentFragment();
    for (; e.childNodes.length; )
      n.appendChild(e.childNodes[0]);
    return this.innerText = "", pe.Element.prototype.appendChild.call(this, n), this.innerHTML;
  }
}), $8 = (t, e) => {
  let n = {};
  for (let r = 0; r < t.length && (n = Object.getOwnPropertyDescriptor(t[r], e), !(n && n.set && n.get)); r++)
    ;
  return n.enumerable = !0, n.configurable = !0, n;
}, wCe = (t) => $8([t.el(), pe.HTMLMediaElement.prototype, pe.Element.prototype, xCe], "innerHTML"), lw = function(t) {
  const e = t.el();
  if (e.resetSourceWatch_)
    return;
  const n = {}, r = wCe(t), i = (s) => (...a) => {
    const o = s.apply(e, a);
    return ny(t), o;
  };
  ["append", "appendChild", "insertAdjacentHTML"].forEach((s) => {
    e[s] && (n[s] = e[s], e[s] = i(n[s]));
  }), Object.defineProperty(e, "innerHTML", Dn(r, {
    set: i(r.set)
  })), e.resetSourceWatch_ = () => {
    e.resetSourceWatch_ = null, Object.keys(n).forEach((s) => {
      e[s] = n[s];
    }), Object.defineProperty(e, "innerHTML", r);
  }, t.one("sourceset", e.resetSourceWatch_);
}, CCe = Object.defineProperty({}, "src", {
  get() {
    return this.hasAttribute("src") ? u8(pe.Element.prototype.getAttribute.call(this, "src")) : "";
  },
  set(t) {
    return pe.Element.prototype.setAttribute.call(this, "src", t), t;
  }
}), SCe = (t) => $8([t.el(), pe.HTMLMediaElement.prototype, CCe], "src"), ICe = function(t) {
  if (!t.featuresSourceset)
    return;
  const e = t.el();
  if (e.resetSourceset_)
    return;
  const n = SCe(t), r = e.setAttribute, i = e.load;
  Object.defineProperty(e, "src", Dn(n, {
    set: (s) => {
      const a = n.set.call(e, s);
      return t.triggerSourceset(e.src), a;
    }
  })), e.setAttribute = (s, a) => {
    const o = r.call(e, s, a);
    return /src/i.test(s) && t.triggerSourceset(e.src), o;
  }, e.load = () => {
    const s = i.call(e);
    return ny(t) || (t.triggerSourceset(""), lw(t)), s;
  }, e.currentSrc ? t.triggerSourceset(e.currentSrc) : ny(t) || lw(t), e.resetSourceset_ = () => {
    e.resetSourceset_ = null, e.load = i, e.setAttribute = r, Object.defineProperty(e, "src", n), e.resetSourceWatch_ && e.resetSourceWatch_();
  };
};
class bt extends Ht {
  /**
  * Create an instance of this Tech.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  *
  * @param {Function} [ready]
  *        Callback function to call when the `HTML5` Tech is ready.
  */
  constructor(e, n) {
    super(e, n);
    const r = e.source;
    let i = !1;
    if (this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === "VIDEO", r && (this.el_.currentSrc !== r.src || e.tag && e.tag.initNetworkState_ === 3) ? this.setSource(r) : this.handleLateInit_(this.el_), e.enableSourceset && this.setupSourcesetHandling_(), this.isScrubbing_ = !1, this.el_.hasChildNodes()) {
      const s = this.el_.childNodes;
      let a = s.length;
      const o = [];
      for (; a--; ) {
        const u = s[a];
        u.nodeName.toLowerCase() === "track" && (this.featuresNativeTextTracks ? (this.remoteTextTrackEls().addTrackElement_(u), this.remoteTextTracks().addTrack(u.track), this.textTracks().addTrack(u.track), !i && !this.el_.hasAttribute("crossorigin") && Bg(u.src) && (i = !0)) : o.push(u));
      }
      for (let u = 0; u < o.length; u++)
        this.el_.removeChild(o[u]);
    }
    this.proxyNativeTracks_(), this.featuresNativeTextTracks && i && Kt.warn(`Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.
This may prevent text tracks from loading.`), this.restoreMetadataTracksInIOSNativePlayer_(), (Gf || Ig) && e.nativeControlsForTouch === !0 && this.setControls(!0), this.proxyWebkitFullscreen_(), this.triggerReady();
  }
  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */
  dispose() {
    this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), bt.disposeMediaElement(this.el_), this.options_ = null, super.dispose();
  }
  /**
   * Modify the media element so that we can detect when
   * the source is changed. Fires `sourceset` just after the source has changed
   */
  setupSourcesetHandling_() {
    ICe(this);
  }
  /**
   * When a captions track is enabled in the iOS Safari native player, all other
   * tracks are disabled (including metadata tracks), which nulls all of their
   * associated cue points. This will restore metadata tracks to their pre-fullscreen
   * state in those cases so that cue points are not needlessly lost.
   *
   * @private
   */
  restoreMetadataTracksInIOSNativePlayer_() {
    const e = this.textTracks();
    let n;
    const r = () => {
      n = [];
      for (let s = 0; s < e.length; s++) {
        const a = e[s];
        a.kind === "metadata" && n.push({
          track: a,
          storedMode: a.mode
        });
      }
    };
    r(), e.addEventListener("change", r), this.on("dispose", () => e.removeEventListener("change", r));
    const i = () => {
      for (let s = 0; s < n.length; s++) {
        const a = n[s];
        a.track.mode === "disabled" && a.track.mode !== a.storedMode && (a.track.mode = a.storedMode);
      }
      e.removeEventListener("change", i);
    };
    this.on("webkitbeginfullscreen", () => {
      e.removeEventListener("change", r), e.removeEventListener("change", i), e.addEventListener("change", i);
    }), this.on("webkitendfullscreen", () => {
      e.removeEventListener("change", r), e.addEventListener("change", r), e.removeEventListener("change", i);
    });
  }
  /**
   * Attempt to force override of tracks for the given type
   *
   * @param {string} type - Track type to override, possible values include 'Audio',
   * 'Video', and 'Text'.
   * @param {boolean} override - If set to true native audio/video will be overridden,
   * otherwise native audio/video will potentially be used.
   * @private
   */
  overrideNative_(e, n) {
    if (n !== this[`featuresNative${e}Tracks`])
      return;
    const r = e.toLowerCase();
    this[`${r}TracksListeners_`] && Object.keys(this[`${r}TracksListeners_`]).forEach((i) => {
      this.el()[`${r}Tracks`].removeEventListener(i, this[`${r}TracksListeners_`][i]);
    }), this[`featuresNative${e}Tracks`] = !n, this[`${r}TracksListeners_`] = null, this.proxyNativeTracksForType_(r);
  }
  /**
   * Attempt to force override of native audio tracks.
   *
   * @param {boolean} override - If set to true native audio will be overridden,
   * otherwise native audio will potentially be used.
   */
  overrideNativeAudioTracks(e) {
    this.overrideNative_("Audio", e);
  }
  /**
   * Attempt to force override of native video tracks.
   *
   * @param {boolean} override - If set to true native video will be overridden,
   * otherwise native video will potentially be used.
   */
  overrideNativeVideoTracks(e) {
    this.overrideNative_("Video", e);
  }
  /**
   * Proxy native track list events for the given type to our track
   * lists if the browser we are playing in supports that type of track list.
   *
   * @param {string} name - Track type; values include 'audio', 'video', and 'text'
   * @private
   */
  proxyNativeTracksForType_(e) {
    const n = as[e], r = this.el()[n.getterName], i = this[n.getterName]();
    if (!this[`featuresNative${n.capitalName}Tracks`] || !r || !r.addEventListener)
      return;
    const s = {
      change: (o) => {
        const u = {
          type: "change",
          target: i,
          currentTarget: i,
          srcElement: i
        };
        i.trigger(u), e === "text" && this[gc.remoteText.getterName]().trigger(u);
      },
      addtrack(o) {
        i.addTrack(o.track);
      },
      removetrack(o) {
        i.removeTrack(o.track);
      }
    }, a = function() {
      const o = [];
      for (let u = 0; u < i.length; u++) {
        let c = !1;
        for (let d = 0; d < r.length; d++)
          if (r[d] === i[u]) {
            c = !0;
            break;
          }
        c || o.push(i[u]);
      }
      for (; o.length; )
        i.removeTrack(o.shift());
    };
    this[n.getterName + "Listeners_"] = s, Object.keys(s).forEach((o) => {
      const u = s[o];
      r.addEventListener(o, u), this.on("dispose", (c) => r.removeEventListener(o, u));
    }), this.on("loadstart", a), this.on("dispose", (o) => this.off("loadstart", a));
  }
  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */
  proxyNativeTracks_() {
    as.names.forEach((e) => {
      this.proxyNativeTracksForType_(e);
    });
  }
  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    let e = this.options_.tag;
    if (!e || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (e) {
        const r = e.cloneNode(!0);
        e.parentNode && e.parentNode.insertBefore(r, e), bt.disposeMediaElement(e), e = r;
      } else {
        e = ot.createElement("video");
        const r = this.options_.tag && mo(this.options_.tag), i = Dn({}, r);
        (!Gf || this.options_.nativeControlsForTouch !== !0) && delete i.controls, FD(e, Object.assign(i, {
          id: this.options_.techId,
          class: "vjs-tech"
        }));
      }
      e.playerId = this.options_.playerId;
    }
    typeof this.options_.preload < "u" && hc(e, "preload", this.options_.preload), this.options_.disablePictureInPicture !== void 0 && (e.disablePictureInPicture = this.options_.disablePictureInPicture);
    const n = ["loop", "muted", "playsinline", "autoplay"];
    for (let r = 0; r < n.length; r++) {
      const i = n[r], s = this.options_[i];
      typeof s < "u" && (s ? hc(e, i, i) : Mg(e, i), e[i] = s);
    }
    return e;
  }
  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */
  handleLateInit_(e) {
    if (e.networkState === 0 || e.networkState === 3)
      return;
    if (e.readyState === 0) {
      let r = !1;
      const i = function() {
        r = !0;
      };
      this.on("loadstart", i);
      const s = function() {
        r || this.trigger("loadstart");
      };
      this.on("loadedmetadata", s), this.ready(function() {
        this.off("loadstart", i), this.off("loadedmetadata", s), r || this.trigger("loadstart");
      });
      return;
    }
    const n = ["loadstart"];
    n.push("loadedmetadata"), e.readyState >= 2 && n.push("loadeddata"), e.readyState >= 3 && n.push("canplay"), e.readyState >= 4 && n.push("canplaythrough"), this.ready(function() {
      n.forEach(function(r) {
        this.trigger(r);
      }, this);
    });
  }
  /**
   * Set whether we are scrubbing or not.
   * This is used to decide whether we should use `fastSeek` or not.
   * `fastSeek` is used to provide trick play on Safari browsers.
   *
   * @param {boolean} isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   */
  setScrubbing(e) {
    this.isScrubbing_ = e;
  }
  /**
   * Get whether we are scrubbing or not.
   *
   * @return {boolean} isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   */
  scrubbing() {
    return this.isScrubbing_;
  }
  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */
  setCurrentTime(e) {
    try {
      this.isScrubbing_ && this.el_.fastSeek && kg ? this.el_.fastSeek(e) : this.el_.currentTime = e;
    } catch (n) {
      Kt(n, "Video is not ready. (Video.js)");
    }
  }
  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */
  duration() {
    if (this.el_.duration === 1 / 0 && Ns && ha && this.el_.currentTime === 0) {
      const e = () => {
        this.el_.currentTime > 0 && (this.el_.duration === 1 / 0 && this.trigger("durationchange"), this.off("timeupdate", e));
      };
      return this.on("timeupdate", e), NaN;
    }
    return this.el_.duration || NaN;
  }
  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */
  width() {
    return this.el_.offsetWidth;
  }
  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The height of the HTML5 media element.
   */
  height() {
    return this.el_.offsetHeight;
  }
  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */
  proxyWebkitFullscreen_() {
    if (!("webkitDisplayingFullscreen" in this.el_))
      return;
    const e = function() {
      this.trigger("fullscreenchange", {
        isFullscreen: !1
      }), this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1);
    }, n = function() {
      "webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture" && (this.one("webkitendfullscreen", e), this.trigger("fullscreenchange", {
        isFullscreen: !0,
        // set a flag in case another tech triggers fullscreenchange
        nativeIOSFullscreen: !0
      }));
    };
    this.on("webkitbeginfullscreen", n), this.on("dispose", () => {
      this.off("webkitbeginfullscreen", n), this.off("webkitendfullscreen", e);
    });
  }
  /**
   * Check if fullscreen is supported on the video el.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */
  supportsFullScreen() {
    return typeof this.el_.webkitEnterFullScreen == "function";
  }
  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */
  enterFullScreen() {
    const e = this.el_;
    if (e.paused && e.networkState <= e.HAVE_METADATA)
      ta(this.el_.play()), this.setTimeout(function() {
        e.pause();
        try {
          e.webkitEnterFullScreen();
        } catch (n) {
          this.trigger("fullscreenerror", n);
        }
      }, 0);
    else
      try {
        e.webkitEnterFullScreen();
      } catch (n) {
        this.trigger("fullscreenerror", n);
      }
  }
  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */
  exitFullScreen() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  }
  /**
   * Create a floating video window always on top of other windows so that users may
   * continue consuming media while they interact with other content sites, or
   * applications on their device.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @return {Promise}
   *         A promise with a Picture-in-Picture window.
   */
  requestPictureInPicture() {
    return this.el_.requestPictureInPicture();
  }
  /**
   * Native requestVideoFrameCallback if supported by browser/tech, or fallback
   * Don't use rVCF on Safari when DRM is playing, as it doesn't fire
   * Needs to be checked later than the constructor
   * This will be a false positive for clear sources loaded after a Fairplay source
   *
   * @param {function} cb function to call
   * @return {number} id of request
   */
  requestVideoFrameCallback(e) {
    return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(e) : super.requestVideoFrameCallback(e);
  }
  /**
   * Native or fallback requestVideoFrameCallback
   *
   * @param {number} id request id to cancel
   */
  cancelVideoFrameCallback(e) {
    this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(e) : super.cancelVideoFrameCallback(e);
  }
  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */
  src(e) {
    if (e === void 0)
      return this.el_.src;
    this.setSrc(e);
  }
  /**
   * Add a <source> element to the <video> element.
   *
   * @param {string} srcUrl
   *        The URL of the video source.
   *
   * @param {string} [mimeType]
   *        The MIME type of the video source. Optional but recommended.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully added, false otherwise.
   */
  addSourceElement(e, n) {
    if (!e)
      return Kt.error("Invalid source URL."), !1;
    const r = {
      src: e
    };
    n && (r.type = n);
    const i = Nt("source", {}, r);
    return this.el_.appendChild(i), !0;
  }
  /**
   * Remove a <source> element from the <video> element by its URL.
   *
   * @param {string} srcUrl
   *        The URL of the source to remove.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully removed, false otherwise.
   */
  removeSourceElement(e) {
    if (!e)
      return Kt.error("Source URL is required to remove the source element."), !1;
    const n = this.el_.querySelectorAll("source");
    for (const r of n)
      if (r.src === e)
        return this.el_.removeChild(r), !0;
    return Kt.warn(`No matching source element found with src: ${e}`), !1;
  }
  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */
  reset() {
    bt.resetMediaElement(this.el_);
  }
  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */
  currentSrc() {
    return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc;
  }
  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */
  setControls(e) {
    this.el_.controls = !!e;
  }
  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */
  addTextTrack(e, n, r) {
    return this.featuresNativeTextTracks ? this.el_.addTextTrack(e, n, r) : super.addTextTrack(e, n, r);
  }
  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label]
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */
  createRemoteTextTrack(e) {
    if (!this.featuresNativeTextTracks)
      return super.createRemoteTextTrack(e);
    const n = ot.createElement("track");
    return e.kind && (n.kind = e.kind), e.label && (n.label = e.label), (e.language || e.srclang) && (n.srclang = e.language || e.srclang), e.default && (n.default = e.default), e.id && (n.id = e.id), e.src && (n.src = e.src), n;
  }
  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {boolean} [manualCleanup=false] if set to true, the TextTrack
   * will not be removed from the TextTrackList and HtmlTrackElementList
   * after a source change
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   */
  addRemoteTextTrack(e, n) {
    const r = super.addRemoteTextTrack(e, n);
    return this.featuresNativeTextTracks && this.el().appendChild(r), r;
  }
  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */
  removeRemoteTextTrack(e) {
    if (super.removeRemoteTextTrack(e), this.featuresNativeTextTracks) {
      const n = this.$$("track");
      let r = n.length;
      for (; r--; )
        (e === n[r] || e === n[r].track) && this.el().removeChild(n[r]);
    }
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */
  getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality == "function")
      return this.el().getVideoPlaybackQuality();
    const e = {};
    return typeof this.el().webkitDroppedFrameCount < "u" && typeof this.el().webkitDecodedFrameCount < "u" && (e.droppedVideoFrames = this.el().webkitDroppedFrameCount, e.totalVideoFrames = this.el().webkitDecodedFrameCount), pe.performance && (e.creationTime = pe.performance.now()), e;
  }
}
wg(bt, "TEST_VID", function() {
  if (!$c())
    return;
  const t = ot.createElement("video"), e = ot.createElement("track");
  return e.kind = "captions", e.srclang = "en", e.label = "English", t.appendChild(e), t;
});
bt.isSupported = function() {
  try {
    bt.TEST_VID.volume = 0.5;
  } catch {
    return !1;
  }
  return !!(bt.TEST_VID && bt.TEST_VID.canPlayType);
};
bt.canPlayType = function(t) {
  return bt.TEST_VID.canPlayType(t);
};
bt.canPlaySource = function(t, e) {
  return bt.canPlayType(t.type);
};
bt.canControlVolume = function() {
  try {
    const t = bt.TEST_VID.volume;
    bt.TEST_VID.volume = t / 2 + 0.1;
    const e = t !== bt.TEST_VID.volume;
    return e && ei ? (pe.setTimeout(() => {
      bt && bt.prototype && (bt.prototype.featuresVolumeControl = t !== bt.TEST_VID.volume);
    }), !1) : e;
  } catch {
    return !1;
  }
};
bt.canMuteVolume = function() {
  try {
    const t = bt.TEST_VID.muted;
    return bt.TEST_VID.muted = !t, bt.TEST_VID.muted ? hc(bt.TEST_VID, "muted", "muted") : Mg(bt.TEST_VID, "muted", "muted"), t !== bt.TEST_VID.muted;
  } catch {
    return !1;
  }
};
bt.canControlPlaybackRate = function() {
  if (Ns && ha && Cg < 58)
    return !1;
  try {
    const t = bt.TEST_VID.playbackRate;
    return bt.TEST_VID.playbackRate = t / 2 + 0.1, t !== bt.TEST_VID.playbackRate;
  } catch {
    return !1;
  }
};
bt.canOverrideAttributes = function() {
  try {
    const t = () => {
    };
    Object.defineProperty(ot.createElement("video"), "src", {
      get: t,
      set: t
    }), Object.defineProperty(ot.createElement("audio"), "src", {
      get: t,
      set: t
    }), Object.defineProperty(ot.createElement("video"), "innerHTML", {
      get: t,
      set: t
    }), Object.defineProperty(ot.createElement("audio"), "innerHTML", {
      get: t,
      set: t
    });
  } catch {
    return !1;
  }
  return !0;
};
bt.supportsNativeTextTracks = function() {
  return kg || ei && ha;
};
bt.supportsNativeVideoTracks = function() {
  return !!(bt.TEST_VID && bt.TEST_VID.videoTracks);
};
bt.supportsNativeAudioTracks = function() {
  return !!(bt.TEST_VID && bt.TEST_VID.audioTracks);
};
bt.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
[["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function([t, e]) {
  wg(bt.prototype, t, () => bt[e](), !0);
});
bt.prototype.featuresVolumeControl = bt.canControlVolume();
bt.prototype.movingMediaElementInDOM = !ei;
bt.prototype.featuresFullscreenResize = !0;
bt.prototype.featuresProgressEvents = !0;
bt.prototype.featuresTimeupdateEvents = !0;
bt.prototype.featuresVideoFrameCallback = !!(bt.TEST_VID && bt.TEST_VID.requestVideoFrameCallback);
bt.disposeMediaElement = function(t) {
  if (t) {
    for (t.parentNode && t.parentNode.removeChild(t); t.hasChildNodes(); )
      t.removeChild(t.firstChild);
    t.removeAttribute("src"), typeof t.load == "function" && function() {
      try {
        t.load();
      } catch {
      }
    }();
  }
};
bt.resetMediaElement = function(t) {
  if (!t)
    return;
  const e = t.querySelectorAll("source");
  let n = e.length;
  for (; n--; )
    t.removeChild(e[n]);
  t.removeAttribute("src"), typeof t.load == "function" && function() {
    try {
      t.load();
    } catch {
    }
  }();
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(t) {
  bt.prototype[t] = function() {
    return this.el_[t] || this.el_.hasAttribute(t);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(t) {
  bt.prototype["set" + or(t)] = function(e) {
    this.el_[t] = e, e ? this.el_.setAttribute(t, t) : this.el_.removeAttribute(t);
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(t) {
  bt.prototype[t] = function() {
    return this.el_[t];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(t) {
  bt.prototype["set" + or(t)] = function(e) {
    this.el_[t] = e;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(t) {
  bt.prototype[t] = function() {
    return this.el_[t]();
  };
});
Ht.withSourceHandlers(bt);
bt.nativeSourceHandler = {};
bt.nativeSourceHandler.canPlayType = function(t) {
  try {
    return bt.TEST_VID.canPlayType(t);
  } catch {
    return "";
  }
};
bt.nativeSourceHandler.canHandleSource = function(t, e) {
  if (t.type)
    return bt.nativeSourceHandler.canPlayType(t.type);
  if (t.src) {
    const n = ET(t.src);
    return bt.nativeSourceHandler.canPlayType(`video/${n}`);
  }
  return "";
};
bt.nativeSourceHandler.handleSource = function(t, e, n) {
  e.setSrc(t.src);
};
bt.nativeSourceHandler.dispose = function() {
};
bt.registerSourceHandler(bt.nativeSourceHandler);
Ht.registerTech("Html5", bt);
const H8 = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
], o2 = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
}, ry = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"], ym = {};
ry.forEach((t) => {
  const e = t.charAt(0) === "x" ? `x-${t.substring(1)}` : t;
  ym[t] = `vjs-layout-${e}`;
});
const kCe = {
  tiny: 210,
  xsmall: 320,
  small: 425,
  medium: 768,
  large: 1440,
  xlarge: 2560,
  huge: 1 / 0
};
class En extends He {
  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {PlayerReadyCallback} [ready]
   *        Ready callback function.
   */
  constructor(e, n, r) {
    if (e.id = e.id || n.id || `vjs_video_${fs()}`, n = Object.assign(En.getTagSettings(e), n), n.initChildren = !1, n.createEl = !1, n.evented = !1, n.reportTouchActivity = !1, !n.language) {
      const a = e.closest("[lang]");
      a && (n.language = a.getAttribute("lang"));
    }
    if (super(null, n, r), this.boundDocumentFullscreenChange_ = (a) => this.documentFullscreenChange_(a), this.boundFullWindowOnEscKey_ = (a) => this.fullWindowOnEscKey(a), this.boundUpdateStyleEl_ = (a) => this.updateStyleEl_(a), this.boundApplyInitTime_ = (a) => this.applyInitTime_(a), this.boundUpdateCurrentBreakpoint_ = (a) => this.updateCurrentBreakpoint_(a), this.boundHandleTechClick_ = (a) => this.handleTechClick_(a), this.boundHandleTechDoubleClick_ = (a) => this.handleTechDoubleClick_(a), this.boundHandleTechTouchStart_ = (a) => this.handleTechTouchStart_(a), this.boundHandleTechTouchMove_ = (a) => this.handleTechTouchMove_(a), this.boundHandleTechTouchEnd_ = (a) => this.handleTechTouchEnd_(a), this.boundHandleTechTap_ = (a) => this.handleTechTap_(a), this.boundUpdatePlayerHeightOnAudioOnlyMode_ = (a) => this.updatePlayerHeightOnAudioOnlyMode_(a), this.isFullscreen_ = !1, this.log = CD(this.id_), this.fsApi_ = s0, this.isPosterFromTech_ = !1, this.queuedCallbacks_ = [], this.isReady_ = !1, this.hasStarted_ = !1, this.userActive_ = !1, this.debugEnabled_ = !1, this.audioOnlyMode_ = !1, this.audioPosterMode_ = !1, this.audioOnlyCache_ = {
      controlBarHeight: null,
      playerHeight: null,
      hiddenChildren: []
    }, !this.options_ || !this.options_.techOrder || !this.options_.techOrder.length)
      throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
    if (this.tag = e, this.tagAttributes = e && mo(e), this.language(this.options_.language), n.languages) {
      const a = {};
      Object.getOwnPropertyNames(n.languages).forEach(function(o) {
        a[o.toLowerCase()] = n.languages[o];
      }), this.languages_ = a;
    } else
      this.languages_ = En.prototype.options_.languages;
    this.resetCache_(), this.poster_ = n.poster || "", this.controls_ = !!n.controls, e.controls = !1, e.removeAttribute("controls"), this.changingSrc_ = !1, this.playCallbacks_ = [], this.playTerminatedQueue_ = [], e.hasAttribute("autoplay") ? this.autoplay(!0) : this.autoplay(this.options_.autoplay), n.plugins && Object.keys(n.plugins).forEach((a) => {
      if (typeof this[a] != "function")
        throw new Error(`plugin "${a}" does not exist`);
    }), this.scrubbing_ = !1, this.el_ = this.createEl(), bT(this, {
      eventBusKey: "el_"
    }), this.fsApi_.requestFullscreen && (Qi(ot, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_)), this.fluid_ && this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
    const i = Dn(this.options_);
    if (n.plugins && Object.keys(n.plugins).forEach((a) => {
      this[a](n.plugins[a]);
    }), n.debug && this.debug(!0), this.options_.playerOptions = i, this.middleware_ = [], this.playbackRates(n.playbackRates), n.experimentalSvgIcons) {
      const o = new pe.DOMParser().parseFromString(Zwe, "image/svg+xml");
      if (o.querySelector("parsererror"))
        Kt.warn("Failed to load SVG Icons. Falling back to Font Icons."), this.options_.experimentalSvgIcons = null;
      else {
        const c = o.documentElement;
        c.style.display = "none", this.el_.appendChild(c), this.addClass("vjs-svg-icons-enabled");
      }
    }
    this.initChildren(), this.isAudio(e.nodeName.toLowerCase() === "audio"), this.controls() ? this.addClass("vjs-controls-enabled") : this.addClass("vjs-controls-disabled"), this.el_.setAttribute("role", "region"), this.isAudio() ? this.el_.setAttribute("aria-label", this.localize("Audio Player")) : this.el_.setAttribute("aria-label", this.localize("Video Player")), this.isAudio() && this.addClass("vjs-audio"), n.spatialNavigation && n.spatialNavigation.enabled && (this.spatialNavigation = new Jwe(this), this.addClass("vjs-spatial-navigation-enabled")), Gf && this.addClass("vjs-touch-enabled"), ei || this.addClass("vjs-workinghover"), En.players[this.id_] = this;
    const s = Wb.split(".")[0];
    this.addClass(`vjs-v${s}`), this.userActive(!0), this.reportUserActivity(), this.one("play", (a) => this.listenForUserActivity_(a)), this.on("keydown", (a) => this.handleKeyDown(a)), this.on("languagechange", (a) => this.handleLanguagechange(a)), this.breakpoints(this.options_.breakpoints), this.responsive(this.options_.responsive), this.on("ready", () => {
      this.audioPosterMode(this.options_.audioPosterMode), this.audioOnlyMode(this.options_.audioOnlyMode);
    });
  }
  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */
  dispose() {
    this.trigger("dispose"), this.off("dispose"), ti(ot, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_), ti(ot, "keydown", this.boundFullWindowOnEscKey_), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), En.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), Gwe(this), ci.names.forEach((e) => {
      const n = ci[e], r = this[n.getterName]();
      r && r.off && r.off();
    }), super.dispose({
      restoreEl: this.options_.restoreEl
    });
  }
  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    let e = this.tag, n, r = this.playerElIngest_ = e.parentNode && e.parentNode.hasAttribute && e.parentNode.hasAttribute("data-vjs-player");
    const i = this.tag.tagName.toLowerCase() === "video-js";
    r ? n = this.el_ = e.parentNode : i || (n = this.el_ = super.createEl("div"));
    const s = mo(e);
    if (i) {
      for (n = this.el_ = e, e = this.tag = ot.createElement("video"); n.children.length; )
        e.appendChild(n.firstChild);
      gf(n, "video-js") || Iu(n, "video-js"), n.appendChild(e), r = this.playerElIngest_ = n, Object.keys(n).forEach((u) => {
        try {
          e[u] = n[u];
        } catch {
        }
      });
    }
    e.setAttribute("tabindex", "-1"), s.tabindex = "-1", ha && Sg && (e.setAttribute("role", "application"), s.role = "application"), e.removeAttribute("width"), e.removeAttribute("height"), "width" in s && delete s.width, "height" in s && delete s.height, Object.getOwnPropertyNames(s).forEach(function(u) {
      i && u === "class" || n.setAttribute(u, s[u]), i && e.setAttribute(u, s[u]);
    }), e.playerId = e.id, e.id += "_html5_api", e.className = "vjs-tech", e.player = n.player = this, this.addClass("vjs-paused");
    const a = ["IS_SMART_TV", "IS_TIZEN", "IS_WEBOS", "IS_ANDROID", "IS_IPAD", "IS_IPHONE", "IS_CHROMECAST_RECEIVER"].filter((u) => LD[u]).map((u) => "vjs-device-" + u.substring(3).toLowerCase().replace(/\_/g, "-"));
    if (this.addClass(...a), pe.VIDEOJS_NO_DYNAMIC_STYLE !== !0) {
      this.styleEl_ = YD("vjs-styles-dimensions");
      const u = No(".vjs-styles-defaults"), c = No("head");
      c.insertBefore(this.styleEl_, u ? u.nextSibling : c.firstChild);
    }
    this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio), this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    const o = e.getElementsByTagName("a");
    for (let u = 0; u < o.length; u++) {
      const c = o.item(u);
      Iu(c, "vjs-hidden"), c.setAttribute("hidden", "hidden");
    }
    return e.initNetworkState_ = e.networkState, e.parentNode && !r && e.parentNode.insertBefore(n, e), Gb(e, n), this.children_.unshift(e), this.el_.setAttribute("lang", this.language_), this.el_.setAttribute("translate", "no"), this.el_ = n, n;
  }
  /**
   * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this
   * sets the `crossOrigin` property on the `<video>` tag to control the CORS
   * behavior.
   *
   * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}
   *
   * @param {string|null} [value]
   *        The value to set the `Player`'s crossOrigin to. If an argument is
   *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
   *
   * @return {string|null|undefined}
   *         - The current crossOrigin value of the `Player` when getting.
   *         - undefined when setting
   */
  crossOrigin(e) {
    if (typeof e > "u")
      return this.techGet_("crossOrigin");
    if (e !== null && e !== "anonymous" && e !== "use-credentials") {
      Kt.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`);
      return;
    }
    this.techCall_("setCrossOrigin", e), this.posterImage && this.posterImage.crossOrigin(e);
  }
  /**
   * A getter/setter for the `Player`'s width. Returns the player's configured value.
   * To get the current width use `currentWidth()`.
   *
   * @param {number|string} [value]
   *        CSS value to set the `Player`'s width to.
   *
   * @return {number|undefined}
   *         - The current width of the `Player` when getting.
   *         - Nothing when setting
   */
  width(e) {
    return this.dimension("width", e);
  }
  /**
   * A getter/setter for the `Player`'s height. Returns the player's configured value.
   * To get the current height use `currentheight()`.
   *
   * @param {number|string} [value]
   *        CSS value to set the `Player`'s height to.
   *
   * @return {number|undefined}
   *         - The current height of the `Player` when getting.
   *         - Nothing when setting
   */
  height(e) {
    return this.dimension("height", e);
  }
  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number|string} [value]
   *        Value for dimension specified in the first argument.
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */
  dimension(e, n) {
    const r = e + "_";
    if (n === void 0)
      return this[r] || 0;
    if (n === "" || n === "auto") {
      this[r] = void 0, this.updateStyleEl_();
      return;
    }
    const i = parseFloat(n);
    if (isNaN(i)) {
      Kt.error(`Improper value "${n}" supplied for for ${e}`);
      return;
    }
    this[r] = i, this.updateStyleEl_();
  }
  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * Turning this on will turn off fill mode.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fluid(e) {
    if (e === void 0)
      return !!this.fluid_;
    this.fluid_ = !!e, Ha(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_), e ? (this.addClass("vjs-fluid"), this.fill(!1), Cwe(this, () => {
      this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
    })) : this.removeClass("vjs-fluid"), this.updateStyleEl_();
  }
  /**
   * A getter/setter/toggler for the vjs-fill `className` on the `Player`.
   *
   * Turning this on will turn off fluid mode.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fill(e) {
    if (e === void 0)
      return !!this.fill_;
    this.fill_ = !!e, e ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill");
  }
  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */
  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player`'s aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */
  aspectRatio(e) {
    if (e === void 0)
      return this.aspectRatio_;
    if (!/^\d+\:\d+$/.test(e))
      throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
    this.aspectRatio_ = e, this.fluid(!0), this.updateStyleEl_();
  }
  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */
  updateStyleEl_() {
    if (pe.VIDEOJS_NO_DYNAMIC_STYLE === !0) {
      const o = typeof this.width_ == "number" ? this.width_ : this.options_.width, u = typeof this.height_ == "number" ? this.height_ : this.options_.height, c = this.tech_ && this.tech_.el();
      c && (o >= 0 && (c.width = o), u >= 0 && (c.height = u));
      return;
    }
    let e, n, r, i;
    this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto" ? r = this.aspectRatio_ : this.videoWidth() > 0 ? r = this.videoWidth() + ":" + this.videoHeight() : r = "16:9";
    const s = r.split(":"), a = s[1] / s[0];
    this.width_ !== void 0 ? e = this.width_ : this.height_ !== void 0 ? e = this.height_ / a : e = this.videoWidth() || 300, this.height_ !== void 0 ? n = this.height_ : n = e * a, /^[^a-zA-Z]/.test(this.id()) ? i = "dimensions-" + this.id() : i = this.id() + "-dimensions", this.addClass(i), XD(this.styleEl_, `
      .${i} {
        width: ${e}px;
        height: ${n}px;
      }

      .${i}.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ${a * 100}%;
      }
    `);
  }
  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */
  loadTech_(e, n) {
    this.tech_ && this.unloadTech_();
    const r = or(e), i = e.charAt(0).toLowerCase() + e.slice(1);
    r !== "Html5" && this.tag && (Ht.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = r, this.isReady_ = !1;
    let s = this.autoplay();
    (typeof this.autoplay() == "string" || this.autoplay() === !0 && this.options_.normalizeAutoplay) && (s = !1);
    const a = {
      source: n,
      autoplay: s,
      nativeControlsForTouch: this.options_.nativeControlsForTouch,
      playerId: this.id(),
      techId: `${this.id()}_${i}_api`,
      playsinline: this.options_.playsinline,
      preload: this.options_.preload,
      loop: this.options_.loop,
      disablePictureInPicture: this.options_.disablePictureInPicture,
      muted: this.options_.muted,
      poster: this.poster(),
      language: this.language(),
      playerElIngest: this.playerElIngest_ || !1,
      "vtt.js": this.options_["vtt.js"],
      canOverridePoster: !!this.options_.techCanOverridePoster,
      enableSourceset: this.options_.enableSourceset
    };
    ci.names.forEach((u) => {
      const c = ci[u];
      a[c.getterName] = this[c.privateName];
    }), Object.assign(a, this.options_[r]), Object.assign(a, this.options_[i]), Object.assign(a, this.options_[e.toLowerCase()]), this.tag && (a.tag = this.tag), n && n.src === this.cache_.src && this.cache_.currentTime > 0 && (a.startTime = this.cache_.currentTime);
    const o = Ht.getTech(e);
    if (!o)
      throw new Error(`No Tech named '${r}' exists! '${r}' should be registered using videojs.registerTech()'`);
    this.tech_ = new o(a), this.tech_.ready(Un(this, this.handleTechReady_), !0), ey.jsonToTextTracks(this.textTracksJson_ || [], this.tech_), H8.forEach((u) => {
      this.on(this.tech_, u, (c) => this[`handleTech${or(u)}_`](c));
    }), Object.keys(o2).forEach((u) => {
      this.on(this.tech_, u, (c) => {
        if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
          this.queuedCallbacks_.push({
            callback: this[`handleTech${o2[u]}_`].bind(this),
            event: c
          });
          return;
        }
        this[`handleTech${o2[u]}_`](c);
      });
    }), this.on(this.tech_, "loadstart", (u) => this.handleTechLoadStart_(u)), this.on(this.tech_, "sourceset", (u) => this.handleTechSourceset_(u)), this.on(this.tech_, "waiting", (u) => this.handleTechWaiting_(u)), this.on(this.tech_, "ended", (u) => this.handleTechEnded_(u)), this.on(this.tech_, "seeking", (u) => this.handleTechSeeking_(u)), this.on(this.tech_, "play", (u) => this.handleTechPlay_(u)), this.on(this.tech_, "pause", (u) => this.handleTechPause_(u)), this.on(this.tech_, "durationchange", (u) => this.handleTechDurationChange_(u)), this.on(this.tech_, "fullscreenchange", (u, c) => this.handleTechFullscreenChange_(u, c)), this.on(this.tech_, "fullscreenerror", (u, c) => this.handleTechFullscreenError_(u, c)), this.on(this.tech_, "enterpictureinpicture", (u) => this.handleTechEnterPictureInPicture_(u)), this.on(this.tech_, "leavepictureinpicture", (u) => this.handleTechLeavePictureInPicture_(u)), this.on(this.tech_, "error", (u) => this.handleTechError_(u)), this.on(this.tech_, "posterchange", (u) => this.handleTechPosterChange_(u)), this.on(this.tech_, "textdata", (u) => this.handleTechTextData_(u)), this.on(this.tech_, "ratechange", (u) => this.handleTechRateChange_(u)), this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode !== this.el() && (r !== "Html5" || !this.tag) && Gb(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null);
  }
  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */
  unloadTech_() {
    ci.names.forEach((e) => {
      const n = ci[e];
      this[n.privateName] = this[n.getterName]();
    }), this.textTracksJson_ = ey.textTracksToJson(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1;
  }
  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */
  tech(e) {
    return e === void 0 && Kt.warn(`Using the tech directly can be dangerous. I hope you know what you're doing.
See https://github.com/videojs/video.js/issues/2617 for more info.
`), this.tech_;
  }
  /**
   * An object that contains Video.js version.
   *
   * @typedef {Object} PlayerVersion
   *
   * @property {string} 'video.js' - Video.js version
   */
  /**
   * Returns an object with Video.js version.
   *
   * @return {PlayerVersion}
   *          An object with Video.js version.
   */
  version() {
    return {
      "video.js": Wb
    };
  }
  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */
  addTechControlsListeners_() {
    this.removeTechControlsListeners_(), this.on(this.tech_, "click", this.boundHandleTechClick_), this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_), this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.on(this.tech_, "tap", this.boundHandleTechTap_);
  }
  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */
  removeTechControlsListeners_() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_), this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_), this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_), this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_), this.off(this.tech_, "click", this.boundHandleTechClick_), this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  }
  /**
   * Player waits for the tech to be ready
   *
   * @private
   */
  handleTechReady_() {
    this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_();
  }
  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}.
   *
   * @fires Player#loadstart
   * @listens Tech#loadstart
   * @private
   */
  handleTechLoadStart_() {
    this.removeClass("vjs-ended", "vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : this.trigger("loadstart"), this.manualAutoplay_(this.autoplay() === !0 && this.options_.normalizeAutoplay ? "play" : this.autoplay());
  }
  /**
   * Handle autoplay string values, rather than the typical boolean
   * values that should be handled by the tech. Note that this is not
   * part of any specification. Valid values and what they do can be
   * found on the autoplay getter at Player#autoplay()
   */
  manualAutoplay_(e) {
    if (!this.tech_ || typeof e != "string")
      return;
    const n = () => {
      const i = this.muted();
      this.muted(!0);
      const s = () => {
        this.muted(i);
      };
      this.playTerminatedQueue_.push(s);
      const a = this.play();
      if (bf(a))
        return a.catch((o) => {
          throw s(), new Error(`Rejection at manualAutoplay. Restoring muted value. ${o || ""}`);
        });
    };
    let r;
    if (e === "any" && !this.muted() ? (r = this.play(), bf(r) && (r = r.catch(n))) : e === "muted" && !this.muted() ? r = n() : r = this.play(), !!bf(r))
      return r.then(() => {
        this.trigger({
          type: "autoplay-success",
          autoplay: e
        });
      }).catch(() => {
        this.trigger({
          type: "autoplay-failure",
          autoplay: e
        });
      });
  }
  /**
   * Update the internal source caches so that we return the correct source from
   * `src()`, `currentSource()`, and `currentSources()`.
   *
   * > Note: `currentSources` will not be updated if the source that is passed in exists
   *         in the current `currentSources` cache.
   *
   *
   * @param {Tech~SourceObject} srcObj
   *        A string or object source to update our caches to.
   */
  updateSourceCaches_(e = "") {
    let n = e, r = "";
    typeof n != "string" && (n = e.src, r = e.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], n && !r && (r = Kwe(this, n)), this.cache_.source = Dn({}, e, {
      src: n,
      type: r
    });
    const i = this.cache_.sources.filter((u) => u.src && u.src === n), s = [], a = this.$$("source"), o = [];
    for (let u = 0; u < a.length; u++) {
      const c = mo(a[u]);
      s.push(c), c.src && c.src === n && o.push(c.src);
    }
    o.length && !i.length ? this.cache_.sources = s : i.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = n;
  }
  /**
   * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}
   * causing the media element to reload.
   *
   * It will fire for the initial source and each subsequent source.
   * This event is a custom event from Video.js and is triggered by the {@link Tech}.
   *
   * The event object for this event contains a `src` property that will contain the source
   * that was available when the event was triggered. This is generally only necessary if Video.js
   * is switching techs while the source was being changed.
   *
   * It is also fired when `load` is called on the player (or media element)
   * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}
   * says that the resource selection algorithm needs to be aborted and restarted.
   * In this case, it is very likely that the `src` property will be set to the
   * empty string `""` to indicate we do not know what the source will be but
   * that it is changing.
   *
   * *This event is currently still experimental and may change in minor releases.*
   * __To use this, pass `enableSourceset` option to the player.__
   *
   * @event Player#sourceset
   * @type {Event}
   * @prop {string} src
   *                The source url available when the `sourceset` was triggered.
   *                It will be an empty string if we cannot know what the source is
   *                but know that the source will change.
   */
  /**
   * Retrigger the `sourceset` event that was triggered by the {@link Tech}.
   *
   * @fires Player#sourceset
   * @listens Tech#sourceset
   * @private
   */
  handleTechSourceset_(e) {
    if (!this.changingSrc_) {
      let n = (s) => this.updateSourceCaches_(s);
      const r = this.currentSource().src, i = e.src;
      r && !/^blob:/.test(r) && /^blob:/.test(i) && (!this.lastSource_ || this.lastSource_.tech !== i && this.lastSource_.player !== r) && (n = () => {
      }), n(i), e.src || this.tech_.any(["sourceset", "loadstart"], (s) => {
        if (s.type === "sourceset")
          return;
        const a = this.techGet_("currentSrc");
        this.lastSource_.tech = a, this.updateSourceCaches_(a);
      });
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: e.src
    }, this.trigger({
      src: e.src,
      type: "sourceset"
    });
  }
  /**
   * Add/remove the vjs-has-started class
   *
   *
   * @param {boolean} request
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted_
   */
  hasStarted(e) {
    if (e === void 0)
      return this.hasStarted_;
    e !== this.hasStarted_ && (this.hasStarted_ = e, this.hasStarted_ ? this.addClass("vjs-has-started") : this.removeClass("vjs-has-started"));
  }
  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */
  handleTechPlay_() {
    this.removeClass("vjs-ended", "vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play");
  }
  /**
   * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
   *
   * If there were any events queued while the playback rate was zero, fire
   * those events now.
   *
   * @private
   * @method Player#handleTechRateChange_
   * @fires Player#ratechange
   * @listens Tech#ratechange
   */
  handleTechRateChange_() {
    this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0 && (this.queuedCallbacks_.forEach((e) => e.callback(e.event)), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange");
  }
  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */
  handleTechWaiting_() {
    this.addClass("vjs-waiting"), this.trigger("waiting");
    const e = this.currentTime(), n = () => {
      e !== this.currentTime() && (this.removeClass("vjs-waiting"), this.off("timeupdate", n));
    };
    this.on("timeupdate", n);
  }
  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */
  handleTechCanPlay_() {
    this.removeClass("vjs-waiting"), this.trigger("canplay");
  }
  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */
  handleTechCanPlayThrough_() {
    this.removeClass("vjs-waiting"), this.trigger("canplaythrough");
  }
  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */
  handleTechPlaying_() {
    this.removeClass("vjs-waiting"), this.trigger("playing");
  }
  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */
  handleTechSeeking_() {
    this.addClass("vjs-seeking"), this.trigger("seeking");
  }
  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */
  handleTechSeeked_() {
    this.removeClass("vjs-seeking", "vjs-ended"), this.trigger("seeked");
  }
  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */
  handleTechPause_() {
    this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause");
  }
  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */
  handleTechEnded_() {
    this.addClass("vjs-ended"), this.removeClass("vjs-waiting"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended");
  }
  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */
  handleTechDurationChange_() {
    this.duration(this.techGet_("duration"));
  }
  /**
   * Handle a click on the media element to play/pause
   *
   * @param {Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#click
   * @private
   */
  handleTechClick_(e) {
    this.controls_ && (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click == "function" ? this.options_.userActions.click.call(this, e) : this.paused() ? ta(this.play()) : this.pause());
  }
  /**
   * Handle a double-click on the media element to enter/exit fullscreen,
   * or exit documentPictureInPicture mode
   *
   * @param {Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#dblclick
   * @private
   */
  handleTechDoubleClick_(e) {
    if (!this.controls_)
      return;
    Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (r) => r.contains(e.target)) || (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick == "function" ? this.options_.userActions.doubleClick.call(this, e) : this.isInPictureInPicture() && !ot.pictureInPictureElement ? this.exitPictureInPicture() : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen());
  }
  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */
  handleTechTap_() {
    this.userActive(!this.userActive());
  }
  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */
  handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  }
  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */
  handleTechTouchMove_() {
    this.userWasActive && this.reportUserActivity();
  }
  /**
   * Handle touch to end
   *
   * @param {Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */
  handleTechTouchEnd_(e) {
    e.cancelable && e.preventDefault();
  }
  /**
   * @private
   */
  toggleFullscreenClass_() {
    this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen");
  }
  /**
   * when the document fschange event triggers it calls this
   */
  documentFullscreenChange_(e) {
    const n = e.target.player;
    if (n && n !== this)
      return;
    const r = this.el();
    let i = ot[this.fsApi_.fullscreenElement] === r;
    !i && r.matches && (i = r.matches(":" + this.fsApi_.fullscreen)), this.isFullscreen(i);
  }
  /**
   * Handle Tech Fullscreen Change
   *
   * @param {Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */
  handleTechFullscreenChange_(e, n) {
    n && (n.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"), this.tech_.one("webkitendfullscreen", () => {
      this.removeClass("vjs-ios-native-fs");
    })), this.isFullscreen(n.isFullscreen));
  }
  handleTechFullscreenError_(e, n) {
    this.trigger("fullscreenerror", n);
  }
  /**
   * @private
   */
  togglePictureInPictureClass_() {
    this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture");
  }
  /**
   * Handle Tech Enter Picture-in-Picture.
   *
   * @param {Event} event
   *        the enterpictureinpicture event that triggered this function
   *
   * @private
   * @listens Tech#enterpictureinpicture
   */
  handleTechEnterPictureInPicture_(e) {
    this.isInPictureInPicture(!0);
  }
  /**
   * Handle Tech Leave Picture-in-Picture.
   *
   * @param {Event} event
   *        the leavepictureinpicture event that triggered this function
   *
   * @private
   * @listens Tech#leavepictureinpicture
   */
  handleTechLeavePictureInPicture_(e) {
    this.isInPictureInPicture(!1);
  }
  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */
  handleTechError_() {
    const e = this.tech_.error();
    e && this.error(e);
  }
  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */
  handleTechTextData_() {
    let e = null;
    arguments.length > 1 && (e = arguments[1]), this.trigger("textdata", e);
  }
  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */
  getCache() {
    return this.cache_;
  }
  /**
   * Resets the internal cache object.
   *
   * Using this function outside the player constructor or reset method may
   * have unintended side-effects.
   *
   * @private
   */
  resetCache_() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      initTime: 0,
      inactivityTimeout: this.options_.inactivityTimeout,
      duration: NaN,
      lastVolume: 1,
      lastPlaybackRate: this.defaultPlaybackRate(),
      media: null,
      src: "",
      source: {},
      sources: [],
      playbackRates: [],
      volume: 1
    };
  }
  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} [arg]
   *        the argument to pass
   *
   * @private
   */
  techCall_(e, n) {
    this.ready(function() {
      if (e in Wwe)
        return qwe(this.middleware_, this.tech_, e, n);
      if (e in Gx)
        return Qx(this.middleware_, this.tech_, e, n);
      try {
        this.tech_ && this.tech_[e](n);
      } catch (r) {
        throw Kt(r), r;
      }
    }, !0);
  }
  /**
   * Mediate attempt to call playback tech method
   * and return the value of the method called.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {*}
   *         Value returned by the tech method called, undefined if tech
   *         is not ready or tech method is not present
   *
   * @private
   */
  techGet_(e) {
    if (!(!this.tech_ || !this.tech_.isReady_)) {
      if (e in Vwe)
        return zwe(this.middleware_, this.tech_, e);
      if (e in Gx)
        return Qx(this.middleware_, this.tech_, e);
      try {
        return this.tech_[e]();
      } catch (n) {
        throw this.tech_[e] === void 0 ? (Kt(`Video.js: ${e} method not defined for ${this.techName_} playback technology.`, n), n) : n.name === "TypeError" ? (Kt(`Video.js: ${e} unavailable on ${this.techName_} playback technology element.`, n), this.tech_.isReady_ = !1, n) : (Kt(n), n);
      }
    }
  }
  /**
   * Attempt to begin playback at the first opportunity.
   *
   * @return {Promise|undefined}
   *         Returns a promise if the browser supports Promises (or one
   *         was passed in as an option). This promise will be resolved on
   *         the return value of play. If this is undefined it will fulfill the
   *         promise chain otherwise the promise chain will be fulfilled when
   *         the promise from play is fulfilled.
   */
  play() {
    return new Promise((e) => {
      this.play_(e);
    });
  }
  /**
   * The actual logic for play, takes a callback that will be resolved on the
   * return value of play. This allows us to resolve to the play promise if there
   * is one on modern browsers.
   *
   * @private
   * @param {Function} [callback]
   *        The callback that should be called when the techs play is actually called
   */
  play_(e = ta) {
    this.playCallbacks_.push(e);
    const n = !!(!this.changingSrc_ && (this.src() || this.currentSrc())), r = !!(kg || ei);
    if (this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_), this.waitToPlay_ = null), !this.isReady_ || !n) {
      this.waitToPlay_ = (a) => {
        this.play_();
      }, this.one(["ready", "loadstart"], this.waitToPlay_), !n && r && this.load();
      return;
    }
    const i = this.techGet_("play");
    r && this.hasClass("vjs-ended") && this.resetProgressBar_(), i === null ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(i);
  }
  /**
   * These functions will be run when if play is terminated. If play
   * runPlayCallbacks_ is run these function will not be run. This allows us
   * to differentiate between a terminated play and an actual call to play.
   */
  runPlayTerminatedQueue_() {
    const e = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [], e.forEach(function(n) {
      n();
    });
  }
  /**
   * When a callback to play is delayed we have to run these
   * callbacks when play is actually called on the tech. This function
   * runs the callbacks that were delayed and accepts the return value
   * from the tech.
   *
   * @param {undefined|Promise} val
   *        The return value from the tech.
   */
  runPlayCallbacks_(e) {
    const n = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [], this.playTerminatedQueue_ = [], n.forEach(function(r) {
      r(e);
    });
  }
  /**
   * Pause the video playback
   */
  pause() {
    this.techCall_("pause");
  }
  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */
  paused() {
    return this.techGet_("paused") !== !1;
  }
  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */
  played() {
    return this.techGet_("played") || Ds(0, 0);
  }
  /**
   * Sets or returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        whether the user is or is not scrubbing
   *
   * @return {boolean|undefined}
   *         - The value of scrubbing when getting
   *         - Nothing when setting
   */
  scrubbing(e) {
    if (typeof e > "u")
      return this.scrubbing_;
    this.scrubbing_ = !!e, this.techCall_("setScrubbing", this.scrubbing_), e ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing");
  }
  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number|undefined}
   *         - the current time in seconds when getting
   *         - Nothing when setting
   */
  currentTime(e) {
    if (e === void 0)
      return this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime;
    if (e < 0 && (e = 0), !this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
      this.cache_.initTime = e, this.off("canplay", this.boundApplyInitTime_), this.one("canplay", this.boundApplyInitTime_);
      return;
    }
    this.techCall_("setCurrentTime", e), this.cache_.initTime = 0, isFinite(e) && (this.cache_.currentTime = Number(e));
  }
  /**
   * Apply the value of initTime stored in cache as currentTime.
   *
   * @private
   */
  applyInitTime_() {
    this.currentTime(this.cache_.initTime);
  }
  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and depending on preload behaviour may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number|undefined}
   *         - The duration of the video in seconds when getting
   *         - Nothing when setting
   */
  duration(e) {
    if (e === void 0)
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    e = parseFloat(e), e < 0 && (e = 1 / 0), e !== this.cache_.duration && (this.cache_.duration = e, e === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"), isNaN(e) || this.trigger("durationchange"));
  }
  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */
  remainingTime() {
    return this.duration() - this.currentTime();
  }
  /**
   * A remaining time function that is intended to be used when
   * the time is to be displayed directly to the user.
   *
   * @return {number}
   *         The rounded time remaining in seconds
   */
  remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  }
  //
  // Kind of like an array of portions of the video that have been downloaded.
  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock {@link TimeRanges} object (following HTML spec)
   */
  buffered() {
    let e = this.techGet_("buffered");
    return (!e || !e.length) && (e = Ds(0, 0)), e;
  }
  /**
   * Get the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @see [Seekable Spec]{@link https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable}
   *
   * @return {TimeRange}
   *         A mock {@link TimeRanges} object (following HTML spec)
   */
  seekable() {
    let e = this.techGet_("seekable");
    return (!e || !e.length) && (e = Ds(0, 0)), e;
  }
  /**
   * Returns whether the player is in the "seeking" state.
   *
   * @return {boolean} True if the player is in the seeking state, false if not.
   */
  seeking() {
    return this.techGet_("seeking");
  }
  /**
   * Returns whether the player is in the "ended" state.
   *
   * @return {boolean} True if the player is in the ended state, false if not.
   */
  ended() {
    return this.techGet_("ended");
  }
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   */
  networkState() {
    return this.techGet_("networkState");
  }
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   */
  readyState() {
    return this.techGet_("readyState");
  }
  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is buffered 0 being 0% and 1 being 100%
   */
  bufferedPercent() {
    return s8(this.buffered(), this.duration());
  }
  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */
  bufferedEnd() {
    const e = this.buffered(), n = this.duration();
    let r = e.end(e.length - 1);
    return r > n && (r = n), r;
  }
  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number|undefined}
   *         The current volume as a percent when getting
   */
  volume(e) {
    let n;
    if (e !== void 0) {
      n = Math.max(0, Math.min(1, e)), this.cache_.volume = n, this.techCall_("setVolume", n), n > 0 && this.lastVolume_(n);
      return;
    }
    return n = parseFloat(this.techGet_("volume")), isNaN(n) ? 1 : n;
  }
  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|undefined}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   *         - nothing if setting
   */
  muted(e) {
    if (e !== void 0) {
      this.techCall_("setMuted", e);
      return;
    }
    return this.techGet_("muted") || !1;
  }
  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on initial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|undefined}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - Nothing when setting
   */
  defaultMuted(e) {
    return e !== void 0 && this.techCall_("setDefaultMuted", e), this.techGet_("defaultMuted") || !1;
  }
  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number|undefined}
   *         - The current value of lastVolume as a percent when getting
   *         - Nothing when setting
   *
   * @private
   */
  lastVolume_(e) {
    if (e !== void 0 && e !== 0) {
      this.cache_.lastVolume = e;
      return;
    }
    return this.cache_.lastVolume;
  }
  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */
  supportsFullScreen() {
    return this.techGet_("supportsFullScreen") || !1;
  }
  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean|undefined}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   *         - Nothing when setting
   */
  isFullscreen(e) {
    if (e !== void 0) {
      const n = this.isFullscreen_;
      this.isFullscreen_ = !!e, this.isFullscreen_ !== n && this.fsApi_.prefixed && this.trigger("fullscreenchange"), this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  }
  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @param  {Object} [fullscreenOptions]
   *         Override the player fullscreen options
   *
   * @fires Player#fullscreenchange
   */
  requestFullscreen(e) {
    this.isInPictureInPicture() && this.exitPictureInPicture();
    const n = this;
    return new Promise((r, i) => {
      function s() {
        n.off("fullscreenerror", o), n.off("fullscreenchange", a);
      }
      function a() {
        s(), r();
      }
      function o(c, d) {
        s(), i(d);
      }
      n.one("fullscreenchange", a), n.one("fullscreenerror", o);
      const u = n.requestFullscreenHelper_(e);
      u && (u.then(s, s), u.then(r, i));
    });
  }
  requestFullscreenHelper_(e) {
    let n;
    if (this.fsApi_.prefixed || (n = this.options_.fullscreen && this.options_.fullscreen.options || {}, e !== void 0 && (n = e)), this.fsApi_.requestFullscreen) {
      const r = this.el_[this.fsApi_.requestFullscreen](n);
      return r && r.then(() => this.isFullscreen(!0), () => this.isFullscreen(!1)), r;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow();
  }
  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */
  exitFullscreen() {
    const e = this;
    return new Promise((n, r) => {
      function i() {
        e.off("fullscreenerror", a), e.off("fullscreenchange", s);
      }
      function s() {
        i(), n();
      }
      function a(u, c) {
        i(), r(c);
      }
      e.one("fullscreenchange", s), e.one("fullscreenerror", a);
      const o = e.exitFullscreenHelper_();
      o && (o.then(i, i), o.then(n, r));
    });
  }
  exitFullscreenHelper_() {
    if (this.fsApi_.requestFullscreen) {
      const e = ot[this.fsApi_.exitFullscreen]();
      return e && ta(e.then(() => this.isFullscreen(!1))), e;
    } else this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow();
  }
  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */
  enterFullWindow() {
    this.isFullscreen(!0), this.isFullWindow = !0, this.docOrigOverflow = ot.documentElement.style.overflow, Qi(ot, "keydown", this.boundFullWindowOnEscKey_), ot.documentElement.style.overflow = "hidden", Iu(ot.body, "vjs-full-window"), this.trigger("enterFullWindow");
  }
  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */
  fullWindowOnEscKey(e) {
    e.key === "Escape" && this.isFullscreen() === !0 && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen());
  }
  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */
  exitFullWindow() {
    this.isFullscreen(!1), this.isFullWindow = !1, ti(ot, "keydown", this.boundFullWindowOnEscKey_), ot.documentElement.style.overflow = this.docOrigOverflow, Dg(ot.body, "vjs-full-window"), this.trigger("exitFullWindow");
  }
  /**
   * Get or set disable Picture-in-Picture mode.
   *
   * @param {boolean} [value]
   *                  - true will disable Picture-in-Picture mode
   *                  - false will enable Picture-in-Picture mode
   */
  disablePictureInPicture(e) {
    if (e === void 0)
      return this.techGet_("disablePictureInPicture");
    this.techCall_("setDisablePictureInPicture", e), this.options_.disablePictureInPicture = e, this.trigger("disablepictureinpicturechanged");
  }
  /**
   * Check if the player is in Picture-in-Picture mode or tell the player that it
   * is or is not in Picture-in-Picture mode.
   *
   * @param  {boolean} [isPiP]
   *         Set the players current Picture-in-Picture state
   *
   * @return {boolean|undefined}
   *         - true if Picture-in-Picture is on and getting
   *         - false if Picture-in-Picture is off and getting
   *         - nothing if setting
   */
  isInPictureInPicture(e) {
    if (e !== void 0) {
      this.isInPictureInPicture_ = !!e, this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  }
  /**
   * Create a floating video window always on top of other windows so that users may
   * continue consuming media while they interact with other content sites, or
   * applications on their device.
   *
   * This can use document picture-in-picture or element picture in picture
   *
   * Set `enableDocumentPictureInPicture` to `true` to use docPiP on a supported browser
   * Else set `disablePictureInPicture` to `false` to disable elPiP on a supported browser
   *
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/}
   * @see [Spec]{@link https://wicg.github.io/document-picture-in-picture/}
   *
   * @fires Player#enterpictureinpicture
   *
   * @return {Promise}
   *         A promise with a Picture-in-Picture window.
   */
  requestPictureInPicture() {
    if (this.options_.enableDocumentPictureInPicture && pe.documentPictureInPicture) {
      const e = ot.createElement(this.el().tagName);
      return e.classList = this.el().classList, e.classList.add("vjs-pip-container"), this.posterImage && e.appendChild(this.posterImage.el().cloneNode(!0)), this.titleBar && e.appendChild(this.titleBar.el().cloneNode(!0)), e.appendChild(Nt("p", {
        className: "vjs-pip-text"
      }, {}, this.localize("Playing in picture-in-picture"))), pe.documentPictureInPicture.requestWindow({
        // The aspect ratio won't be correct, Chrome bug https://crbug.com/1407629
        width: this.videoWidth(),
        height: this.videoHeight()
      }).then((n) => (WD(n), this.el_.parentNode.insertBefore(e, this.el_), n.document.body.appendChild(this.el_), n.document.body.classList.add("vjs-pip-window"), this.player_.isInPictureInPicture(!0), this.player_.trigger({
        type: "enterpictureinpicture",
        pipWindow: n
      }), n.addEventListener("pagehide", (r) => {
        const i = r.target.querySelector(".video-js");
        e.parentNode.replaceChild(i, e), this.player_.isInPictureInPicture(!1), this.player_.trigger("leavepictureinpicture");
      }), n));
    }
    return "pictureInPictureEnabled" in ot && this.disablePictureInPicture() === !1 ? this.techGet_("requestPictureInPicture") : Promise.reject("No PiP mode is available");
  }
  /**
   * Exit Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @fires Player#leavepictureinpicture
   *
   * @return {Promise}
   *         A promise.
   */
  exitPictureInPicture() {
    if (pe.documentPictureInPicture && pe.documentPictureInPicture.window)
      return pe.documentPictureInPicture.window.close(), Promise.resolve();
    if ("pictureInPictureEnabled" in ot)
      return ot.exitPictureInPicture();
  }
  /**
   * Called when this Player has focus and a key gets pressed down, or when
   * any Component of this player receives a key press that it doesn't handle.
   * This allows player-wide hotkeys (either as defined below, or optionally
   * by an external function).
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(e) {
    const {
      userActions: n
    } = this.options_;
    !n || !n.hotkeys || ((i) => {
      const s = i.tagName.toLowerCase();
      if (i.isContentEditable)
        return !0;
      const a = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
      return s === "input" ? a.indexOf(i.type) === -1 : ["textarea"].indexOf(s) !== -1;
    })(this.el_.ownerDocument.activeElement) || (typeof n.hotkeys == "function" ? n.hotkeys.call(this, e) : this.handleHotkeys(e));
  }
  /**
   * Called when this Player receives a hotkey keydown event.
   * Supported player-wide hotkeys are:
   *
   *   f          - toggle fullscreen
   *   m          - toggle mute
   *   k or Space - toggle play/pause
   *
   * @param {Event} event
   *        The `keydown` event that caused this function to be called.
   */
  handleHotkeys(e) {
    const n = this.options_.userActions ? this.options_.userActions.hotkeys : {}, {
      fullscreenKey: r = (a) => e.key.toLowerCase() === "f",
      muteKey: i = (a) => e.key.toLowerCase() === "m",
      playPauseKey: s = (a) => e.key.toLowerCase() === "k" || e.key.toLowerCase() === " "
    } = n;
    if (r.call(this, e)) {
      e.preventDefault(), e.stopPropagation();
      const a = He.getComponent("FullscreenToggle");
      ot[this.fsApi_.fullscreenEnabled] !== !1 && a.prototype.handleClick.call(this, e);
    } else i.call(this, e) ? (e.preventDefault(), e.stopPropagation(), He.getComponent("MuteToggle").prototype.handleClick.call(this, e)) : s.call(this, e) && (e.preventDefault(), e.stopPropagation(), He.getComponent("PlayToggle").prototype.handleClick.call(this, e));
  }
  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  canPlayType(e) {
    let n;
    for (let r = 0, i = this.options_.techOrder; r < i.length; r++) {
      const s = i[r];
      let a = Ht.getTech(s);
      if (a || (a = He.getComponent(s)), !a) {
        Kt.error(`The "${s}" tech is undefined. Skipped browser support check for that tech.`);
        continue;
      }
      if (a.isSupported() && (n = a.canPlayType(e), n))
        return n;
    }
    return "";
  }
  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */
  selectSource(e) {
    const n = this.options_.techOrder.map((o) => [o, Ht.getTech(o)]).filter(([o, u]) => u ? u.isSupported() : (Kt.error(`The "${o}" tech is undefined. Skipped browser support check for that tech.`), !1)), r = function(o, u, c) {
      let d;
      return o.some((l) => u.some((f) => {
        if (d = c(l, f), d)
          return !0;
      })), d;
    };
    let i;
    const s = (o) => (u, c) => o(c, u), a = ([o, u], c) => {
      if (u.canPlaySource(c, this.options_[o.toLowerCase()]))
        return {
          source: c,
          tech: o
        };
    };
    return this.options_.sourceOrder ? i = r(e, n, s(a)) : i = r(n, e, a), i || !1;
  }
  /**
   * Executes source setting and getting logic
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   * @param {boolean} [isRetry]
   *        Indicates whether this is being called internally as a result of a retry
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */
  handleSrc_(e, n) {
    if (typeof e > "u")
      return this.cache_.src || "";
    this.resetRetryOnError_ && this.resetRetryOnError_();
    const r = d8(e);
    if (!r.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    if (this.changingSrc_ = !0, n || (this.cache_.sources = r), this.updateSourceCaches_(r[0]), Hwe(this, r[0], (i, s) => {
      if (this.middleware_ = s, n || (this.cache_.sources = r), this.updateSourceCaches_(i), this.src_(i)) {
        if (r.length > 1)
          return this.handleSrc_(r.slice(1));
        this.changingSrc_ = !1, this.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0), this.triggerReady();
        return;
      }
      jwe(s, this.tech_);
    }), r.length > 1) {
      const i = () => {
        this.error(null), this.handleSrc_(r.slice(1), !0);
      }, s = () => {
        this.off("error", i);
      };
      this.one("error", i), this.one("playing", s), this.resetRetryOnError_ = () => {
        this.off("error", i), this.off("playing", s);
      };
    }
  }
  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */
  src(e) {
    return this.handleSrc_(e, !1);
  }
  /**
   * Set the source object on the tech, returns a boolean that indicates whether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */
  src_(e) {
    const n = this.selectSource([e]);
    return n ? t8(n.tech, this.techName_) ? (this.ready(function() {
      this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", e) : this.techCall_("src", e.src), this.changingSrc_ = !1;
    }, !0), !1) : (this.changingSrc_ = !0, this.loadTech_(n.tech, n.source), this.tech_.ready(() => {
      this.changingSrc_ = !1;
    }), !1) : !0;
  }
  /**
   * Add a <source> element to the <video> element.
   *
   * @param {string} srcUrl
   *        The URL of the video source.
   *
   * @param {string} [mimeType]
   *        The MIME type of the video source. Optional but recommended.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully added, false otherwise.
   */
  addSourceElement(e, n) {
    return this.tech_ ? this.tech_.addSourceElement(e, n) : !1;
  }
  /**
   * Remove a <source> element from the <video> element by its URL.
   *
   * @param {string} srcUrl
   *        The URL of the source to remove.
   *
   * @return {boolean}
   *         Returns true if the source element was successfully removed, false otherwise.
   */
  removeSourceElement(e) {
    return this.tech_ ? this.tech_.removeSourceElement(e) : !1;
  }
  /**
   * Begin loading the src data.
   */
  load() {
    if (this.tech_ && this.tech_.vhs) {
      this.src(this.currentSource());
      return;
    }
    this.techCall_("load");
  }
  /**
   * Reset the player. Loads the first tech in the techOrder,
   * removes all the text tracks in the existing `tech`,
   * and calls `reset` on the `tech`.
   */
  reset() {
    if (this.paused())
      this.doReset_();
    else {
      const e = this.play();
      ta(e.then(() => this.doReset_()));
    }
  }
  doReset_() {
    this.tech_ && this.tech_.clearTracks("text"), this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.resetCache_(), this.poster(""), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), this.resetControlBarUI_(), this.error(null), this.titleBar && this.titleBar.update({
      title: void 0,
      description: void 0
    }), Ha(this) && this.trigger("playerreset");
  }
  /**
   * Reset Control Bar's UI by calling sub-methods that reset
   * all of Control Bar's components
   */
  resetControlBarUI_() {
    this.resetProgressBar_(), this.resetPlaybackRate_(), this.resetVolumeBar_();
  }
  /**
   * Reset tech's progress so progress bar is reset in the UI
   */
  resetProgressBar_() {
    this.currentTime(0);
    const {
      currentTimeDisplay: e,
      durationDisplay: n,
      progressControl: r,
      remainingTimeDisplay: i
    } = this.controlBar || {}, {
      seekBar: s
    } = r || {};
    e && e.updateContent(), n && n.updateContent(), i && i.updateContent(), s && (s.update(), s.loadProgressBar && s.loadProgressBar.update());
  }
  /**
   * Reset Playback ratio
   */
  resetPlaybackRate_() {
    this.playbackRate(this.defaultPlaybackRate()), this.handleTechRateChange_();
  }
  /**
   * Reset Volume bar
   */
  resetVolumeBar_() {
    this.volume(1), this.trigger("volumechange");
  }
  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */
  currentSources() {
    const e = this.currentSource(), n = [];
    return Object.keys(e).length !== 0 && n.push(e), this.cache_.sources || n;
  }
  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */
  currentSource() {
    return this.cache_.source || {};
  }
  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */
  currentSrc() {
    return this.currentSource() && this.currentSource().src || "";
  }
  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */
  currentType() {
    return this.currentSource() && this.currentSource().type || "";
  }
  /**
   * Get or set the preload attribute
   *
   * @param {'none'|'auto'|'metadata'} [value]
   *        Preload mode to pass to tech
   *
   * @return {string|undefined}
   *         - The preload attribute value when getting
   *         - Nothing when setting
   */
  preload(e) {
    if (e !== void 0) {
      this.techCall_("setPreload", e), this.options_.preload = e;
      return;
    }
    return this.techGet_("preload");
  }
  /**
   * Get or set the autoplay option. When this is a boolean it will
   * modify the attribute on the tech. When this is a string the attribute on
   * the tech will be removed and `Player` will handle autoplay on loadstarts.
   *
   * @param {boolean|'play'|'muted'|'any'} [value]
   *        - true: autoplay using the browser behavior
   *        - false: do not autoplay
   *        - 'play': call play() on every loadstart
   *        - 'muted': call muted() then play() on every loadstart
   *        - 'any': call play() on every loadstart. if that fails call muted() then play().
   *        - *: values other than those listed here will be set `autoplay` to true
   *
   * @return {boolean|string|undefined}
   *         - The current value of autoplay when getting
   *         - Nothing when setting
   */
  autoplay(e) {
    if (e === void 0)
      return this.options_.autoplay || !1;
    let n;
    typeof e == "string" && /(any|play|muted)/.test(e) || e === !0 && this.options_.normalizeAutoplay ? (this.options_.autoplay = e, this.manualAutoplay_(typeof e == "string" ? e : "play"), n = !1) : e ? this.options_.autoplay = !0 : this.options_.autoplay = !1, n = typeof n > "u" ? this.options_.autoplay : n, this.tech_ && this.techCall_("setAutoplay", n);
  }
  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|undefined}
   *         - the current value of playsinline
   *         - Nothing when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  playsinline(e) {
    return e !== void 0 && (this.techCall_("setPlaysinline", e), this.options_.playsinline = e), this.techGet_("playsinline");
  }
  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {boolean|undefined}
   *         - The current value of loop when getting
   *         - Nothing when setting
   */
  loop(e) {
    if (e !== void 0) {
      this.techCall_("setLoop", e), this.options_.loop = e;
      return;
    }
    return this.techGet_("loop");
  }
  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string|undefined}
   *         - The current value of poster when getting
   *         - Nothing when setting
   */
  poster(e) {
    if (e === void 0)
      return this.poster_;
    e || (e = ""), e !== this.poster_ && (this.poster_ = e, this.techCall_("setPoster", e), this.isPosterFromTech_ = !1, this.trigger("posterchange"));
  }
  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */
  handleTechPosterChange_() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      const e = this.tech_.poster() || "";
      e !== this.poster_ && (this.poster_ = e, this.isPosterFromTech_ = !0, this.trigger("posterchange"));
    }
  }
  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean|undefined}
   *         - The current value of controls when getting
   *         - Nothing when setting
   */
  controls(e) {
    if (e === void 0)
      return !!this.controls_;
    e = !!e, this.controls_ !== e && (this.controls_ = e, this.usingNativeControls() && this.techCall_("setControls", e), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_()));
  }
  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls) or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean|undefined}
   *         - The current value of native controls when getting
   *         - Nothing when setting
   */
  usingNativeControls(e) {
    if (e === void 0)
      return !!this.usingNativeControls_;
    e = !!e, this.usingNativeControls_ !== e && (this.usingNativeControls_ = e, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols")));
  }
  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null|undefined}
   *         - The current MediaError when getting (or null)
   *         - Nothing when setting
   */
  error(e) {
    if (e === void 0)
      return this.error_ || null;
    if (Oo("beforeerror").forEach((n) => {
      const r = n(this, e);
      if (!(fa(r) && !Array.isArray(r) || typeof r == "string" || typeof r == "number" || r === null)) {
        this.log.error("please return a value that MediaError expects in beforeerror hooks");
        return;
      }
      e = r;
    }), this.options_.suppressNotSupportedError && e && e.code === 4) {
      const n = function() {
        this.error(e);
      };
      this.options_.suppressNotSupportedError = !1, this.any(["click", "touchstart"], n), this.one("loadstart", function() {
        this.off(["click", "touchstart"], n);
      });
      return;
    }
    if (e === null) {
      this.error_ = null, this.removeClass("vjs-error"), this.errorDisplay && this.errorDisplay.close();
      return;
    }
    this.error_ = new nr(e), this.addClass("vjs-error"), Kt.error(`(CODE:${this.error_.code} ${nr.errorTypes[this.error_.code]})`, this.error_.message, this.error_), this.trigger("error"), Oo("error").forEach((n) => n(this, this.error_));
  }
  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */
  reportUserActivity(e) {
    this.userActivity_ = !0;
  }
  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean|undefined}
   *         - The current value of userActive when getting
   *         - Nothing when setting
   */
  userActive(e) {
    if (e === void 0)
      return this.userActive_;
    if (e = !!e, e !== this.userActive_) {
      if (this.userActive_ = e, this.userActive_) {
        this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), this.trigger("useractive");
        return;
      }
      this.tech_ && this.tech_.one("mousemove", function(n) {
        n.stopPropagation(), n.preventDefault();
      }), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive");
    }
  }
  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */
  listenForUserActivity_() {
    let e, n, r;
    const i = Un(this, this.reportUserActivity), s = function(l) {
      (l.screenX !== n || l.screenY !== r) && (n = l.screenX, r = l.screenY, i());
    }, a = function() {
      i(), this.clearInterval(e), e = this.setInterval(i, 250);
    }, o = function(l) {
      i(), this.clearInterval(e);
    };
    this.on("mousedown", a), this.on("mousemove", s), this.on("mouseup", o), this.on("mouseleave", o);
    const u = this.getChild("controlBar");
    u && !ei && !Ns && (u.on("mouseenter", function(l) {
      this.player().options_.inactivityTimeout !== 0 && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout), this.player().options_.inactivityTimeout = 0;
    }), u.on("mouseleave", function(l) {
      this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
    })), this.on("keydown", i), this.on("keyup", i);
    let c;
    const d = function() {
      if (!this.userActivity_)
        return;
      this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(c);
      const l = this.options_.inactivityTimeout;
      l <= 0 || (c = this.setTimeout(function() {
        this.userActivity_ || this.userActive(!1);
      }, l));
    };
    this.setInterval(d, 250);
  }
  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number|undefined}
   *         - The current playback rate when getting or 1.0
   *         - Nothing when setting
   */
  playbackRate(e) {
    if (e !== void 0) {
      this.techCall_("setPlaybackRate", e);
      return;
    }
    return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1;
  }
  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|undefined}
   *         - The default playback rate when getting or 1.0
   *         - Nothing when setting
   */
  defaultPlaybackRate(e) {
    return e !== void 0 ? this.techCall_("setDefaultPlaybackRate", e) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1;
  }
  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} [bool]
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean|undefined}
   *         - The current value of isAudio when getting
   *         - Nothing when setting
   */
  isAudio(e) {
    if (e !== void 0) {
      this.isAudio_ = !!e;
      return;
    }
    return !!this.isAudio_;
  }
  updatePlayerHeightOnAudioOnlyMode_() {
    const e = this.getChild("ControlBar");
    !e || this.audioOnlyCache_.controlBarHeight === e.currentHeight() || (this.audioOnlyCache_.controlBarHeight = e.currentHeight(), this.height(this.audioOnlyCache_.controlBarHeight));
  }
  enableAudioOnlyUI_() {
    this.addClass("vjs-audio-only-mode");
    const e = this.children(), n = this.getChild("ControlBar"), r = n && n.currentHeight();
    e.forEach((i) => {
      i !== n && i.el_ && !i.hasClass("vjs-hidden") && (i.hide(), this.audioOnlyCache_.hiddenChildren.push(i));
    }), this.audioOnlyCache_.playerHeight = this.currentHeight(), this.audioOnlyCache_.controlBarHeight = r, this.on("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_), this.height(r), this.trigger("audioonlymodechange");
  }
  disableAudioOnlyUI_() {
    this.removeClass("vjs-audio-only-mode"), this.off("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_), this.audioOnlyCache_.hiddenChildren.forEach((e) => e.show()), this.height(this.audioOnlyCache_.playerHeight), this.trigger("audioonlymodechange");
  }
  /**
   * Get the current audioOnlyMode state or set audioOnlyMode to true or false.
   *
   * Setting this to `true` will hide all player components except the control bar,
   * as well as control bar components needed only for video.
   *
   * @param {boolean} [value]
   *         The value to set audioOnlyMode to.
   *
   * @return {Promise|boolean}
   *        A Promise is returned when setting the state, and a boolean when getting
   *        the present state
   */
  audioOnlyMode(e) {
    if (typeof e != "boolean" || e === this.audioOnlyMode_)
      return this.audioOnlyMode_;
    if (this.audioOnlyMode_ = e, e) {
      const n = [];
      return this.isInPictureInPicture() && n.push(this.exitPictureInPicture()), this.isFullscreen() && n.push(this.exitFullscreen()), this.audioPosterMode() && n.push(this.audioPosterMode(!1)), Promise.all(n).then(() => this.enableAudioOnlyUI_());
    }
    return Promise.resolve().then(() => this.disableAudioOnlyUI_());
  }
  enablePosterModeUI_() {
    (this.tech_ && this.tech_).hide(), this.addClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }
  disablePosterModeUI_() {
    (this.tech_ && this.tech_).show(), this.removeClass("vjs-audio-poster-mode"), this.trigger("audiopostermodechange");
  }
  /**
   * Get the current audioPosterMode state or set audioPosterMode to true or false
   *
   * @param {boolean} [value]
   *         The value to set audioPosterMode to.
   *
   * @return {Promise|boolean}
   *         A Promise is returned when setting the state, and a boolean when getting
   *        the present state
   */
  audioPosterMode(e) {
    return typeof e != "boolean" || e === this.audioPosterMode_ ? this.audioPosterMode_ : (this.audioPosterMode_ = e, e ? this.audioOnlyMode() ? this.audioOnlyMode(!1).then(() => {
      this.enablePosterModeUI_();
    }) : Promise.resolve().then(() => {
      this.enablePosterModeUI_();
    }) : Promise.resolve().then(() => {
      this.disablePosterModeUI_();
    }));
  }
  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */
  addTextTrack(e, n, r) {
    if (this.tech_)
      return this.tech_.addTextTrack(e, n, r);
  }
  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed
   *                                        from the TextTrackList and HtmlTrackElementList
   *                                        after a source change
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   */
  addRemoteTextTrack(e, n) {
    if (this.tech_)
      return this.tech_.addRemoteTextTrack(e, n);
  }
  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */
  removeRemoteTextTrack(e = {}) {
    let {
      track: n
    } = e;
    if (n || (n = e), this.tech_)
      return this.tech_.removeRemoteTextTrack(n);
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */
  getVideoPlaybackQuality() {
    return this.techGet_("getVideoPlaybackQuality");
  }
  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */
  videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  }
  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */
  videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  }
  /**
   * Set or get the player's language code.
   *
   * Changing the language will trigger
   * [languagechange]{@link Player#event:languagechange}
   * which Components can use to update control text.
   * ClickableComponent will update its control text by default on
   * [languagechange]{@link Player#event:languagechange}.
   *
   * @fires Player#languagechange
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string|undefined}
   *         - The current language code when getting
   *         - Nothing when setting
   */
  language(e) {
    if (e === void 0)
      return this.language_;
    this.language_ !== String(e).toLowerCase() && (this.language_ = String(e).toLowerCase(), Ha(this) && this.trigger("languagechange"));
  }
  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */
  languages() {
    return Dn(En.prototype.options_.languages, this.languages_);
  }
  /**
   * returns a JavaScript object representing the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */
  toJSON() {
    const e = Dn(this.options_), n = e.tracks;
    e.tracks = [];
    for (let r = 0; r < n.length; r++) {
      let i = n[r];
      i = Dn(i), i.player = void 0, e.tracks[r] = i;
    }
    return e;
  }
  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */
  createModal(e, n) {
    n = n || {}, n.content = e || "";
    const r = new zc(this, n);
    return this.addChild(r), r.on("dispose", () => {
      this.removeChild(r);
    }), r.open(), r;
  }
  /**
   * Change breakpoint classes when the player resizes.
   *
   * @private
   */
  updateCurrentBreakpoint_() {
    if (!this.responsive())
      return;
    const e = this.currentBreakpoint(), n = this.currentWidth();
    for (let r = 0; r < ry.length; r++) {
      const i = ry[r], s = this.breakpoints_[i];
      if (n <= s) {
        if (e === i)
          return;
        e && this.removeClass(ym[e]), this.addClass(ym[i]), this.breakpoint_ = i;
        break;
      }
    }
  }
  /**
   * Removes the current breakpoint.
   *
   * @private
   */
  removeCurrentBreakpoint_() {
    const e = this.currentBreakpointClass();
    this.breakpoint_ = "", e && this.removeClass(e);
  }
  /**
   * Get or set breakpoints on the player.
   *
   * Calling this method with an object or `true` will remove any previous
   * custom breakpoints and start from the defaults again.
   *
   * @param  {Object|boolean} [breakpoints]
   *         If an object is given, it can be used to provide custom
   *         breakpoints. If `true` is given, will set default breakpoints.
   *         If this argument is not given, will simply return the current
   *         breakpoints.
   *
   * @param  {number} [breakpoints.tiny]
   *         The maximum width for the "vjs-layout-tiny" class.
   *
   * @param  {number} [breakpoints.xsmall]
   *         The maximum width for the "vjs-layout-x-small" class.
   *
   * @param  {number} [breakpoints.small]
   *         The maximum width for the "vjs-layout-small" class.
   *
   * @param  {number} [breakpoints.medium]
   *         The maximum width for the "vjs-layout-medium" class.
   *
   * @param  {number} [breakpoints.large]
   *         The maximum width for the "vjs-layout-large" class.
   *
   * @param  {number} [breakpoints.xlarge]
   *         The maximum width for the "vjs-layout-x-large" class.
   *
   * @param  {number} [breakpoints.huge]
   *         The maximum width for the "vjs-layout-huge" class.
   *
   * @return {Object}
   *         An object mapping breakpoint names to maximum width values.
   */
  breakpoints(e) {
    return e === void 0 ? Object.assign(this.breakpoints_) : (this.breakpoint_ = "", this.breakpoints_ = Object.assign({}, kCe, e), this.updateCurrentBreakpoint_(), Object.assign(this.breakpoints_));
  }
  /**
   * Get or set a flag indicating whether or not this player should adjust
   * its UI based on its dimensions.
   *
   * @param  {boolean} [value]
   *         Should be `true` if the player should adjust its UI based on its
   *         dimensions; otherwise, should be `false`.
   *
   * @return {boolean|undefined}
   *         Will be `true` if this player should adjust its UI based on its
   *         dimensions; otherwise, will be `false`.
   *         Nothing if setting
   */
  responsive(e) {
    if (e === void 0)
      return this.responsive_;
    e = !!e;
    const n = this.responsive_;
    if (e !== n)
      return this.responsive_ = e, e ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), e;
  }
  /**
   * Get current breakpoint name, if any.
   *
   * @return {string}
   *         If there is currently a breakpoint set, returns a the key from the
   *         breakpoints object matching it. Otherwise, returns an empty string.
   */
  currentBreakpoint() {
    return this.breakpoint_;
  }
  /**
   * Get the current breakpoint class name.
   *
   * @return {string}
   *         The matching class name (e.g. `"vjs-layout-tiny"` or
   *         `"vjs-layout-large"`) for the current breakpoint. Empty string if
   *         there is no current breakpoint.
   */
  currentBreakpointClass() {
    return ym[this.breakpoint_] || "";
  }
  /**
   * An object that describes a single piece of media.
   *
   * Properties that are not part of this type description will be retained; so,
   * this can be viewed as a generic metadata storage mechanism as well.
   *
   * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}
   * @typedef  {Object} Player~MediaObject
   *
   * @property {string} [album]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {string} [artist]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {Object[]} [artwork]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API. If not specified, will be populated via the `poster`, if
   *           available.
   *
   * @property {string} [poster]
   *           URL to an image that will display before playback.
   *
   * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]
   *           A single source object, an array of source objects, or a string
   *           referencing a URL to a media source. It is _highly recommended_
   *           that an object or array of objects is used here, so that source
   *           selection algorithms can take the `type` into account.
   *
   * @property {string} [title]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {Object[]} [textTracks]
   *           An array of objects to be used to create text tracks, following
   *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.
   *           For ease of removal, these will be created as "remote" text
   *           tracks and set to automatically clean up on source changes.
   *
   *           These objects may have properties like `src`, `kind`, `label`,
   *           and `language`, see {@link Tech#createRemoteTextTrack}.
   */
  /**
   * Populate the player using a {@link Player~MediaObject|MediaObject}.
   *
   * @param  {Player~MediaObject} media
   *         A media object.
   *
   * @param  {Function} ready
   *         A callback to be called when the player is ready.
   */
  loadMedia(e, n) {
    if (!e || typeof e != "object")
      return;
    const r = this.crossOrigin();
    this.reset(), this.cache_.media = Dn(e);
    const {
      artist: i,
      artwork: s,
      description: a,
      poster: o,
      src: u,
      textTracks: c,
      title: d
    } = this.cache_.media;
    !s && o && (this.cache_.media.artwork = [{
      src: o,
      type: m0(o)
    }]), r && this.crossOrigin(r), u && this.src(u), o && this.poster(o), Array.isArray(c) && c.forEach((l) => this.addRemoteTextTrack(l, !1)), this.titleBar && this.titleBar.update({
      title: d,
      description: a || i || ""
    }), this.ready(n);
  }
  /**
   * Get a clone of the current {@link Player~MediaObject} for this player.
   *
   * If the `loadMedia` method has not been used, will attempt to return a
   * {@link Player~MediaObject} based on the current state of the player.
   *
   * @return {Player~MediaObject}
   */
  getMedia() {
    if (!this.cache_.media) {
      const e = this.poster(), n = this.currentSources(), r = Array.prototype.map.call(this.remoteTextTracks(), (s) => ({
        kind: s.kind,
        label: s.label,
        language: s.language,
        src: s.src
      })), i = {
        src: n,
        textTracks: r
      };
      return e && (i.poster = e, i.artwork = [{
        src: i.poster,
        type: m0(i.poster)
      }]), i;
    }
    return Dn(this.cache_.media);
  }
  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */
  static getTagSettings(e) {
    const n = {
      sources: [],
      tracks: []
    }, r = mo(e), i = r["data-setup"];
    if (gf(e, "vjs-fill") && (r.fill = !0), gf(e, "vjs-fluid") && (r.fluid = !0), i !== null)
      try {
        Object.assign(r, JSON.parse(i || "{}"));
      } catch (s) {
        Kt.error("data-setup", s);
      }
    if (Object.assign(n, r), e.hasChildNodes()) {
      const s = e.childNodes;
      for (let a = 0, o = s.length; a < o; a++) {
        const u = s[a], c = u.nodeName.toLowerCase();
        c === "source" ? n.sources.push(mo(u)) : c === "track" && n.tracks.push(mo(u));
      }
    }
    return n;
  }
  /**
   * Set debug mode to enable/disable logs at info level.
   *
   * @param {boolean} enabled
   * @fires Player#debugon
   * @fires Player#debugoff
   * @return {boolean|undefined}
   */
  debug(e) {
    if (e === void 0)
      return this.debugEnabled_;
    e ? (this.trigger("debugon"), this.previousLogLevel_ = this.log.level, this.log.level("debug"), this.debugEnabled_ = !0) : (this.trigger("debugoff"), this.log.level(this.previousLogLevel_), this.previousLogLevel_ = void 0, this.debugEnabled_ = !1);
  }
  /**
   * Set or get current playback rates.
   * Takes an array and updates the playback rates menu with the new items.
   * Pass in an empty array to hide the menu.
   * Values other than arrays are ignored.
   *
   * @fires Player#playbackrateschange
   * @param {number[]} [newRates]
   *                   The new rates that the playback rates menu should update to.
   *                   An empty array will hide the menu
   * @return {number[]} When used as a getter will return the current playback rates
   */
  playbackRates(e) {
    if (e === void 0)
      return this.cache_.playbackRates;
    Array.isArray(e) && e.every((n) => typeof n == "number") && (this.cache_.playbackRates = e, this.trigger("playbackrateschange"));
  }
  /**
   * Reports whether or not a player has a plugin available.
   *
   * This does not report whether or not the plugin has ever been initialized
   * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
   *
   * @method hasPlugin
   * @param  {string}  name
   *         The name of a plugin.
   *
   * @return {boolean}
   *         Whether or not this player has the requested plugin available.
   */
  /**
   * Reports whether or not a player is using a plugin by name.
   *
   * For basic plugins, this only reports whether the plugin has _ever_ been
   * initialized on this player.
   *
   * @method Player#usingPlugin
   * @param  {string} name
   *         The name of a plugin.
   *
   * @return {boolean}
   *         Whether or not this player is using the requested plugin.
   */
}
En.prototype.videoTracks = () => {
};
En.prototype.audioTracks = () => {
};
En.prototype.textTracks = () => {
};
En.prototype.remoteTextTracks = () => {
};
En.prototype.remoteTextTrackEls = () => {
};
ci.names.forEach(function(t) {
  const e = ci[t];
  En.prototype[e.getterName] = function() {
    return this.tech_ ? this.tech_[e.getterName]() : (this[e.privateName] = this[e.privateName] || new e.ListClass(), this[e.privateName]);
  };
});
En.prototype.crossorigin = En.prototype.crossOrigin;
En.players = {};
const Ld = pe.navigator;
En.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Ht.defaultTechOrder_,
  html5: {},
  // enable sourceset by default
  enableSourceset: !0,
  // default inactivity timeout
  inactivityTimeout: 2e3,
  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: !1,
  // Included control sets
  children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
  language: Ld && (Ld.languages && Ld.languages[0] || Ld.userLanguage || Ld.language) || "en",
  // locales and their language translations
  languages: {},
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  normalizeAutoplay: !1,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  breakpoints: {},
  responsive: !1,
  audioOnlyMode: !1,
  audioPosterMode: !1,
  spatialNavigation: {
    enabled: !1,
    horizontalSeek: !1
  },
  // Default smooth seeking to false
  enableSmoothSeeking: !1,
  disableSeekWhileScrubbingOnMobile: !1,
  disableSeekWhileScrubbingOnSTV: !1
};
H8.forEach(function(t) {
  En.prototype[`handleTech${or(t)}_`] = function() {
    return this.trigger(t);
  };
});
He.registerComponent("Player", En);
const g0 = "plugin", Gl = "activePlugins_", Rl = {}, A0 = (t) => Rl.hasOwnProperty(t), vm = (t) => A0(t) ? Rl[t] : void 0, j8 = (t, e) => {
  t[Gl] = t[Gl] || {}, t[Gl][e] = !0;
}, b0 = (t, e, n) => {
  const r = (n ? "before" : "") + "pluginsetup";
  t.trigger(r, e), t.trigger(r + ":" + e.name, e);
}, DCe = function(t, e) {
  const n = function() {
    b0(this, {
      name: t,
      plugin: e,
      instance: null
    }, !0);
    const r = e.apply(this, arguments);
    return j8(this, t), b0(this, {
      name: t,
      plugin: e,
      instance: r
    }), r;
  };
  return Object.keys(e).forEach(function(r) {
    n[r] = e[r];
  }), n;
}, cw = (t, e) => (e.prototype.name = t, function(...n) {
  b0(this, {
    name: t,
    plugin: e,
    instance: null
  }, !0);
  const r = new e(this, ...n);
  return this[t] = () => r, b0(this, r.getEventHash()), r;
});
class Oi {
  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  constructor(e) {
    if (this.constructor === Oi)
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    this.player = e, this.log || (this.log = this.player.log.createLogger(this.name)), bT(this), delete this.trigger, e8(this, this.constructor.defaultState), j8(e, this.name), this.dispose = this.dispose.bind(this), e.on("dispose", this.dispose);
  }
  /**
   * Get the version of the plugin that was set on <pluginName>.VERSION
   */
  version() {
    return this.constructor.VERSION;
  }
  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @return {PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */
  getEventHash(e = {}) {
    return e.name = this.name, e.plugin = this.constructor, e.instance = this, e;
  }
  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link PluginEventHash|PluginEventHash}.
   *
   * @return {boolean}
   *          Whether or not default was prevented.
   */
  trigger(e, n = {}) {
    return jc(this.eventBusEl_, e, this.getEventHash(n));
  }
  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */
  handleStateChanged(e) {
  }
  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */
  dispose() {
    const {
      name: e,
      player: n
    } = this;
    this.trigger("dispose"), this.off(), n.off("dispose", this.dispose), n[Gl][e] = !1, this.player = this.state = null, n[e] = cw(e, Rl[e]);
  }
  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @return {boolean}
   *          Whether or not a plugin is a basic plugin.
   */
  static isBasic(e) {
    const n = typeof e == "string" ? vm(e) : e;
    return typeof n == "function" && !Oi.prototype.isPrototypeOf(n.prototype);
  }
  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {typeof Plugin|Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @return {typeof Plugin|Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */
  static registerPlugin(e, n) {
    if (typeof e != "string")
      throw new Error(`Illegal plugin name, "${e}", must be a string, was ${typeof e}.`);
    if (A0(e))
      Kt.warn(`A plugin named "${e}" already exists. You may want to avoid re-registering plugins!`);
    else if (En.prototype.hasOwnProperty(e))
      throw new Error(`Illegal plugin name, "${e}", cannot share a name with an existing player method!`);
    if (typeof n != "function")
      throw new Error(`Illegal plugin for "${e}", must be a function, was ${typeof n}.`);
    return Rl[e] = n, e !== g0 && (Oi.isBasic(n) ? En.prototype[e] = DCe(e, n) : En.prototype[e] = cw(e, n)), n;
  }
  /**
   * De-register a Video.js plugin.
   *
   * @param  {string} name
   *         The name of the plugin to be de-registered. Must be a string that
   *         matches an existing plugin.
   *
   * @throws {Error}
   *         If an attempt is made to de-register the base plugin.
   */
  static deregisterPlugin(e) {
    if (e === g0)
      throw new Error("Cannot de-register base plugin.");
    A0(e) && (delete Rl[e], delete En.prototype[e]);
  }
  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @return {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */
  static getPlugins(e = Object.keys(Rl)) {
    let n;
    return e.forEach((r) => {
      const i = vm(r);
      i && (n = n || {}, n[r] = i);
    }), n;
  }
  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @return {string}
   *          The plugin's version or an empty string.
   */
  static getPluginVersion(e) {
    const n = vm(e);
    return n && n.VERSION || "";
  }
}
Oi.getPlugin = vm;
Oi.BASE_PLUGIN_NAME = g0;
Oi.registerPlugin(g0, Oi);
En.prototype.usingPlugin = function(t) {
  return !!this[Gl] && this[Gl][t] === !0;
};
En.prototype.hasPlugin = function(t) {
  return !!A0(t);
};
function MCe(t, e) {
  let n = !1;
  return function(...r) {
    return n || Kt.warn(t), n = !0, e.apply(this, r);
  };
}
function $s(t, e, n, r) {
  return MCe(`${e} is deprecated and will be removed in ${t}.0; please use ${n} instead.`, r);
}
var OCe = {
  NetworkBadStatus: "networkbadstatus",
  NetworkRequestFailed: "networkrequestfailed",
  NetworkRequestAborted: "networkrequestaborted",
  NetworkRequestTimeout: "networkrequesttimeout",
  NetworkBodyParserFailed: "networkbodyparserfailed",
  StreamingHlsPlaylistParserError: "streaminghlsplaylistparsererror",
  StreamingDashManifestParserError: "streamingdashmanifestparsererror",
  StreamingContentSteeringParserError: "streamingcontentsteeringparsererror",
  StreamingVttParserError: "streamingvttparsererror",
  StreamingFailedToSelectNextSegment: "streamingfailedtoselectnextsegment",
  StreamingFailedToDecryptSegment: "streamingfailedtodecryptsegment",
  StreamingFailedToTransmuxSegment: "streamingfailedtotransmuxsegment",
  StreamingFailedToAppendSegment: "streamingfailedtoappendsegment",
  StreamingCodecsChangeError: "streamingcodecschangeerror"
};
const z8 = (t) => t.indexOf("#") === 0 ? t.slice(1) : t;
function Me(t, e, n) {
  let r = Me.getPlayer(t);
  if (r)
    return e && Kt.warn(`Player "${t}" is already initialised. Options will not be applied.`), n && r.ready(n), r;
  const i = typeof t == "string" ? No("#" + z8(t)) : t;
  if (!Hc(i))
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  const a = ("getRootNode" in i ? i.getRootNode() instanceof pe.ShadowRoot : !1) ? i.getRootNode() : i.ownerDocument.body;
  (!i.ownerDocument.defaultView || !a.contains(i)) && Kt.warn("The element supplied is not included in the DOM"), e = e || {}, e.restoreEl === !0 && (e.restoreEl = (i.parentNode && i.parentNode.hasAttribute && i.parentNode.hasAttribute("data-vjs-player") ? i.parentNode : i).cloneNode(!0)), Oo("beforesetup").forEach((u) => {
    const c = u(i, Dn(e));
    if (!fa(c) || Array.isArray(c)) {
      Kt.error("please return an object in beforesetup hooks");
      return;
    }
    e = Dn(e, c);
  });
  const o = He.getComponent("Player");
  return r = new o(i, e, n), Oo("setup").forEach((u) => u(r)), r;
}
Me.hooks_ = Oa;
Me.hooks = Oo;
Me.hook = fwe;
Me.hookOnce = hwe;
Me.removeHook = wD;
if (pe.VIDEOJS_NO_DYNAMIC_STYLE !== !0 && $c()) {
  let t = No(".vjs-styles-defaults");
  if (!t) {
    t = YD("vjs-styles-defaults");
    const e = No("head");
    e && e.insertBefore(t, e.firstChild), XD(t, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `);
  }
}
Xb(1, Me);
Me.VERSION = Wb;
Me.options = En.prototype.options_;
Me.getPlayers = () => En.players;
Me.getPlayer = (t) => {
  const e = En.players;
  let n;
  if (typeof t == "string") {
    const r = z8(t), i = e[r];
    if (i)
      return i;
    n = No("#" + r);
  } else
    n = t;
  if (Hc(n)) {
    const {
      player: r,
      playerId: i
    } = n;
    if (r || e[i])
      return r || e[i];
  }
};
Me.getAllPlayers = () => (
  // Disposed players leave a key with a `null` value, so we need to make sure
  // we filter those out.
  Object.keys(En.players).map((t) => En.players[t]).filter(Boolean)
);
Me.players = En.players;
Me.getComponent = He.getComponent;
Me.registerComponent = (t, e) => (Ht.isTech(e) && Kt.warn(`The ${t} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`), He.registerComponent.call(He, t, e));
Me.getTech = Ht.getTech;
Me.registerTech = Ht.registerTech;
Me.use = $we;
Object.defineProperty(Me, "middleware", {
  value: {},
  writeable: !1,
  enumerable: !0
});
Object.defineProperty(Me.middleware, "TERMINATOR", {
  value: p0,
  writeable: !1,
  enumerable: !0
});
Me.browser = LD;
Me.obj = gwe;
Me.mergeOptions = $s(9, "videojs.mergeOptions", "videojs.obj.merge", Dn);
Me.defineLazyProperty = $s(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", wg);
Me.bind = $s(9, "videojs.bind", "native Function.prototype.bind", Un);
Me.registerPlugin = Oi.registerPlugin;
Me.deregisterPlugin = Oi.deregisterPlugin;
Me.plugin = (t, e) => (Kt.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead"), Oi.registerPlugin(t, e));
Me.getPlugins = Oi.getPlugins;
Me.getPlugin = Oi.getPlugin;
Me.getPluginVersion = Oi.getPluginVersion;
Me.addLanguage = function(t, e) {
  return t = ("" + t).toLowerCase(), Me.options.languages = Dn(Me.options.languages, {
    [t]: e
  }), Me.options.languages[t];
};
Me.log = Kt;
Me.createLogger = CD;
Me.time = Mwe;
Me.createTimeRange = $s(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", Ds);
Me.createTimeRanges = $s(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", Ds);
Me.formatTime = $s(9, "videojs.formatTime", "videojs.time.formatTime", Vu);
Me.setFormatTime = $s(9, "videojs.setFormatTime", "videojs.time.setFormatTime", r8);
Me.resetFormatTime = $s(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", i8);
Me.parseUrl = $s(9, "videojs.parseUrl", "videojs.url.parseUrl", _T);
Me.isCrossOrigin = $s(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", Bg);
Me.EventTarget = Gi;
Me.any = AT;
Me.on = Qi;
Me.one = Pg;
Me.off = ti;
Me.trigger = jc;
Me.xhr = cD;
Me.TrackList = Wu;
Me.TextTrack = vh;
Me.TextTrackList = vT;
Me.AudioTrack = l8;
Me.AudioTrackList = a8;
Me.VideoTrack = c8;
Me.VideoTrackList = o8;
["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach((t) => {
  Me[t] = function() {
    return Kt.warn(`videojs.${t}() is deprecated; use videojs.dom.${t}() instead`), QD[t].apply(null, arguments);
  };
});
Me.computedStyle = $s(9, "videojs.computedStyle", "videojs.dom.computedStyle", mc);
Me.dom = QD;
Me.fn = wwe;
Me.num = oCe;
Me.str = kwe;
Me.url = Fwe;
Me.Error = OCe;
/*! @name videojs-contrib-quality-levels @version 4.1.0 @license Apache-2.0 */
class NCe {
  /**
   * Creates a QualityLevel
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   */
  constructor(e) {
    let n = this;
    return n.id = e.id, n.label = n.id, n.width = e.width, n.height = e.height, n.bitrate = e.bandwidth, n.frameRate = e.frameRate, n.enabled_ = e.enabled, Object.defineProperty(n, "enabled", {
      /**
       * Get whether the QualityLevel is enabled.
       *
       * @return {boolean} True if the QualityLevel is enabled.
       */
      get() {
        return n.enabled_();
      },
      /**
       * Enable or disable the QualityLevel.
       *
       * @param {boolean} enable true to enable QualityLevel, false to disable.
       */
      set(r) {
        n.enabled_(r);
      }
    }), n;
  }
}
class y0 extends Me.EventTarget {
  /**
   * Creates a QualityLevelList.
   */
  constructor() {
    super();
    let e = this;
    return e.levels_ = [], e.selectedIndex_ = -1, Object.defineProperty(e, "selectedIndex", {
      get() {
        return e.selectedIndex_;
      }
    }), Object.defineProperty(e, "length", {
      get() {
        return e.levels_.length;
      }
    }), e[Symbol.iterator] = () => e.levels_.values(), e;
  }
  /**
   * Adds a quality level to the list.
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   * @return {QualityLevel} the QualityLevel added to the list
   * @method addQualityLevel
   */
  addQualityLevel(e) {
    let n = this.getQualityLevelById(e.id);
    if (n)
      return n;
    const r = this.levels_.length;
    return n = new NCe(e), "" + r in this || Object.defineProperty(this, r, {
      get() {
        return this.levels_[r];
      }
    }), this.levels_.push(n), this.trigger({
      qualityLevel: n,
      type: "addqualitylevel"
    }), n;
  }
  /**
   * Removes a quality level from the list.
   *
   * @param {QualityLevel} qualityLevel The QualityLevel to remove from the list.
   * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed
   * @method removeQualityLevel
   */
  removeQualityLevel(e) {
    let n = null;
    for (let r = 0, i = this.length; r < i; r++)
      if (this[r] === e) {
        n = this.levels_.splice(r, 1)[0], this.selectedIndex_ === r ? this.selectedIndex_ = -1 : this.selectedIndex_ > r && this.selectedIndex_--;
        break;
      }
    return n && this.trigger({
      qualityLevel: e,
      type: "removequalitylevel"
    }), n;
  }
  /**
   * Searches for a QualityLevel with the given id.
   *
   * @param {string} id The id of the QualityLevel to find.
   * @return {QualityLevel|null} The QualityLevel with id, or null if not found.
   * @method getQualityLevelById
   */
  getQualityLevelById(e) {
    for (let n = 0, r = this.length; n < r; n++) {
      const i = this[n];
      if (i.id === e)
        return i;
    }
    return null;
  }
  /**
   * Resets the list of QualityLevels to empty
   *
   * @method dispose
   */
  dispose() {
    this.selectedIndex_ = -1, this.levels_.length = 0;
  }
}
y0.prototype.allowedEvents_ = {
  change: "change",
  addqualitylevel: "addqualitylevel",
  removequalitylevel: "removequalitylevel"
};
for (const t in y0.prototype.allowedEvents_)
  y0.prototype["on" + t] = null;
var q8 = "4.1.0";
const LCe = function(t, e) {
  const n = t.qualityLevels, r = new y0(), i = function() {
    r.dispose(), t.qualityLevels = n, t.off("dispose", i);
  };
  return t.on("dispose", i), t.qualityLevels = () => r, t.qualityLevels.VERSION = q8, r;
}, V8 = function(t) {
  return LCe(this, Me.obj.merge({}, t));
};
Me.registerPlugin("qualityLevels", V8);
V8.VERSION = q8;
/*! @name @videojs/http-streaming @version 3.17.0 @license Apache-2.0 */
const wi = Tg, v0 = (t, e) => e && e.responseURL && t !== e.responseURL ? e.responseURL : t, gs = (t) => Me.log.debug ? Me.log.debug.bind(Me, "VHS:", `${t} >`) : function() {
};
function xn(...t) {
  const e = Me.obj || Me;
  return (e.merge || e.mergeOptions).apply(e, t);
}
function Mr(...t) {
  const e = Me.time || Me;
  return (e.createTimeRanges || e.createTimeRanges).apply(e, t);
}
function PCe(t) {
  if (t.length === 0)
    return "Buffered Ranges are empty";
  let e = `Buffered Ranges: 
`;
  for (let n = 0; n < t.length; n++) {
    const r = t.start(n), i = t.end(n);
    e += `${r} --> ${i}. Duration (${i - r})
`;
  }
  return e;
}
const na = 1 / 30, ra = na * 3, W8 = function(t, e) {
  const n = [];
  let r;
  if (t && t.length)
    for (r = 0; r < t.length; r++)
      e(t.start(r), t.end(r)) && n.push([t.start(r), t.end(r)]);
  return Mr(n);
}, Bl = function(t, e) {
  return W8(t, function(n, r) {
    return n - ra <= e && r + ra >= e;
  });
}, Np = function(t, e) {
  return W8(t, function(n) {
    return n - na >= e;
  });
}, RCe = function(t) {
  if (t.length < 2)
    return Mr();
  const e = [];
  for (let n = 1; n < t.length; n++) {
    const r = t.end(n - 1), i = t.start(n);
    e.push([r, i]);
  }
  return Mr(e);
}, BCe = function(t, e) {
  let n = null, r = null, i = 0;
  const s = [], a = [];
  if (!t || !t.length || !e || !e.length)
    return Mr();
  let o = t.length;
  for (; o--; )
    s.push({
      time: t.start(o),
      type: "start"
    }), s.push({
      time: t.end(o),
      type: "end"
    });
  for (o = e.length; o--; )
    s.push({
      time: e.start(o),
      type: "start"
    }), s.push({
      time: e.end(o),
      type: "end"
    });
  for (s.sort(function(u, c) {
    return u.time - c.time;
  }), o = 0; o < s.length; o++)
    s[o].type === "start" ? (i++, i === 2 && (n = s[o].time)) : s[o].type === "end" && (i--, i === 1 && (r = s[o].time)), n !== null && r !== null && (a.push([n, r]), n = null, r = null);
  return Mr(a);
}, Q8 = (t) => {
  const e = [];
  if (!t || !t.length)
    return "";
  for (let n = 0; n < t.length; n++)
    e.push(t.start(n) + " => " + t.end(n));
  return e.join(", ");
}, FCe = function(t, e, n = 1) {
  return ((t.length ? t.end(t.length - 1) : 0) - e) / n;
}, Au = (t) => {
  const e = [];
  for (let n = 0; n < t.length; n++)
    e.push({
      start: t.start(n),
      end: t.end(n)
    });
  return e;
}, UCe = function(t, e) {
  if (t === e)
    return !1;
  if (!t && e || !e && t || t.length !== e.length)
    return !0;
  for (let n = 0; n < t.length; n++)
    if (t.start(n) !== e.start(n) || t.end(n) !== e.end(n))
      return !0;
  return !1;
}, u2 = function(t) {
  if (!(!t || !t.length || !t.end))
    return t.end(t.length - 1);
}, UT = function(t, e) {
  let n = 0;
  if (!t || !t.length)
    return n;
  for (let r = 0; r < t.length; r++) {
    const i = t.start(r), s = t.end(r);
    if (!(e > s)) {
      if (e > i && e <= s) {
        n += s - e;
        continue;
      }
      n += s - i;
    }
  }
  return n;
}, $T = (t, e) => {
  if (!e.preload)
    return e.duration;
  let n = 0;
  return (e.parts || []).forEach(function(r) {
    n += r.duration;
  }), (e.preloadHints || []).forEach(function(r) {
    r.type === "PART" && (n += t.partTargetDuration);
  }), n;
}, iy = (t) => (t.segments || []).reduce((e, n, r) => (n.parts ? n.parts.forEach(function(i, s) {
  e.push({
    duration: i.duration,
    segmentIndex: r,
    partIndex: s,
    part: i,
    segment: n
  });
}) : e.push({
  duration: n.duration,
  segmentIndex: r,
  partIndex: null,
  segment: n,
  part: null
}), e), []), G8 = (t) => {
  const e = t.segments && t.segments.length && t.segments[t.segments.length - 1];
  return e && e.parts || [];
}, Y8 = ({
  preloadSegment: t
}) => {
  if (!t)
    return;
  const {
    parts: e,
    preloadHints: n
  } = t;
  let r = (n || []).reduce((i, s) => i + (s.type === "PART" ? 1 : 0), 0);
  return r += e && e.length ? e.length : 0, r;
}, X8 = (t, e) => {
  if (e.endList)
    return 0;
  if (t && t.suggestedPresentationDelay)
    return t.suggestedPresentationDelay;
  const n = G8(e).length > 0;
  return n && e.serverControl && e.serverControl.partHoldBack ? e.serverControl.partHoldBack : n && e.partTargetDuration ? e.partTargetDuration * 3 : e.serverControl && e.serverControl.holdBack ? e.serverControl.holdBack : e.targetDuration ? e.targetDuration * 3 : 0;
}, $Ce = function(t, e) {
  let n = 0, r = e - t.mediaSequence, i = t.segments[r];
  if (i) {
    if (typeof i.start < "u")
      return {
        result: i.start,
        precise: !0
      };
    if (typeof i.end < "u")
      return {
        result: i.end - i.duration,
        precise: !0
      };
  }
  for (; r--; ) {
    if (i = t.segments[r], typeof i.end < "u")
      return {
        result: n + i.end,
        precise: !0
      };
    if (n += $T(t, i), typeof i.start < "u")
      return {
        result: n + i.start,
        precise: !0
      };
  }
  return {
    result: n,
    precise: !1
  };
}, HCe = function(t, e) {
  let n = 0, r, i = e - t.mediaSequence;
  for (; i < t.segments.length; i++) {
    if (r = t.segments[i], typeof r.start < "u")
      return {
        result: r.start - n,
        precise: !0
      };
    if (n += $T(t, r), typeof r.end < "u")
      return {
        result: r.end - n,
        precise: !0
      };
  }
  return {
    result: -1,
    precise: !1
  };
}, K8 = function(t, e, n) {
  if (typeof e > "u" && (e = t.mediaSequence + t.segments.length), e < t.mediaSequence)
    return 0;
  const r = $Ce(t, e);
  if (r.precise)
    return r.result;
  const i = HCe(t, e);
  return i.precise ? i.result : r.result + n;
}, Z8 = function(t, e, n) {
  if (!t)
    return 0;
  if (typeof n != "number" && (n = 0), typeof e > "u") {
    if (t.totalDuration)
      return t.totalDuration;
    if (!t.endList)
      return pe.Infinity;
  }
  return K8(t, e, n);
}, yf = function({
  defaultDuration: t,
  durationList: e,
  startIndex: n,
  endIndex: r
}) {
  let i = 0;
  if (n > r && ([n, r] = [r, n]), n < 0) {
    for (let s = n; s < Math.min(0, r); s++)
      i += t;
    n = 0;
  }
  for (let s = n; s < r; s++)
    i += e[s].duration;
  return i;
}, J8 = function(t, e, n, r) {
  if (!t || !t.segments)
    return null;
  if (t.endList)
    return Z8(t);
  if (e === null)
    return null;
  e = e || 0;
  let i = K8(t, t.mediaSequence + t.segments.length, e);
  return n && (r = typeof r == "number" ? r : X8(null, t), i -= r), Math.max(0, i);
}, jCe = function(t, e, n) {
  const i = e || 0;
  let s = J8(t, e, !0, n);
  return s === null ? Mr() : (s < i && (s = i), Mr(i, s));
}, zCe = function({
  playlist: t,
  currentTime: e,
  startingSegmentIndex: n,
  startingPartIndex: r,
  startTime: i,
  exactManifestTimings: s
}) {
  let a = e - i;
  const o = iy(t);
  let u = 0;
  for (let c = 0; c < o.length; c++) {
    const d = o[c];
    if (n === d.segmentIndex && !(typeof r == "number" && typeof d.partIndex == "number" && r !== d.partIndex)) {
      u = c;
      break;
    }
  }
  if (a < 0) {
    if (u > 0)
      for (let c = u - 1; c >= 0; c--) {
        const d = o[c];
        if (a += d.duration, s) {
          if (a < 0)
            continue;
        } else if (a + na <= 0)
          continue;
        return {
          partIndex: d.partIndex,
          segmentIndex: d.segmentIndex,
          startTime: i - yf({
            defaultDuration: t.targetDuration,
            durationList: o,
            startIndex: u,
            endIndex: c
          })
        };
      }
    return {
      partIndex: o[0] && o[0].partIndex || null,
      segmentIndex: o[0] && o[0].segmentIndex || 0,
      startTime: e
    };
  }
  if (u < 0) {
    for (let c = u; c < 0; c++)
      if (a -= t.targetDuration, a < 0)
        return {
          partIndex: o[0] && o[0].partIndex || null,
          segmentIndex: o[0] && o[0].segmentIndex || 0,
          startTime: e
        };
    u = 0;
  }
  for (let c = u; c < o.length; c++) {
    const d = o[c];
    a -= d.duration;
    const l = d.duration > na, f = a === 0, p = l && a + na >= 0;
    if (!((f || p) && c !== o.length - 1)) {
      if (s) {
        if (a > 0)
          continue;
      } else if (a - na >= 0)
        continue;
      return {
        partIndex: d.partIndex,
        segmentIndex: d.segmentIndex,
        startTime: i + yf({
          defaultDuration: t.targetDuration,
          durationList: o,
          startIndex: u,
          endIndex: c
        })
      };
    }
  }
  return {
    segmentIndex: o[o.length - 1].segmentIndex,
    partIndex: o[o.length - 1].partIndex,
    startTime: e
  };
}, eM = function(t) {
  return t.excludeUntil && t.excludeUntil > Date.now();
}, HT = function(t) {
  return t.excludeUntil && t.excludeUntil === 1 / 0;
}, Hg = function(t) {
  const e = eM(t);
  return !t.disabled && !e;
}, qCe = function(t) {
  return t.disabled;
}, VCe = function(t) {
  for (let e = 0; e < t.segments.length; e++)
    if (t.segments[e].key)
      return !0;
  return !1;
}, tM = function(t, e) {
  return e.attributes && e.attributes[t];
}, WCe = function(t, e, n, r = 0) {
  return tM("BANDWIDTH", n) ? (t * n.attributes.BANDWIDTH - r * 8) / e : NaN;
}, sy = (t, e) => {
  if (t.playlists.length === 1)
    return !0;
  const n = e.attributes.BANDWIDTH || Number.MAX_VALUE;
  return t.playlists.filter((r) => Hg(r) ? (r.attributes.BANDWIDTH || 0) < n : !1).length === 0;
}, jT = (t, e) => !t && !e || !t && e || t && !e ? !1 : !!(t === e || t.id && e.id && t.id === e.id || t.resolvedUri && e.resolvedUri && t.resolvedUri === e.resolvedUri || t.uri && e.uri && t.uri === e.uri), dw = function(t, e) {
  const n = t && t.mediaGroups && t.mediaGroups.AUDIO || {};
  let r = !1;
  for (const i in n) {
    for (const s in n[i])
      if (r = e(n[i][s]), r)
        break;
    if (r)
      break;
  }
  return !!r;
}, xh = (t) => {
  if (!t || !t.playlists || !t.playlists.length)
    return dw(t, (n) => n.playlists && n.playlists.length || n.uri);
  for (let e = 0; e < t.playlists.length; e++) {
    const n = t.playlists[e], r = n.attributes && n.attributes.CODECS;
    if (!(r && r.split(",").every((s) => hD(s)) || dw(t, (s) => jT(n, s))))
      return !1;
  }
  return !0;
};
var Si = {
  liveEdgeDelay: X8,
  duration: Z8,
  seekable: jCe,
  getMediaInfoForTime: zCe,
  isEnabled: Hg,
  isDisabled: qCe,
  isExcluded: eM,
  isIncompatible: HT,
  playlistEnd: J8,
  isAes: VCe,
  hasAttribute: tM,
  estimateSegmentRequestTime: WCe,
  isLowestEnabledRendition: sy,
  isAudioOnly: xh,
  playlistMatch: jT,
  segmentDurationWithParts: $T
};
const {
  log: nM
} = Me, Yl = (t, e) => `${t}-${e}`, rM = (t, e, n) => `placeholder-uri-${t}-${e}-${n}`, QCe = ({
  onwarn: t,
  oninfo: e,
  manifestString: n,
  customTagParsers: r = [],
  customTagMappers: i = [],
  llhls: s
}) => {
  const a = new L4e();
  t && a.on("warn", t), e && a.on("info", e), r.forEach((c) => a.addParser(c)), i.forEach((c) => a.addTagMapper(c)), a.push(n), a.end();
  const o = a.manifest;
  if (s || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(c) {
    o.hasOwnProperty(c) && delete o[c];
  }), o.segments && o.segments.forEach(function(c) {
    ["parts", "preloadHints"].forEach(function(d) {
      c.hasOwnProperty(d) && delete c[d];
    });
  })), !o.targetDuration) {
    let c = 10;
    o.segments && o.segments.length && (c = o.segments.reduce((d, l) => Math.max(d, l.duration), 0)), t && t({
      message: `manifest has no targetDuration defaulting to ${c}`
    }), o.targetDuration = c;
  }
  const u = G8(o);
  if (u.length && !o.partTargetDuration) {
    const c = u.reduce((d, l) => Math.max(d, l.duration), 0);
    t && (t({
      message: `manifest has no partTargetDuration defaulting to ${c}`
    }), nM.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")), o.partTargetDuration = c;
  }
  return o;
}, Wc = (t, e) => {
  t.mediaGroups && ["AUDIO", "SUBTITLES"].forEach((n) => {
    if (t.mediaGroups[n])
      for (const r in t.mediaGroups[n])
        for (const i in t.mediaGroups[n][r]) {
          const s = t.mediaGroups[n][r][i];
          e(s, n, r, i);
        }
  });
}, iM = ({
  playlist: t,
  uri: e,
  id: n
}) => {
  t.id = n, t.playlistErrors_ = 0, e && (t.uri = e), t.attributes = t.attributes || {};
}, GCe = (t) => {
  let e = t.playlists.length;
  for (; e--; ) {
    const n = t.playlists[e];
    iM({
      playlist: n,
      id: Yl(e, n.uri)
    }), n.resolvedUri = wi(t.uri, n.uri), t.playlists[n.id] = n, t.playlists[n.uri] = n, n.attributes.BANDWIDTH || nM.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
  }
}, YCe = (t) => {
  Wc(t, (e) => {
    e.uri && (e.resolvedUri = wi(t.uri, e.uri));
  });
}, XCe = (t, e) => {
  const n = Yl(0, e), r = {
    mediaGroups: {
      AUDIO: {},
      VIDEO: {},
      "CLOSED-CAPTIONS": {},
      SUBTITLES: {}
    },
    uri: pe.location.href,
    resolvedUri: pe.location.href,
    playlists: [{
      uri: e,
      id: n,
      resolvedUri: e,
      // m3u8-parser does not attach an attributes property to media playlists so make
      // sure that the property is attached to avoid undefined reference errors
      attributes: {}
    }]
  };
  return r.playlists[n] = r.playlists[0], r.playlists[e] = r.playlists[0], r;
}, sM = (t, e, n = rM) => {
  t.uri = e;
  for (let i = 0; i < t.playlists.length; i++)
    if (!t.playlists[i].uri) {
      const s = `placeholder-uri-${i}`;
      t.playlists[i].uri = s;
    }
  const r = xh(t);
  Wc(t, (i, s, a, o) => {
    if (!i.playlists || !i.playlists.length) {
      if (r && s === "AUDIO" && !i.uri)
        for (let u = 0; u < t.playlists.length; u++) {
          const c = t.playlists[u];
          if (c.attributes && c.attributes.AUDIO && c.attributes.AUDIO === a)
            return;
        }
      i.playlists = [fr({}, i)];
    }
    i.playlists.forEach(function(u, c) {
      const d = n(s, a, o, u), l = Yl(c, d);
      u.uri ? u.resolvedUri = u.resolvedUri || wi(t.uri, u.uri) : (u.uri = c === 0 ? d : l, u.resolvedUri = u.uri), u.id = u.id || l, u.attributes = u.attributes || {}, t.playlists[u.id] = u, t.playlists[u.uri] = u;
    });
  }), GCe(t), YCe(t);
};
class fw {
  constructor() {
    this.offset_ = null, this.pendingDateRanges_ = /* @__PURE__ */ new Map(), this.processedDateRanges_ = /* @__PURE__ */ new Map();
  }
  setOffset(e = []) {
    if (this.offset_ !== null || !e.length)
      return;
    const [n] = e;
    n.programDateTime !== void 0 && (this.offset_ = n.programDateTime / 1e3);
  }
  setPendingDateRanges(e = []) {
    if (!e.length)
      return;
    const [n] = e, r = n.startDate.getTime();
    this.trimProcessedDateRanges_(r), this.pendingDateRanges_ = e.reduce((i, s) => (i.set(s.id, s), i), /* @__PURE__ */ new Map());
  }
  processDateRange(e) {
    this.pendingDateRanges_.delete(e.id), this.processedDateRanges_.set(e.id, e);
  }
  getDateRangesToProcess() {
    if (this.offset_ === null)
      return [];
    const e = {}, n = [];
    this.pendingDateRanges_.forEach((r, i) => {
      if (!this.processedDateRanges_.has(i) && (r.startTime = r.startDate.getTime() / 1e3 - this.offset_, r.processDateRange = () => this.processDateRange(r), n.push(r), !!r.class))
        if (e[r.class]) {
          const s = e[r.class].push(r);
          r.classListIndex = s - 1;
        } else
          e[r.class] = [r], r.classListIndex = 0;
    });
    for (const r of n) {
      const i = e[r.class] || [];
      r.endDate ? r.endTime = r.endDate.getTime() / 1e3 - this.offset_ : r.endOnNext && i[r.classListIndex + 1] ? r.endTime = i[r.classListIndex + 1].startTime : r.duration ? r.endTime = r.startTime + r.duration : r.plannedDuration ? r.endTime = r.startTime + r.plannedDuration : r.endTime = r.startTime;
    }
    return n;
  }
  trimProcessedDateRanges_(e) {
    new Map(this.processedDateRanges_).forEach((r, i) => {
      r.startDate.getTime() < e && this.processedDateRanges_.delete(i);
    });
  }
}
const aM = 22, Mu = ({
  requestType: t,
  request: e,
  error: n,
  parseFailure: r
}) => {
  const i = e.status < 200 || e.status > 299, s = e.status >= 400 && e.status <= 499, a = {
    uri: e.uri,
    requestType: t
  }, o = i && !s || r;
  if (n && s)
    a.error = fr({}, n), a.errorType = Me.Error.NetworkRequestFailed;
  else if (e.aborted)
    a.errorType = Me.Error.NetworkRequestAborted;
  else if (e.timedout)
    a.erroType = Me.Error.NetworkRequestTimeout;
  else if (o) {
    const u = r ? Me.Error.NetworkBodyParserFailed : Me.Error.NetworkBadStatus;
    a.errorType = u, a.status = e.status, a.headers = e.headers;
  }
  return a;
}, KCe = gs("CodecUtils"), oM = function(t) {
  const e = t.attributes || {};
  if (e.CODECS)
    return Gs(e.CODECS);
}, uM = (t, e) => {
  const n = e.attributes || {};
  return t && t.mediaGroups && t.mediaGroups.AUDIO && n.AUDIO && t.mediaGroups.AUDIO[n.AUDIO];
}, ZCe = (t, e) => {
  if (!uM(t, e))
    return !0;
  const n = e.attributes || {}, r = t.mediaGroups.AUDIO[n.AUDIO];
  for (const i in r)
    if (!r[i].uri && !r[i].playlists)
      return !0;
  return !1;
}, Kf = function(t) {
  const e = {};
  return t.forEach(({
    mediaType: n,
    type: r,
    details: i
  }) => {
    e[n] = e[n] || [], e[n].push(fD(`${r}${i}`));
  }), Object.keys(e).forEach(function(n) {
    if (e[n].length > 1) {
      KCe(`multiple ${n} codecs found as attributes: ${e[n].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`), e[n] = null;
      return;
    }
    e[n] = e[n][0];
  }), e;
}, hw = function(t) {
  let e = 0;
  return t.audio && e++, t.video && e++, e;
}, vf = function(t, e) {
  const n = e.attributes || {}, r = Kf(oM(e) || []);
  if (uM(t, e) && !r.audio && !ZCe(t, e)) {
    const i = Kf(R4e(t, n.AUDIO) || []);
    i.audio && (r.audio = i.audio);
  }
  return r;
}, {
  EventTarget: JCe
} = Me, eSe = (t, e) => {
  if (e.endList || !e.serverControl)
    return t;
  const n = {};
  if (e.serverControl.canBlockReload) {
    const {
      preloadSegment: r
    } = e;
    let i = e.mediaSequence + e.segments.length;
    if (r) {
      const s = r.parts || [], a = Y8(e) - 1;
      a > -1 && a !== s.length - 1 && (n._HLS_part = a), (a > -1 || s.length) && i--;
    }
    n._HLS_msn = i;
  }
  if (e.serverControl && e.serverControl.canSkipUntil && (n._HLS_skip = e.serverControl.canSkipDateranges ? "v2" : "YES"), Object.keys(n).length) {
    const r = new pe.URL(t);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(i) {
      n.hasOwnProperty(i) && r.searchParams.set(i, n[i]);
    }), t = r.toString();
  }
  return t;
}, tSe = (t, e) => {
  if (!t)
    return e;
  const n = xn(t, e);
  if (t.preloadHints && !e.preloadHints && delete n.preloadHints, t.parts && !e.parts)
    delete n.parts;
  else if (t.parts && e.parts)
    for (let r = 0; r < e.parts.length; r++)
      t.parts && t.parts[r] && (n.parts[r] = xn(t.parts[r], e.parts[r]));
  return !t.skipped && e.skipped && (n.skipped = !1), t.preload && !e.preload && (n.preload = !1), n;
}, nSe = (t, e, n) => {
  const r = t.slice(), i = e.slice();
  n = n || 0;
  const s = [];
  let a;
  for (let o = 0; o < i.length; o++) {
    const u = r[o + n], c = i[o];
    u ? (a = u.map || a, s.push(tSe(u, c))) : (a && !c.map && (c.map = a), s.push(c));
  }
  return s;
}, lM = (t, e) => {
  !t.resolvedUri && t.uri && (t.resolvedUri = wi(e, t.uri)), t.key && !t.key.resolvedUri && (t.key.resolvedUri = wi(e, t.key.uri)), t.map && !t.map.resolvedUri && (t.map.resolvedUri = wi(e, t.map.uri)), t.map && t.map.key && !t.map.key.resolvedUri && (t.map.key.resolvedUri = wi(e, t.map.key.uri)), t.parts && t.parts.length && t.parts.forEach((n) => {
    n.resolvedUri || (n.resolvedUri = wi(e, n.uri));
  }), t.preloadHints && t.preloadHints.length && t.preloadHints.forEach((n) => {
    n.resolvedUri || (n.resolvedUri = wi(e, n.uri));
  });
}, cM = function(t) {
  const e = t.segments || [], n = t.preloadSegment;
  if (n && n.parts && n.parts.length) {
    if (n.preloadHints) {
      for (let r = 0; r < n.preloadHints.length; r++)
        if (n.preloadHints[r].type === "MAP")
          return e;
    }
    n.duration = t.targetDuration, n.preload = !0, e.push(n);
  }
  return e;
}, dM = (t, e) => t === e || t.segments && e.segments && t.segments.length === e.segments.length && t.endList === e.endList && t.mediaSequence === e.mediaSequence && t.preloadSegment === e.preloadSegment, ay = (t, e, n = dM) => {
  const r = xn(t, {}), i = r.playlists[e.id];
  if (!i || n(i, e))
    return null;
  e.segments = cM(e);
  const s = xn(i, e);
  if (s.preloadSegment && !e.preloadSegment && delete s.preloadSegment, i.segments) {
    if (e.skip) {
      e.segments = e.segments || [];
      for (let a = 0; a < e.skip.skippedSegments; a++)
        e.segments.unshift({
          skipped: !0
        });
    }
    s.segments = nSe(i.segments, e.segments, e.mediaSequence - i.mediaSequence);
  }
  s.segments.forEach((a) => {
    lM(a, s.resolvedUri);
  });
  for (let a = 0; a < r.playlists.length; a++)
    r.playlists[a].id === e.id && (r.playlists[a] = s);
  return r.playlists[e.id] = s, r.playlists[e.uri] = s, Wc(t, (a, o, u, c) => {
    if (a.playlists)
      for (let d = 0; d < a.playlists.length; d++)
        e.id === a.playlists[d].id && (a.playlists[d] = s);
  }), r;
}, oy = (t, e) => {
  const n = t.segments || [], r = n[n.length - 1], i = r && r.parts && r.parts[r.parts.length - 1], s = i && i.duration || r && r.duration;
  return e && s ? s * 1e3 : (t.partTargetDuration || t.targetDuration || 10) * 500;
}, pw = (t, e, n) => {
  if (!t)
    return;
  const r = [];
  return t.forEach((i) => {
    if (!i.attributes)
      return;
    const {
      BANDWIDTH: s,
      RESOLUTION: a,
      CODECS: o
    } = i.attributes;
    r.push({
      id: i.id,
      bandwidth: s,
      resolution: a,
      codecs: o
    });
  }), {
    type: e,
    isLive: n,
    renditions: r
  };
};
class Fl extends JCe {
  constructor(e, n, r = {}) {
    if (super(), !e)
      throw new Error("A non-empty playlist URL or object is required");
    this.logger_ = gs("PlaylistLoader");
    const {
      withCredentials: i = !1
    } = r;
    this.src = e, this.vhs_ = n, this.withCredentials = i, this.addDateRangesToTextTrack_ = r.addDateRangesToTextTrack;
    const s = n.options_;
    this.customTagParsers = s && s.customTagParsers || [], this.customTagMappers = s && s.customTagMappers || [], this.llhls = s && s.llhls, this.dateRangesStorage_ = new fw(), this.state = "HAVE_NOTHING", this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this), this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_), this.on("loadedplaylist", this.handleLoadedPlaylist_.bind(this));
  }
  handleLoadedPlaylist_() {
    const e = this.media();
    if (!e)
      return;
    this.dateRangesStorage_.setOffset(e.segments), this.dateRangesStorage_.setPendingDateRanges(e.dateRanges);
    const n = this.dateRangesStorage_.getDateRangesToProcess();
    !n.length || !this.addDateRangesToTextTrack_ || this.addDateRangesToTextTrack_(n);
  }
  handleMediaupdatetimeout_() {
    if (this.state !== "HAVE_METADATA")
      return;
    const e = this.media();
    let n = wi(this.main.uri, e.uri);
    this.llhls && (n = eSe(n, e)), this.state = "HAVE_CURRENT_METADATA", this.request = this.vhs_.xhr({
      uri: n,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (r, i) => {
      if (this.request) {
        if (r)
          return this.playlistRequestError(this.request, this.media(), "HAVE_METADATA");
        this.haveMetadata({
          playlistString: this.request.responseText,
          url: this.media().uri,
          id: this.media().id
        });
      }
    });
  }
  playlistRequestError(e, n, r) {
    const {
      uri: i,
      id: s
    } = n;
    this.request = null, r && (this.state = r), this.error = {
      playlist: this.main.playlists[s],
      status: e.status,
      message: `HLS playlist request error at URL: ${i}.`,
      responseText: e.responseText,
      code: e.status >= 500 ? 4 : 2,
      metadata: Mu({
        requestType: e.requestType,
        request: e,
        error: e.error
      })
    }, this.trigger("error");
  }
  parseManifest_({
    url: e,
    manifestString: n
  }) {
    try {
      const r = QCe({
        onwarn: ({
          message: i
        }) => this.logger_(`m3u8-parser warn for ${e}: ${i}`),
        oninfo: ({
          message: i
        }) => this.logger_(`m3u8-parser info for ${e}: ${i}`),
        manifestString: n,
        customTagParsers: this.customTagParsers,
        customTagMappers: this.customTagMappers,
        llhls: this.llhls
      });
      return !r.playlists || !r.playlists.length || this.excludeAudioOnlyVariants(r.playlists), r;
    } catch (r) {
      this.error = r, this.error.metadata = {
        errorType: Me.Error.StreamingHlsPlaylistParserError,
        error: r
      };
    }
  }
  excludeAudioOnlyVariants(e) {
    const n = (r) => {
      const i = r.attributes || {}, {
        width: s,
        height: a
      } = i.RESOLUTION || {};
      if (s && a)
        return !0;
      const o = oM(r) || [];
      return !!Kf(o).video;
    };
    e.some(n) && e.forEach((r) => {
      n(r) || (r.excludeUntil = 1 / 0);
    });
  }
  /**
   * Update the playlist loader's state in response to a new or updated playlist.
   *
   * @param {string} [playlistString]
   *        Playlist string (if playlistObject is not provided)
   * @param {Object} [playlistObject]
   *        Playlist object (if playlistString is not provided)
   * @param {string} url
   *        URL of playlist
   * @param {string} id
   *        ID to use for playlist
   */
  haveMetadata({
    playlistString: e,
    playlistObject: n,
    url: r,
    id: i
  }) {
    this.request = null, this.state = "HAVE_METADATA";
    const s = {
      playlistInfo: {
        type: "media",
        uri: r
      }
    };
    this.trigger({
      type: "playlistparsestart",
      metadata: s
    });
    const a = n || this.parseManifest_({
      url: r,
      manifestString: e
    });
    a.lastRequest = Date.now(), iM({
      playlist: a,
      uri: r,
      id: i
    });
    const o = ay(this.main, a);
    this.targetDuration = a.partTargetDuration || a.targetDuration, this.pendingMedia_ = null, o ? (this.main = o, this.media_ = this.main.playlists[i]) : this.trigger("playlistunchanged"), this.updateMediaUpdateTimeout_(oy(this.media(), !!o)), s.parsedPlaylist = pw(this.main.playlists, s.playlistInfo.type, !this.media_.endList), this.trigger({
      type: "playlistparsecomplete",
      metadata: s
    }), this.trigger("loadedplaylist");
  }
  /**
    * Abort any outstanding work and clean up.
    */
  dispose() {
    this.trigger("dispose"), this.stopRequest(), pe.clearTimeout(this.mediaUpdateTimeout), pe.clearTimeout(this.finalRenditionTimeout), this.dateRangesStorage_ = new fw(), this.off();
  }
  stopRequest() {
    if (this.request) {
      const e = this.request;
      this.request = null, e.onreadystatechange = null, e.abort();
    }
  }
  /**
    * When called without any arguments, returns the currently
    * active media playlist. When called with a single argument,
    * triggers the playlist loader to asynchronously switch to the
    * specified media playlist. Calling this method while the
    * loader is in the HAVE_NOTHING causes an error to be emitted
    * but otherwise has no effect.
    *
    * @param {Object=} playlist the parsed media playlist
    * object to switch to
    * @param {boolean=} shouldDelay whether we should delay the request by half target duration
    *
    * @return {Playlist} the current loaded media
    */
  media(e, n) {
    if (!e)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    if (typeof e == "string") {
      if (!this.main.playlists[e])
        throw new Error("Unknown playlist URI: " + e);
      e = this.main.playlists[e];
    }
    if (pe.clearTimeout(this.finalRenditionTimeout), n) {
      const o = (e.partTargetDuration || e.targetDuration) / 2 * 1e3 || 5e3;
      this.finalRenditionTimeout = pe.setTimeout(this.media.bind(this, e, !1), o);
      return;
    }
    const r = this.state, i = !this.media_ || e.id !== this.media_.id, s = this.main.playlists[e.id];
    if (s && s.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    e.endList && e.segments.length) {
      this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = e, i && (this.trigger("mediachanging"), r === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange"));
      return;
    }
    if (this.updateMediaUpdateTimeout_(oy(e, !0)), !i)
      return;
    if (this.state = "SWITCHING_MEDIA", this.request) {
      if (e.resolvedUri === this.request.url)
        return;
      this.request.onreadystatechange = null, this.request.abort(), this.request = null;
    }
    this.media_ && this.trigger("mediachanging"), this.pendingMedia_ = e;
    const a = {
      playlistInfo: {
        type: "media",
        uri: e.uri
      }
    };
    this.trigger({
      type: "playlistrequeststart",
      metadata: a
    }), this.request = this.vhs_.xhr({
      uri: e.resolvedUri,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (o, u) => {
      if (this.request) {
        if (e.lastRequest = Date.now(), e.resolvedUri = v0(e.resolvedUri, u), o)
          return this.playlistRequestError(this.request, e, r);
        this.trigger({
          type: "playlistrequestcomplete",
          metadata: a
        }), this.haveMetadata({
          playlistString: u.responseText,
          url: e.uri,
          id: e.id
        }), r === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange");
      }
    });
  }
  /**
   * pause loading of the playlist
   */
  pause() {
    this.mediaUpdateTimeout && (pe.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), this.stopRequest(), this.state === "HAVE_NOTHING" && (this.started = !1), this.state === "SWITCHING_MEDIA" ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MAIN_MANIFEST" : this.state === "HAVE_CURRENT_METADATA" && (this.state = "HAVE_METADATA");
  }
  /**
   * start loading of the playlist
   */
  load(e) {
    this.mediaUpdateTimeout && (pe.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null);
    const n = this.media();
    if (e) {
      const r = n ? (n.partTargetDuration || n.targetDuration) / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = pe.setTimeout(() => {
        this.mediaUpdateTimeout = null, this.load();
      }, r);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    n && !n.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist");
  }
  updateMediaUpdateTimeout_(e) {
    this.mediaUpdateTimeout && (pe.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null), !(!this.media() || this.media().endList) && (this.mediaUpdateTimeout = pe.setTimeout(() => {
      this.mediaUpdateTimeout = null, this.trigger("mediaupdatetimeout"), this.updateMediaUpdateTimeout_(e);
    }, e));
  }
  /**
   * start loading of the playlist
   */
  start() {
    if (this.started = !0, typeof this.src == "object") {
      this.src.uri || (this.src.uri = pe.location.href), this.src.resolvedUri = this.src.uri, setTimeout(() => {
        this.setupInitialPlaylist(this.src);
      }, 0);
      return;
    }
    const e = {
      playlistInfo: {
        type: "multivariant",
        uri: this.src
      }
    };
    this.trigger({
      type: "playlistrequeststart",
      metadata: e
    }), this.request = this.vhs_.xhr({
      uri: this.src,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (n, r) => {
      if (!this.request)
        return;
      if (this.request = null, n)
        return this.error = {
          status: r.status,
          message: `HLS playlist request error at URL: ${this.src}.`,
          responseText: r.responseText,
          // MEDIA_ERR_NETWORK
          code: 2,
          metadata: Mu({
            requestType: r.requestType,
            request: r,
            error: n
          })
        }, this.state === "HAVE_NOTHING" && (this.started = !1), this.trigger("error");
      this.trigger({
        type: "playlistrequestcomplete",
        metadata: e
      }), this.src = v0(this.src, r), this.trigger({
        type: "playlistparsestart",
        metadata: e
      });
      const i = this.parseManifest_({
        manifestString: r.responseText,
        url: this.src
      });
      e.parsedPlaylist = pw(i.playlists, e.playlistInfo.type, !1), this.trigger({
        type: "playlistparsecomplete",
        metadata: e
      }), this.setupInitialPlaylist(i);
    });
  }
  srcUri() {
    return typeof this.src == "string" ? this.src : this.src.uri;
  }
  /**
   * Given a manifest object that's either a main or media playlist, trigger the proper
   * events and set the state of the playlist loader.
   *
   * If the manifest object represents a main playlist, `loadedplaylist` will be
   * triggered to allow listeners to select a playlist. If none is selected, the loader
   * will default to the first one in the playlists array.
   *
   * If the manifest object represents a media playlist, `loadedplaylist` will be
   * triggered followed by `loadedmetadata`, as the only available playlist is loaded.
   *
   * In the case of a media playlist, a main playlist object wrapper with one playlist
   * will be created so that all logic can handle playlists in the same fashion (as an
   * assumed manifest object schema).
   *
   * @param {Object} manifest
   *        The parsed manifest object
   */
  setupInitialPlaylist(e) {
    if (this.state = "HAVE_MAIN_MANIFEST", e.playlists) {
      this.main = e, sM(this.main, this.srcUri()), e.playlists.forEach((r) => {
        r.segments = cM(r), r.segments.forEach((i) => {
          lM(i, r.resolvedUri);
        });
      }), this.trigger("loadedplaylist"), this.request || this.media(this.main.playlists[0]);
      return;
    }
    const n = this.srcUri() || pe.location.href;
    this.main = XCe(e, n), this.haveMetadata({
      playlistObject: e,
      url: n,
      id: this.main.playlists[0].id
    }), this.trigger("loadedmetadata");
  }
  /**
   * Updates or deletes a preexisting pathway clone.
   * Ensures that all playlists related to the old pathway clone are
   * either updated or deleted.
   *
   * @param {Object} clone On update, the pathway clone object for the newly updated pathway clone.
   *        On delete, the old pathway clone object to be deleted.
   * @param {boolean} isUpdate True if the pathway is to be updated,
   *        false if it is meant to be deleted.
   */
  updateOrDeleteClone(e, n) {
    const r = this.main, i = e.ID;
    let s = r.playlists.length;
    for (; s--; ) {
      const a = r.playlists[s];
      if (a.attributes["PATHWAY-ID"] === i) {
        const o = a.resolvedUri, u = a.id;
        if (n) {
          const c = this.createCloneURI_(a.resolvedUri, e), d = Yl(i, c), l = this.createCloneAttributes_(i, a.attributes), f = this.createClonePlaylist_(a, d, e, l);
          r.playlists[s] = f, r.playlists[d] = f, r.playlists[c] = f;
        } else
          r.playlists.splice(s, 1);
        delete r.playlists[u], delete r.playlists[o];
      }
    }
    this.updateOrDeleteCloneMedia(e, n);
  }
  /**
   * Updates or deletes media data based on the pathway clone object.
   * Due to the complexity of the media groups and playlists, in all cases
   * we remove all of the old media groups and playlists.
   * On updates, we then create new media groups and playlists based on the
   * new pathway clone object.
   *
   * @param {Object} clone The pathway clone object for the newly updated pathway clone.
   * @param {boolean} isUpdate True if the pathway is to be updated,
   *        false if it is meant to be deleted.
   */
  updateOrDeleteCloneMedia(e, n) {
    const r = this.main, i = e.ID;
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((s) => {
      if (!(!r.mediaGroups[s] || !r.mediaGroups[s][i])) {
        for (const a in r.mediaGroups[s])
          if (a === i) {
            for (const o in r.mediaGroups[s][a])
              r.mediaGroups[s][a][o].playlists.forEach((c, d) => {
                const l = r.playlists[c.id], f = l.id, p = l.resolvedUri;
                delete r.playlists[f], delete r.playlists[p];
              });
            delete r.mediaGroups[s][a];
          }
      }
    }), n && this.createClonedMediaGroups_(e);
  }
  /**
   * Given a pathway clone object, clones all necessary playlists.
   *
   * @param {Object} clone The pathway clone object.
   * @param {Object} basePlaylist The original playlist to clone from.
   */
  addClonePathway(e, n = {}) {
    const r = this.main, i = r.playlists.length, s = this.createCloneURI_(n.resolvedUri, e), a = Yl(e.ID, s), o = this.createCloneAttributes_(e.ID, n.attributes), u = this.createClonePlaylist_(n, a, e, o);
    r.playlists[i] = u, r.playlists[a] = u, r.playlists[s] = u, this.createClonedMediaGroups_(e);
  }
  /**
   * Given a pathway clone object we create clones of all media.
   * In this function, all necessary information and updated playlists
   * are added to the `mediaGroup` object.
   * Playlists are also added to the `playlists` array so the media groups
   * will be properly linked.
   *
   * @param {Object} clone The pathway clone object.
   */
  createClonedMediaGroups_(e) {
    const n = e.ID, r = e["BASE-ID"], i = this.main;
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((s) => {
      if (!(!i.mediaGroups[s] || i.mediaGroups[s][n]))
        for (const a in i.mediaGroups[s]) {
          if (a === r)
            i.mediaGroups[s][n] = {};
          else
            continue;
          for (const o in i.mediaGroups[s][a]) {
            const u = i.mediaGroups[s][a][o];
            i.mediaGroups[s][n][o] = fr({}, u);
            const c = i.mediaGroups[s][n][o], d = this.createCloneURI_(u.resolvedUri, e);
            c.resolvedUri = d, c.uri = d, c.playlists = [], u.playlists.forEach((l, f) => {
              const p = i.playlists[l.id], m = rM(s, n, o), g = Yl(n, m);
              if (p && !i.playlists[g]) {
                const y = this.createClonePlaylist_(p, g, e), b = y.resolvedUri;
                i.playlists[g] = y, i.playlists[b] = y;
              }
              c.playlists[f] = this.createClonePlaylist_(l, g, e);
            });
          }
        }
    });
  }
  /**
   * Using the original playlist to be cloned, and the pathway clone object
   * information, we create a new playlist.
   *
   * @param {Object} basePlaylist  The original playlist to be cloned from.
   * @param {string} id The desired id of the newly cloned playlist.
   * @param {Object} clone The pathway clone object.
   * @param {Object} attributes An optional object to populate the `attributes` property in the playlist.
   *
   * @return {Object} The combined cloned playlist.
   */
  createClonePlaylist_(e, n, r, i) {
    const s = this.createCloneURI_(e.resolvedUri, r), a = {
      resolvedUri: s,
      uri: s,
      id: n
    };
    return e.segments && (a.segments = []), i && (a.attributes = i), xn(e, a);
  }
  /**
   * Generates an updated URI for a cloned pathway based on the original
   * pathway's URI and the paramaters from the pathway clone object in the
   * content steering server response.
   *
   * @param {string} baseUri URI to be updated in the cloned pathway.
   * @param {Object} clone The pathway clone object.
   *
   * @return {string} The updated URI for the cloned pathway.
   */
  createCloneURI_(e, n) {
    const r = new URL(e);
    r.hostname = n["URI-REPLACEMENT"].HOST;
    const i = n["URI-REPLACEMENT"].PARAMS;
    for (const s of Object.keys(i))
      r.searchParams.set(s, i[s]);
    return r.href;
  }
  /**
   * Helper function to create the attributes needed for the new clone.
   * This mainly adds the necessary media attributes.
   *
   * @param {string} id The pathway clone object ID.
   * @param {Object} oldAttributes The old attributes to compare to.
   * @return {Object} The new attributes to add to the playlist.
   */
  createCloneAttributes_(e, n) {
    const r = {
      "PATHWAY-ID": e
    };
    return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((i) => {
      n[i] && (r[i] = e);
    }), r;
  }
  /**
   * Returns the key ID set from a playlist
   *
   * @param {playlist} playlist to fetch the key ID set from.
   * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
   */
  getKeyIdSet(e) {
    if (e.contentProtection) {
      const n = /* @__PURE__ */ new Set();
      for (const r in e.contentProtection) {
        const i = e.contentProtection[r].attributes.keyId;
        i && n.add(i.toLowerCase());
      }
      return n;
    }
  }
}
const uy = function(t, e, n, r) {
  const i = t.responseType === "arraybuffer" ? t.response : t.responseText;
  !e && i && (t.responseTime = Date.now(), t.roundTripTime = t.responseTime - t.requestTime, t.bytesReceived = i.byteLength || i.length, t.bandwidth || (t.bandwidth = Math.floor(t.bytesReceived / t.roundTripTime * 8 * 1e3))), n.headers && (t.responseHeaders = n.headers), e && e.code === "ETIMEDOUT" && (t.timedout = !0), !e && !t.aborted && n.statusCode !== 200 && n.statusCode !== 206 && n.statusCode !== 0 && (e = new Error("XHR Failed with a response of: " + (t && (i || t.responseText)))), r(e, t);
}, rSe = (t, e) => {
  if (!t || !t.size)
    return;
  let n = e;
  return t.forEach((r) => {
    n = r(n);
  }), n;
}, iSe = (t, e, n, r) => {
  !t || !t.size || t.forEach((i) => {
    i(e, n, r);
  });
}, fM = function() {
  const t = function e(n, r) {
    n = xn({
      timeout: 45e3
    }, n);
    const i = e.beforeRequest || Me.Vhs.xhr.beforeRequest, s = e._requestCallbackSet || Me.Vhs.xhr._requestCallbackSet || /* @__PURE__ */ new Set(), a = e._responseCallbackSet || Me.Vhs.xhr._responseCallbackSet;
    i && typeof i == "function" && (Me.log.warn("beforeRequest is deprecated, use onRequest instead."), s.add(i));
    const o = Me.Vhs.xhr.original === !0 ? Me.xhr : Me.Vhs.xhr, u = rSe(s, n);
    s.delete(i);
    const c = o(u || n, function(l, f) {
      return iSe(a, c, l, f), uy(c, l, f, r);
    }), d = c.abort;
    return c.abort = function() {
      return c.aborted = !0, d.apply(c, arguments);
    }, c.uri = n.uri, c.requestType = n.requestType, c.requestTime = Date.now(), c;
  };
  return t.original = !0, t;
}, sSe = function(t) {
  let e;
  const n = t.offset;
  return typeof t.offset == "bigint" || typeof t.length == "bigint" ? e = pe.BigInt(t.offset) + pe.BigInt(t.length) - pe.BigInt(1) : e = t.offset + t.length - 1, "bytes=" + n + "-" + e;
}, ly = function(t) {
  const e = {};
  return t.byterange && (e.Range = sSe(t.byterange)), e;
}, aSe = function(t, e) {
  return t.start(e) + "-" + t.end(e);
}, oSe = function(t, e) {
  const n = t.toString(16);
  return "00".substring(0, 2 - n.length) + n + (e % 2 ? " " : "");
}, uSe = function(t) {
  return t >= 32 && t < 126 ? String.fromCharCode(t) : ".";
}, hM = function(t) {
  const e = {};
  return Object.keys(t).forEach((n) => {
    const r = t[n];
    mD(r) ? e[n] = {
      bytes: r.buffer,
      byteOffset: r.byteOffset,
      byteLength: r.byteLength
    } : e[n] = r;
  }), e;
}, T0 = function(t) {
  const e = t.byterange || {
    length: 1 / 0,
    offset: 0
  };
  return [e.length, e.offset, t.resolvedUri].join(",");
}, pM = function(t) {
  return t.resolvedUri;
}, mM = (t) => {
  const e = Array.prototype.slice.call(t), n = 16;
  let r = "", i, s;
  for (let a = 0; a < e.length / n; a++)
    i = e.slice(a * n, a * n + n).map(oSe).join(""), s = e.slice(a * n, a * n + n).map(uSe).join(""), r += i + " " + s + `
`;
  return r;
}, lSe = ({
  bytes: t
}) => mM(t), cSe = (t) => {
  let e = "", n;
  for (n = 0; n < t.length; n++)
    e += aSe(t, n) + " ";
  return e;
};
var dSe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTransferableMessage: hM,
  initSegmentId: T0,
  segmentKeyId: pM,
  hexDump: mM,
  tagDump: lSe,
  textRanges: cSe
});
const gM = 0.25, fSe = (t, e) => {
  if (!e.dateTimeObject)
    return null;
  const n = e.videoTimingInfo.transmuxerPrependedSeconds, i = e.videoTimingInfo.transmuxedPresentationStart + n, s = t - i;
  return new Date(e.dateTimeObject.getTime() + s * 1e3);
}, hSe = (t) => t.transmuxedPresentationEnd - t.transmuxedPresentationStart - t.transmuxerPrependedSeconds, pSe = (t, e) => {
  let n;
  try {
    n = new Date(t);
  } catch {
    return null;
  }
  if (!e || !e.segments || e.segments.length === 0)
    return null;
  let r = e.segments[0];
  if (n < new Date(r.dateTimeObject))
    return null;
  for (let u = 0; u < e.segments.length - 1; u++) {
    r = e.segments[u];
    const c = new Date(e.segments[u + 1].dateTimeObject);
    if (n < c)
      break;
  }
  const i = e.segments[e.segments.length - 1], s = i.dateTimeObject, a = i.videoTimingInfo ? hSe(i.videoTimingInfo) : i.duration + i.duration * gM, o = new Date(s.getTime() + a * 1e3);
  return n > o ? null : (n > new Date(s) && (r = i), {
    segment: r,
    estimatedStart: r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationStart : Si.duration(e, e.mediaSequence + e.segments.indexOf(r)),
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: r.videoTimingInfo ? "accurate" : "estimate"
  });
}, mSe = (t, e) => {
  if (!e || !e.segments || e.segments.length === 0)
    return null;
  let n = 0, r;
  for (let s = 0; s < e.segments.length && (r = e.segments[s], n = r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationEnd : n + r.duration, !(t <= n)); s++)
    ;
  const i = e.segments[e.segments.length - 1];
  if (i.videoTimingInfo && i.videoTimingInfo.transmuxedPresentationEnd < t)
    return null;
  if (t > n) {
    if (t > n + i.duration * gM)
      return null;
    r = i;
  }
  return {
    segment: r,
    estimatedStart: r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationStart : n - r.duration,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: r.videoTimingInfo ? "accurate" : "estimate"
  };
}, gSe = (t, e) => {
  let n, r;
  try {
    n = new Date(t), r = new Date(e);
  } catch {
  }
  const i = n.getTime();
  return (r.getTime() - i) / 1e3;
}, ASe = (t) => {
  if (!t.segments || t.segments.length === 0)
    return !1;
  for (let e = 0; e < t.segments.length; e++)
    if (!t.segments[e].dateTimeObject)
      return !1;
  return !0;
}, bSe = ({
  playlist: t,
  time: e = void 0,
  callback: n
}) => {
  if (!n)
    throw new Error("getProgramTime: callback must be provided");
  if (!t || e === void 0)
    return n({
      message: "getProgramTime: playlist and time must be provided"
    });
  const r = mSe(e, t);
  if (!r)
    return n({
      message: "valid programTime was not found"
    });
  if (r.type === "estimate")
    return n({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: r.estimatedStart
    });
  const i = {
    mediaSeconds: e
  }, s = fSe(e, r.segment);
  return s && (i.programDateTime = s.toISOString()), n(null, i);
}, AM = ({
  programTime: t,
  playlist: e,
  retryCount: n = 2,
  seekTo: r,
  pauseAfterSeek: i = !0,
  tech: s,
  callback: a
}) => {
  if (!a)
    throw new Error("seekToProgramTime: callback must be provided");
  if (typeof t > "u" || !e || !r)
    return a({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  if (!e.endList && !s.hasStarted_)
    return a({
      message: "player must be playing a live stream to start buffering"
    });
  if (!ASe(e))
    return a({
      message: "programDateTime tags must be provided in the manifest " + e.resolvedUri
    });
  const o = pSe(t, e);
  if (!o)
    return a({
      message: `${t} was not found in the stream`
    });
  const u = o.segment, c = gSe(u.dateTimeObject, t);
  if (o.type === "estimate") {
    if (n === 0)
      return a({
        message: `${t} is not buffered yet. Try again`
      });
    r(o.estimatedStart + c), s.one("seeked", () => {
      AM({
        programTime: t,
        playlist: e,
        retryCount: n - 1,
        seekTo: r,
        pauseAfterSeek: i,
        tech: s,
        callback: a
      });
    });
    return;
  }
  const d = u.start + c, l = () => a(null, s.currentTime());
  s.one("seeked", l), i && s.pause(), r(d);
}, l2 = (t, e) => {
  if (t.readyState === 4)
    return e();
}, ySe = (t, e, n, r) => {
  let i = [], s, a = !1;
  const o = function(l, f, p, m) {
    return f.abort(), a = !0, n(l, f, p, m);
  }, u = function(l, f) {
    if (a)
      return;
    if (l)
      return l.metadata = Mu({
        requestType: r,
        request: f,
        error: l
      }), o(l, f, "", i);
    const p = f.responseText.substring(i && i.byteLength || 0, f.responseText.length);
    if (i = W4e(i, gD(p, !0)), s = s || Gd(i), i.length < 10 || s && i.length < s + 2)
      return l2(f, () => o(l, f, "", i));
    const m = fT(i);
    return m === "ts" && i.length < 188 ? l2(f, () => o(l, f, "", i)) : !m && i.length < 376 ? l2(f, () => o(l, f, "", i)) : o(null, f, m, i);
  }, d = e({
    uri: t,
    beforeSend(l) {
      l.overrideMimeType("text/plain; charset=x-user-defined"), l.addEventListener("progress", function({
        total: f,
        loaded: p
      }) {
        return uy(l, null, {
          statusCode: l.status
        }, u);
      });
    }
  }, function(l, f) {
    return uy(d, l, f, u);
  });
  return d;
}, {
  EventTarget: vSe
} = Me, mw = function(t, e) {
  if (!dM(t, e) || t.sidx && e.sidx && (t.sidx.offset !== e.sidx.offset || t.sidx.length !== e.sidx.length))
    return !1;
  if (!t.sidx && e.sidx || t.sidx && !e.sidx || t.segments && !e.segments || !t.segments && e.segments)
    return !1;
  if (!t.segments && !e.segments)
    return !0;
  for (let n = 0; n < t.segments.length; n++) {
    const r = t.segments[n], i = e.segments[n];
    if (r.uri !== i.uri)
      return !1;
    if (!r.byterange && !i.byterange)
      continue;
    const s = r.byterange, a = i.byterange;
    if (s && !a || !s && a || s.offset !== a.offset || s.length !== a.length)
      return !1;
  }
  return !0;
}, TSe = (t, e, n, r) => {
  const i = r.attributes.NAME || n;
  return `placeholder-uri-${t}-${e}-${i}`;
}, _Se = ({
  mainXml: t,
  srcUrl: e,
  clientOffset: n,
  sidxMapping: r,
  previousManifest: i
}) => {
  const s = qxe(t, {
    manifestUri: e,
    clientOffset: n,
    sidxMapping: r,
    previousManifest: i
  });
  return sM(s, e, TSe), s;
}, ESe = (t, e) => {
  Wc(t, (n, r, i, s) => {
    (!e.mediaGroups[r][i] || !(s in e.mediaGroups[r][i])) && delete t.mediaGroups[r][i][s];
  });
}, xSe = (t, e, n) => {
  let r = !0, i = xn(t, {
    // These are top level properties that can be updated
    duration: e.duration,
    minimumUpdatePeriod: e.minimumUpdatePeriod,
    timelineStarts: e.timelineStarts
  });
  for (let s = 0; s < e.playlists.length; s++) {
    const a = e.playlists[s];
    if (a.sidx) {
      const u = Eg(a.sidx);
      n && n[u] && n[u].sidx && lT(a, n[u].sidx, a.sidx.resolvedUri);
    }
    const o = ay(i, a, mw);
    o && (i = o, r = !1);
  }
  return Wc(e, (s, a, o, u) => {
    if (s.playlists && s.playlists.length) {
      const c = s.playlists[0].id, d = ay(i, s.playlists[0], mw);
      d && (i = d, u in i.mediaGroups[a][o] || (i.mediaGroups[a][o][u] = s), i.mediaGroups[a][o][u].playlists[0] = i.playlists[c], r = !1);
    }
  }), ESe(i, e), e.minimumUpdatePeriod !== t.minimumUpdatePeriod && (r = !1), r ? null : i;
}, wSe = (t, e) => (!t.map && !e.map || !!(t.map && e.map && t.map.byterange.offset === e.map.byterange.offset && t.map.byterange.length === e.map.byterange.length)) && t.uri === e.uri && t.byterange.offset === e.byterange.offset && t.byterange.length === e.byterange.length, gw = (t, e) => {
  const n = {};
  for (const r in t) {
    const s = t[r].sidx;
    if (s) {
      const a = Eg(s);
      if (!e[a])
        break;
      const o = e[a].sidxInfo;
      wSe(o, s) && (n[a] = e[a]);
    }
  }
  return n;
}, CSe = (t, e) => {
  let r = gw(t.playlists, e);
  return Wc(t, (i, s, a, o) => {
    if (i.playlists && i.playlists.length) {
      const u = i.playlists;
      r = xn(r, gw(u, e));
    }
  }), r;
};
class cy extends vSe {
  // DashPlaylistLoader must accept either a src url or a playlist because subsequent
  // playlist loader setups from media groups will expect to be able to pass a playlist
  // (since there aren't external URLs to media playlists with DASH)
  constructor(e, n, r = {}, i) {
    super(), this.isPaused_ = !0, this.mainPlaylistLoader_ = i || this, i || (this.isMain_ = !0);
    const {
      withCredentials: s = !1
    } = r;
    if (this.vhs_ = n, this.withCredentials = s, this.addMetadataToTextTrack = r.addMetadataToTextTrack, !e)
      throw new Error("A non-empty playlist URL or object is required");
    this.on("minimumUpdatePeriod", () => {
      this.refreshXml_();
    }), this.on("mediaupdatetimeout", () => {
      this.refreshMedia_(this.media().id);
    }), this.state = "HAVE_NOTHING", this.loadedPlaylists_ = {}, this.logger_ = gs("DashPlaylistLoader"), this.isMain_ ? (this.mainPlaylistLoader_.srcUrl = e, this.mainPlaylistLoader_.sidxMapping_ = {}) : this.childPlaylist_ = e;
  }
  get isPaused() {
    return this.isPaused_;
  }
  requestErrored_(e, n, r) {
    if (!this.request)
      return !0;
    if (this.request = null, e)
      return this.error = typeof e == "object" && !(e instanceof Error) ? e : {
        status: n.status,
        message: "DASH request error at URL: " + n.uri,
        response: n.response,
        // MEDIA_ERR_NETWORK
        code: 2,
        metadata: e.metadata
      }, r && (this.state = r), this.trigger("error"), !0;
  }
  /**
   * Verify that the container of the sidx segment can be parsed
   * and if it can, get and parse that segment.
   */
  addSidxSegments_(e, n, r) {
    const i = e.sidx && Eg(e.sidx);
    if (!e.sidx || !i || this.mainPlaylistLoader_.sidxMapping_[i]) {
      pe.clearTimeout(this.mediaRequest_), this.mediaRequest_ = pe.setTimeout(() => r(!1), 0);
      return;
    }
    const s = v0(e.sidx.resolvedUri), a = (u, c) => {
      if (this.requestErrored_(u, c, n))
        return;
      const d = this.mainPlaylistLoader_.sidxMapping_, {
        requestType: l
      } = c;
      let f;
      try {
        f = Yxe(kt(c.response).subarray(8));
      } catch (p) {
        p.metadata = Mu({
          requestType: l,
          request: c,
          parseFailure: !0
        }), this.requestErrored_(p, c, n);
        return;
      }
      return d[i] = {
        sidxInfo: e.sidx,
        sidx: f
      }, lT(e, f, e.sidx.resolvedUri), r(!0);
    }, o = "dash-sidx";
    this.request = ySe(s, this.vhs_.xhr, (u, c, d, l) => {
      if (u)
        return a(u, c);
      if (!d || d !== "mp4") {
        const m = d || "unknown";
        return a({
          status: c.status,
          message: `Unsupported ${m} container type for sidx segment at URL: ${s}`,
          // response is just bytes in this case
          // but we really don't want to return that.
          response: "",
          playlist: e,
          internal: !0,
          playlistExclusionDuration: 1 / 0,
          // MEDIA_ERR_NETWORK
          code: 2
        }, c);
      }
      const {
        offset: f,
        length: p
      } = e.sidx.byterange;
      if (l.length >= p + f)
        return a(u, {
          response: l.subarray(f, f + p),
          status: c.status,
          uri: c.uri
        });
      this.request = this.vhs_.xhr({
        uri: s,
        responseType: "arraybuffer",
        requestType: "dash-sidx",
        headers: ly({
          byterange: e.sidx.byterange
        })
      }, a);
    }, o);
  }
  dispose() {
    this.isPaused_ = !0, this.trigger("dispose"), this.stopRequest(), this.loadedPlaylists_ = {}, pe.clearTimeout(this.minimumUpdatePeriodTimeout_), pe.clearTimeout(this.mediaRequest_), pe.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.mediaRequest_ = null, this.minimumUpdatePeriodTimeout_ = null, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.off();
  }
  hasPendingRequest() {
    return this.request || this.mediaRequest_;
  }
  stopRequest() {
    if (this.request) {
      const e = this.request;
      this.request = null, e.onreadystatechange = null, e.abort();
    }
  }
  media(e) {
    if (!e)
      return this.media_;
    if (this.state === "HAVE_NOTHING")
      throw new Error("Cannot switch media playlist from " + this.state);
    const n = this.state;
    if (typeof e == "string") {
      if (!this.mainPlaylistLoader_.main.playlists[e])
        throw new Error("Unknown playlist URI: " + e);
      e = this.mainPlaylistLoader_.main.playlists[e];
    }
    const r = !this.media_ || e.id !== this.media_.id;
    if (r && this.loadedPlaylists_[e.id] && this.loadedPlaylists_[e.id].endList) {
      this.state = "HAVE_METADATA", this.media_ = e, r && (this.trigger("mediachanging"), this.trigger("mediachange"));
      return;
    }
    r && (this.media_ && this.trigger("mediachanging"), this.addSidxSegments_(e, n, (i) => {
      this.haveMetadata({
        startingState: n,
        playlist: e
      });
    }));
  }
  haveMetadata({
    startingState: e,
    playlist: n
  }) {
    this.state = "HAVE_METADATA", this.loadedPlaylists_[n.id] = n, pe.clearTimeout(this.mediaRequest_), this.mediaRequest_ = null, this.refreshMedia_(n.id), e === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange");
  }
  pause() {
    this.isPaused_ = !0, this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_), this.mainPlaylistLoader_.createMupOnMedia_ = null), this.stopRequest(), pe.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null, this.isMain_ && (pe.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_), this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null), this.state === "HAVE_NOTHING" && (this.started = !1);
  }
  load(e) {
    this.isPaused_ = !1, pe.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = null;
    const n = this.media();
    if (e) {
      const r = n ? n.targetDuration / 2 * 1e3 : 5e3;
      this.mediaUpdateTimeout = pe.setTimeout(() => this.load(), r);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    n && !n.endList ? (this.isMain_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"), this.updateMinimumUpdatePeriodTimeout_()), this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist");
  }
  start() {
    if (this.started = !0, !this.isMain_) {
      pe.clearTimeout(this.mediaRequest_), this.mediaRequest_ = pe.setTimeout(() => this.haveMain_(), 0);
      return;
    }
    this.requestMain_((e, n) => {
      this.haveMain_(), !this.hasPendingRequest() && !this.media_ && this.media(this.mainPlaylistLoader_.main.playlists[0]);
    });
  }
  requestMain_(e) {
    const n = {
      manifestInfo: {
        uri: this.mainPlaylistLoader_.srcUrl
      }
    };
    this.trigger({
      type: "manifestrequeststart",
      metadata: n
    }), this.request = this.vhs_.xhr({
      uri: this.mainPlaylistLoader_.srcUrl,
      withCredentials: this.withCredentials,
      requestType: "dash-manifest"
    }, (r, i) => {
      if (r) {
        const {
          requestType: a
        } = i;
        r.metadata = Mu({
          requestType: a,
          request: i,
          error: r
        });
      }
      if (this.requestErrored_(r, i)) {
        this.state === "HAVE_NOTHING" && (this.started = !1);
        return;
      }
      this.trigger({
        type: "manifestrequestcomplete",
        metadata: n
      });
      const s = i.responseText !== this.mainPlaylistLoader_.mainXml_;
      if (this.mainPlaylistLoader_.mainXml_ = i.responseText, i.responseHeaders && i.responseHeaders.date ? this.mainLoaded_ = Date.parse(i.responseHeaders.date) : this.mainLoaded_ = Date.now(), this.mainPlaylistLoader_.srcUrl = v0(this.mainPlaylistLoader_.srcUrl, i), s) {
        this.handleMain_(), this.syncClientServerClock_(() => e(i, s));
        return;
      }
      return e(i, s);
    });
  }
  /**
   * Parses the main xml for UTCTiming node to sync the client clock to the server
   * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.
   *
   * @param {Function} done
   *        Function to call when clock sync has completed
   */
  syncClientServerClock_(e) {
    const n = Vxe(this.mainPlaylistLoader_.mainXml_);
    if (n === null)
      return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e();
    if (n.method === "DIRECT")
      return this.mainPlaylistLoader_.clientOffset_ = n.value - Date.now(), e();
    this.request = this.vhs_.xhr({
      uri: wi(this.mainPlaylistLoader_.srcUrl, n.value),
      method: n.method,
      withCredentials: this.withCredentials,
      requestType: "dash-clock-sync"
    }, (r, i) => {
      if (!this.request)
        return;
      if (r) {
        const {
          requestType: a
        } = i;
        return this.error.metadata = Mu({
          requestType: a,
          request: i,
          error: r
        }), this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(), e();
      }
      let s;
      n.method === "HEAD" ? !i.responseHeaders || !i.responseHeaders.date ? s = this.mainLoaded_ : s = Date.parse(i.responseHeaders.date) : s = Date.parse(i.responseText), this.mainPlaylistLoader_.clientOffset_ = s - Date.now(), e();
    });
  }
  haveMain_() {
    this.state = "HAVE_MAIN_MANIFEST", this.isMain_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_);
  }
  handleMain_() {
    pe.clearTimeout(this.mediaRequest_), this.mediaRequest_ = null;
    const e = this.mainPlaylistLoader_.main, n = {
      manifestInfo: {
        uri: this.mainPlaylistLoader_.srcUrl
      }
    };
    this.trigger({
      type: "manifestparsestart",
      metadata: n
    });
    let r;
    try {
      r = _Se({
        mainXml: this.mainPlaylistLoader_.mainXml_,
        srcUrl: this.mainPlaylistLoader_.srcUrl,
        clientOffset: this.mainPlaylistLoader_.clientOffset_,
        sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
        previousManifest: e
      });
    } catch (s) {
      this.error = s, this.error.metadata = {
        errorType: Me.Error.StreamingDashManifestParserError,
        error: s
      }, this.trigger("error");
    }
    e && (r = xSe(e, r, this.mainPlaylistLoader_.sidxMapping_)), this.mainPlaylistLoader_.main = r || e;
    const i = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
    if (i && i !== this.mainPlaylistLoader_.srcUrl && (this.mainPlaylistLoader_.srcUrl = i), (!e || r && r.minimumUpdatePeriod !== e.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(), this.addEventStreamToMetadataTrack_(r), r) {
      const {
        duration: s,
        endList: a
      } = r, o = [];
      r.playlists.forEach((c) => {
        o.push({
          id: c.id,
          bandwidth: c.attributes.BANDWIDTH,
          resolution: c.attributes.RESOLUTION,
          codecs: c.attributes.CODECS
        });
      });
      const u = {
        duration: s,
        isLive: !a,
        renditions: o
      };
      n.parsedManifest = u, this.trigger({
        type: "manifestparsecomplete",
        metadata: n
      });
    }
    return !!r;
  }
  updateMinimumUpdatePeriodTimeout_() {
    const e = this.mainPlaylistLoader_;
    e.createMupOnMedia_ && (e.off("loadedmetadata", e.createMupOnMedia_), e.createMupOnMedia_ = null), e.minimumUpdatePeriodTimeout_ && (pe.clearTimeout(e.minimumUpdatePeriodTimeout_), e.minimumUpdatePeriodTimeout_ = null);
    let n = e.main && e.main.minimumUpdatePeriod;
    if (n === 0 && (e.media() ? n = e.media().targetDuration * 1e3 : (e.createMupOnMedia_ = e.updateMinimumUpdatePeriodTimeout_, e.one("loadedmetadata", e.createMupOnMedia_))), typeof n != "number" || n <= 0) {
      n < 0 && this.logger_(`found invalid minimumUpdatePeriod of ${n}, not setting a timeout`);
      return;
    }
    this.createMUPTimeout_(n);
  }
  createMUPTimeout_(e) {
    const n = this.mainPlaylistLoader_;
    n.minimumUpdatePeriodTimeout_ = pe.setTimeout(() => {
      n.minimumUpdatePeriodTimeout_ = null, n.trigger("minimumUpdatePeriod"), n.createMUPTimeout_(e);
    }, e);
  }
  /**
   * Sends request to refresh the main xml and updates the parsed main manifest
   */
  refreshXml_() {
    this.requestMain_((e, n) => {
      n && (this.media_ && (this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id]), this.mainPlaylistLoader_.sidxMapping_ = CSe(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_), this.addSidxSegments_(this.media(), this.state, (r) => {
        this.refreshMedia_(this.media().id);
      }));
    });
  }
  /**
   * Refreshes the media playlist by re-parsing the main xml and updating playlist
   * references. If this is an alternate loader, the updated parsed manifest is retrieved
   * from the main loader.
   */
  refreshMedia_(e) {
    if (!e)
      throw new Error("refreshMedia_ must take a media id");
    this.media_ && this.isMain_ && this.handleMain_();
    const n = this.mainPlaylistLoader_.main.playlists, r = !this.media_ || this.media_ !== n[e];
    if (r ? this.media_ = n[e] : this.trigger("playlistunchanged"), !this.mediaUpdateTimeout) {
      const i = () => {
        this.media().endList || (this.mediaUpdateTimeout = pe.setTimeout(() => {
          this.trigger("mediaupdatetimeout"), i();
        }, oy(this.media(), !!r)));
      };
      i();
    }
    this.trigger("loadedplaylist");
  }
  /**
   * Takes eventstream data from a parsed DASH manifest and adds it to the metadata text track.
   *
   * @param {manifest} newMain the newly parsed manifest
   */
  addEventStreamToMetadataTrack_(e) {
    if (e && this.mainPlaylistLoader_.main.eventStream) {
      const n = this.mainPlaylistLoader_.main.eventStream.map((r) => ({
        cueTime: r.start,
        frames: [{
          data: r.messageData
        }]
      }));
      this.addMetadataToTextTrack("EventStream", n, this.mainPlaylistLoader_.main.duration);
    }
  }
  /**
   * Returns the key ID set from a playlist
   *
   * @param {playlist} playlist to fetch the key ID set from.
   * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
   */
  getKeyIdSet(e) {
    if (e.contentProtection) {
      const n = /* @__PURE__ */ new Set();
      for (const r in e.contentProtection) {
        const i = e.contentProtection[r].attributes["cenc:default_KID"];
        i && n.add(i.replace(/-/g, "").toLowerCase());
      }
      return n;
    }
  }
}
var Ir = {
  GOAL_BUFFER_LENGTH: 30,
  MAX_GOAL_BUFFER_LENGTH: 60,
  BACK_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30
};
const SSe = (t) => {
  const e = new Uint8Array(new ArrayBuffer(t.length));
  for (let n = 0; n < t.length; n++)
    e[n] = t.charCodeAt(n);
  return e.buffer;
}, bM = function(t) {
  return t.on = t.addEventListener, t.off = t.removeEventListener, t;
}, ISe = function(t) {
  try {
    return URL.createObjectURL(new Blob([t], {
      type: "application/javascript"
    }));
  } catch {
    const n = new BlobBuilder();
    return n.append(t), URL.createObjectURL(n.getBlob());
  }
}, yM = function(t) {
  return function() {
    const e = ISe(t), n = bM(new Worker(e));
    n.objURL = e;
    const r = n.terminate;
    return n.on = n.addEventListener, n.off = n.removeEventListener, n.terminate = function() {
      return URL.revokeObjectURL(e), r.call(this);
    }, n;
  };
}, vM = function(t) {
  return `var browserWorkerPolyFill = ${bM.toString()};
browserWorkerPolyFill(self);
` + t;
}, TM = function(t) {
  return t.toString().replace(/^function.+?{/, "").slice(0, -1);
}, kSe = vM(TM(function() {
  var t = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, e = function() {
    this.init = function() {
      var A = {};
      this.on = function(x, k) {
        A[x] || (A[x] = []), A[x] = A[x].concat(k);
      }, this.off = function(x, k) {
        var C;
        return A[x] ? (C = A[x].indexOf(k), A[x] = A[x].slice(), A[x].splice(C, 1), C > -1) : !1;
      }, this.trigger = function(x) {
        var k, C, L, z;
        if (k = A[x], !!k)
          if (arguments.length === 2)
            for (L = k.length, C = 0; C < L; ++C)
              k[C].call(this, arguments[1]);
          else {
            for (z = [], C = arguments.length, C = 1; C < arguments.length; ++C)
              z.push(arguments[C]);
            for (L = k.length, C = 0; C < L; ++C)
              k[C].apply(this, z);
          }
      }, this.dispose = function() {
        A = {};
      };
    };
  };
  e.prototype.pipe = function(A) {
    return this.on("data", function(x) {
      A.push(x);
    }), this.on("done", function(x) {
      A.flush(x);
    }), this.on("partialdone", function(x) {
      A.partialFlush(x);
    }), this.on("endedtimeline", function(x) {
      A.endTimeline(x);
    }), this.on("reset", function(x) {
      A.reset(x);
    }), A;
  }, e.prototype.push = function(A) {
    this.trigger("data", A);
  }, e.prototype.flush = function(A) {
    this.trigger("done", A);
  }, e.prototype.partialFlush = function(A) {
    this.trigger("partialdone", A);
  }, e.prototype.endTimeline = function(A) {
    this.trigger("endedtimeline", A);
  }, e.prototype.reset = function(A) {
    this.trigger("reset", A);
  };
  var n = e, r = Math.pow(2, 32), i = function(A) {
    var x = new DataView(A.buffer, A.byteOffset, A.byteLength), k;
    return x.getBigUint64 ? (k = x.getBigUint64(0), k < Number.MAX_SAFE_INTEGER ? Number(k) : k) : x.getUint32(0) * r + x.getUint32(4);
  }, s = {
    getUint64: i,
    MAX_UINT32: r
  }, a = s.MAX_UINT32, o, u, c, d, l, f, p, m, g, y, b, E, v, _, D, S, M, O, T, N, H, $, j, U, V, B, R, K, Q, P, I, G, te, ee, Z, ye;
  (function() {
    var A;
    if (j = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      // codingname
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      smhd: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      styp: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: []
    }, !(typeof Uint8Array > "u")) {
      for (A in j)
        j.hasOwnProperty(A) && (j[A] = [A.charCodeAt(0), A.charCodeAt(1), A.charCodeAt(2), A.charCodeAt(3)]);
      U = new Uint8Array([105, 115, 111, 109]), B = new Uint8Array([97, 118, 99, 49]), V = new Uint8Array([0, 0, 0, 1]), R = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        118,
        105,
        100,
        101,
        // handler_type: 'vide'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        86,
        105,
        100,
        101,
        111,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'VideoHandler'
      ]), K = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // pre_defined
        115,
        111,
        117,
        110,
        // handler_type: 'soun'
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        83,
        111,
        117,
        110,
        100,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
        // name: 'SoundHandler'
      ]), Q = {
        video: R,
        audio: K
      }, G = new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1,
        // entry_count
        0,
        0,
        0,
        12,
        // entry_size
        117,
        114,
        108,
        32,
        // 'url' type
        0,
        // version 0
        0,
        0,
        1
        // entry_flags
      ]), I = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        // balance, 0 means centered
        0,
        0
        // reserved
      ]), te = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0
        // entry_count
      ]), ee = te, Z = new Uint8Array([
        0,
        // version
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        0,
        // sample_size
        0,
        0,
        0,
        0
        // sample_count
      ]), ye = te, P = new Uint8Array([
        0,
        // version
        0,
        0,
        1,
        // flags
        0,
        0,
        // graphicsmode
        0,
        0,
        0,
        0,
        0,
        0
        // opcolor
      ]);
    }
  })(), o = function(A) {
    var x = [], k = 0, C, L, z;
    for (C = 1; C < arguments.length; C++)
      x.push(arguments[C]);
    for (C = x.length; C--; )
      k += x[C].byteLength;
    for (L = new Uint8Array(k + 8), z = new DataView(L.buffer, L.byteOffset, L.byteLength), z.setUint32(0, L.byteLength), L.set(A, 4), C = 0, k = 8; C < x.length; C++)
      L.set(x[C], k), k += x[C].byteLength;
    return L;
  }, u = function() {
    return o(j.dinf, o(j.dref, G));
  }, c = function(A) {
    return o(j.esds, new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      // ES_Descriptor
      3,
      // tag, ES_DescrTag
      25,
      // length
      0,
      0,
      // ES_ID
      0,
      // streamDependenceFlag, URL_flag, reserved, streamPriority
      // DecoderConfigDescriptor
      4,
      // tag, DecoderConfigDescrTag
      17,
      // length
      64,
      // object type
      21,
      // streamType
      0,
      6,
      0,
      // bufferSizeDB
      0,
      0,
      218,
      192,
      // maxBitrate
      0,
      0,
      218,
      192,
      // avgBitrate
      // DecoderSpecificInfo
      5,
      // tag, DecoderSpecificInfoTag
      2,
      // length
      // ISO/IEC 14496-3, AudioSpecificConfig
      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
      A.audioobjecttype << 3 | A.samplingfrequencyindex >>> 1,
      A.samplingfrequencyindex << 7 | A.channelcount << 3,
      6,
      1,
      2
      // GASpecificConfig
    ]));
  }, d = function() {
    return o(j.ftyp, U, V, U, B);
  }, S = function(A) {
    return o(j.hdlr, Q[A]);
  }, l = function(A) {
    return o(j.mdat, A);
  }, D = function(A) {
    var x = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      3,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      A.duration >>> 24 & 255,
      A.duration >>> 16 & 255,
      A.duration >>> 8 & 255,
      A.duration & 255,
      // duration
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]);
    return A.samplerate && (x[12] = A.samplerate >>> 24 & 255, x[13] = A.samplerate >>> 16 & 255, x[14] = A.samplerate >>> 8 & 255, x[15] = A.samplerate & 255), o(j.mdhd, x);
  }, _ = function(A) {
    return o(j.mdia, D(A), S(A.type), p(A));
  }, f = function(A) {
    return o(j.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      (A & 4278190080) >> 24,
      (A & 16711680) >> 16,
      (A & 65280) >> 8,
      A & 255
      // sequence_number
    ]));
  }, p = function(A) {
    return o(j.minf, A.type === "video" ? o(j.vmhd, P) : o(j.smhd, I), u(), O(A));
  }, m = function(A, x) {
    for (var k = [], C = x.length; C--; )
      k[C] = N(x[C]);
    return o.apply(null, [j.moof, f(A)].concat(k));
  }, g = function(A) {
    for (var x = A.length, k = []; x--; )
      k[x] = E(A[x]);
    return o.apply(null, [j.moov, b(4294967295)].concat(k).concat(y(A)));
  }, y = function(A) {
    for (var x = A.length, k = []; x--; )
      k[x] = H(A[x]);
    return o.apply(null, [j.mvex].concat(k));
  }, b = function(A) {
    var x = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // creation_time
      0,
      0,
      0,
      2,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      (A & 4278190080) >> 24,
      (A & 16711680) >> 16,
      (A & 65280) >> 8,
      A & 255,
      // duration
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return o(j.mvhd, x);
  }, M = function(A) {
    var x = A.samples || [], k = new Uint8Array(4 + x.length), C, L;
    for (L = 0; L < x.length; L++)
      C = x[L].flags, k[L + 4] = C.dependsOn << 4 | C.isDependedOn << 2 | C.hasRedundancy;
    return o(j.sdtp, k);
  }, O = function(A) {
    return o(j.stbl, T(A), o(j.stts, ye), o(j.stsc, ee), o(j.stsz, Z), o(j.stco, te));
  }, function() {
    var A, x;
    T = function(k) {
      return o(j.stsd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1
      ]), k.type === "video" ? A(k) : x(k));
    }, A = function(k) {
      var C = k.sps || [], L = k.pps || [], z = [], re = [], oe, fe;
      for (oe = 0; oe < C.length; oe++)
        z.push((C[oe].byteLength & 65280) >>> 8), z.push(C[oe].byteLength & 255), z = z.concat(Array.prototype.slice.call(C[oe]));
      for (oe = 0; oe < L.length; oe++)
        re.push((L[oe].byteLength & 65280) >>> 8), re.push(L[oe].byteLength & 255), re = re.concat(Array.prototype.slice.call(L[oe]));
      if (fe = [j.avc1, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        (k.width & 65280) >> 8,
        k.width & 255,
        // width
        (k.height & 65280) >> 8,
        k.height & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        19,
        118,
        105,
        100,
        101,
        111,
        106,
        115,
        45,
        99,
        111,
        110,
        116,
        114,
        105,
        98,
        45,
        104,
        108,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
        // pre_defined = -1
      ]), o(j.avcC, new Uint8Array([
        1,
        // configurationVersion
        k.profileIdc,
        // AVCProfileIndication
        k.profileCompatibility,
        // profile_compatibility
        k.levelIdc,
        // AVCLevelIndication
        255
        // lengthSizeMinusOne, hard-coded to 4 bytes
      ].concat(
        [C.length],
        // numOfSequenceParameterSets
        z,
        // "SPS"
        [L.length],
        // numOfPictureParameterSets
        re
        // "PPS"
      ))), o(j.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
        // avgBitrate
      ]))], k.sarRatio) {
        var ge = k.sarRatio[0], we = k.sarRatio[1];
        fe.push(o(j.pasp, new Uint8Array([(ge & 4278190080) >> 24, (ge & 16711680) >> 16, (ge & 65280) >> 8, ge & 255, (we & 4278190080) >> 24, (we & 16711680) >> 16, (we & 65280) >> 8, we & 255])));
      }
      return o.apply(null, fe);
    }, x = function(k) {
      return o(j.mp4a, new Uint8Array([
        // SampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        // AudioSampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        (k.channelcount & 65280) >> 8,
        k.channelcount & 255,
        // channelcount
        (k.samplesize & 65280) >> 8,
        k.samplesize & 255,
        // samplesize
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        (k.samplerate & 65280) >> 8,
        k.samplerate & 255,
        0,
        0
        // samplerate, 16.16
        // MP4AudioSampleEntry, ISO/IEC 14496-14
      ]), c(k));
    };
  }(), v = function(A) {
    var x = new Uint8Array([
      0,
      // version 0
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      // creation_time
      0,
      0,
      0,
      0,
      // modification_time
      (A.id & 4278190080) >> 24,
      (A.id & 16711680) >> 16,
      (A.id & 65280) >> 8,
      A.id & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      (A.duration & 4278190080) >> 24,
      (A.duration & 16711680) >> 16,
      (A.duration & 65280) >> 8,
      A.duration & 255,
      // duration
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      1,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      (A.width & 65280) >> 8,
      A.width & 255,
      0,
      0,
      // width
      (A.height & 65280) >> 8,
      A.height & 255,
      0,
      0
      // height
    ]);
    return o(j.tkhd, x);
  }, N = function(A) {
    var x, k, C, L, z, re, oe;
    return x = o(j.tfhd, new Uint8Array([
      0,
      // version 0
      0,
      0,
      58,
      // flags
      (A.id & 4278190080) >> 24,
      (A.id & 16711680) >> 16,
      (A.id & 65280) >> 8,
      A.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      0,
      0,
      0
      // default_sample_flags
    ])), re = Math.floor(A.baseMediaDecodeTime / a), oe = Math.floor(A.baseMediaDecodeTime % a), k = o(j.tfdt, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      // baseMediaDecodeTime
      re >>> 24 & 255,
      re >>> 16 & 255,
      re >>> 8 & 255,
      re & 255,
      oe >>> 24 & 255,
      oe >>> 16 & 255,
      oe >>> 8 & 255,
      oe & 255
    ])), z = 92, A.type === "audio" ? (C = $(A, z), o(j.traf, x, k, C)) : (L = M(A), C = $(A, L.length + z), o(j.traf, x, k, C, L));
  }, E = function(A) {
    return A.duration = A.duration || 4294967295, o(j.trak, v(A), _(A));
  }, H = function(A) {
    var x = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      (A.id & 4278190080) >> 24,
      (A.id & 16711680) >> 16,
      (A.id & 65280) >> 8,
      A.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]);
    return A.type !== "video" && (x[x.length - 1] = 0), o(j.trex, x);
  }, function() {
    var A, x, k;
    k = function(C, L) {
      var z = 0, re = 0, oe = 0, fe = 0;
      return C.length && (C[0].duration !== void 0 && (z = 1), C[0].size !== void 0 && (re = 2), C[0].flags !== void 0 && (oe = 4), C[0].compositionTimeOffset !== void 0 && (fe = 8)), [
        0,
        // version 0
        0,
        z | re | oe | fe,
        1,
        // flags
        (C.length & 4278190080) >>> 24,
        (C.length & 16711680) >>> 16,
        (C.length & 65280) >>> 8,
        C.length & 255,
        // sample_count
        (L & 4278190080) >>> 24,
        (L & 16711680) >>> 16,
        (L & 65280) >>> 8,
        L & 255
        // data_offset
      ];
    }, x = function(C, L) {
      var z, re, oe, fe, ge, we;
      for (fe = C.samples || [], L += 20 + 16 * fe.length, oe = k(fe, L), re = new Uint8Array(oe.length + fe.length * 16), re.set(oe), z = oe.length, we = 0; we < fe.length; we++)
        ge = fe[we], re[z++] = (ge.duration & 4278190080) >>> 24, re[z++] = (ge.duration & 16711680) >>> 16, re[z++] = (ge.duration & 65280) >>> 8, re[z++] = ge.duration & 255, re[z++] = (ge.size & 4278190080) >>> 24, re[z++] = (ge.size & 16711680) >>> 16, re[z++] = (ge.size & 65280) >>> 8, re[z++] = ge.size & 255, re[z++] = ge.flags.isLeading << 2 | ge.flags.dependsOn, re[z++] = ge.flags.isDependedOn << 6 | ge.flags.hasRedundancy << 4 | ge.flags.paddingValue << 1 | ge.flags.isNonSyncSample, re[z++] = ge.flags.degradationPriority & 61440, re[z++] = ge.flags.degradationPriority & 15, re[z++] = (ge.compositionTimeOffset & 4278190080) >>> 24, re[z++] = (ge.compositionTimeOffset & 16711680) >>> 16, re[z++] = (ge.compositionTimeOffset & 65280) >>> 8, re[z++] = ge.compositionTimeOffset & 255;
      return o(j.trun, re);
    }, A = function(C, L) {
      var z, re, oe, fe, ge, we;
      for (fe = C.samples || [], L += 20 + 8 * fe.length, oe = k(fe, L), z = new Uint8Array(oe.length + fe.length * 8), z.set(oe), re = oe.length, we = 0; we < fe.length; we++)
        ge = fe[we], z[re++] = (ge.duration & 4278190080) >>> 24, z[re++] = (ge.duration & 16711680) >>> 16, z[re++] = (ge.duration & 65280) >>> 8, z[re++] = ge.duration & 255, z[re++] = (ge.size & 4278190080) >>> 24, z[re++] = (ge.size & 16711680) >>> 16, z[re++] = (ge.size & 65280) >>> 8, z[re++] = ge.size & 255;
      return o(j.trun, z);
    }, $ = function(C, L) {
      return C.type === "audio" ? A(C, L) : x(C, L);
    };
  }();
  var he = {
    ftyp: d,
    mdat: l,
    moof: m,
    moov: g,
    initSegment: function(A) {
      var x = d(), k = g(A), C;
      return C = new Uint8Array(x.byteLength + k.byteLength), C.set(x), C.set(k, x.byteLength), C;
    }
  }, Ee = function(A) {
    var x, k, C = [], L = [];
    for (L.byteLength = 0, L.nalCount = 0, L.duration = 0, C.byteLength = 0, x = 0; x < A.length; x++)
      k = A[x], k.nalUnitType === "access_unit_delimiter_rbsp" ? (C.length && (C.duration = k.dts - C.dts, L.byteLength += C.byteLength, L.nalCount += C.length, L.duration += C.duration, L.push(C)), C = [k], C.byteLength = k.data.byteLength, C.pts = k.pts, C.dts = k.dts) : (k.nalUnitType === "slice_layer_without_partitioning_rbsp_idr" && (C.keyFrame = !0), C.duration = k.dts - C.dts, C.byteLength += k.data.byteLength, C.push(k));
    return L.length && (!C.duration || C.duration <= 0) && (C.duration = L[L.length - 1].duration), L.byteLength += C.byteLength, L.nalCount += C.length, L.duration += C.duration, L.push(C), L;
  }, be = function(A) {
    var x, k, C = [], L = [];
    for (C.byteLength = 0, C.nalCount = 0, C.duration = 0, C.pts = A[0].pts, C.dts = A[0].dts, L.byteLength = 0, L.nalCount = 0, L.duration = 0, L.pts = A[0].pts, L.dts = A[0].dts, x = 0; x < A.length; x++)
      k = A[x], k.keyFrame ? (C.length && (L.push(C), L.byteLength += C.byteLength, L.nalCount += C.nalCount, L.duration += C.duration), C = [k], C.nalCount = k.length, C.byteLength = k.byteLength, C.pts = k.pts, C.dts = k.dts, C.duration = k.duration) : (C.duration += k.duration, C.nalCount += k.length, C.byteLength += k.byteLength, C.push(k));
    return L.length && C.duration <= 0 && (C.duration = L[L.length - 1].duration), L.byteLength += C.byteLength, L.nalCount += C.nalCount, L.duration += C.duration, L.push(C), L;
  }, ve = function(A) {
    var x;
    return !A[0][0].keyFrame && A.length > 1 && (x = A.shift(), A.byteLength -= x.byteLength, A.nalCount -= x.nalCount, A[0][0].dts = x.dts, A[0][0].pts = x.pts, A[0][0].duration += x.duration), A;
  }, Ce = function() {
    return {
      size: 0,
      flags: {
        isLeading: 0,
        dependsOn: 1,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradationPriority: 0,
        isNonSyncSample: 1
      }
    };
  }, Ne = function(A, x) {
    var k = Ce();
    return k.dataOffset = x, k.compositionTimeOffset = A.pts - A.dts, k.duration = A.duration, k.size = 4 * A.length, k.size += A.byteLength, A.keyFrame && (k.flags.dependsOn = 2, k.flags.isNonSyncSample = 0), k;
  }, qe = function(A, x) {
    var k, C, L, z, re, oe = x || 0, fe = [];
    for (k = 0; k < A.length; k++)
      for (z = A[k], C = 0; C < z.length; C++)
        re = z[C], L = Ne(re, oe), oe += L.size, fe.push(L);
    return fe;
  }, $e = function(A) {
    var x, k, C, L, z, re, oe = 0, fe = A.byteLength, ge = A.nalCount, we = fe + 4 * ge, Pe = new Uint8Array(we), dt = new DataView(Pe.buffer);
    for (x = 0; x < A.length; x++)
      for (L = A[x], k = 0; k < L.length; k++)
        for (z = L[k], C = 0; C < z.length; C++)
          re = z[C], dt.setUint32(oe, re.data.byteLength), oe += 4, Pe.set(re.data, oe), oe += re.data.byteLength;
    return Pe;
  }, Xe = function(A, x) {
    var k, C = x || 0, L = [];
    return k = Ne(A, C), L.push(k), L;
  }, at = function(A) {
    var x, k, C = 0, L = A.byteLength, z = A.length, re = L + 4 * z, oe = new Uint8Array(re), fe = new DataView(oe.buffer);
    for (x = 0; x < A.length; x++)
      k = A[x], fe.setUint32(C, k.data.byteLength), C += 4, oe.set(k.data, C), C += k.data.byteLength;
    return oe;
  }, Ie = {
    groupNalsIntoFrames: Ee,
    groupFramesIntoGops: be,
    extendFirstKeyFrame: ve,
    generateSampleTable: qe,
    concatenateNalData: $e,
    generateSampleTableForFrame: Xe,
    concatenateNalDataForFrame: at
  }, ne = [33, 16, 5, 32, 164, 27], ue = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], ie = function(A) {
    for (var x = []; A--; )
      x.push(0);
    return x;
  }, Te = function(A) {
    return Object.keys(A).reduce(function(x, k) {
      return x[k] = new Uint8Array(A[k].reduce(function(C, L) {
        return C.concat(L);
      }, [])), x;
    }, {});
  }, je, We = function() {
    if (!je) {
      var A = {
        96e3: [ne, [227, 64], ie(154), [56]],
        88200: [ne, [231], ie(170), [56]],
        64e3: [ne, [248, 192], ie(240), [56]],
        48e3: [ne, [255, 192], ie(268), [55, 148, 128], ie(54), [112]],
        44100: [ne, [255, 192], ie(268), [55, 163, 128], ie(84), [112]],
        32e3: [ne, [255, 192], ie(268), [55, 234], ie(226), [112]],
        24e3: [ne, [255, 192], ie(268), [55, 255, 128], ie(268), [111, 112], ie(126), [224]],
        16e3: [ne, [255, 192], ie(268), [55, 255, 128], ie(268), [111, 255], ie(269), [223, 108], ie(195), [1, 192]],
        12e3: [ue, ie(268), [3, 127, 248], ie(268), [6, 255, 240], ie(268), [13, 255, 224], ie(268), [27, 253, 128], ie(259), [56]],
        11025: [ue, ie(268), [3, 127, 248], ie(268), [6, 255, 240], ie(268), [13, 255, 224], ie(268), [27, 255, 192], ie(268), [55, 175, 128], ie(108), [112]],
        8e3: [ue, ie(268), [3, 121, 16], ie(47), [7]]
      };
      je = Te(A);
    }
    return je;
  }, Qe = 9e4, xe, Be, At, xt, Rt, Xt, jt;
  xe = function(A) {
    return A * Qe;
  }, Be = function(A, x) {
    return A * x;
  }, At = function(A) {
    return A / Qe;
  }, xt = function(A, x) {
    return A / x;
  }, Rt = function(A, x) {
    return xe(xt(A, x));
  }, Xt = function(A, x) {
    return Be(At(A), x);
  }, jt = function(A, x, k) {
    return At(k ? A : A - x);
  };
  var Tt = {
    ONE_SECOND_IN_TS: Qe,
    secondsToVideoTs: xe,
    secondsToAudioTs: Be,
    videoTsToSeconds: At,
    audioTsToSeconds: xt,
    audioTsToVideoTs: Rt,
    videoTsToAudioTs: Xt,
    metadataTsToSeconds: jt
  }, bn = We, Ve = Tt, ut = function(A) {
    var x, k, C = 0;
    for (x = 0; x < A.length; x++)
      k = A[x], C += k.data.byteLength;
    return C;
  }, _t = function(A, x, k, C) {
    var L, z = 0, re = 0, oe = 0, fe = 0, ge, we, Pe;
    if (x.length && (L = Ve.audioTsToVideoTs(A.baseMediaDecodeTime, A.samplerate), z = Math.ceil(Ve.ONE_SECOND_IN_TS / (A.samplerate / 1024)), k && C && (re = L - Math.max(k, C), oe = Math.floor(re / z), fe = oe * z), !(oe < 1 || fe > Ve.ONE_SECOND_IN_TS / 2))) {
      for (ge = bn()[A.samplerate], ge || (ge = x[0].data), we = 0; we < oe; we++)
        Pe = x[0], x.splice(0, 0, {
          data: ge,
          dts: Pe.dts - z,
          pts: Pe.pts - z
        });
      return A.baseMediaDecodeTime -= Math.floor(Ve.videoTsToAudioTs(fe, A.samplerate)), fe;
    }
  }, zt = function(A, x, k) {
    return x.minSegmentDts >= k ? A : (x.minSegmentDts = 1 / 0, A.filter(function(C) {
      return C.dts >= k ? (x.minSegmentDts = Math.min(x.minSegmentDts, C.dts), x.minSegmentPts = x.minSegmentDts, !0) : !1;
    }));
  }, wn = function(A) {
    var x, k, C = [];
    for (x = 0; x < A.length; x++)
      k = A[x], C.push({
        size: k.data.byteLength,
        duration: 1024
        // For AAC audio, all samples contain 1024 samples
      });
    return C;
  }, Hn = function(A) {
    var x, k, C = 0, L = new Uint8Array(ut(A));
    for (x = 0; x < A.length; x++)
      k = A[x], L.set(k.data, C), C += k.data.byteLength;
    return L;
  }, jn = {
    prefixWithSilence: _t,
    trimAdtsFramesByEarliestDts: zt,
    generateSampleTable: wn,
    concatenateFrameData: Hn
  }, Y = Tt.ONE_SECOND_IN_TS, J = function(A, x) {
    typeof x.pts == "number" && (A.timelineStartInfo.pts === void 0 && (A.timelineStartInfo.pts = x.pts), A.minSegmentPts === void 0 ? A.minSegmentPts = x.pts : A.minSegmentPts = Math.min(A.minSegmentPts, x.pts), A.maxSegmentPts === void 0 ? A.maxSegmentPts = x.pts : A.maxSegmentPts = Math.max(A.maxSegmentPts, x.pts)), typeof x.dts == "number" && (A.timelineStartInfo.dts === void 0 && (A.timelineStartInfo.dts = x.dts), A.minSegmentDts === void 0 ? A.minSegmentDts = x.dts : A.minSegmentDts = Math.min(A.minSegmentDts, x.dts), A.maxSegmentDts === void 0 ? A.maxSegmentDts = x.dts : A.maxSegmentDts = Math.max(A.maxSegmentDts, x.dts));
  }, me = function(A) {
    delete A.minSegmentDts, delete A.maxSegmentDts, delete A.minSegmentPts, delete A.maxSegmentPts;
  }, Oe = function(A, x) {
    var k, C, L = A.minSegmentDts;
    return x || (L -= A.timelineStartInfo.dts), k = A.timelineStartInfo.baseMediaDecodeTime, k += L, k = Math.max(0, k), A.type === "audio" && (C = A.samplerate / Y, k *= C, k = Math.floor(k)), k;
  }, rt = {
    clearDtsInfo: me,
    calculateTrackBaseMediaDecodeTime: Oe,
    collectDtsInfo: J
  }, ht = 4, qt = 128, Bt = function(A) {
    for (var x = 0, k = {
      payloadType: -1,
      payloadSize: 0
    }, C = 0, L = 0; x < A.byteLength && A[x] !== qt; ) {
      for (; A[x] === 255; )
        C += 255, x++;
      for (C += A[x++]; A[x] === 255; )
        L += 255, x++;
      if (L += A[x++], !k.payload && C === ht) {
        var z = String.fromCharCode(A[x + 3], A[x + 4], A[x + 5], A[x + 6]);
        if (z === "GA94") {
          k.payloadType = C, k.payloadSize = L, k.payload = A.subarray(x, x + L);
          break;
        } else
          k.payload = void 0;
      }
      x += L, C = 0, L = 0;
    }
    return k;
  }, mr = function(A) {
    return A.payload[0] !== 181 || (A.payload[1] << 8 | A.payload[2]) !== 49 || String.fromCharCode(A.payload[3], A.payload[4], A.payload[5], A.payload[6]) !== "GA94" || A.payload[7] !== 3 ? null : A.payload.subarray(8, A.payload.length - 1);
  }, wr = function(A, x) {
    var k = [], C, L, z, re;
    if (!(x[0] & 64))
      return k;
    for (L = x[0] & 31, C = 0; C < L; C++)
      z = C * 3, re = {
        type: x[z + 2] & 3,
        pts: A
      }, x[z + 2] & 4 && (re.ccData = x[z + 3] << 8 | x[z + 4], k.push(re));
    return k;
  }, gn = function(A) {
    for (var x = A.byteLength, k = [], C = 1, L, z; C < x - 2; )
      A[C] === 0 && A[C + 1] === 0 && A[C + 2] === 3 ? (k.push(C + 2), C += 2) : C++;
    if (k.length === 0)
      return A;
    L = x - k.length, z = new Uint8Array(L);
    var re = 0;
    for (C = 0; C < L; re++, C++)
      re === k[0] && (re++, k.shift()), z[C] = A[re];
    return z;
  }, Kn = {
    parseSei: Bt,
    parseUserData: mr,
    parseCaptionPackets: wr,
    discardEmulationPreventionBytes: gn,
    USER_DATA_REGISTERED_ITU_T_T35: ht
  }, Rn = n, On = Kn, $t = function(A) {
    A = A || {}, $t.prototype.init.call(this), this.parse708captions_ = typeof A.parse708captions == "boolean" ? A.parse708captions : !0, this.captionPackets_ = [], this.ccStreams_ = [
      new Bn(0, 0),
      // eslint-disable-line no-use-before-define
      new Bn(0, 1),
      // eslint-disable-line no-use-before-define
      new Bn(1, 0),
      // eslint-disable-line no-use-before-define
      new Bn(1, 1)
      // eslint-disable-line no-use-before-define
    ], this.parse708captions_ && (this.cc708Stream_ = new rn({
      captionServices: A.captionServices
    })), this.reset(), this.ccStreams_.forEach(function(x) {
      x.on("data", this.trigger.bind(this, "data")), x.on("partialdone", this.trigger.bind(this, "partialdone")), x.on("done", this.trigger.bind(this, "done"));
    }, this), this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")), this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")), this.cc708Stream_.on("done", this.trigger.bind(this, "done")));
  };
  $t.prototype = new Rn(), $t.prototype.push = function(A) {
    var x, k, C;
    if (A.nalUnitType === "sei_rbsp" && (x = On.parseSei(A.escapedRBSP), !!x.payload && x.payloadType === On.USER_DATA_REGISTERED_ITU_T_T35 && (k = On.parseUserData(x), !!k))) {
      if (A.dts < this.latestDts_) {
        this.ignoreNextEqualDts_ = !0;
        return;
      } else if (A.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
        this.numSameDts_--, this.numSameDts_ || (this.ignoreNextEqualDts_ = !1);
        return;
      }
      C = On.parseCaptionPackets(A.pts, k), this.captionPackets_ = this.captionPackets_.concat(C), this.latestDts_ !== A.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = A.dts;
    }
  }, $t.prototype.flushCCStreams = function(A) {
    this.ccStreams_.forEach(function(x) {
      return A === "flush" ? x.flush() : x.partialFlush();
    }, this);
  }, $t.prototype.flushStream = function(A) {
    if (!this.captionPackets_.length) {
      this.flushCCStreams(A);
      return;
    }
    this.captionPackets_.forEach(function(x, k) {
      x.presortIndex = k;
    }), this.captionPackets_.sort(function(x, k) {
      return x.pts === k.pts ? x.presortIndex - k.presortIndex : x.pts - k.pts;
    }), this.captionPackets_.forEach(function(x) {
      x.type < 2 ? this.dispatchCea608Packet(x) : this.dispatchCea708Packet(x);
    }, this), this.captionPackets_.length = 0, this.flushCCStreams(A);
  }, $t.prototype.flush = function() {
    return this.flushStream("flush");
  }, $t.prototype.partialFlush = function() {
    return this.flushStream("partialFlush");
  }, $t.prototype.reset = function() {
    this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach(function(A) {
      A.reset();
    });
  }, $t.prototype.dispatchCea608Packet = function(A) {
    this.setsTextOrXDSActive(A) ? this.activeCea608Channel_[A.type] = null : this.setsChannel1Active(A) ? this.activeCea608Channel_[A.type] = 0 : this.setsChannel2Active(A) && (this.activeCea608Channel_[A.type] = 1), this.activeCea608Channel_[A.type] !== null && this.ccStreams_[(A.type << 1) + this.activeCea608Channel_[A.type]].push(A);
  }, $t.prototype.setsChannel1Active = function(A) {
    return (A.ccData & 30720) === 4096;
  }, $t.prototype.setsChannel2Active = function(A) {
    return (A.ccData & 30720) === 6144;
  }, $t.prototype.setsTextOrXDSActive = function(A) {
    return (A.ccData & 28928) === 256 || (A.ccData & 30974) === 4138 || (A.ccData & 30974) === 6186;
  }, $t.prototype.dispatchCea708Packet = function(A) {
    this.parse708captions_ && this.cc708Stream_.push(A);
  };
  var ur = {
    127: 9834,
    // ♪
    4128: 32,
    // Transparent Space
    4129: 160,
    // Nob-breaking Transparent Space
    4133: 8230,
    // …
    4138: 352,
    // Š
    4140: 338,
    // Œ
    4144: 9608,
    // █
    4145: 8216,
    // ‘
    4146: 8217,
    // ’
    4147: 8220,
    // “
    4148: 8221,
    // ”
    4149: 8226,
    // •
    4153: 8482,
    // ™
    4154: 353,
    // š
    4156: 339,
    // œ
    4157: 8480,
    // ℠
    4159: 376,
    // Ÿ
    4214: 8539,
    // ⅛
    4215: 8540,
    // ⅜
    4216: 8541,
    // ⅝
    4217: 8542,
    // ⅞
    4218: 9168,
    // ⏐
    4219: 9124,
    // ⎤
    4220: 9123,
    // ⎣
    4221: 9135,
    // ⎯
    4222: 9126,
    // ⎦
    4223: 9121,
    // ⎡
    4256: 12600
    // ㄸ (CC char)
  }, Or = function(A) {
    var x = ur[A] || A;
    return A & 4096 && A === x ? "" : String.fromCharCode(x);
  }, Nn = function(A) {
    return 32 <= A && A <= 127 || 160 <= A && A <= 255;
  }, Nr = function(A) {
    this.windowNum = A, this.reset();
  };
  Nr.prototype.reset = function() {
    this.clearText(), this.pendingNewLine = !1, this.winAttr = {}, this.penAttr = {}, this.penLoc = {}, this.penColor = {}, this.visible = 0, this.rowLock = 0, this.columnLock = 0, this.priority = 0, this.relativePositioning = 0, this.anchorVertical = 0, this.anchorHorizontal = 0, this.anchorPoint = 0, this.rowCount = 1, this.virtualRowCount = this.rowCount + 1, this.columnCount = 41, this.windowStyle = 0, this.penStyle = 0;
  }, Nr.prototype.getText = function() {
    return this.rows.join(`
`);
  }, Nr.prototype.clearText = function() {
    this.rows = [""], this.rowIdx = 0;
  }, Nr.prototype.newLine = function(A) {
    for (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow == "function" && this.beforeRowOverflow(A), this.rows.length > 0 && (this.rows.push(""), this.rowIdx++); this.rows.length > this.virtualRowCount; )
      this.rows.shift(), this.rowIdx--;
  }, Nr.prototype.isEmpty = function() {
    return this.rows.length === 0 ? !0 : this.rows.length === 1 ? this.rows[0] === "" : !1;
  }, Nr.prototype.addText = function(A) {
    this.rows[this.rowIdx] += A;
  }, Nr.prototype.backspace = function() {
    if (!this.isEmpty()) {
      var A = this.rows[this.rowIdx];
      this.rows[this.rowIdx] = A.substr(0, A.length - 1);
    }
  };
  var ii = function(A, x, k) {
    this.serviceNum = A, this.text = "", this.currentWindow = new Nr(-1), this.windows = [], this.stream = k, typeof x == "string" && this.createTextDecoder(x);
  };
  ii.prototype.init = function(A, x) {
    this.startPts = A;
    for (var k = 0; k < 8; k++)
      this.windows[k] = new Nr(k), typeof x == "function" && (this.windows[k].beforeRowOverflow = x);
  }, ii.prototype.setCurrentWindow = function(A) {
    this.currentWindow = this.windows[A];
  }, ii.prototype.createTextDecoder = function(A) {
    if (typeof TextDecoder > "u")
      this.stream.trigger("log", {
        level: "warn",
        message: "The `encoding` option is unsupported without TextDecoder support"
      });
    else
      try {
        this.textDecoder_ = new TextDecoder(A);
      } catch (x) {
        this.stream.trigger("log", {
          level: "warn",
          message: "TextDecoder could not be created with " + A + " encoding. " + x
        });
      }
  };
  var rn = function(A) {
    A = A || {}, rn.prototype.init.call(this);
    var x = this, k = A.captionServices || {}, C = {}, L;
    Object.keys(k).forEach((z) => {
      L = k[z], /^SERVICE/.test(z) && (C[z] = L.encoding);
    }), this.serviceEncodings = C, this.current708Packet = null, this.services = {}, this.push = function(z) {
      z.type === 3 ? (x.new708Packet(), x.add708Bytes(z)) : (x.current708Packet === null && x.new708Packet(), x.add708Bytes(z));
    };
  };
  rn.prototype = new Rn(), rn.prototype.new708Packet = function() {
    this.current708Packet !== null && this.push708Packet(), this.current708Packet = {
      data: [],
      ptsVals: []
    };
  }, rn.prototype.add708Bytes = function(A) {
    var x = A.ccData, k = x >>> 8, C = x & 255;
    this.current708Packet.ptsVals.push(A.pts), this.current708Packet.data.push(k), this.current708Packet.data.push(C);
  }, rn.prototype.push708Packet = function() {
    var A = this.current708Packet, x = A.data, k = null, C = null, L = 0, z = x[L++];
    for (A.seq = z >> 6, A.sizeCode = z & 63; L < x.length; L++)
      z = x[L++], k = z >> 5, C = z & 31, k === 7 && C > 0 && (z = x[L++], k = z), this.pushServiceBlock(k, L, C), C > 0 && (L += C - 1);
  }, rn.prototype.pushServiceBlock = function(A, x, k) {
    var C, L = x, z = this.current708Packet.data, re = this.services[A];
    for (re || (re = this.initService(A, L)); L < x + k && L < z.length; L++)
      C = z[L], Nn(C) ? L = this.handleText(L, re) : C === 24 ? L = this.multiByteCharacter(L, re) : C === 16 ? L = this.extendedCommands(L, re) : 128 <= C && C <= 135 ? L = this.setCurrentWindow(L, re) : 152 <= C && C <= 159 ? L = this.defineWindow(L, re) : C === 136 ? L = this.clearWindows(L, re) : C === 140 ? L = this.deleteWindows(L, re) : C === 137 ? L = this.displayWindows(L, re) : C === 138 ? L = this.hideWindows(L, re) : C === 139 ? L = this.toggleWindows(L, re) : C === 151 ? L = this.setWindowAttributes(L, re) : C === 144 ? L = this.setPenAttributes(L, re) : C === 145 ? L = this.setPenColor(L, re) : C === 146 ? L = this.setPenLocation(L, re) : C === 143 ? re = this.reset(L, re) : C === 8 ? re.currentWindow.backspace() : C === 12 ? re.currentWindow.clearText() : C === 13 ? re.currentWindow.pendingNewLine = !0 : C === 14 ? re.currentWindow.clearText() : C === 141 && L++;
  }, rn.prototype.extendedCommands = function(A, x) {
    var k = this.current708Packet.data, C = k[++A];
    return Nn(C) && (A = this.handleText(A, x, {
      isExtended: !0
    })), A;
  }, rn.prototype.getPts = function(A) {
    return this.current708Packet.ptsVals[Math.floor(A / 2)];
  }, rn.prototype.initService = function(A, x) {
    var C = "SERVICE" + A, k = this, C, L;
    return C in this.serviceEncodings && (L = this.serviceEncodings[C]), this.services[A] = new ii(A, L, k), this.services[A].init(this.getPts(x), function(z) {
      k.flushDisplayed(z, k.services[A]);
    }), this.services[A];
  }, rn.prototype.handleText = function(A, x, k) {
    var C = k && k.isExtended, L = k && k.isMultiByte, z = this.current708Packet.data, re = C ? 4096 : 0, oe = z[A], fe = z[A + 1], ge = x.currentWindow, we, Pe;
    function dt(ze) {
      return ze.map((St) => ("0" + (St & 255).toString(16)).slice(-2)).join("");
    }
    if (L ? (Pe = [oe, fe], A++) : Pe = [oe], x.textDecoder_ && !C)
      we = x.textDecoder_.decode(new Uint8Array(Pe));
    else if (L) {
      const ze = dt(Pe);
      we = String.fromCharCode(parseInt(ze, 16));
    } else
      we = Or(re | oe);
    return ge.pendingNewLine && !ge.isEmpty() && ge.newLine(this.getPts(A)), ge.pendingNewLine = !1, ge.addText(we), A;
  }, rn.prototype.multiByteCharacter = function(A, x) {
    var k = this.current708Packet.data, C = k[A + 1], L = k[A + 2];
    return Nn(C) && Nn(L) && (A = this.handleText(++A, x, {
      isMultiByte: !0
    })), A;
  }, rn.prototype.setCurrentWindow = function(A, x) {
    var k = this.current708Packet.data, C = k[A], L = C & 7;
    return x.setCurrentWindow(L), A;
  }, rn.prototype.defineWindow = function(A, x) {
    var k = this.current708Packet.data, C = k[A], L = C & 7;
    x.setCurrentWindow(L);
    var z = x.currentWindow;
    return C = k[++A], z.visible = (C & 32) >> 5, z.rowLock = (C & 16) >> 4, z.columnLock = (C & 8) >> 3, z.priority = C & 7, C = k[++A], z.relativePositioning = (C & 128) >> 7, z.anchorVertical = C & 127, C = k[++A], z.anchorHorizontal = C, C = k[++A], z.anchorPoint = (C & 240) >> 4, z.rowCount = C & 15, C = k[++A], z.columnCount = C & 63, C = k[++A], z.windowStyle = (C & 56) >> 3, z.penStyle = C & 7, z.virtualRowCount = z.rowCount + 1, A;
  }, rn.prototype.setWindowAttributes = function(A, x) {
    var k = this.current708Packet.data, C = k[A], L = x.currentWindow.winAttr;
    return C = k[++A], L.fillOpacity = (C & 192) >> 6, L.fillRed = (C & 48) >> 4, L.fillGreen = (C & 12) >> 2, L.fillBlue = C & 3, C = k[++A], L.borderType = (C & 192) >> 6, L.borderRed = (C & 48) >> 4, L.borderGreen = (C & 12) >> 2, L.borderBlue = C & 3, C = k[++A], L.borderType += (C & 128) >> 5, L.wordWrap = (C & 64) >> 6, L.printDirection = (C & 48) >> 4, L.scrollDirection = (C & 12) >> 2, L.justify = C & 3, C = k[++A], L.effectSpeed = (C & 240) >> 4, L.effectDirection = (C & 12) >> 2, L.displayEffect = C & 3, A;
  }, rn.prototype.flushDisplayed = function(A, x) {
    for (var k = [], C = 0; C < 8; C++)
      x.windows[C].visible && !x.windows[C].isEmpty() && k.push(x.windows[C].getText());
    x.endPts = A, x.text = k.join(`

`), this.pushCaption(x), x.startPts = A;
  }, rn.prototype.pushCaption = function(A) {
    A.text !== "" && (this.trigger("data", {
      startPts: A.startPts,
      endPts: A.endPts,
      text: A.text,
      stream: "cc708_" + A.serviceNum
    }), A.text = "", A.startPts = A.endPts);
  }, rn.prototype.displayWindows = function(A, x) {
    var k = this.current708Packet.data, C = k[++A], L = this.getPts(A);
    this.flushDisplayed(L, x);
    for (var z = 0; z < 8; z++)
      C & 1 << z && (x.windows[z].visible = 1);
    return A;
  }, rn.prototype.hideWindows = function(A, x) {
    var k = this.current708Packet.data, C = k[++A], L = this.getPts(A);
    this.flushDisplayed(L, x);
    for (var z = 0; z < 8; z++)
      C & 1 << z && (x.windows[z].visible = 0);
    return A;
  }, rn.prototype.toggleWindows = function(A, x) {
    var k = this.current708Packet.data, C = k[++A], L = this.getPts(A);
    this.flushDisplayed(L, x);
    for (var z = 0; z < 8; z++)
      C & 1 << z && (x.windows[z].visible ^= 1);
    return A;
  }, rn.prototype.clearWindows = function(A, x) {
    var k = this.current708Packet.data, C = k[++A], L = this.getPts(A);
    this.flushDisplayed(L, x);
    for (var z = 0; z < 8; z++)
      C & 1 << z && x.windows[z].clearText();
    return A;
  }, rn.prototype.deleteWindows = function(A, x) {
    var k = this.current708Packet.data, C = k[++A], L = this.getPts(A);
    this.flushDisplayed(L, x);
    for (var z = 0; z < 8; z++)
      C & 1 << z && x.windows[z].reset();
    return A;
  }, rn.prototype.setPenAttributes = function(A, x) {
    var k = this.current708Packet.data, C = k[A], L = x.currentWindow.penAttr;
    return C = k[++A], L.textTag = (C & 240) >> 4, L.offset = (C & 12) >> 2, L.penSize = C & 3, C = k[++A], L.italics = (C & 128) >> 7, L.underline = (C & 64) >> 6, L.edgeType = (C & 56) >> 3, L.fontStyle = C & 7, A;
  }, rn.prototype.setPenColor = function(A, x) {
    var k = this.current708Packet.data, C = k[A], L = x.currentWindow.penColor;
    return C = k[++A], L.fgOpacity = (C & 192) >> 6, L.fgRed = (C & 48) >> 4, L.fgGreen = (C & 12) >> 2, L.fgBlue = C & 3, C = k[++A], L.bgOpacity = (C & 192) >> 6, L.bgRed = (C & 48) >> 4, L.bgGreen = (C & 12) >> 2, L.bgBlue = C & 3, C = k[++A], L.edgeRed = (C & 48) >> 4, L.edgeGreen = (C & 12) >> 2, L.edgeBlue = C & 3, A;
  }, rn.prototype.setPenLocation = function(A, x) {
    var k = this.current708Packet.data, C = k[A], L = x.currentWindow.penLoc;
    return x.currentWindow.pendingNewLine = !0, C = k[++A], L.row = C & 15, C = k[++A], L.column = C & 63, A;
  }, rn.prototype.reset = function(A, x) {
    var k = this.getPts(A);
    return this.flushDisplayed(k, x), this.initService(x.serviceNum, A);
  };
  var s1 = {
    42: 225,
    // á
    92: 233,
    // é
    94: 237,
    // í
    95: 243,
    // ó
    96: 250,
    // ú
    123: 231,
    // ç
    124: 247,
    // ÷
    125: 209,
    // Ñ
    126: 241,
    // ñ
    127: 9608,
    // █
    304: 174,
    // ®
    305: 176,
    // °
    306: 189,
    // ½
    307: 191,
    // ¿
    308: 8482,
    // ™
    309: 162,
    // ¢
    310: 163,
    // £
    311: 9834,
    // ♪
    312: 224,
    // à
    313: 160,
    //
    314: 232,
    // è
    315: 226,
    // â
    316: 234,
    // ê
    317: 238,
    // î
    318: 244,
    // ô
    319: 251,
    // û
    544: 193,
    // Á
    545: 201,
    // É
    546: 211,
    // Ó
    547: 218,
    // Ú
    548: 220,
    // Ü
    549: 252,
    // ü
    550: 8216,
    // ‘
    551: 161,
    // ¡
    552: 42,
    // *
    553: 39,
    // '
    554: 8212,
    // —
    555: 169,
    // ©
    556: 8480,
    // ℠
    557: 8226,
    // •
    558: 8220,
    // “
    559: 8221,
    // ”
    560: 192,
    // À
    561: 194,
    // Â
    562: 199,
    // Ç
    563: 200,
    // È
    564: 202,
    // Ê
    565: 203,
    // Ë
    566: 235,
    // ë
    567: 206,
    // Î
    568: 207,
    // Ï
    569: 239,
    // ï
    570: 212,
    // Ô
    571: 217,
    // Ù
    572: 249,
    // ù
    573: 219,
    // Û
    574: 171,
    // «
    575: 187,
    // »
    800: 195,
    // Ã
    801: 227,
    // ã
    802: 205,
    // Í
    803: 204,
    // Ì
    804: 236,
    // ì
    805: 210,
    // Ò
    806: 242,
    // ò
    807: 213,
    // Õ
    808: 245,
    // õ
    809: 123,
    // {
    810: 125,
    // }
    811: 92,
    // \
    812: 94,
    // ^
    813: 95,
    // _
    814: 124,
    // |
    815: 126,
    // ~
    816: 196,
    // Ä
    817: 228,
    // ä
    818: 214,
    // Ö
    819: 246,
    // ö
    820: 223,
    // ß
    821: 165,
    // ¥
    822: 164,
    // ¤
    823: 9474,
    // │
    824: 197,
    // Å
    825: 229,
    // å
    826: 216,
    // Ø
    827: 248,
    // ø
    828: 9484,
    // ┌
    829: 9488,
    // ┐
    830: 9492,
    // └
    831: 9496
    // ┘
  }, il = function(A) {
    return A === null ? "" : (A = s1[A] || A, String.fromCharCode(A));
  }, sl = 14, a1 = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152], ya = function() {
    for (var A = [], x = sl + 1; x--; )
      A.push({
        text: "",
        indent: 0,
        offset: 0
      });
    return A;
  }, Bn = function(A, x) {
    Bn.prototype.init.call(this), this.field_ = A || 0, this.dataChannel_ = x || 0, this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1), this.setConstants(), this.reset(), this.push = function(k) {
      var C, L, z, re, oe;
      if (C = k.ccData & 32639, C === this.lastControlCode_) {
        this.lastControlCode_ = null;
        return;
      }
      if ((C & 61440) === 4096 ? this.lastControlCode_ = C : C !== this.PADDING_ && (this.lastControlCode_ = null), z = C >>> 8, re = C & 255, C !== this.PADDING_)
        if (C === this.RESUME_CAPTION_LOADING_)
          this.mode_ = "popOn";
        else if (C === this.END_OF_CAPTION_)
          this.mode_ = "popOn", this.clearFormatting(k.pts), this.flushDisplayed(k.pts), L = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = L, this.startPts_ = k.pts;
        else if (C === this.ROLL_UP_2_ROWS_)
          this.rollUpRows_ = 2, this.setRollUp(k.pts);
        else if (C === this.ROLL_UP_3_ROWS_)
          this.rollUpRows_ = 3, this.setRollUp(k.pts);
        else if (C === this.ROLL_UP_4_ROWS_)
          this.rollUpRows_ = 4, this.setRollUp(k.pts);
        else if (C === this.CARRIAGE_RETURN_)
          this.clearFormatting(k.pts), this.flushDisplayed(k.pts), this.shiftRowsUp_(), this.startPts_ = k.pts;
        else if (C === this.BACKSPACE_)
          this.mode_ === "popOn" ? this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1) : this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
        else if (C === this.ERASE_DISPLAYED_MEMORY_)
          this.flushDisplayed(k.pts), this.displayed_ = ya();
        else if (C === this.ERASE_NON_DISPLAYED_MEMORY_)
          this.nonDisplayed_ = ya();
        else if (C === this.RESUME_DIRECT_CAPTIONING_)
          this.mode_ !== "paintOn" && (this.flushDisplayed(k.pts), this.displayed_ = ya()), this.mode_ = "paintOn", this.startPts_ = k.pts;
        else if (this.isSpecialCharacter(z, re))
          z = (z & 3) << 8, oe = il(z | re), this[this.mode_](k.pts, oe), this.column_++;
        else if (this.isExtCharacter(z, re))
          this.mode_ === "popOn" ? this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1) : this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1), z = (z & 3) << 8, oe = il(z | re), this[this.mode_](k.pts, oe), this.column_++;
        else if (this.isMidRowCode(z, re))
          this.clearFormatting(k.pts), this[this.mode_](k.pts, " "), this.column_++, (re & 14) === 14 && this.addFormatting(k.pts, ["i"]), (re & 1) === 1 && this.addFormatting(k.pts, ["u"]);
        else if (this.isOffsetControlCode(z, re)) {
          const ge = re & 3;
          this.nonDisplayed_[this.row_].offset = ge, this.column_ += ge;
        } else if (this.isPAC(z, re)) {
          var fe = a1.indexOf(C & 7968);
          if (this.mode_ === "rollUp" && (fe - this.rollUpRows_ + 1 < 0 && (fe = this.rollUpRows_ - 1), this.setRollUp(k.pts, fe)), fe !== this.row_ && fe >= 0 && fe <= 14 && (this.clearFormatting(k.pts), this.row_ = fe), re & 1 && this.formatting_.indexOf("u") === -1 && this.addFormatting(k.pts, ["u"]), (C & 16) === 16) {
            const ge = (C & 14) >> 1;
            this.column_ = ge * 4, this.nonDisplayed_[this.row_].indent += ge;
          }
          this.isColorPAC(re) && (re & 14) === 14 && this.addFormatting(k.pts, ["i"]);
        } else this.isNormalChar(z) && (re === 0 && (re = null), oe = il(z), oe += il(re), this[this.mode_](k.pts, oe), this.column_ += oe.length);
    };
  };
  Bn.prototype = new Rn(), Bn.prototype.flushDisplayed = function(A) {
    const x = (C) => {
      this.trigger("log", {
        level: "warn",
        message: "Skipping a malformed 608 caption at index " + C + "."
      });
    }, k = [];
    this.displayed_.forEach((C, L) => {
      if (C && C.text && C.text.length) {
        try {
          C.text = C.text.trim();
        } catch {
          x(L);
        }
        C.text.length && k.push({
          // The text to be displayed in the caption from this specific row, with whitespace removed.
          text: C.text,
          // Value between 1 and 15 representing the PAC row used to calculate line height.
          line: L + 1,
          // A number representing the indent position by percentage (CEA-608 PAC indent code).
          // The value will be a number between 10 and 80. Offset is used to add an aditional
          // value to the position if necessary.
          position: 10 + Math.min(70, C.indent * 10) + C.offset * 2.5
        });
      } else C == null && x(L);
    }), k.length && this.trigger("data", {
      startPts: this.startPts_,
      endPts: A,
      content: k,
      stream: this.name_
    });
  }, Bn.prototype.reset = function() {
    this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = ya(), this.nonDisplayed_ = ya(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = sl, this.rollUpRows_ = 2, this.formatting_ = [];
  }, Bn.prototype.setConstants = function() {
    this.dataChannel_ === 0 ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : this.dataChannel_ === 1 && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32, this.END_OF_CAPTION_ = this.CONTROL_ | 47, this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37, this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38, this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39, this.CARRIAGE_RETURN_ = this.CONTROL_ | 45, this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41, this.BACKSPACE_ = this.CONTROL_ | 33, this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44, this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
  }, Bn.prototype.isSpecialCharacter = function(A, x) {
    return A === this.EXT_ && x >= 48 && x <= 63;
  }, Bn.prototype.isExtCharacter = function(A, x) {
    return (A === this.EXT_ + 1 || A === this.EXT_ + 2) && x >= 32 && x <= 63;
  }, Bn.prototype.isMidRowCode = function(A, x) {
    return A === this.EXT_ && x >= 32 && x <= 47;
  }, Bn.prototype.isOffsetControlCode = function(A, x) {
    return A === this.OFFSET_ && x >= 33 && x <= 35;
  }, Bn.prototype.isPAC = function(A, x) {
    return A >= this.BASE_ && A < this.BASE_ + 8 && x >= 64 && x <= 127;
  }, Bn.prototype.isColorPAC = function(A) {
    return A >= 64 && A <= 79 || A >= 96 && A <= 127;
  }, Bn.prototype.isNormalChar = function(A) {
    return A >= 32 && A <= 127;
  }, Bn.prototype.setRollUp = function(A, x) {
    if (this.mode_ !== "rollUp" && (this.row_ = sl, this.mode_ = "rollUp", this.flushDisplayed(A), this.nonDisplayed_ = ya(), this.displayed_ = ya()), x !== void 0 && x !== this.row_)
      for (var k = 0; k < this.rollUpRows_; k++)
        this.displayed_[x - k] = this.displayed_[this.row_ - k], this.displayed_[this.row_ - k] = {
          text: "",
          indent: 0,
          offset: 0
        };
    x === void 0 && (x = this.row_), this.topRow_ = x - this.rollUpRows_ + 1;
  }, Bn.prototype.addFormatting = function(A, x) {
    this.formatting_ = this.formatting_.concat(x);
    var k = x.reduce(function(C, L) {
      return C + "<" + L + ">";
    }, "");
    this[this.mode_](A, k);
  }, Bn.prototype.clearFormatting = function(A) {
    if (this.formatting_.length) {
      var x = this.formatting_.reverse().reduce(function(k, C) {
        return k + "</" + C + ">";
      }, "");
      this.formatting_ = [], this[this.mode_](A, x);
    }
  }, Bn.prototype.popOn = function(A, x) {
    var k = this.nonDisplayed_[this.row_].text;
    k += x, this.nonDisplayed_[this.row_].text = k;
  }, Bn.prototype.rollUp = function(A, x) {
    var k = this.displayed_[this.row_].text;
    k += x, this.displayed_[this.row_].text = k;
  }, Bn.prototype.shiftRowsUp_ = function() {
    var A;
    for (A = 0; A < this.topRow_; A++)
      this.displayed_[A] = {
        text: "",
        indent: 0,
        offset: 0
      };
    for (A = this.row_ + 1; A < sl + 1; A++)
      this.displayed_[A] = {
        text: "",
        indent: 0,
        offset: 0
      };
    for (A = this.topRow_; A < this.row_; A++)
      this.displayed_[A] = this.displayed_[A + 1];
    this.displayed_[this.row_] = {
      text: "",
      indent: 0,
      offset: 0
    };
  }, Bn.prototype.paintOn = function(A, x) {
    var k = this.displayed_[this.row_].text;
    k += x, this.displayed_[this.row_].text = k;
  };
  var Fh = {
    CaptionStream: $t,
    Cea608Stream: Bn,
    Cea708Stream: rn
  }, al = {
    H264_STREAM_TYPE: 27,
    ADTS_STREAM_TYPE: 15,
    METADATA_STREAM_TYPE: 21
  }, o1 = n, va = 8589934592, u1 = 4294967296, Uh = "shared", id = function(A, x) {
    var k = 1;
    for (A > x && (k = -1); Math.abs(x - A) > u1; )
      A += k * va;
    return A;
  }, sd = function(A) {
    var x, k;
    sd.prototype.init.call(this), this.type_ = A || Uh, this.push = function(C) {
      if (C.type === "metadata") {
        this.trigger("data", C);
        return;
      }
      this.type_ !== Uh && C.type !== this.type_ || (k === void 0 && (k = C.dts), C.dts = id(C.dts, k), C.pts = id(C.pts, k), x = C.dts, this.trigger("data", C));
    }, this.flush = function() {
      k = x, this.trigger("done");
    }, this.endTimeline = function() {
      this.flush(), this.trigger("endedtimeline");
    }, this.discontinuity = function() {
      k = void 0, x = void 0;
    }, this.reset = function() {
      this.discontinuity(), this.trigger("reset");
    };
  };
  sd.prototype = new o1();
  var $h = {
    TimestampRolloverStream: sd,
    handleRollover: id
  }, l1 = (A, x, k) => {
    if (!A)
      return -1;
    for (var C = k; C < A.length; C++)
      if (A[C] === x)
        return C;
    return -1;
  }, c1 = {
    typedArrayIndexOf: l1
  }, ol = c1.typedArrayIndexOf, ul = {
    // UTF-16BE encoded Unicode, without BOM, terminated with \0\0
    Utf8: 3
    // UTF-8 encoded Unicode, terminated with \0
  }, Hh = function(A, x, k) {
    var C, L = "";
    for (C = x; C < k; C++)
      L += "%" + ("00" + A[C].toString(16)).slice(-2);
    return L;
  }, jo = function(A, x, k) {
    return decodeURIComponent(Hh(A, x, k));
  }, zo = function(A, x, k) {
    return unescape(Hh(A, x, k));
  }, qo = function(A) {
    return A[0] << 21 | A[1] << 14 | A[2] << 7 | A[3];
  }, Vo = {
    APIC: function(A) {
      var x = 1, k, C, L = "-->";
      A.data[0] === ul.Utf8 && (k = ol(A.data, 0, x), !(k < 0) && (A.mimeType = zo(A.data, x, k), x = k + 1, A.pictureType = A.data[x], x++, C = ol(A.data, 0, x), !(C < 0) && (A.description = jo(A.data, x, C), x = C + 1, A.mimeType === L ? A.url = zo(A.data, x, A.data.length) : A.pictureData = A.data.subarray(x, A.data.length))));
    },
    "T*": function(A) {
      A.data[0] === ul.Utf8 && (A.value = jo(A.data, 1, A.data.length).replace(/\0*$/, ""), A.values = A.value.split("\0"));
    },
    TXXX: function(A) {
      var x;
      A.data[0] === ul.Utf8 && (x = ol(A.data, 0, 1), x !== -1 && (A.description = jo(A.data, 1, x), A.value = jo(A.data, x + 1, A.data.length).replace(/\0*$/, ""), A.data = A.value));
    },
    "W*": function(A) {
      A.url = zo(A.data, 0, A.data.length).replace(/\0.*$/, "");
    },
    WXXX: function(A) {
      var x;
      A.data[0] === ul.Utf8 && (x = ol(A.data, 0, 1), x !== -1 && (A.description = jo(A.data, 1, x), A.url = zo(A.data, x + 1, A.data.length).replace(/\0.*$/, "")));
    },
    PRIV: function(A) {
      var x;
      for (x = 0; x < A.data.length; x++)
        if (A.data[x] === 0) {
          A.owner = zo(A.data, 0, x);
          break;
        }
      A.privateData = A.data.subarray(x + 1), A.data = A.privateData;
    }
  }, d1 = function(A) {
    var x, k, C = 10, L = 0, z = [];
    if (!(A.length < 10 || A[0] !== 73 || A[1] !== 68 || A[2] !== 51)) {
      L = qo(A.subarray(6, 10)), L += 10;
      var re = A[5] & 64;
      re && (C += 4, C += qo(A.subarray(10, 14)), L -= qo(A.subarray(16, 20)));
      do {
        if (x = qo(A.subarray(C + 4, C + 8)), x < 1)
          break;
        k = String.fromCharCode(A[C], A[C + 1], A[C + 2], A[C + 3]);
        var oe = {
          id: k,
          data: A.subarray(C + 10, C + x + 10)
        };
        oe.key = oe.id, Vo[oe.id] ? Vo[oe.id](oe) : oe.id[0] === "T" ? Vo["T*"](oe) : oe.id[0] === "W" && Vo["W*"](oe), z.push(oe), C += 10, C += x;
      } while (C < L);
      return z;
    }
  }, jh = {
    parseId3Frames: d1,
    parseSyncSafeInteger: qo,
    frameParsers: Vo
  }, f1 = n, h1 = al, zs = jh, Sn;
  Sn = function(A) {
    var x = {
      // the bytes of the program-level descriptor field in MP2T
      // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
      // program element descriptors"
      descriptor: A && A.descriptor
    }, k = 0, C = [], L = 0, z;
    if (Sn.prototype.init.call(this), this.dispatchType = h1.METADATA_STREAM_TYPE.toString(16), x.descriptor)
      for (z = 0; z < x.descriptor.length; z++)
        this.dispatchType += ("00" + x.descriptor[z].toString(16)).slice(-2);
    this.push = function(re) {
      var oe, fe, ge, we, Pe, dt;
      if (re.type === "timed-metadata") {
        if (re.dataAlignmentIndicator && (L = 0, C.length = 0), C.length === 0 && (re.data.length < 10 || re.data[0] !== 73 || re.data[1] !== 68 || re.data[2] !== 51)) {
          this.trigger("log", {
            level: "warn",
            message: "Skipping unrecognized metadata packet"
          });
          return;
        }
        if (C.push(re), L += re.data.byteLength, C.length === 1 && (k = zs.parseSyncSafeInteger(re.data.subarray(6, 10)), k += 10), !(L < k)) {
          for (oe = {
            data: new Uint8Array(k),
            frames: [],
            pts: C[0].pts,
            dts: C[0].dts
          }, Pe = 0; Pe < k; )
            oe.data.set(C[0].data.subarray(0, k - Pe), Pe), Pe += C[0].data.byteLength, L -= C[0].data.byteLength, C.shift();
          fe = 10, oe.data[5] & 64 && (fe += 4, fe += zs.parseSyncSafeInteger(oe.data.subarray(10, 14)), k -= zs.parseSyncSafeInteger(oe.data.subarray(16, 20)));
          do {
            if (ge = zs.parseSyncSafeInteger(oe.data.subarray(fe + 4, fe + 8)), ge < 1) {
              this.trigger("log", {
                level: "warn",
                message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
              });
              break;
            }
            if (dt = String.fromCharCode(oe.data[fe], oe.data[fe + 1], oe.data[fe + 2], oe.data[fe + 3]), we = {
              id: dt,
              data: oe.data.subarray(fe + 10, fe + ge + 10)
            }, we.key = we.id, zs.frameParsers[we.id] ? zs.frameParsers[we.id](we) : we.id[0] === "T" ? zs.frameParsers["T*"](we) : we.id[0] === "W" && zs.frameParsers["W*"](we), we.owner === "com.apple.streaming.transportStreamTimestamp") {
              var ze = we.data, St = (ze[3] & 1) << 30 | ze[4] << 22 | ze[5] << 14 | ze[6] << 6 | ze[7] >>> 2;
              St *= 4, St += ze[7] & 3, we.timeStamp = St, oe.pts === void 0 && oe.dts === void 0 && (oe.pts = we.timeStamp, oe.dts = we.timeStamp), this.trigger("timestamp", we);
            }
            oe.frames.push(we), fe += 10, fe += ge;
          } while (fe < k);
          this.trigger("data", oe);
        }
      }
    };
  }, Sn.prototype = new f1();
  var p1 = Sn, ll = n, ad = Fh, Ur = al, od = $h.TimestampRolloverStream, cl, Wo, dl, Xa = 188, Qo = 71;
  cl = function() {
    var A = new Uint8Array(Xa), x = 0;
    cl.prototype.init.call(this), this.push = function(k) {
      var C = 0, L = Xa, z;
      for (x ? (z = new Uint8Array(k.byteLength + x), z.set(A.subarray(0, x)), z.set(k, x), x = 0) : z = k; L < z.byteLength; ) {
        if (z[C] === Qo && z[L] === Qo) {
          this.trigger("data", z.subarray(C, L)), C += Xa, L += Xa;
          continue;
        }
        C++, L++;
      }
      C < z.byteLength && (A.set(z.subarray(C), 0), x = z.byteLength - C);
    }, this.flush = function() {
      x === Xa && A[0] === Qo && (this.trigger("data", A), x = 0), this.trigger("done");
    }, this.endTimeline = function() {
      this.flush(), this.trigger("endedtimeline");
    }, this.reset = function() {
      x = 0, this.trigger("reset");
    };
  }, cl.prototype = new ll(), Wo = function() {
    var A, x, k, C;
    Wo.prototype.init.call(this), C = this, this.packetsWaitingForPmt = [], this.programMapTable = void 0, A = function(L, z) {
      var re = 0;
      z.payloadUnitStartIndicator && (re += L[re] + 1), z.type === "pat" ? x(L.subarray(re), z) : k(L.subarray(re), z);
    }, x = function(L, z) {
      z.section_number = L[7], z.last_section_number = L[8], C.pmtPid = (L[10] & 31) << 8 | L[11], z.pmtPid = C.pmtPid;
    }, k = function(L, z) {
      var re, oe, fe, ge;
      if (L[5] & 1) {
        for (C.programMapTable = {
          video: null,
          audio: null,
          "timed-metadata": {}
        }, re = (L[1] & 15) << 8 | L[2], oe = 3 + re - 4, fe = (L[10] & 15) << 8 | L[11], ge = 12 + fe; ge < oe; ) {
          var we = L[ge], Pe = (L[ge + 1] & 31) << 8 | L[ge + 2];
          we === Ur.H264_STREAM_TYPE && C.programMapTable.video === null ? C.programMapTable.video = Pe : we === Ur.ADTS_STREAM_TYPE && C.programMapTable.audio === null ? C.programMapTable.audio = Pe : we === Ur.METADATA_STREAM_TYPE && (C.programMapTable["timed-metadata"][Pe] = we), ge += ((L[ge + 3] & 15) << 8 | L[ge + 4]) + 5;
        }
        z.programMapTable = C.programMapTable;
      }
    }, this.push = function(L) {
      var z = {}, re = 4;
      if (z.payloadUnitStartIndicator = !!(L[1] & 64), z.pid = L[1] & 31, z.pid <<= 8, z.pid |= L[2], (L[3] & 48) >>> 4 > 1 && (re += L[re] + 1), z.pid === 0)
        z.type = "pat", A(L.subarray(re), z), this.trigger("data", z);
      else if (z.pid === this.pmtPid)
        for (z.type = "pmt", A(L.subarray(re), z), this.trigger("data", z); this.packetsWaitingForPmt.length; )
          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
      else this.programMapTable === void 0 ? this.packetsWaitingForPmt.push([L, re, z]) : this.processPes_(L, re, z);
    }, this.processPes_ = function(L, z, re) {
      re.pid === this.programMapTable.video ? re.streamType = Ur.H264_STREAM_TYPE : re.pid === this.programMapTable.audio ? re.streamType = Ur.ADTS_STREAM_TYPE : re.streamType = this.programMapTable["timed-metadata"][re.pid], re.type = "pes", re.data = L.subarray(z), this.trigger("data", re);
    };
  }, Wo.prototype = new ll(), Wo.STREAM_TYPES = {
    h264: 27,
    adts: 15
  }, dl = function() {
    var A = this, x = !1, k = {
      data: [],
      size: 0
    }, C = {
      data: [],
      size: 0
    }, L = {
      data: [],
      size: 0
    }, z, re = function(fe, ge) {
      var we;
      const Pe = fe[0] << 16 | fe[1] << 8 | fe[2];
      ge.data = new Uint8Array(), Pe === 1 && (ge.packetLength = 6 + (fe[4] << 8 | fe[5]), ge.dataAlignmentIndicator = (fe[6] & 4) !== 0, we = fe[7], we & 192 && (ge.pts = (fe[9] & 14) << 27 | (fe[10] & 255) << 20 | (fe[11] & 254) << 12 | (fe[12] & 255) << 5 | (fe[13] & 254) >>> 3, ge.pts *= 4, ge.pts += (fe[13] & 6) >>> 1, ge.dts = ge.pts, we & 64 && (ge.dts = (fe[14] & 14) << 27 | (fe[15] & 255) << 20 | (fe[16] & 254) << 12 | (fe[17] & 255) << 5 | (fe[18] & 254) >>> 3, ge.dts *= 4, ge.dts += (fe[18] & 6) >>> 1)), ge.data = fe.subarray(9 + fe[8]));
    }, oe = function(fe, ge, we) {
      var Pe = new Uint8Array(fe.size), dt = {
        type: ge
      }, ze = 0, St = 0, Wt = !1, Cr;
      if (!(!fe.data.length || fe.size < 9)) {
        for (dt.trackId = fe.data[0].pid, ze = 0; ze < fe.data.length; ze++)
          Cr = fe.data[ze], Pe.set(Cr.data, St), St += Cr.data.byteLength;
        re(Pe, dt), Wt = ge === "video" || dt.packetLength <= fe.size, (we || Wt) && (fe.size = 0, fe.data.length = 0), Wt && A.trigger("data", dt);
      }
    };
    dl.prototype.init.call(this), this.push = function(fe) {
      ({
        pat: function() {
        },
        pes: function() {
          var ge, we;
          switch (fe.streamType) {
            case Ur.H264_STREAM_TYPE:
              ge = k, we = "video";
              break;
            case Ur.ADTS_STREAM_TYPE:
              ge = C, we = "audio";
              break;
            case Ur.METADATA_STREAM_TYPE:
              ge = L, we = "timed-metadata";
              break;
            default:
              return;
          }
          fe.payloadUnitStartIndicator && oe(ge, we, !0), ge.data.push(fe), ge.size += fe.data.byteLength;
        },
        pmt: function() {
          var ge = {
            type: "metadata",
            tracks: []
          };
          z = fe.programMapTable, z.video !== null && ge.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +z.video,
            codec: "avc",
            type: "video"
          }), z.audio !== null && ge.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +z.audio,
            codec: "adts",
            type: "audio"
          }), x = !0, A.trigger("data", ge);
        }
      })[fe.type]();
    }, this.reset = function() {
      k.size = 0, k.data.length = 0, C.size = 0, C.data.length = 0, this.trigger("reset");
    }, this.flushStreams_ = function() {
      oe(k, "video"), oe(C, "audio"), oe(L, "timed-metadata");
    }, this.flush = function() {
      if (!x && z) {
        var fe = {
          type: "metadata",
          tracks: []
        };
        z.video !== null && fe.tracks.push({
          timelineStartInfo: {
            baseMediaDecodeTime: 0
          },
          id: +z.video,
          codec: "avc",
          type: "video"
        }), z.audio !== null && fe.tracks.push({
          timelineStartInfo: {
            baseMediaDecodeTime: 0
          },
          id: +z.audio,
          codec: "adts",
          type: "audio"
        }), A.trigger("data", fe);
      }
      x = !1, this.flushStreams_(), this.trigger("done");
    };
  }, dl.prototype = new ll();
  var ud = {
    PAT_PID: 0,
    MP2T_PACKET_LENGTH: Xa,
    TransportPacketStream: cl,
    TransportParseStream: Wo,
    ElementaryStream: dl,
    TimestampRolloverStream: od,
    CaptionStream: ad.CaptionStream,
    Cea608Stream: ad.Cea608Stream,
    Cea708Stream: ad.Cea708Stream,
    MetadataStream: p1
  };
  for (var gi in Ur)
    Ur.hasOwnProperty(gi) && (ud[gi] = Ur[gi]);
  var ld = ud, m1 = n, g1 = Tt.ONE_SECOND_IN_TS, fl, zh = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  fl = function(A) {
    var x, k = 0;
    fl.prototype.init.call(this), this.skipWarn_ = function(C, L) {
      this.trigger("log", {
        level: "warn",
        message: `adts skiping bytes ${C} to ${L} in frame ${k} outside syncword`
      });
    }, this.push = function(C) {
      var L = 0, z, re, oe, fe, ge;
      if (A || (k = 0), C.type === "audio") {
        x && x.length ? (oe = x, x = new Uint8Array(oe.byteLength + C.data.byteLength), x.set(oe), x.set(C.data, oe.byteLength)) : x = C.data;
        for (var we; L + 7 < x.length; ) {
          if (x[L] !== 255 || (x[L + 1] & 246) !== 240) {
            typeof we != "number" && (we = L), L++;
            continue;
          }
          if (typeof we == "number" && (this.skipWarn_(we, L), we = null), re = (~x[L + 1] & 1) * 2, z = (x[L + 3] & 3) << 11 | x[L + 4] << 3 | (x[L + 5] & 224) >> 5, fe = ((x[L + 6] & 3) + 1) * 1024, ge = fe * g1 / zh[(x[L + 2] & 60) >>> 2], x.byteLength - L < z)
            break;
          this.trigger("data", {
            pts: C.pts + k * ge,
            dts: C.dts + k * ge,
            sampleCount: fe,
            audioobjecttype: (x[L + 2] >>> 6 & 3) + 1,
            channelcount: (x[L + 2] & 1) << 2 | (x[L + 3] & 192) >>> 6,
            samplerate: zh[(x[L + 2] & 60) >>> 2],
            samplingfrequencyindex: (x[L + 2] & 60) >>> 2,
            // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
            samplesize: 16,
            // data is the frame without it's header
            data: x.subarray(L + 7 + re, L + z)
          }), k++, L += z;
        }
        typeof we == "number" && (this.skipWarn_(we, L), we = null), x = x.subarray(L);
      }
    }, this.flush = function() {
      k = 0, this.trigger("done");
    }, this.reset = function() {
      x = void 0, this.trigger("reset");
    }, this.endTimeline = function() {
      x = void 0, this.trigger("endedtimeline");
    };
  }, fl.prototype = new m1();
  var A1 = fl, qh;
  qh = function(A) {
    var x = A.byteLength, k = 0, C = 0;
    this.length = function() {
      return 8 * x;
    }, this.bitsAvailable = function() {
      return 8 * x + C;
    }, this.loadWord = function() {
      var L = A.byteLength - x, z = new Uint8Array(4), re = Math.min(4, x);
      if (re === 0)
        throw new Error("no bytes available");
      z.set(A.subarray(L, L + re)), k = new DataView(z.buffer).getUint32(0), C = re * 8, x -= re;
    }, this.skipBits = function(L) {
      var z;
      C > L ? (k <<= L, C -= L) : (L -= C, z = Math.floor(L / 8), L -= z * 8, x -= z, this.loadWord(), k <<= L, C -= L);
    }, this.readBits = function(L) {
      var z = Math.min(C, L), re = k >>> 32 - z;
      return C -= z, C > 0 ? k <<= z : x > 0 && this.loadWord(), z = L - z, z > 0 ? re << z | this.readBits(z) : re;
    }, this.skipLeadingZeros = function() {
      var L;
      for (L = 0; L < C; ++L)
        if ((k & 2147483648 >>> L) !== 0)
          return k <<= L, C -= L, L;
      return this.loadWord(), L + this.skipLeadingZeros();
    }, this.skipUnsignedExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    }, this.skipExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    }, this.readUnsignedExpGolomb = function() {
      var L = this.skipLeadingZeros();
      return this.readBits(L + 1) - 1;
    }, this.readExpGolomb = function() {
      var L = this.readUnsignedExpGolomb();
      return 1 & L ? 1 + L >>> 1 : -1 * (L >>> 1);
    }, this.readBoolean = function() {
      return this.readBits(1) === 1;
    }, this.readUnsignedByte = function() {
      return this.readBits(8);
    }, this.loadWord();
  };
  var b1 = qh, Vh = n, y1 = b1, hl, pl, Wh;
  pl = function() {
    var A = 0, x, k;
    pl.prototype.init.call(this), this.push = function(C) {
      var L;
      k ? (L = new Uint8Array(k.byteLength + C.data.byteLength), L.set(k), L.set(C.data, k.byteLength), k = L) : k = C.data;
      for (var z = k.byteLength; A < z - 3; A++)
        if (k[A + 2] === 1) {
          x = A + 5;
          break;
        }
      for (; x < z; )
        switch (k[x]) {
          case 0:
            if (k[x - 1] !== 0) {
              x += 2;
              break;
            } else if (k[x - 2] !== 0) {
              x++;
              break;
            }
            A + 3 !== x - 2 && this.trigger("data", k.subarray(A + 3, x - 2));
            do
              x++;
            while (k[x] !== 1 && x < z);
            A = x - 2, x += 3;
            break;
          case 1:
            if (k[x - 1] !== 0 || k[x - 2] !== 0) {
              x += 3;
              break;
            }
            this.trigger("data", k.subarray(A + 3, x - 2)), A = x - 2, x += 3;
            break;
          default:
            x += 3;
            break;
        }
      k = k.subarray(A), x -= A, A = 0;
    }, this.reset = function() {
      k = null, A = 0, this.trigger("reset");
    }, this.flush = function() {
      k && k.byteLength > 3 && this.trigger("data", k.subarray(A + 3)), k = null, A = 0, this.trigger("done");
    }, this.endTimeline = function() {
      this.flush(), this.trigger("endedtimeline");
    };
  }, pl.prototype = new Vh(), Wh = {
    100: !0,
    110: !0,
    122: !0,
    244: !0,
    44: !0,
    83: !0,
    86: !0,
    118: !0,
    128: !0,
    // TODO: the three profiles below don't
    // appear to have sps data in the specificiation anymore?
    138: !0,
    139: !0,
    134: !0
  }, hl = function() {
    var A = new pl(), x, k, C, L, z, re, oe;
    hl.prototype.init.call(this), x = this, this.push = function(fe) {
      fe.type === "video" && (k = fe.trackId, C = fe.pts, L = fe.dts, A.push(fe));
    }, A.on("data", function(fe) {
      var ge = {
        trackId: k,
        pts: C,
        dts: L,
        data: fe,
        nalUnitTypeCode: fe[0] & 31
      };
      switch (ge.nalUnitTypeCode) {
        case 5:
          ge.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
          break;
        case 6:
          ge.nalUnitType = "sei_rbsp", ge.escapedRBSP = z(fe.subarray(1));
          break;
        case 7:
          ge.nalUnitType = "seq_parameter_set_rbsp", ge.escapedRBSP = z(fe.subarray(1)), ge.config = re(ge.escapedRBSP);
          break;
        case 8:
          ge.nalUnitType = "pic_parameter_set_rbsp";
          break;
        case 9:
          ge.nalUnitType = "access_unit_delimiter_rbsp";
          break;
      }
      x.trigger("data", ge);
    }), A.on("done", function() {
      x.trigger("done");
    }), A.on("partialdone", function() {
      x.trigger("partialdone");
    }), A.on("reset", function() {
      x.trigger("reset");
    }), A.on("endedtimeline", function() {
      x.trigger("endedtimeline");
    }), this.flush = function() {
      A.flush();
    }, this.partialFlush = function() {
      A.partialFlush();
    }, this.reset = function() {
      A.reset();
    }, this.endTimeline = function() {
      A.endTimeline();
    }, oe = function(fe, ge) {
      var we = 8, Pe = 8, dt, ze;
      for (dt = 0; dt < fe; dt++)
        Pe !== 0 && (ze = ge.readExpGolomb(), Pe = (we + ze + 256) % 256), we = Pe === 0 ? we : Pe;
    }, z = function(fe) {
      for (var ge = fe.byteLength, we = [], Pe = 1, dt, ze; Pe < ge - 2; )
        fe[Pe] === 0 && fe[Pe + 1] === 0 && fe[Pe + 2] === 3 ? (we.push(Pe + 2), Pe += 2) : Pe++;
      if (we.length === 0)
        return fe;
      dt = ge - we.length, ze = new Uint8Array(dt);
      var St = 0;
      for (Pe = 0; Pe < dt; St++, Pe++)
        St === we[0] && (St++, we.shift()), ze[Pe] = fe[St];
      return ze;
    }, re = function(fe) {
      var ge = 0, we = 0, Pe = 0, dt = 0, ze, St, Wt, Cr, Ui, Ja, hd, pd, md, gd, np, zn = [1, 1], Ad, ys;
      if (ze = new y1(fe), St = ze.readUnsignedByte(), Cr = ze.readUnsignedByte(), Wt = ze.readUnsignedByte(), ze.skipUnsignedExpGolomb(), Wh[St] && (Ui = ze.readUnsignedExpGolomb(), Ui === 3 && ze.skipBits(1), ze.skipUnsignedExpGolomb(), ze.skipUnsignedExpGolomb(), ze.skipBits(1), ze.readBoolean()))
        for (np = Ui !== 3 ? 8 : 12, ys = 0; ys < np; ys++)
          ze.readBoolean() && (ys < 6 ? oe(16, ze) : oe(64, ze));
      if (ze.skipUnsignedExpGolomb(), Ja = ze.readUnsignedExpGolomb(), Ja === 0)
        ze.readUnsignedExpGolomb();
      else if (Ja === 1)
        for (ze.skipBits(1), ze.skipExpGolomb(), ze.skipExpGolomb(), hd = ze.readUnsignedExpGolomb(), ys = 0; ys < hd; ys++)
          ze.skipExpGolomb();
      if (ze.skipUnsignedExpGolomb(), ze.skipBits(1), pd = ze.readUnsignedExpGolomb(), md = ze.readUnsignedExpGolomb(), gd = ze.readBits(1), gd === 0 && ze.skipBits(1), ze.skipBits(1), ze.readBoolean() && (ge = ze.readUnsignedExpGolomb(), we = ze.readUnsignedExpGolomb(), Pe = ze.readUnsignedExpGolomb(), dt = ze.readUnsignedExpGolomb()), ze.readBoolean() && ze.readBoolean()) {
        switch (Ad = ze.readUnsignedByte(), Ad) {
          case 1:
            zn = [1, 1];
            break;
          case 2:
            zn = [12, 11];
            break;
          case 3:
            zn = [10, 11];
            break;
          case 4:
            zn = [16, 11];
            break;
          case 5:
            zn = [40, 33];
            break;
          case 6:
            zn = [24, 11];
            break;
          case 7:
            zn = [20, 11];
            break;
          case 8:
            zn = [32, 11];
            break;
          case 9:
            zn = [80, 33];
            break;
          case 10:
            zn = [18, 11];
            break;
          case 11:
            zn = [15, 11];
            break;
          case 12:
            zn = [64, 33];
            break;
          case 13:
            zn = [160, 99];
            break;
          case 14:
            zn = [4, 3];
            break;
          case 15:
            zn = [3, 2];
            break;
          case 16:
            zn = [2, 1];
            break;
          case 255: {
            zn = [ze.readUnsignedByte() << 8 | ze.readUnsignedByte(), ze.readUnsignedByte() << 8 | ze.readUnsignedByte()];
            break;
          }
        }
        zn && zn[0] / zn[1];
      }
      return {
        profileIdc: St,
        levelIdc: Wt,
        profileCompatibility: Cr,
        width: (pd + 1) * 16 - ge * 2 - we * 2,
        height: (2 - gd) * (md + 1) * 16 - Pe * 2 - dt * 2,
        // sar is sample aspect ratio
        sarRatio: zn
      };
    };
  }, hl.prototype = new Vh();
  var v1 = {
    H264Stream: hl
  }, T1 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], Qh = function(A, x) {
    var k = A[x + 6] << 21 | A[x + 7] << 14 | A[x + 8] << 7 | A[x + 9], C = A[x + 5], L = (C & 16) >> 4;
    return k = k >= 0 ? k : 0, L ? k + 20 : k + 10;
  }, Gh = function(A, x) {
    return A.length - x < 10 || A[x] !== 73 || A[x + 1] !== 68 || A[x + 2] !== 51 ? x : (x += Qh(A, x), Gh(A, x));
  }, _1 = function(A) {
    var x = Gh(A, 0);
    return A.length >= x + 2 && (A[x] & 255) === 255 && (A[x + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
    // is not mp3 data but aac data.
    (A[x + 1] & 22) === 16;
  }, Yh = function(A) {
    return A[0] << 21 | A[1] << 14 | A[2] << 7 | A[3];
  }, E1 = function(A, x, k) {
    var C, L = "";
    for (C = x; C < k; C++)
      L += "%" + ("00" + A[C].toString(16)).slice(-2);
    return L;
  }, x1 = function(A, x, k) {
    return unescape(E1(A, x, k));
  }, w1 = function(A, x) {
    var k = (A[x + 5] & 224) >> 5, C = A[x + 4] << 3, L = A[x + 3] & 6144;
    return L | C | k;
  }, C1 = function(A, x) {
    return A[x] === 73 && A[x + 1] === 68 && A[x + 2] === 51 ? "timed-metadata" : A[x] & !0 && (A[x + 1] & 240) === 240 ? "audio" : null;
  }, S1 = function(A) {
    for (var x = 0; x + 5 < A.length; ) {
      if (A[x] !== 255 || (A[x + 1] & 246) !== 240) {
        x++;
        continue;
      }
      return T1[(A[x + 2] & 60) >>> 2];
    }
    return null;
  }, Ai = function(A) {
    var x, k, C, L;
    x = 10, A[5] & 64 && (x += 4, x += Yh(A.subarray(10, 14)));
    do {
      if (k = Yh(A.subarray(x + 4, x + 8)), k < 1)
        return null;
      if (L = String.fromCharCode(A[x], A[x + 1], A[x + 2], A[x + 3]), L === "PRIV") {
        C = A.subarray(x + 10, x + k + 10);
        for (var z = 0; z < C.byteLength; z++)
          if (C[z] === 0) {
            var re = x1(C, 0, z);
            if (re === "com.apple.streaming.transportStreamTimestamp") {
              var oe = C.subarray(z + 1), fe = (oe[3] & 1) << 30 | oe[4] << 22 | oe[5] << 14 | oe[6] << 6 | oe[7] >>> 2;
              return fe *= 4, fe += oe[7] & 3, fe;
            }
            break;
          }
      }
      x += 10, x += k;
    } while (x < A.byteLength);
    return null;
  }, bi = {
    isLikelyAacData: _1,
    parseId3TagSize: Qh,
    parseAdtsSize: w1,
    parseType: C1,
    parseSampleRate: S1,
    parseAacTimestamp: Ai
  }, Yi = n, Xh = bi, Ka;
  Ka = function() {
    var A = new Uint8Array(), x = 0;
    Ka.prototype.init.call(this), this.setTimestamp = function(k) {
      x = k;
    }, this.push = function(k) {
      var C = 0, L = 0, z, re, oe, fe;
      for (A.length ? (fe = A.length, A = new Uint8Array(k.byteLength + fe), A.set(A.subarray(0, fe)), A.set(k, fe)) : A = k; A.length - L >= 3; ) {
        if (A[L] === 73 && A[L + 1] === 68 && A[L + 2] === 51) {
          if (A.length - L < 10 || (C = Xh.parseId3TagSize(A, L), L + C > A.length))
            break;
          re = {
            type: "timed-metadata",
            data: A.subarray(L, L + C)
          }, this.trigger("data", re), L += C;
          continue;
        } else if ((A[L] & 255) === 255 && (A[L + 1] & 240) === 240) {
          if (A.length - L < 7 || (C = Xh.parseAdtsSize(A, L), L + C > A.length))
            break;
          oe = {
            type: "audio",
            data: A.subarray(L, L + C),
            pts: x,
            dts: x
          }, this.trigger("data", oe), L += C;
          continue;
        }
        L++;
      }
      z = A.length - L, z > 0 ? A = A.subarray(L) : A = new Uint8Array();
    }, this.reset = function() {
      A = new Uint8Array(), this.trigger("reset");
    }, this.endTimeline = function() {
      A = new Uint8Array(), this.trigger("endedtimeline");
    };
  }, Ka.prototype = new Yi();
  var I1 = Ka, k1 = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"], D1 = k1, M1 = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"], O1 = M1, ml = n, h = he, F = Ie, q = jn, le = rt, Le = ld, st = Tt, Je = A1, Lr = v1.H264Stream, Tn = I1, $r = bi.isLikelyAacData, Ta = Tt.ONE_SECOND_IN_TS, _r = D1, un = O1, bs, Xi, gl, Go, Z9 = function(A, x) {
    x.stream = A, this.trigger("log", x);
  }, R_ = function(A, x) {
    for (var k = Object.keys(x), C = 0; C < k.length; C++) {
      var L = k[C];
      L === "headOfPipeline" || !x[L].on || x[L].on("log", Z9.bind(A, L));
    }
  }, B_ = function(A, x) {
    var k;
    if (A.length !== x.length)
      return !1;
    for (k = 0; k < A.length; k++)
      if (A[k] !== x[k])
        return !1;
    return !0;
  }, F_ = function(A, x, k, C, L, z) {
    var re = k - x, oe = C - x, fe = L - k;
    return {
      start: {
        dts: A,
        pts: A + re
      },
      end: {
        dts: A + oe,
        pts: A + fe
      },
      prependedContentDuration: z,
      baseMediaDecodeTime: A
    };
  };
  Xi = function(A, x) {
    var k = [], C, L = 0, z = 0, re = 1 / 0;
    x = x || {}, C = x.firstSequenceNumber || 0, Xi.prototype.init.call(this), this.push = function(oe) {
      le.collectDtsInfo(A, oe), A && _r.forEach(function(fe) {
        A[fe] = oe[fe];
      }), k.push(oe);
    }, this.setEarliestDts = function(oe) {
      L = oe;
    }, this.setVideoBaseMediaDecodeTime = function(oe) {
      re = oe;
    }, this.setAudioAppendStart = function(oe) {
      z = oe;
    }, this.flush = function() {
      var oe, fe, ge, we, Pe, dt, ze;
      if (k.length === 0) {
        this.trigger("done", "AudioSegmentStream");
        return;
      }
      oe = q.trimAdtsFramesByEarliestDts(k, A, L), A.baseMediaDecodeTime = le.calculateTrackBaseMediaDecodeTime(A, x.keepOriginalTimestamps), ze = q.prefixWithSilence(A, oe, z, re), A.samples = q.generateSampleTable(oe), ge = h.mdat(q.concatenateFrameData(oe)), k = [], fe = h.moof(C, [A]), we = new Uint8Array(fe.byteLength + ge.byteLength), C++, we.set(fe), we.set(ge, fe.byteLength), le.clearDtsInfo(A), Pe = Math.ceil(Ta * 1024 / A.samplerate), oe.length && (dt = oe.length * Pe, this.trigger("segmentTimingInfo", F_(
        // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
        // frame info is in video clock cycles. Convert to match expectation of
        // listeners (that all timestamps will be based on video clock cycles).
        st.audioTsToVideoTs(A.baseMediaDecodeTime, A.samplerate),
        // frame times are already in video clock, as is segment duration
        oe[0].dts,
        oe[0].pts,
        oe[0].dts + dt,
        oe[0].pts + dt,
        ze || 0
      )), this.trigger("timingInfo", {
        start: oe[0].pts,
        end: oe[0].pts + dt
      })), this.trigger("data", {
        track: A,
        boxes: we
      }), this.trigger("done", "AudioSegmentStream");
    }, this.reset = function() {
      le.clearDtsInfo(A), k = [], this.trigger("reset");
    };
  }, Xi.prototype = new ml(), bs = function(A, x) {
    var k, C = [], L = [], z, re;
    x = x || {}, k = x.firstSequenceNumber || 0, bs.prototype.init.call(this), delete A.minPTS, this.gopCache_ = [], this.push = function(oe) {
      le.collectDtsInfo(A, oe), oe.nalUnitType === "seq_parameter_set_rbsp" && !z && (z = oe.config, A.sps = [oe.data], un.forEach(function(fe) {
        A[fe] = z[fe];
      }, this)), oe.nalUnitType === "pic_parameter_set_rbsp" && !re && (re = oe.data, A.pps = [oe.data]), C.push(oe);
    }, this.flush = function() {
      for (var oe, fe, ge, we, Pe, dt, ze = 0, St, Wt; C.length && C[0].nalUnitType !== "access_unit_delimiter_rbsp"; )
        C.shift();
      if (C.length === 0) {
        this.resetStream_(), this.trigger("done", "VideoSegmentStream");
        return;
      }
      if (oe = F.groupNalsIntoFrames(C), ge = F.groupFramesIntoGops(oe), ge[0][0].keyFrame || (fe = this.getGopForFusion_(C[0], A), fe ? (ze = fe.duration, ge.unshift(fe), ge.byteLength += fe.byteLength, ge.nalCount += fe.nalCount, ge.pts = fe.pts, ge.dts = fe.dts, ge.duration += fe.duration) : ge = F.extendFirstKeyFrame(ge)), L.length) {
        var Cr;
        if (x.alignGopsAtEnd ? Cr = this.alignGopsAtEnd_(ge) : Cr = this.alignGopsAtStart_(ge), !Cr) {
          this.gopCache_.unshift({
            gop: ge.pop(),
            pps: A.pps,
            sps: A.sps
          }), this.gopCache_.length = Math.min(6, this.gopCache_.length), C = [], this.resetStream_(), this.trigger("done", "VideoSegmentStream");
          return;
        }
        le.clearDtsInfo(A), ge = Cr;
      }
      le.collectDtsInfo(A, ge), A.samples = F.generateSampleTable(ge), Pe = h.mdat(F.concatenateNalData(ge)), A.baseMediaDecodeTime = le.calculateTrackBaseMediaDecodeTime(A, x.keepOriginalTimestamps), this.trigger("processedGopsInfo", ge.map(function(Ui) {
        return {
          pts: Ui.pts,
          dts: Ui.dts,
          byteLength: Ui.byteLength
        };
      })), St = ge[0], Wt = ge[ge.length - 1], this.trigger("segmentTimingInfo", F_(A.baseMediaDecodeTime, St.dts, St.pts, Wt.dts + Wt.duration, Wt.pts + Wt.duration, ze)), this.trigger("timingInfo", {
        start: ge[0].pts,
        end: ge[ge.length - 1].pts + ge[ge.length - 1].duration
      }), this.gopCache_.unshift({
        gop: ge.pop(),
        pps: A.pps,
        sps: A.sps
      }), this.gopCache_.length = Math.min(6, this.gopCache_.length), C = [], this.trigger("baseMediaDecodeTime", A.baseMediaDecodeTime), this.trigger("timelineStartInfo", A.timelineStartInfo), we = h.moof(k, [A]), dt = new Uint8Array(we.byteLength + Pe.byteLength), k++, dt.set(we), dt.set(Pe, we.byteLength), this.trigger("data", {
        track: A,
        boxes: dt
      }), this.resetStream_(), this.trigger("done", "VideoSegmentStream");
    }, this.reset = function() {
      this.resetStream_(), C = [], this.gopCache_.length = 0, L.length = 0, this.trigger("reset");
    }, this.resetStream_ = function() {
      le.clearDtsInfo(A), z = void 0, re = void 0;
    }, this.getGopForFusion_ = function(oe) {
      var fe = 45e3, ge = 1 / 0, we, Pe, dt, ze, St;
      for (St = 0; St < this.gopCache_.length; St++)
        ze = this.gopCache_[St], dt = ze.gop, !(!(A.pps && B_(A.pps[0], ze.pps[0])) || !(A.sps && B_(A.sps[0], ze.sps[0]))) && (dt.dts < A.timelineStartInfo.dts || (we = oe.dts - dt.dts - dt.duration, we >= -1e4 && we <= fe && (!Pe || ge > we) && (Pe = ze, ge = we)));
      return Pe ? Pe.gop : null;
    }, this.alignGopsAtStart_ = function(oe) {
      var fe, ge, we, Pe, dt, ze, St, Wt;
      for (dt = oe.byteLength, ze = oe.nalCount, St = oe.duration, fe = ge = 0; fe < L.length && ge < oe.length && (we = L[fe], Pe = oe[ge], we.pts !== Pe.pts); ) {
        if (Pe.pts > we.pts) {
          fe++;
          continue;
        }
        ge++, dt -= Pe.byteLength, ze -= Pe.nalCount, St -= Pe.duration;
      }
      return ge === 0 ? oe : ge === oe.length ? null : (Wt = oe.slice(ge), Wt.byteLength = dt, Wt.duration = St, Wt.nalCount = ze, Wt.pts = Wt[0].pts, Wt.dts = Wt[0].dts, Wt);
    }, this.alignGopsAtEnd_ = function(oe) {
      var fe, ge, we, Pe, dt, ze;
      for (fe = L.length - 1, ge = oe.length - 1, dt = null, ze = !1; fe >= 0 && ge >= 0; ) {
        if (we = L[fe], Pe = oe[ge], we.pts === Pe.pts) {
          ze = !0;
          break;
        }
        if (we.pts > Pe.pts) {
          fe--;
          continue;
        }
        fe === L.length - 1 && (dt = ge), ge--;
      }
      if (!ze && dt === null)
        return null;
      var St;
      if (ze ? St = ge : St = dt, St === 0)
        return oe;
      var Wt = oe.slice(St), Cr = Wt.reduce(function(Ui, Ja) {
        return Ui.byteLength += Ja.byteLength, Ui.duration += Ja.duration, Ui.nalCount += Ja.nalCount, Ui;
      }, {
        byteLength: 0,
        duration: 0,
        nalCount: 0
      });
      return Wt.byteLength = Cr.byteLength, Wt.duration = Cr.duration, Wt.nalCount = Cr.nalCount, Wt.pts = Wt[0].pts, Wt.dts = Wt[0].dts, Wt;
    }, this.alignGopsWith = function(oe) {
      L = oe;
    };
  }, bs.prototype = new ml(), Go = function(A, x) {
    this.numberOfTracks = 0, this.metadataStream = x, A = A || {}, typeof A.remux < "u" ? this.remuxTracks = !!A.remux : this.remuxTracks = !0, typeof A.keepOriginalTimestamps == "boolean" ? this.keepOriginalTimestamps = A.keepOriginalTimestamps : this.keepOriginalTimestamps = !1, this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, Go.prototype.init.call(this), this.push = function(k) {
      if (k.content || k.text)
        return this.pendingCaptions.push(k);
      if (k.frames)
        return this.pendingMetadata.push(k);
      this.pendingTracks.push(k.track), this.pendingBytes += k.boxes.byteLength, k.track.type === "video" && (this.videoTrack = k.track, this.pendingBoxes.push(k.boxes)), k.track.type === "audio" && (this.audioTrack = k.track, this.pendingBoxes.unshift(k.boxes));
    };
  }, Go.prototype = new ml(), Go.prototype.flush = function(A) {
    var x = 0, k = {
      captions: [],
      captionStreams: {},
      metadata: [],
      info: {}
    }, C, L, z, re = 0, oe;
    if (this.pendingTracks.length < this.numberOfTracks) {
      if (A !== "VideoSegmentStream" && A !== "AudioSegmentStream")
        return;
      if (this.remuxTracks)
        return;
      if (this.pendingTracks.length === 0) {
        this.emittedTracks++, this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
        return;
      }
    }
    if (this.videoTrack ? (re = this.videoTrack.timelineStartInfo.pts, un.forEach(function(fe) {
      k.info[fe] = this.videoTrack[fe];
    }, this)) : this.audioTrack && (re = this.audioTrack.timelineStartInfo.pts, _r.forEach(function(fe) {
      k.info[fe] = this.audioTrack[fe];
    }, this)), this.videoTrack || this.audioTrack) {
      for (this.pendingTracks.length === 1 ? k.type = this.pendingTracks[0].type : k.type = "combined", this.emittedTracks += this.pendingTracks.length, z = h.initSegment(this.pendingTracks), k.initSegment = new Uint8Array(z.byteLength), k.initSegment.set(z), k.data = new Uint8Array(this.pendingBytes), oe = 0; oe < this.pendingBoxes.length; oe++)
        k.data.set(this.pendingBoxes[oe], x), x += this.pendingBoxes[oe].byteLength;
      for (oe = 0; oe < this.pendingCaptions.length; oe++)
        C = this.pendingCaptions[oe], C.startTime = st.metadataTsToSeconds(C.startPts, re, this.keepOriginalTimestamps), C.endTime = st.metadataTsToSeconds(C.endPts, re, this.keepOriginalTimestamps), k.captionStreams[C.stream] = !0, k.captions.push(C);
      for (oe = 0; oe < this.pendingMetadata.length; oe++)
        L = this.pendingMetadata[oe], L.cueTime = st.metadataTsToSeconds(L.pts, re, this.keepOriginalTimestamps), k.metadata.push(L);
      for (k.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", k), oe = 0; oe < k.captions.length; oe++)
        C = k.captions[oe], this.trigger("caption", C);
      for (oe = 0; oe < k.metadata.length; oe++)
        L = k.metadata[oe], this.trigger("id3Frame", L);
    }
    this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0);
  }, Go.prototype.setRemux = function(A) {
    this.remuxTracks = A;
  }, gl = function(A) {
    var x = this, k = !0, C, L;
    gl.prototype.init.call(this), A = A || {}, this.baseMediaDecodeTime = A.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() {
      var z = {};
      this.transmuxPipeline_ = z, z.type = "aac", z.metadataStream = new Le.MetadataStream(), z.aacStream = new Tn(), z.audioTimestampRolloverStream = new Le.TimestampRolloverStream("audio"), z.timedMetadataTimestampRolloverStream = new Le.TimestampRolloverStream("timed-metadata"), z.adtsStream = new Je(), z.coalesceStream = new Go(A, z.metadataStream), z.headOfPipeline = z.aacStream, z.aacStream.pipe(z.audioTimestampRolloverStream).pipe(z.adtsStream), z.aacStream.pipe(z.timedMetadataTimestampRolloverStream).pipe(z.metadataStream).pipe(z.coalesceStream), z.metadataStream.on("timestamp", function(re) {
        z.aacStream.setTimestamp(re.timeStamp);
      }), z.aacStream.on("data", function(re) {
        re.type !== "timed-metadata" && re.type !== "audio" || z.audioSegmentStream || (L = L || {
          timelineStartInfo: {
            baseMediaDecodeTime: x.baseMediaDecodeTime
          },
          codec: "adts",
          type: "audio"
        }, z.coalesceStream.numberOfTracks++, z.audioSegmentStream = new Xi(L, A), z.audioSegmentStream.on("log", x.getLogTrigger_("audioSegmentStream")), z.audioSegmentStream.on("timingInfo", x.trigger.bind(x, "audioTimingInfo")), z.adtsStream.pipe(z.audioSegmentStream).pipe(z.coalesceStream), x.trigger("trackinfo", {
          hasAudio: !!L,
          hasVideo: !!C
        }));
      }), z.coalesceStream.on("data", this.trigger.bind(this, "data")), z.coalesceStream.on("done", this.trigger.bind(this, "done")), R_(this, z);
    }, this.setupTsPipeline = function() {
      var z = {};
      this.transmuxPipeline_ = z, z.type = "ts", z.metadataStream = new Le.MetadataStream(), z.packetStream = new Le.TransportPacketStream(), z.parseStream = new Le.TransportParseStream(), z.elementaryStream = new Le.ElementaryStream(), z.timestampRolloverStream = new Le.TimestampRolloverStream(), z.adtsStream = new Je(), z.h264Stream = new Lr(), z.captionStream = new Le.CaptionStream(A), z.coalesceStream = new Go(A, z.metadataStream), z.headOfPipeline = z.packetStream, z.packetStream.pipe(z.parseStream).pipe(z.elementaryStream).pipe(z.timestampRolloverStream), z.timestampRolloverStream.pipe(z.h264Stream), z.timestampRolloverStream.pipe(z.adtsStream), z.timestampRolloverStream.pipe(z.metadataStream).pipe(z.coalesceStream), z.h264Stream.pipe(z.captionStream).pipe(z.coalesceStream), z.elementaryStream.on("data", function(re) {
        var oe;
        if (re.type === "metadata") {
          for (oe = re.tracks.length; oe--; )
            !C && re.tracks[oe].type === "video" ? (C = re.tracks[oe], C.timelineStartInfo.baseMediaDecodeTime = x.baseMediaDecodeTime) : !L && re.tracks[oe].type === "audio" && (L = re.tracks[oe], L.timelineStartInfo.baseMediaDecodeTime = x.baseMediaDecodeTime);
          C && !z.videoSegmentStream && (z.coalesceStream.numberOfTracks++, z.videoSegmentStream = new bs(C, A), z.videoSegmentStream.on("log", x.getLogTrigger_("videoSegmentStream")), z.videoSegmentStream.on("timelineStartInfo", function(fe) {
            L && !A.keepOriginalTimestamps && (L.timelineStartInfo = fe, z.audioSegmentStream.setEarliestDts(fe.dts - x.baseMediaDecodeTime));
          }), z.videoSegmentStream.on("processedGopsInfo", x.trigger.bind(x, "gopInfo")), z.videoSegmentStream.on("segmentTimingInfo", x.trigger.bind(x, "videoSegmentTimingInfo")), z.videoSegmentStream.on("baseMediaDecodeTime", function(fe) {
            L && z.audioSegmentStream.setVideoBaseMediaDecodeTime(fe);
          }), z.videoSegmentStream.on("timingInfo", x.trigger.bind(x, "videoTimingInfo")), z.h264Stream.pipe(z.videoSegmentStream).pipe(z.coalesceStream)), L && !z.audioSegmentStream && (z.coalesceStream.numberOfTracks++, z.audioSegmentStream = new Xi(L, A), z.audioSegmentStream.on("log", x.getLogTrigger_("audioSegmentStream")), z.audioSegmentStream.on("timingInfo", x.trigger.bind(x, "audioTimingInfo")), z.audioSegmentStream.on("segmentTimingInfo", x.trigger.bind(x, "audioSegmentTimingInfo")), z.adtsStream.pipe(z.audioSegmentStream).pipe(z.coalesceStream)), x.trigger("trackinfo", {
            hasAudio: !!L,
            hasVideo: !!C
          });
        }
      }), z.coalesceStream.on("data", this.trigger.bind(this, "data")), z.coalesceStream.on("id3Frame", function(re) {
        re.dispatchType = z.metadataStream.dispatchType, x.trigger("id3Frame", re);
      }), z.coalesceStream.on("caption", this.trigger.bind(this, "caption")), z.coalesceStream.on("done", this.trigger.bind(this, "done")), R_(this, z);
    }, this.setBaseMediaDecodeTime = function(z) {
      var re = this.transmuxPipeline_;
      A.keepOriginalTimestamps || (this.baseMediaDecodeTime = z), L && (L.timelineStartInfo.dts = void 0, L.timelineStartInfo.pts = void 0, le.clearDtsInfo(L), re.audioTimestampRolloverStream && re.audioTimestampRolloverStream.discontinuity()), C && (re.videoSegmentStream && (re.videoSegmentStream.gopCache_ = []), C.timelineStartInfo.dts = void 0, C.timelineStartInfo.pts = void 0, le.clearDtsInfo(C), re.captionStream.reset()), re.timestampRolloverStream && re.timestampRolloverStream.discontinuity();
    }, this.setAudioAppendStart = function(z) {
      L && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(z);
    }, this.setRemux = function(z) {
      var re = this.transmuxPipeline_;
      A.remux = z, re && re.coalesceStream && re.coalesceStream.setRemux(z);
    }, this.alignGopsWith = function(z) {
      C && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(z);
    }, this.getLogTrigger_ = function(z) {
      var re = this;
      return function(oe) {
        oe.stream = z, re.trigger("log", oe);
      };
    }, this.push = function(z) {
      if (k) {
        var re = $r(z);
        re && this.transmuxPipeline_.type !== "aac" ? this.setupAacPipeline() : !re && this.transmuxPipeline_.type !== "ts" && this.setupTsPipeline(), k = !1;
      }
      this.transmuxPipeline_.headOfPipeline.push(z);
    }, this.flush = function() {
      k = !0, this.transmuxPipeline_.headOfPipeline.flush();
    }, this.endTimeline = function() {
      this.transmuxPipeline_.headOfPipeline.endTimeline();
    }, this.reset = function() {
      this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset();
    }, this.resetCaptions = function() {
      this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset();
    };
  }, gl.prototype = new ml();
  var J9 = {
    Transmuxer: gl
  }, eL = function(A) {
    return A >>> 0;
  }, tL = function(A) {
    return ("00" + A.toString(16)).slice(-2);
  }, Kh = {
    toUnsigned: eL,
    toHexString: tL
  }, nL = function(A) {
    var x = "";
    return x += String.fromCharCode(A[0]), x += String.fromCharCode(A[1]), x += String.fromCharCode(A[2]), x += String.fromCharCode(A[3]), x;
  }, U_ = nL, rL = Kh.toUnsigned, iL = U_, $_ = function(A, x) {
    var k = [], C, L, z, re, oe;
    if (!x.length)
      return null;
    for (C = 0; C < A.byteLength; )
      L = rL(A[C] << 24 | A[C + 1] << 16 | A[C + 2] << 8 | A[C + 3]), z = iL(A.subarray(C + 4, C + 8)), re = L > 1 ? C + L : A.byteLength, z === x[0] && (x.length === 1 ? k.push(A.subarray(C + 8, re)) : (oe = $_(A.subarray(C + 8, re), x.slice(1)), oe.length && (k = k.concat(oe)))), C = re;
    return k;
  }, N1 = $_, sL = Kh.toUnsigned, aL = s.getUint64, oL = function(A) {
    var x = {
      version: A[0],
      flags: new Uint8Array(A.subarray(1, 4))
    };
    return x.version === 1 ? x.baseMediaDecodeTime = aL(A.subarray(4)) : x.baseMediaDecodeTime = sL(A[4] << 24 | A[5] << 16 | A[6] << 8 | A[7]), x;
  }, L1 = oL, uL = function(A) {
    var x = new DataView(A.buffer, A.byteOffset, A.byteLength), k = {
      version: A[0],
      flags: new Uint8Array(A.subarray(1, 4)),
      trackId: x.getUint32(4)
    }, C = k.flags[2] & 1, L = k.flags[2] & 2, z = k.flags[2] & 8, re = k.flags[2] & 16, oe = k.flags[2] & 32, fe = k.flags[0] & 65536, ge = k.flags[0] & 131072, we;
    return we = 8, C && (we += 4, k.baseDataOffset = x.getUint32(12), we += 4), L && (k.sampleDescriptionIndex = x.getUint32(we), we += 4), z && (k.defaultSampleDuration = x.getUint32(we), we += 4), re && (k.defaultSampleSize = x.getUint32(we), we += 4), oe && (k.defaultSampleFlags = x.getUint32(we)), fe && (k.durationIsEmpty = !0), !C && ge && (k.baseDataOffsetIsMoof = !0), k;
  }, H_ = uL, lL = function(A) {
    return {
      isLeading: (A[0] & 12) >>> 2,
      dependsOn: A[0] & 3,
      isDependedOn: (A[1] & 192) >>> 6,
      hasRedundancy: (A[1] & 48) >>> 4,
      paddingValue: (A[1] & 14) >>> 1,
      isNonSyncSample: A[1] & 1,
      degradationPriority: A[2] << 8 | A[3]
    };
  }, cL = lL, j_ = cL, dL = function(A) {
    var x = {
      version: A[0],
      flags: new Uint8Array(A.subarray(1, 4)),
      samples: []
    }, k = new DataView(A.buffer, A.byteOffset, A.byteLength), C = x.flags[2] & 1, L = x.flags[2] & 4, z = x.flags[1] & 1, re = x.flags[1] & 2, oe = x.flags[1] & 4, fe = x.flags[1] & 8, ge = k.getUint32(4), we = 8, Pe;
    for (C && (x.dataOffset = k.getInt32(we), we += 4), L && ge && (Pe = {
      flags: j_(A.subarray(we, we + 4))
    }, we += 4, z && (Pe.duration = k.getUint32(we), we += 4), re && (Pe.size = k.getUint32(we), we += 4), fe && (x.version === 1 ? Pe.compositionTimeOffset = k.getInt32(we) : Pe.compositionTimeOffset = k.getUint32(we), we += 4), x.samples.push(Pe), ge--); ge--; )
      Pe = {}, z && (Pe.duration = k.getUint32(we), we += 4), re && (Pe.size = k.getUint32(we), we += 4), oe && (Pe.flags = j_(A.subarray(we, we + 4)), we += 4), fe && (x.version === 1 ? Pe.compositionTimeOffset = k.getInt32(we) : Pe.compositionTimeOffset = k.getUint32(we), we += 4), x.samples.push(Pe);
    return x;
  }, z_ = dL, q_ = {
    tfdt: L1,
    trun: z_
  }, V_ = {
    parseTfdt: q_.tfdt,
    parseTrun: q_.trun
  }, fL = function(A) {
    for (var x = 0, k = String.fromCharCode(A[x]), C = ""; k !== "\0"; )
      C += k, x++, k = String.fromCharCode(A[x]);
    return C += k, C;
  }, hL = {
    uint8ToCString: fL
  }, Zh = hL.uint8ToCString, pL = s.getUint64, mL = function(A) {
    var x = 4, k = A[0], C, L, z, re, oe, fe, ge, we;
    if (k === 0) {
      C = Zh(A.subarray(x)), x += C.length, L = Zh(A.subarray(x)), x += L.length;
      var Pe = new DataView(A.buffer);
      z = Pe.getUint32(x), x += 4, oe = Pe.getUint32(x), x += 4, fe = Pe.getUint32(x), x += 4, ge = Pe.getUint32(x), x += 4;
    } else if (k === 1) {
      var Pe = new DataView(A.buffer);
      z = Pe.getUint32(x), x += 4, re = pL(A.subarray(x)), x += 8, fe = Pe.getUint32(x), x += 4, ge = Pe.getUint32(x), x += 4, C = Zh(A.subarray(x)), x += C.length, L = Zh(A.subarray(x)), x += L.length;
    }
    we = new Uint8Array(A.subarray(x, A.byteLength));
    var dt = {
      scheme_id_uri: C,
      value: L,
      // if timescale is undefined or 0 set to 1 
      timescale: z || 1,
      presentation_time: re,
      presentation_time_delta: oe,
      event_duration: fe,
      id: ge,
      message_data: we
    };
    return AL(k, dt) ? dt : void 0;
  }, gL = function(A, x, k, C) {
    return A || A === 0 ? A / x : C + k / x;
  }, AL = function(A, x) {
    var k = x.scheme_id_uri !== "\0", C = A === 0 && W_(x.presentation_time_delta) && k, L = A === 1 && W_(x.presentation_time) && k;
    return !(A > 1) && C || L;
  }, W_ = function(A) {
    return A !== void 0 || A !== null;
  }, bL = {
    parseEmsgBox: mL,
    scaleTime: gL
  }, cd;
  typeof window < "u" ? cd = window : typeof t < "u" ? cd = t : typeof self < "u" ? cd = self : cd = {};
  var Q_ = cd, Jh = Kh.toUnsigned, dd = Kh.toHexString, lr = N1, Al = U_, P1 = bL, yL = H_, vL = z_, TL = L1, _L = s.getUint64, G_, Y_, X_, K_, Z_, R1, J_, B1 = Q_, EL = jh.parseId3Frames;
  G_ = function(A) {
    var x = {}, k = lr(A, ["moov", "trak"]);
    return k.reduce(function(C, L) {
      var z, re, oe, fe, ge;
      return z = lr(L, ["tkhd"])[0], !z || (re = z[0], oe = re === 0 ? 12 : 20, fe = Jh(z[oe] << 24 | z[oe + 1] << 16 | z[oe + 2] << 8 | z[oe + 3]), ge = lr(L, ["mdia", "mdhd"])[0], !ge) ? null : (re = ge[0], oe = re === 0 ? 12 : 20, C[fe] = Jh(ge[oe] << 24 | ge[oe + 1] << 16 | ge[oe + 2] << 8 | ge[oe + 3]), C);
    }, x);
  }, Y_ = function(A, x) {
    var k;
    k = lr(x, ["moof", "traf"]);
    var C = k.reduce(function(L, z) {
      var re = lr(z, ["tfhd"])[0], oe = Jh(re[4] << 24 | re[5] << 16 | re[6] << 8 | re[7]), fe = A[oe] || 9e4, ge = lr(z, ["tfdt"])[0], we = new DataView(ge.buffer, ge.byteOffset, ge.byteLength), Pe;
      ge[0] === 1 ? Pe = _L(ge.subarray(4, 12)) : Pe = we.getUint32(4);
      let dt;
      return typeof Pe == "bigint" ? dt = Pe / B1.BigInt(fe) : typeof Pe == "number" && !isNaN(Pe) && (dt = Pe / fe), dt < Number.MAX_SAFE_INTEGER && (dt = Number(dt)), dt < L && (L = dt), L;
    }, 1 / 0);
    return typeof C == "bigint" || isFinite(C) ? C : 0;
  }, X_ = function(A, x) {
    var k = lr(x, ["moof", "traf"]), C = 0, L = 0, z;
    if (k && k.length) {
      var re = lr(k[0], ["tfhd"])[0], oe = lr(k[0], ["trun"])[0], fe = lr(k[0], ["tfdt"])[0];
      if (re) {
        var ge = yL(re);
        z = ge.trackId;
      }
      if (fe) {
        var we = TL(fe);
        C = we.baseMediaDecodeTime;
      }
      if (oe) {
        var Pe = vL(oe);
        Pe.samples && Pe.samples.length && (L = Pe.samples[0].compositionTimeOffset || 0);
      }
    }
    var dt = A[z] || 9e4;
    typeof C == "bigint" && (L = B1.BigInt(L), dt = B1.BigInt(dt));
    var ze = (C + L) / dt;
    return typeof ze == "bigint" && ze < Number.MAX_SAFE_INTEGER && (ze = Number(ze)), ze;
  }, K_ = function(A) {
    var x = lr(A, ["moov", "trak"]), k = [];
    return x.forEach(function(C) {
      var L = lr(C, ["mdia", "hdlr"]), z = lr(C, ["tkhd"]);
      L.forEach(function(re, oe) {
        var fe = Al(re.subarray(8, 12)), ge = z[oe], we, Pe, dt;
        fe === "vide" && (we = new DataView(ge.buffer, ge.byteOffset, ge.byteLength), Pe = we.getUint8(0), dt = Pe === 0 ? we.getUint32(12) : we.getUint32(20), k.push(dt));
      });
    }), k;
  }, R1 = function(A) {
    var x = A[0], k = x === 0 ? 12 : 20;
    return Jh(A[k] << 24 | A[k + 1] << 16 | A[k + 2] << 8 | A[k + 3]);
  }, Z_ = function(A) {
    var x = lr(A, ["moov", "trak"]), k = [];
    return x.forEach(function(C) {
      var L = {}, z = lr(C, ["tkhd"])[0], re, oe;
      z && (re = new DataView(z.buffer, z.byteOffset, z.byteLength), oe = re.getUint8(0), L.id = oe === 0 ? re.getUint32(12) : re.getUint32(20));
      var fe = lr(C, ["mdia", "hdlr"])[0];
      if (fe) {
        var ge = Al(fe.subarray(8, 12));
        ge === "vide" ? L.type = "video" : ge === "soun" ? L.type = "audio" : L.type = ge;
      }
      var we = lr(C, ["mdia", "minf", "stbl", "stsd"])[0];
      if (we) {
        var Pe = we.subarray(8);
        L.codec = Al(Pe.subarray(4, 8));
        var dt = lr(Pe, [L.codec])[0], ze, St;
        dt && (/^[asm]vc[1-9]$/i.test(L.codec) ? (ze = dt.subarray(78), St = Al(ze.subarray(4, 8)), St === "avcC" && ze.length > 11 ? (L.codec += ".", L.codec += dd(ze[9]), L.codec += dd(ze[10]), L.codec += dd(ze[11])) : L.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(L.codec) ? (ze = dt.subarray(28), St = Al(ze.subarray(4, 8)), St === "esds" && ze.length > 20 && ze[19] !== 0 ? (L.codec += "." + dd(ze[19]), L.codec += "." + dd(ze[20] >>> 2 & 63).replace(/^0/, "")) : L.codec = "mp4a.40.2") : L.codec = L.codec.toLowerCase());
      }
      var Wt = lr(C, ["mdia", "mdhd"])[0];
      Wt && (L.timescale = R1(Wt)), k.push(L);
    }), k;
  }, J_ = function(A, x = 0) {
    var k = lr(A, ["emsg"]);
    return k.map((C) => {
      var L = P1.parseEmsgBox(new Uint8Array(C)), z = EL(L.message_data);
      return {
        cueTime: P1.scaleTime(L.presentation_time, L.timescale, L.presentation_time_delta, x),
        duration: P1.scaleTime(L.event_duration, L.timescale),
        frames: z
      };
    });
  };
  var fd = {
    // export mp4 inspector's findBox and parseType for backwards compatibility
    findBox: lr,
    parseType: Al,
    timescale: G_,
    startTime: Y_,
    compositionStartTime: X_,
    videoTrackIds: K_,
    tracks: Z_,
    getTimescaleFromMediaHeader: R1,
    getEmsgID3: J_
  };
  const {
    parseTrun: xL
  } = V_, {
    findBox: e3
  } = fd;
  var t3 = Q_, wL = function(A) {
    var x = e3(A, ["moof", "traf"]), k = e3(A, ["mdat"]), C = [];
    return k.forEach(function(L, z) {
      var re = x[z];
      C.push({
        mdat: L,
        traf: re
      });
    }), C;
  }, CL = function(A, x, k) {
    var C = x, L = k.defaultSampleDuration || 0, z = k.defaultSampleSize || 0, re = k.trackId, oe = [];
    return A.forEach(function(fe) {
      var ge = xL(fe), we = ge.samples;
      we.forEach(function(Pe) {
        Pe.duration === void 0 && (Pe.duration = L), Pe.size === void 0 && (Pe.size = z), Pe.trackId = re, Pe.dts = C, Pe.compositionTimeOffset === void 0 && (Pe.compositionTimeOffset = 0), typeof C == "bigint" ? (Pe.pts = C + t3.BigInt(Pe.compositionTimeOffset), C += t3.BigInt(Pe.duration)) : (Pe.pts = C + Pe.compositionTimeOffset, C += Pe.duration);
      }), oe = oe.concat(we);
    }), oe;
  }, n3 = {
    getMdatTrafPairs: wL,
    parseSamples: CL
  }, SL = Kn.discardEmulationPreventionBytes, IL = Fh.CaptionStream, F1 = N1, kL = L1, DL = H_, {
    getMdatTrafPairs: ML,
    parseSamples: OL
  } = n3, NL = function(A, x) {
    for (var k = A, C = 0; C < x.length; C++) {
      var L = x[C];
      if (k < L.size)
        return L;
      k -= L.size;
    }
    return null;
  }, LL = function(A, x, k) {
    var C = new DataView(A.buffer, A.byteOffset, A.byteLength), L = {
      logs: [],
      seiNals: []
    }, z, re, oe, fe;
    for (re = 0; re + 4 < A.length; re += oe)
      if (oe = C.getUint32(re), re += 4, !(oe <= 0))
        switch (A[re] & 31) {
          case 6:
            var ge = A.subarray(re + 1, re + 1 + oe), we = NL(re, x);
            if (z = {
              nalUnitType: "sei_rbsp",
              size: oe,
              data: ge,
              escapedRBSP: SL(ge),
              trackId: k
            }, we)
              z.pts = we.pts, z.dts = we.dts, fe = we;
            else if (fe)
              z.pts = fe.pts, z.dts = fe.dts;
            else {
              L.logs.push({
                level: "warn",
                message: "We've encountered a nal unit without data at " + re + " for trackId " + k + ". See mux.js#223."
              });
              break;
            }
            L.seiNals.push(z);
            break;
        }
    return L;
  }, PL = function(A, x) {
    var k = {}, C = ML(A);
    return C.forEach(function(L) {
      var z = L.mdat, re = L.traf, oe = F1(re, ["tfhd"]), fe = DL(oe[0]), ge = fe.trackId, we = F1(re, ["tfdt"]), Pe = we.length > 0 ? kL(we[0]).baseMediaDecodeTime : 0, dt = F1(re, ["trun"]), ze, St;
      x === ge && dt.length > 0 && (ze = OL(dt, Pe, fe), St = LL(z, ze, ge), k[ge] || (k[ge] = {
        seiNals: [],
        logs: []
      }), k[ge].seiNals = k[ge].seiNals.concat(St.seiNals), k[ge].logs = k[ge].logs.concat(St.logs));
    }), k;
  }, RL = function(A, x, k) {
    var C;
    if (x === null)
      return null;
    C = PL(A, x);
    var L = C[x] || {};
    return {
      seiNals: L.seiNals,
      logs: L.logs,
      timescale: k
    };
  }, BL = function() {
    var A = !1, x, k, C, L, z, re;
    this.isInitialized = function() {
      return A;
    }, this.init = function(oe) {
      x = new IL(), A = !0, re = oe ? oe.isPartial : !1, x.on("data", function(fe) {
        fe.startTime = fe.startPts / L, fe.endTime = fe.endPts / L, z.captions.push(fe), z.captionStreams[fe.stream] = !0;
      }), x.on("log", function(fe) {
        z.logs.push(fe);
      });
    }, this.isNewInit = function(oe, fe) {
      return oe && oe.length === 0 || fe && typeof fe == "object" && Object.keys(fe).length === 0 ? !1 : C !== oe[0] || L !== fe[C];
    }, this.parse = function(oe, fe, ge) {
      var we;
      if (this.isInitialized()) {
        if (!fe || !ge)
          return null;
        if (this.isNewInit(fe, ge))
          C = fe[0], L = ge[C];
        else if (C === null || !L)
          return k.push(oe), null;
      } else return null;
      for (; k.length > 0; ) {
        var Pe = k.shift();
        this.parse(Pe, fe, ge);
      }
      return we = RL(oe, C, L), we && we.logs && (z.logs = z.logs.concat(we.logs)), we === null || !we.seiNals ? z.logs.length ? {
        logs: z.logs,
        captions: [],
        captionStreams: []
      } : null : (this.pushNals(we.seiNals), this.flushStream(), z);
    }, this.pushNals = function(oe) {
      if (!this.isInitialized() || !oe || oe.length === 0)
        return null;
      oe.forEach(function(fe) {
        x.push(fe);
      });
    }, this.flushStream = function() {
      if (!this.isInitialized())
        return null;
      re ? x.partialFlush() : x.flush();
    }, this.clearParsedCaptions = function() {
      z.captions = [], z.captionStreams = {}, z.logs = [];
    }, this.resetCaptionStream = function() {
      if (!this.isInitialized())
        return null;
      x.reset();
    }, this.clearAllCaptions = function() {
      this.clearParsedCaptions(), this.resetCaptionStream();
    }, this.reset = function() {
      k = [], C = null, L = null, z ? this.clearParsedCaptions() : z = {
        captions: [],
        // CC1, CC2, CC3, CC4
        captionStreams: {},
        logs: []
      }, this.resetCaptionStream();
    }, this.reset();
  }, FL = BL;
  const {
    parseTfdt: UL
  } = V_, Za = N1, {
    getTimescaleFromMediaHeader: $L
  } = fd, {
    parseSamples: HL,
    getMdatTrafPairs: jL
  } = n3;
  var r3 = function() {
    let A = 9e4;
    this.init = function(x) {
      const k = Za(x, ["moov", "trak", "mdia", "mdhd"])[0];
      k && (A = $L(k));
    }, this.parseSegment = function(x) {
      const k = [], C = jL(x);
      let L = 0;
      return C.forEach(function(z) {
        const re = z.mdat, oe = z.traf, fe = Za(oe, ["tfdt"])[0], ge = Za(oe, ["tfhd"])[0], we = Za(oe, ["trun"]);
        if (fe && (L = UL(fe).baseMediaDecodeTime), we.length && ge) {
          const Pe = HL(we, L, ge);
          let dt = 0;
          Pe.forEach(function(ze) {
            const St = "utf-8", Wt = new TextDecoder(St), Cr = re.slice(dt, dt + ze.size);
            if (Za(Cr, ["vtte"])[0]) {
              dt += ze.size;
              return;
            }
            Za(Cr, ["vttc"]).forEach(function(hd) {
              const pd = Za(hd, ["payl"])[0], md = Za(hd, ["sttg"])[0], gd = ze.pts / A, np = (ze.pts + ze.duration) / A;
              let zn, Ad;
              if (pd)
                try {
                  zn = Wt.decode(pd);
                } catch (ys) {
                  console.error(ys);
                }
              if (md)
                try {
                  Ad = Wt.decode(md);
                } catch (ys) {
                  console.error(ys);
                }
              ze.duration && zn && k.push({
                cueText: zn,
                start: gd,
                end: np,
                settings: Ad
              });
            }), dt += ze.size;
          });
        }
      }), k;
    };
  }, U1 = al, i3 = function(A) {
    var x = A[1] & 31;
    return x <<= 8, x |= A[2], x;
  }, ep = function(A) {
    return !!(A[1] & 64);
  }, tp = function(A) {
    var x = 0;
    return (A[3] & 48) >>> 4 > 1 && (x += A[4] + 1), x;
  }, zL = function(A, x) {
    var k = i3(A);
    return k === 0 ? "pat" : k === x ? "pmt" : x ? "pes" : null;
  }, qL = function(A) {
    var x = ep(A), k = 4 + tp(A);
    return x && (k += A[k] + 1), (A[k + 10] & 31) << 8 | A[k + 11];
  }, VL = function(A) {
    var x = {}, k = ep(A), C = 4 + tp(A);
    if (k && (C += A[C] + 1), !!(A[C + 5] & 1)) {
      var L, z, re;
      L = (A[C + 1] & 15) << 8 | A[C + 2], z = 3 + L - 4, re = (A[C + 10] & 15) << 8 | A[C + 11];
      for (var oe = 12 + re; oe < z; ) {
        var fe = C + oe;
        x[(A[fe + 1] & 31) << 8 | A[fe + 2]] = A[fe], oe += ((A[fe + 3] & 15) << 8 | A[fe + 4]) + 5;
      }
      return x;
    }
  }, WL = function(A, x) {
    var k = i3(A), C = x[k];
    switch (C) {
      case U1.H264_STREAM_TYPE:
        return "video";
      case U1.ADTS_STREAM_TYPE:
        return "audio";
      case U1.METADATA_STREAM_TYPE:
        return "timed-metadata";
      default:
        return null;
    }
  }, QL = function(A) {
    var x = ep(A);
    if (!x)
      return null;
    var k = 4 + tp(A);
    if (k >= A.byteLength)
      return null;
    var C = null, L;
    return L = A[k + 7], L & 192 && (C = {}, C.pts = (A[k + 9] & 14) << 27 | (A[k + 10] & 255) << 20 | (A[k + 11] & 254) << 12 | (A[k + 12] & 255) << 5 | (A[k + 13] & 254) >>> 3, C.pts *= 4, C.pts += (A[k + 13] & 6) >>> 1, C.dts = C.pts, L & 64 && (C.dts = (A[k + 14] & 14) << 27 | (A[k + 15] & 255) << 20 | (A[k + 16] & 254) << 12 | (A[k + 17] & 255) << 5 | (A[k + 18] & 254) >>> 3, C.dts *= 4, C.dts += (A[k + 18] & 6) >>> 1)), C;
  }, $1 = function(A) {
    switch (A) {
      case 5:
        return "slice_layer_without_partitioning_rbsp_idr";
      case 6:
        return "sei_rbsp";
      case 7:
        return "seq_parameter_set_rbsp";
      case 8:
        return "pic_parameter_set_rbsp";
      case 9:
        return "access_unit_delimiter_rbsp";
      default:
        return null;
    }
  }, GL = function(A) {
    for (var x = 4 + tp(A), k = A.subarray(x), C = 0, L = 0, z = !1, re; L < k.byteLength - 3; L++)
      if (k[L + 2] === 1) {
        C = L + 5;
        break;
      }
    for (; C < k.byteLength; )
      switch (k[C]) {
        case 0:
          if (k[C - 1] !== 0) {
            C += 2;
            break;
          } else if (k[C - 2] !== 0) {
            C++;
            break;
          }
          L + 3 !== C - 2 && (re = $1(k[L + 3] & 31), re === "slice_layer_without_partitioning_rbsp_idr" && (z = !0));
          do
            C++;
          while (k[C] !== 1 && C < k.length);
          L = C - 2, C += 3;
          break;
        case 1:
          if (k[C - 1] !== 0 || k[C - 2] !== 0) {
            C += 3;
            break;
          }
          re = $1(k[L + 3] & 31), re === "slice_layer_without_partitioning_rbsp_idr" && (z = !0), L = C - 2, C += 3;
          break;
        default:
          C += 3;
          break;
      }
    return k = k.subarray(L), C -= L, L = 0, k && k.byteLength > 3 && (re = $1(k[L + 3] & 31), re === "slice_layer_without_partitioning_rbsp_idr" && (z = !0)), z;
  }, YL = {
    parseType: zL,
    parsePat: qL,
    parsePmt: VL,
    parsePayloadUnitStartIndicator: ep,
    parsePesType: WL,
    parsePesTime: QL,
    videoPacketContainsKeyFrame: GL
  }, s3 = al, bl = $h.handleRollover, Cn = {};
  Cn.ts = YL, Cn.aac = bi;
  var Yo = Tt.ONE_SECOND_IN_TS, si = 188, qs = 71, XL = function(A, x) {
    for (var k = 0, C = si, L, z; C < A.byteLength; ) {
      if (A[k] === qs && A[C] === qs) {
        switch (L = A.subarray(k, C), z = Cn.ts.parseType(L, x.pid), z) {
          case "pat":
            x.pid = Cn.ts.parsePat(L);
            break;
          case "pmt":
            var re = Cn.ts.parsePmt(L);
            x.table = x.table || {}, Object.keys(re).forEach(function(oe) {
              x.table[oe] = re[oe];
            });
            break;
        }
        k += si, C += si;
        continue;
      }
      k++, C++;
    }
  }, a3 = function(A, x, k) {
    for (var C = 0, L = si, z, re, oe, fe, ge, we = !1; L <= A.byteLength; ) {
      if (A[C] === qs && (A[L] === qs || L === A.byteLength)) {
        switch (z = A.subarray(C, L), re = Cn.ts.parseType(z, x.pid), re) {
          case "pes":
            oe = Cn.ts.parsePesType(z, x.table), fe = Cn.ts.parsePayloadUnitStartIndicator(z), oe === "audio" && fe && (ge = Cn.ts.parsePesTime(z), ge && (ge.type = "audio", k.audio.push(ge), we = !0));
            break;
        }
        if (we)
          break;
        C += si, L += si;
        continue;
      }
      C++, L++;
    }
    for (L = A.byteLength, C = L - si, we = !1; C >= 0; ) {
      if (A[C] === qs && (A[L] === qs || L === A.byteLength)) {
        switch (z = A.subarray(C, L), re = Cn.ts.parseType(z, x.pid), re) {
          case "pes":
            oe = Cn.ts.parsePesType(z, x.table), fe = Cn.ts.parsePayloadUnitStartIndicator(z), oe === "audio" && fe && (ge = Cn.ts.parsePesTime(z), ge && (ge.type = "audio", k.audio.push(ge), we = !0));
            break;
        }
        if (we)
          break;
        C -= si, L -= si;
        continue;
      }
      C--, L--;
    }
  }, KL = function(A, x, k) {
    for (var C = 0, L = si, z, re, oe, fe, ge, we, Pe, dt, ze = !1, St = {
      data: [],
      size: 0
    }; L < A.byteLength; ) {
      if (A[C] === qs && A[L] === qs) {
        switch (z = A.subarray(C, L), re = Cn.ts.parseType(z, x.pid), re) {
          case "pes":
            if (oe = Cn.ts.parsePesType(z, x.table), fe = Cn.ts.parsePayloadUnitStartIndicator(z), oe === "video" && (fe && !ze && (ge = Cn.ts.parsePesTime(z), ge && (ge.type = "video", k.video.push(ge), ze = !0)), !k.firstKeyFrame)) {
              if (fe && St.size !== 0) {
                for (we = new Uint8Array(St.size), Pe = 0; St.data.length; )
                  dt = St.data.shift(), we.set(dt, Pe), Pe += dt.byteLength;
                if (Cn.ts.videoPacketContainsKeyFrame(we)) {
                  var Wt = Cn.ts.parsePesTime(we);
                  Wt ? (k.firstKeyFrame = Wt, k.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                }
                St.size = 0;
              }
              St.data.push(z), St.size += z.byteLength;
            }
            break;
        }
        if (ze && k.firstKeyFrame)
          break;
        C += si, L += si;
        continue;
      }
      C++, L++;
    }
    for (L = A.byteLength, C = L - si, ze = !1; C >= 0; ) {
      if (A[C] === qs && A[L] === qs) {
        switch (z = A.subarray(C, L), re = Cn.ts.parseType(z, x.pid), re) {
          case "pes":
            oe = Cn.ts.parsePesType(z, x.table), fe = Cn.ts.parsePayloadUnitStartIndicator(z), oe === "video" && fe && (ge = Cn.ts.parsePesTime(z), ge && (ge.type = "video", k.video.push(ge), ze = !0));
            break;
        }
        if (ze)
          break;
        C -= si, L -= si;
        continue;
      }
      C--, L--;
    }
  }, ZL = function(A, x) {
    if (A.audio && A.audio.length) {
      var k = x;
      (typeof k > "u" || isNaN(k)) && (k = A.audio[0].dts), A.audio.forEach(function(z) {
        z.dts = bl(z.dts, k), z.pts = bl(z.pts, k), z.dtsTime = z.dts / Yo, z.ptsTime = z.pts / Yo;
      });
    }
    if (A.video && A.video.length) {
      var C = x;
      if ((typeof C > "u" || isNaN(C)) && (C = A.video[0].dts), A.video.forEach(function(z) {
        z.dts = bl(z.dts, C), z.pts = bl(z.pts, C), z.dtsTime = z.dts / Yo, z.ptsTime = z.pts / Yo;
      }), A.firstKeyFrame) {
        var L = A.firstKeyFrame;
        L.dts = bl(L.dts, C), L.pts = bl(L.pts, C), L.dtsTime = L.dts / Yo, L.ptsTime = L.pts / Yo;
      }
    }
  }, JL = function(A) {
    for (var x = !1, k = 0, C = null, L = null, z = 0, re = 0, oe; A.length - re >= 3; ) {
      var fe = Cn.aac.parseType(A, re);
      switch (fe) {
        case "timed-metadata":
          if (A.length - re < 10) {
            x = !0;
            break;
          }
          if (z = Cn.aac.parseId3TagSize(A, re), z > A.length) {
            x = !0;
            break;
          }
          L === null && (oe = A.subarray(re, re + z), L = Cn.aac.parseAacTimestamp(oe)), re += z;
          break;
        case "audio":
          if (A.length - re < 7) {
            x = !0;
            break;
          }
          if (z = Cn.aac.parseAdtsSize(A, re), z > A.length) {
            x = !0;
            break;
          }
          C === null && (oe = A.subarray(re, re + z), C = Cn.aac.parseSampleRate(oe)), k++, re += z;
          break;
        default:
          re++;
          break;
      }
      if (x)
        return null;
    }
    if (C === null || L === null)
      return null;
    var ge = Yo / C, we = {
      audio: [{
        type: "audio",
        dts: L,
        pts: L
      }, {
        type: "audio",
        dts: L + k * 1024 * ge,
        pts: L + k * 1024 * ge
      }]
    };
    return we;
  }, e7 = function(A) {
    var x = {
      pid: null,
      table: null
    }, k = {};
    XL(A, x);
    for (var C in x.table)
      if (x.table.hasOwnProperty(C)) {
        var L = x.table[C];
        switch (L) {
          case s3.H264_STREAM_TYPE:
            k.video = [], KL(A, x, k), k.video.length === 0 && delete k.video;
            break;
          case s3.ADTS_STREAM_TYPE:
            k.audio = [], a3(A, x, k), k.audio.length === 0 && delete k.audio;
            break;
        }
      }
    return k;
  }, t7 = function(A, x) {
    var k = Cn.aac.isLikelyAacData(A), C;
    return k ? C = JL(A) : C = e7(A), !C || !C.audio && !C.video ? null : (ZL(C, x), C);
  }, n7 = {
    inspect: t7,
    parseAudioPes_: a3
  };
  const r7 = function(A, x) {
    x.on("data", function(k) {
      const C = k.initSegment;
      k.initSegment = {
        data: C.buffer,
        byteOffset: C.byteOffset,
        byteLength: C.byteLength
      };
      const L = k.data;
      k.data = L.buffer, A.postMessage({
        action: "data",
        segment: k,
        byteOffset: L.byteOffset,
        byteLength: L.byteLength
      }, [k.data]);
    }), x.on("done", function(k) {
      A.postMessage({
        action: "done"
      });
    }), x.on("gopInfo", function(k) {
      A.postMessage({
        action: "gopInfo",
        gopInfo: k
      });
    }), x.on("videoSegmentTimingInfo", function(k) {
      const C = {
        start: {
          decode: Tt.videoTsToSeconds(k.start.dts),
          presentation: Tt.videoTsToSeconds(k.start.pts)
        },
        end: {
          decode: Tt.videoTsToSeconds(k.end.dts),
          presentation: Tt.videoTsToSeconds(k.end.pts)
        },
        baseMediaDecodeTime: Tt.videoTsToSeconds(k.baseMediaDecodeTime)
      };
      k.prependedContentDuration && (C.prependedContentDuration = Tt.videoTsToSeconds(k.prependedContentDuration)), A.postMessage({
        action: "videoSegmentTimingInfo",
        videoSegmentTimingInfo: C
      });
    }), x.on("audioSegmentTimingInfo", function(k) {
      const C = {
        start: {
          decode: Tt.videoTsToSeconds(k.start.dts),
          presentation: Tt.videoTsToSeconds(k.start.pts)
        },
        end: {
          decode: Tt.videoTsToSeconds(k.end.dts),
          presentation: Tt.videoTsToSeconds(k.end.pts)
        },
        baseMediaDecodeTime: Tt.videoTsToSeconds(k.baseMediaDecodeTime)
      };
      k.prependedContentDuration && (C.prependedContentDuration = Tt.videoTsToSeconds(k.prependedContentDuration)), A.postMessage({
        action: "audioSegmentTimingInfo",
        audioSegmentTimingInfo: C
      });
    }), x.on("id3Frame", function(k) {
      A.postMessage({
        action: "id3Frame",
        id3Frame: k
      });
    }), x.on("caption", function(k) {
      A.postMessage({
        action: "caption",
        caption: k
      });
    }), x.on("trackinfo", function(k) {
      A.postMessage({
        action: "trackinfo",
        trackInfo: k
      });
    }), x.on("audioTimingInfo", function(k) {
      A.postMessage({
        action: "audioTimingInfo",
        audioTimingInfo: {
          start: Tt.videoTsToSeconds(k.start),
          end: Tt.videoTsToSeconds(k.end)
        }
      });
    }), x.on("videoTimingInfo", function(k) {
      A.postMessage({
        action: "videoTimingInfo",
        videoTimingInfo: {
          start: Tt.videoTsToSeconds(k.start),
          end: Tt.videoTsToSeconds(k.end)
        }
      });
    }), x.on("log", function(k) {
      A.postMessage({
        action: "log",
        log: k
      });
    });
  };
  class o3 {
    constructor(x, k) {
      this.options = k || {}, this.self = x, this.init();
    }
    /**
     * initialize our web worker and wire all the events.
     */
    init() {
      this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new J9.Transmuxer(this.options), r7(this.self, this.transmuxer);
    }
    pushMp4Captions(x) {
      this.captionParser || (this.captionParser = new FL(), this.captionParser.init());
      const k = new Uint8Array(x.data, x.byteOffset, x.byteLength), C = this.captionParser.parse(k, x.trackIds, x.timescales);
      this.self.postMessage({
        action: "mp4Captions",
        captions: C && C.captions || [],
        logs: C && C.logs || [],
        data: k.buffer
      }, [k.buffer]);
    }
    /**
     * Initializes the WebVttParser and passes the init segment.
     *
     * @param {Uint8Array} data mp4 boxed WebVTT init segment data
     */
    initMp4WebVttParser(x) {
      this.webVttParser || (this.webVttParser = new r3());
      const k = new Uint8Array(x.data, x.byteOffset, x.byteLength);
      this.webVttParser.init(k);
    }
    /**
     * Parse an mp4 encapsulated WebVTT segment and return an array of cues.
     *
     * @param {Uint8Array} data a text/webvtt segment
     * @return {Object[]} an array of parsed cue objects
     */
    getMp4WebVttText(x) {
      this.webVttParser || (this.webVttParser = new r3());
      const k = new Uint8Array(x.data, x.byteOffset, x.byteLength), C = this.webVttParser.parseSegment(k);
      this.self.postMessage({
        action: "getMp4WebVttText",
        mp4VttCues: C || [],
        data: k.buffer
      }, [k.buffer]);
    }
    probeMp4StartTime({
      timescales: x,
      data: k
    }) {
      const C = fd.startTime(x, k);
      this.self.postMessage({
        action: "probeMp4StartTime",
        startTime: C,
        data: k
      }, [k.buffer]);
    }
    probeMp4Tracks({
      data: x
    }) {
      const k = fd.tracks(x);
      this.self.postMessage({
        action: "probeMp4Tracks",
        tracks: k,
        data: x
      }, [x.buffer]);
    }
    /**
     * Probes an mp4 segment for EMSG boxes containing ID3 data.
     * https://aomediacodec.github.io/id3-emsg/
     *
     * @param {Uint8Array} data segment data
     * @param {number} offset segment start time
     * @return {Object[]} an array of ID3 frames
     */
    probeEmsgID3({
      data: x,
      offset: k
    }) {
      const C = fd.getEmsgID3(x, k);
      this.self.postMessage({
        action: "probeEmsgID3",
        id3Frames: C,
        emsgData: x
      }, [x.buffer]);
    }
    /**
     * Probe an mpeg2-ts segment to determine the start time of the segment in it's
     * internal "media time," as well as whether it contains video and/or audio.
     *
     * @private
     * @param {Uint8Array} bytes - segment bytes
     * @param {number} baseStartTime
     *        Relative reference timestamp used when adjusting frame timestamps for rollover.
     *        This value should be in seconds, as it's converted to a 90khz clock within the
     *        function body.
     * @return {Object} The start time of the current segment in "media time" as well as
     *                  whether it contains video and/or audio
     */
    probeTs({
      data: x,
      baseStartTime: k
    }) {
      const C = typeof k == "number" && !isNaN(k) ? k * Tt.ONE_SECOND_IN_TS : void 0, L = n7.inspect(x, C);
      let z = null;
      L && (z = {
        // each type's time info comes back as an array of 2 times, start and end
        hasVideo: L.video && L.video.length === 2 || !1,
        hasAudio: L.audio && L.audio.length === 2 || !1
      }, z.hasVideo && (z.videoStart = L.video[0].ptsTime), z.hasAudio && (z.audioStart = L.audio[0].ptsTime)), this.self.postMessage({
        action: "probeTs",
        result: z,
        data: x
      }, [x.buffer]);
    }
    clearAllMp4Captions() {
      this.captionParser && this.captionParser.clearAllCaptions();
    }
    clearParsedMp4Captions() {
      this.captionParser && this.captionParser.clearParsedCaptions();
    }
    /**
     * Adds data (a ts segment) to the start of the transmuxer pipeline for
     * processing.
     *
     * @param {ArrayBuffer} data data to push into the muxer
     */
    push(x) {
      const k = new Uint8Array(x.data, x.byteOffset, x.byteLength);
      this.transmuxer.push(k);
    }
    /**
     * Recreate the transmuxer so that the next segment added via `push`
     * start with a fresh transmuxer.
     */
    reset() {
      this.transmuxer.reset();
    }
    /**
     * Set the value that will be used as the `baseMediaDecodeTime` time for the
     * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`
     * set relative to the first based on the PTS values.
     *
     * @param {Object} data used to set the timestamp offset in the muxer
     */
    setTimestampOffset(x) {
      const k = x.timestampOffset || 0;
      this.transmuxer.setBaseMediaDecodeTime(Math.round(Tt.secondsToVideoTs(k)));
    }
    setAudioAppendStart(x) {
      this.transmuxer.setAudioAppendStart(Math.ceil(Tt.secondsToVideoTs(x.appendStart)));
    }
    setRemux(x) {
      this.transmuxer.setRemux(x.remux);
    }
    /**
     * Forces the pipeline to finish processing the last segment and emit it's
     * results.
     *
     * @param {Object} data event data, not really used
     */
    flush(x) {
      this.transmuxer.flush(), self.postMessage({
        action: "done",
        type: "transmuxed"
      });
    }
    endTimeline() {
      this.transmuxer.endTimeline(), self.postMessage({
        action: "endedtimeline",
        type: "transmuxed"
      });
    }
    alignGopsWith(x) {
      this.transmuxer.alignGopsWith(x.gopsToAlignWith.slice());
    }
  }
  self.onmessage = function(A) {
    if (A.data.action === "init" && A.data.options) {
      this.messageHandlers = new o3(self, A.data.options);
      return;
    }
    this.messageHandlers || (this.messageHandlers = new o3(self)), A.data && A.data.action && A.data.action !== "init" && this.messageHandlers[A.data.action] && this.messageHandlers[A.data.action](A.data);
  };
}));
var DSe = yM(kSe);
const MSe = (t, e, n) => {
  const {
    type: r,
    initSegment: i,
    captions: s,
    captionStreams: a,
    metadata: o,
    videoFrameDtsTime: u,
    videoFramePtsTime: c
  } = t.data.segment;
  e.buffer.push({
    captions: s,
    captionStreams: a,
    metadata: o
  });
  const d = t.data.segment.boxes || {
    data: t.data.segment.data
  }, l = {
    type: r,
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(d.data, d.data.byteOffset, d.data.byteLength),
    initSegment: new Uint8Array(i.data, i.byteOffset, i.byteLength)
  };
  typeof u < "u" && (l.videoFrameDtsTime = u), typeof c < "u" && (l.videoFramePtsTime = c), n(l);
}, OSe = ({
  transmuxedData: t,
  callback: e
}) => {
  t.buffer = [], e(t);
}, NSe = (t, e) => {
  e.gopInfo = t.data.gopInfo;
}, _M = (t) => {
  const {
    transmuxer: e,
    bytes: n,
    audioAppendStart: r,
    gopsToAlignWith: i,
    remux: s,
    onData: a,
    onTrackInfo: o,
    onAudioTimingInfo: u,
    onVideoTimingInfo: c,
    onVideoSegmentTimingInfo: d,
    onAudioSegmentTimingInfo: l,
    onId3: f,
    onCaptions: p,
    onDone: m,
    onEndedTimeline: g,
    onTransmuxerLog: y,
    isEndOfTimeline: b,
    segment: E,
    triggerSegmentEventFn: v
  } = t, _ = {
    buffer: []
  };
  let D = b;
  const S = (O) => {
    e.currentTransmux === t && (O.data.action === "data" && MSe(O, _, a), O.data.action === "trackinfo" && o(O.data.trackInfo), O.data.action === "gopInfo" && NSe(O, _), O.data.action === "audioTimingInfo" && u(O.data.audioTimingInfo), O.data.action === "videoTimingInfo" && c(O.data.videoTimingInfo), O.data.action === "videoSegmentTimingInfo" && d(O.data.videoSegmentTimingInfo), O.data.action === "audioSegmentTimingInfo" && l(O.data.audioSegmentTimingInfo), O.data.action === "id3Frame" && f([O.data.id3Frame], O.data.id3Frame.dispatchType), O.data.action === "caption" && p(O.data.caption), O.data.action === "endedtimeline" && (D = !1, g()), O.data.action === "log" && y(O.data.log), O.data.type === "transmuxed" && (D || (e.onmessage = null, OSe({
      transmuxedData: _,
      callback: m
    }), EM(e))));
  }, M = () => {
    const O = {
      message: "Received an error message from the transmuxer worker",
      metadata: {
        errorType: Me.Error.StreamingFailedToTransmuxSegment,
        segmentInfo: cu({
          segment: E
        })
      }
    };
    m(null, O);
  };
  if (e.onmessage = S, e.onerror = M, r && e.postMessage({
    action: "setAudioAppendStart",
    appendStart: r
  }), Array.isArray(i) && e.postMessage({
    action: "alignGopsWith",
    gopsToAlignWith: i
  }), typeof s < "u" && e.postMessage({
    action: "setRemux",
    remux: s
  }), n.byteLength) {
    const O = n instanceof ArrayBuffer ? n : n.buffer, T = n instanceof ArrayBuffer ? 0 : n.byteOffset;
    v({
      type: "segmenttransmuxingstart",
      segment: E
    }), e.postMessage({
      action: "push",
      // Send the typed-array of data as an ArrayBuffer so that
      // it can be sent as a "Transferable" and avoid the costly
      // memory copy
      data: O,
      // To recreate the original typed-array, we need information
      // about what portion of the ArrayBuffer it was a view into
      byteOffset: T,
      byteLength: n.byteLength
    }, [O]);
  }
  b && e.postMessage({
    action: "endTimeline"
  }), e.postMessage({
    action: "flush"
  });
}, EM = (t) => {
  t.currentTransmux = null, t.transmuxQueue.length && (t.currentTransmux = t.transmuxQueue.shift(), typeof t.currentTransmux == "function" ? t.currentTransmux() : _M(t.currentTransmux));
}, Aw = (t, e) => {
  t.postMessage({
    action: e
  }), EM(t);
}, xM = (t, e) => {
  if (!e.currentTransmux) {
    e.currentTransmux = t, Aw(e, t);
    return;
  }
  e.transmuxQueue.push(Aw.bind(null, e, t));
}, LSe = (t) => {
  xM("reset", t);
}, PSe = (t) => {
  xM("endTimeline", t);
}, wM = (t) => {
  if (!t.transmuxer.currentTransmux) {
    t.transmuxer.currentTransmux = t, _M(t);
    return;
  }
  t.transmuxer.transmuxQueue.push(t);
}, RSe = (t) => {
  const e = new DSe();
  e.currentTransmux = null, e.transmuxQueue = [];
  const n = e.terminate;
  return e.terminate = () => (e.currentTransmux = null, e.transmuxQueue.length = 0, n.call(e)), e.postMessage({
    action: "init",
    options: t
  }), e;
};
var c2 = {
  reset: LSe,
  endTimeline: PSe,
  transmux: wM,
  createTransmuxer: RSe
};
const Xl = function(t) {
  const e = t.transmuxer, n = t.endAction || t.action, r = t.callback, i = fr({}, t, {
    endAction: null,
    transmuxer: null,
    callback: null
  }), s = (a) => {
    a.data.action === n && (e.removeEventListener("message", s), a.data.data && (a.data.data = new Uint8Array(a.data.data, t.byteOffset || 0, t.byteLength || a.data.data.byteLength), t.data && (t.data = a.data.data)), r(a.data));
  };
  if (e.addEventListener("message", s), t.data) {
    const a = t.data instanceof ArrayBuffer;
    i.byteOffset = a ? 0 : t.data.byteOffset, i.byteLength = t.data.byteLength;
    const o = [a ? t.data : t.data.buffer];
    e.postMessage(i, o);
  } else
    e.postMessage(i);
}, ia = {
  FAILURE: 2,
  TIMEOUT: -101,
  ABORTED: -102
}, CM = "wvtt", dy = (t) => {
  t.forEach((e) => {
    e.abort();
  });
}, BSe = (t) => ({
  bandwidth: t.bandwidth,
  bytesReceived: t.bytesReceived || 0,
  roundTripTime: t.roundTripTime || 0
}), FSe = (t) => {
  const e = t.target, r = {
    bandwidth: 1 / 0,
    bytesReceived: 0,
    roundTripTime: Date.now() - e.requestTime || 0
  };
  return r.bytesReceived = t.loaded, r.bandwidth = Math.floor(r.bytesReceived / r.roundTripTime * 8 * 1e3), r;
}, zT = (t, e) => {
  const {
    requestType: n
  } = e, r = Mu({
    requestType: n,
    request: e,
    error: t
  });
  return e.timedout ? {
    status: e.status,
    message: "HLS request timed-out at URL: " + e.uri,
    code: ia.TIMEOUT,
    xhr: e,
    metadata: r
  } : e.aborted ? {
    status: e.status,
    message: "HLS request aborted at URL: " + e.uri,
    code: ia.ABORTED,
    xhr: e,
    metadata: r
  } : t ? {
    status: e.status,
    message: "HLS request errored at URL: " + e.uri,
    code: ia.FAILURE,
    xhr: e,
    metadata: r
  } : e.responseType === "arraybuffer" && e.response.byteLength === 0 ? {
    status: e.status,
    message: "Empty HLS response at URL: " + e.uri,
    code: ia.FAILURE,
    xhr: e,
    metadata: r
  } : null;
}, bw = (t, e, n, r) => (i, s) => {
  const a = s.response, o = zT(i, s);
  if (o)
    return n(o, t);
  if (a.byteLength !== 16)
    return n({
      status: s.status,
      message: "Invalid HLS key at URL: " + s.uri,
      code: ia.FAILURE,
      xhr: s
    }, t);
  const u = new DataView(a), c = new Uint32Array([u.getUint32(0), u.getUint32(4), u.getUint32(8), u.getUint32(12)]);
  for (let l = 0; l < e.length; l++)
    e[l].bytes = c;
  const d = {
    uri: s.uri
  };
  return r({
    type: "segmentkeyloadcomplete",
    segment: t,
    keyInfo: d
  }), n(null, t);
}, USe = (t, e) => {
  e === CM && t.transmuxer.postMessage({
    action: "initMp4WebVttParser",
    data: t.map.bytes
  });
}, $Se = (t, e, n) => {
  e === CM && Xl({
    action: "getMp4WebVttText",
    data: t.bytes,
    transmuxer: t.transmuxer,
    callback: ({
      data: r,
      mp4VttCues: i
    }) => {
      t.bytes = r, n(null, t, {
        mp4VttCues: i
      });
    }
  });
}, SM = (t, e) => {
  const n = fT(t.map.bytes);
  if (n !== "mp4") {
    const r = t.map.resolvedUri || t.map.uri, i = n || "unknown";
    return e({
      internal: !0,
      message: `Found unsupported ${i} container for initialization segment at URL: ${r}`,
      code: ia.FAILURE,
      metadata: {
        mediaType: i
      }
    });
  }
  Xl({
    action: "probeMp4Tracks",
    data: t.map.bytes,
    transmuxer: t.transmuxer,
    callback: ({
      tracks: r,
      data: i
    }) => (t.map.bytes = i, r.forEach(function(s) {
      t.map.tracks = t.map.tracks || {}, !t.map.tracks[s.type] && (t.map.tracks[s.type] = s, typeof s.id == "number" && s.timescale && (t.map.timescales = t.map.timescales || {}, t.map.timescales[s.id] = s.timescale), s.type === "text" && USe(t, s.codec));
    }), e(null))
  });
}, HSe = ({
  segment: t,
  finishProcessingFn: e,
  triggerSegmentEventFn: n
}) => (r, i) => {
  const s = zT(r, i);
  if (s)
    return e(s, t);
  const a = new Uint8Array(i.response);
  if (n({
    type: "segmentloaded",
    segment: t
  }), t.map.key)
    return t.map.encryptedBytes = a, e(null, t);
  t.map.bytes = a, SM(t, function(o) {
    if (o)
      return o.xhr = i, o.status = i.status, e(o, t);
    e(null, t);
  });
}, jSe = ({
  segment: t,
  finishProcessingFn: e,
  responseType: n,
  triggerSegmentEventFn: r
}) => (i, s) => {
  const a = zT(i, s);
  if (a)
    return e(a, t);
  r({
    type: "segmentloaded",
    segment: t
  });
  const o = (
    // although responseText "should" exist, this guard serves to prevent an error being
    // thrown for two primary cases:
    // 1. the mime type override stops working, or is not implemented for a specific
    //    browser
    // 2. when using mock XHR libraries like sinon that do not allow the override behavior
    n === "arraybuffer" || !s.responseText ? s.response : SSe(s.responseText.substring(t.lastReachedChar || 0))
  );
  return t.stats = BSe(s), t.key ? t.encryptedBytes = new Uint8Array(o) : t.bytes = new Uint8Array(o), e(null, t);
}, zSe = ({
  segment: t,
  bytes: e,
  trackInfoFn: n,
  timingInfoFn: r,
  videoSegmentTimingInfoFn: i,
  audioSegmentTimingInfoFn: s,
  id3Fn: a,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: d,
  doneFn: l,
  onTransmuxerLog: f,
  triggerSegmentEventFn: p
}) => {
  const m = t.map && t.map.tracks || {}, g = !!(m.audio && m.video);
  let y = r.bind(null, t, "audio", "start");
  const b = r.bind(null, t, "audio", "end");
  let E = r.bind(null, t, "video", "start");
  const v = r.bind(null, t, "video", "end"), _ = () => wM({
    bytes: e,
    transmuxer: t.transmuxer,
    audioAppendStart: t.audioAppendStart,
    gopsToAlignWith: t.gopsToAlignWith,
    remux: g,
    onData: (D) => {
      D.type = D.type === "combined" ? "video" : D.type, d(t, D);
    },
    onTrackInfo: (D) => {
      n && (g && (D.isMuxed = !0), n(t, D));
    },
    onAudioTimingInfo: (D) => {
      y && typeof D.start < "u" && (y(D.start), y = null), b && typeof D.end < "u" && b(D.end);
    },
    onVideoTimingInfo: (D) => {
      E && typeof D.start < "u" && (E(D.start), E = null), v && typeof D.end < "u" && v(D.end);
    },
    onVideoSegmentTimingInfo: (D) => {
      const S = {
        pts: {
          start: D.start.presentation,
          end: D.end.presentation
        },
        dts: {
          start: D.start.decode,
          end: D.end.decode
        }
      };
      p({
        type: "segmenttransmuxingtiminginfoavailable",
        segment: t,
        timingInfo: S
      }), i(D);
    },
    onAudioSegmentTimingInfo: (D) => {
      const S = {
        pts: {
          start: D.start.pts,
          end: D.end.pts
        },
        dts: {
          start: D.start.dts,
          end: D.end.dts
        }
      };
      p({
        type: "segmenttransmuxingtiminginfoavailable",
        segment: t,
        timingInfo: S
      }), s(D);
    },
    onId3: (D, S) => {
      a(t, D, S);
    },
    onCaptions: (D) => {
      o(t, [D]);
    },
    isEndOfTimeline: u,
    onEndedTimeline: () => {
      c();
    },
    onTransmuxerLog: f,
    onDone: (D, S) => {
      l && (D.type = D.type === "combined" ? "video" : D.type, p({
        type: "segmenttransmuxingcomplete",
        segment: t
      }), l(S, t, D));
    },
    segment: t,
    triggerSegmentEventFn: p
  });
  Xl({
    action: "probeTs",
    transmuxer: t.transmuxer,
    data: e,
    baseStartTime: t.baseStartTime,
    callback: (D) => {
      t.bytes = e = D.data;
      const S = D.result;
      S && (n(t, {
        hasAudio: S.hasAudio,
        hasVideo: S.hasVideo,
        isMuxed: g
      }), n = null), _();
    }
  });
}, IM = ({
  segment: t,
  bytes: e,
  trackInfoFn: n,
  timingInfoFn: r,
  videoSegmentTimingInfoFn: i,
  audioSegmentTimingInfoFn: s,
  id3Fn: a,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: d,
  doneFn: l,
  onTransmuxerLog: f,
  triggerSegmentEventFn: p
}) => {
  let m = new Uint8Array(e);
  if (cwe(m)) {
    t.isFmp4 = !0;
    const {
      tracks: g
    } = t.map;
    if (g.text && (!g.audio || !g.video)) {
      d(t, {
        data: m,
        type: "text"
      }), $Se(t, g.text.codec, l);
      return;
    }
    const b = {
      isFmp4: !0,
      hasVideo: !!g.video,
      hasAudio: !!g.audio
    };
    g.audio && g.audio.codec && g.audio.codec !== "enca" && (b.audioCodec = g.audio.codec), g.video && g.video.codec && g.video.codec !== "encv" && (b.videoCodec = g.video.codec), g.video && g.audio && (b.isMuxed = !0), n(t, b);
    const E = (v, _) => {
      d(t, {
        data: m,
        type: b.hasAudio && !b.isMuxed ? "audio" : "video"
      }), _ && _.length && a(t, _), v && v.length && o(t, v), l(null, t, {});
    };
    Xl({
      action: "probeMp4StartTime",
      timescales: t.map.timescales,
      data: m,
      transmuxer: t.transmuxer,
      callback: ({
        data: v,
        startTime: _
      }) => {
        e = v.buffer, t.bytes = m = v, b.hasAudio && !b.isMuxed && r(t, "audio", "start", _), b.hasVideo && r(t, "video", "start", _), Xl({
          action: "probeEmsgID3",
          data: m,
          transmuxer: t.transmuxer,
          offset: _,
          callback: ({
            emsgData: D,
            id3Frames: S
          }) => {
            if (e = D.buffer, t.bytes = m = D, !g.video || !D.byteLength || !t.transmuxer) {
              E(void 0, S);
              return;
            }
            Xl({
              action: "pushMp4Captions",
              endAction: "mp4Captions",
              transmuxer: t.transmuxer,
              data: m,
              timescales: t.map.timescales,
              trackIds: [g.video.id],
              callback: (M) => {
                e = M.data.buffer, t.bytes = m = M.data, M.logs.forEach(function(O) {
                  f(xn(O, {
                    stream: "mp4CaptionParser"
                  }));
                }), E(M.captions, S);
              }
            });
          }
        });
      }
    });
    return;
  }
  if (!t.transmuxer) {
    l(null, t, {});
    return;
  }
  if (typeof t.container > "u" && (t.container = fT(m)), t.container !== "ts" && t.container !== "aac") {
    n(t, {
      hasAudio: !1,
      hasVideo: !1
    }), l(null, t, {});
    return;
  }
  zSe({
    segment: t,
    bytes: e,
    trackInfoFn: n,
    timingInfoFn: r,
    videoSegmentTimingInfoFn: i,
    audioSegmentTimingInfoFn: s,
    id3Fn: a,
    captionsFn: o,
    isEndOfTimeline: u,
    endedTimelineFn: c,
    dataFn: d,
    doneFn: l,
    onTransmuxerLog: f,
    triggerSegmentEventFn: p
  });
}, kM = function({
  id: t,
  key: e,
  encryptedBytes: n,
  decryptionWorker: r,
  segment: i,
  doneFn: s
}, a) {
  const o = (c) => {
    if (c.data.source === t) {
      r.removeEventListener("message", o);
      const d = c.data.decrypted;
      a(new Uint8Array(d.bytes, d.byteOffset, d.byteLength));
    }
  };
  r.onerror = () => {
    const c = "An error occurred in the decryption worker", d = cu({
      segment: i
    }), l = {
      message: c,
      metadata: {
        error: new Error(c),
        errorType: Me.Error.StreamingFailedToDecryptSegment,
        segmentInfo: d,
        keyInfo: {
          uri: i.key.resolvedUri || i.map.key.resolvedUri
        }
      }
    };
    s(l, i);
  }, r.addEventListener("message", o);
  let u;
  e.bytes.slice ? u = e.bytes.slice() : u = new Uint32Array(Array.prototype.slice.call(e.bytes)), r.postMessage(hM({
    source: t,
    encrypted: n,
    key: u,
    iv: e.iv
  }), [n.buffer, u.buffer]);
}, qSe = ({
  decryptionWorker: t,
  segment: e,
  trackInfoFn: n,
  timingInfoFn: r,
  videoSegmentTimingInfoFn: i,
  audioSegmentTimingInfoFn: s,
  id3Fn: a,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: d,
  doneFn: l,
  onTransmuxerLog: f,
  triggerSegmentEventFn: p
}) => {
  p({
    type: "segmentdecryptionstart"
  }), kM({
    id: e.requestId,
    key: e.key,
    encryptedBytes: e.encryptedBytes,
    decryptionWorker: t,
    segment: e,
    doneFn: l
  }, (m) => {
    e.bytes = m, p({
      type: "segmentdecryptioncomplete",
      segment: e
    }), IM({
      segment: e,
      bytes: e.bytes,
      trackInfoFn: n,
      timingInfoFn: r,
      videoSegmentTimingInfoFn: i,
      audioSegmentTimingInfoFn: s,
      id3Fn: a,
      captionsFn: o,
      isEndOfTimeline: u,
      endedTimelineFn: c,
      dataFn: d,
      doneFn: l,
      onTransmuxerLog: f,
      triggerSegmentEventFn: p
    });
  });
}, VSe = ({
  activeXhrs: t,
  decryptionWorker: e,
  trackInfoFn: n,
  timingInfoFn: r,
  videoSegmentTimingInfoFn: i,
  audioSegmentTimingInfoFn: s,
  id3Fn: a,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: d,
  doneFn: l,
  onTransmuxerLog: f,
  triggerSegmentEventFn: p
}) => {
  let m = 0, g = !1;
  return (y, b) => {
    if (!g) {
      if (y)
        return g = !0, dy(t), l(y, b);
      if (m += 1, m === t.length) {
        const E = function() {
          if (b.encryptedBytes)
            return qSe({
              decryptionWorker: e,
              segment: b,
              trackInfoFn: n,
              timingInfoFn: r,
              videoSegmentTimingInfoFn: i,
              audioSegmentTimingInfoFn: s,
              id3Fn: a,
              captionsFn: o,
              isEndOfTimeline: u,
              endedTimelineFn: c,
              dataFn: d,
              doneFn: l,
              onTransmuxerLog: f,
              triggerSegmentEventFn: p
            });
          IM({
            segment: b,
            bytes: b.bytes,
            trackInfoFn: n,
            timingInfoFn: r,
            videoSegmentTimingInfoFn: i,
            audioSegmentTimingInfoFn: s,
            id3Fn: a,
            captionsFn: o,
            isEndOfTimeline: u,
            endedTimelineFn: c,
            dataFn: d,
            doneFn: l,
            onTransmuxerLog: f,
            triggerSegmentEventFn: p
          });
        };
        if (b.endOfAllRequests = Date.now(), b.map && b.map.encryptedBytes && !b.map.bytes)
          return p({
            type: "segmentdecryptionstart",
            segment: b
          }), kM({
            decryptionWorker: e,
            // add -init to the "id" to differentiate between segment
            // and init segment decryption, just in case they happen
            // at the same time at some point in the future.
            id: b.requestId + "-init",
            encryptedBytes: b.map.encryptedBytes,
            key: b.map.key,
            segment: b,
            doneFn: l
          }, (v) => {
            b.map.bytes = v, p({
              type: "segmentdecryptioncomplete",
              segment: b
            }), SM(b, (_) => {
              if (_)
                return dy(t), l(_, b);
              E();
            });
          });
        E();
      }
    }
  };
}, WSe = ({
  loadendState: t,
  abortFn: e
}) => (n) => {
  n.target.aborted && e && !t.calledAbortFn && (e(), t.calledAbortFn = !0);
}, QSe = ({
  segment: t,
  progressFn: e,
  trackInfoFn: n,
  timingInfoFn: r,
  videoSegmentTimingInfoFn: i,
  audioSegmentTimingInfoFn: s,
  id3Fn: a,
  captionsFn: o,
  isEndOfTimeline: u,
  endedTimelineFn: c,
  dataFn: d
}) => (l) => {
  if (!l.target.aborted)
    return t.stats = xn(t.stats, FSe(l)), !t.stats.firstBytesReceivedAt && t.stats.bytesReceived && (t.stats.firstBytesReceivedAt = Date.now()), e(l, t);
}, GSe = ({
  xhr: t,
  xhrOptions: e,
  decryptionWorker: n,
  segment: r,
  abortFn: i,
  progressFn: s,
  trackInfoFn: a,
  timingInfoFn: o,
  videoSegmentTimingInfoFn: u,
  audioSegmentTimingInfoFn: c,
  id3Fn: d,
  captionsFn: l,
  isEndOfTimeline: f,
  endedTimelineFn: p,
  dataFn: m,
  doneFn: g,
  onTransmuxerLog: y,
  triggerSegmentEventFn: b
}) => {
  const E = [], v = VSe({
    activeXhrs: E,
    decryptionWorker: n,
    trackInfoFn: a,
    timingInfoFn: o,
    videoSegmentTimingInfoFn: u,
    audioSegmentTimingInfoFn: c,
    id3Fn: d,
    captionsFn: l,
    isEndOfTimeline: f,
    endedTimelineFn: p,
    dataFn: m,
    doneFn: g,
    onTransmuxerLog: y,
    triggerSegmentEventFn: b
  });
  if (r.key && !r.key.bytes) {
    const O = [r.key];
    r.map && !r.map.bytes && r.map.key && r.map.key.resolvedUri === r.key.resolvedUri && O.push(r.map.key);
    const T = xn(e, {
      uri: r.key.resolvedUri,
      responseType: "arraybuffer",
      requestType: "segment-key"
    }), N = bw(r, O, v, b), H = {
      uri: r.key.resolvedUri
    };
    b({
      type: "segmentkeyloadstart",
      segment: r,
      keyInfo: H
    });
    const $ = t(T, N);
    E.push($);
  }
  if (r.map && !r.map.bytes) {
    if (r.map.key && (!r.key || r.key.resolvedUri !== r.map.key.resolvedUri)) {
      const $ = xn(e, {
        uri: r.map.key.resolvedUri,
        responseType: "arraybuffer",
        requestType: "segment-key"
      }), j = bw(r, [r.map.key], v, b), U = {
        uri: r.map.key.resolvedUri
      };
      b({
        type: "segmentkeyloadstart",
        segment: r,
        keyInfo: U
      });
      const V = t($, j);
      E.push(V);
    }
    const T = xn(e, {
      uri: r.map.resolvedUri,
      responseType: "arraybuffer",
      headers: ly(r.map),
      requestType: "segment-media-initialization"
    }), N = HSe({
      segment: r,
      finishProcessingFn: v,
      triggerSegmentEventFn: b
    });
    b({
      type: "segmentloadstart",
      segment: r
    });
    const H = t(T, N);
    E.push(H);
  }
  const _ = xn(e, {
    uri: r.part && r.part.resolvedUri || r.resolvedUri,
    responseType: "arraybuffer",
    headers: ly(r),
    requestType: "segment"
  }), D = jSe({
    segment: r,
    finishProcessingFn: v,
    responseType: _.responseType,
    triggerSegmentEventFn: b
  });
  b({
    type: "segmentloadstart",
    segment: r
  });
  const S = t(_, D);
  S.addEventListener("progress", QSe({
    segment: r,
    progressFn: s,
    trackInfoFn: a,
    timingInfoFn: o,
    videoSegmentTimingInfoFn: u,
    audioSegmentTimingInfoFn: c,
    id3Fn: d,
    captionsFn: l,
    isEndOfTimeline: f,
    endedTimelineFn: p,
    dataFn: m
  })), E.push(S);
  const M = {};
  return E.forEach((O) => {
    O.addEventListener("loadend", WSe({
      loadendState: M,
      abortFn: i
    }));
  }), () => dy(E);
}, Lp = gs("PlaylistSelector"), yw = function(t) {
  if (!t || !t.playlist)
    return;
  const e = t.playlist;
  return JSON.stringify({
    id: e.id,
    bandwidth: t.bandwidth,
    width: t.width,
    height: t.height,
    codecs: e.attributes && e.attributes.CODECS || ""
  });
}, Kl = function(t, e) {
  if (!t)
    return "";
  const n = pe.getComputedStyle(t);
  return n ? n[e] : "";
}, Zl = function(t, e) {
  const n = t.slice();
  t.sort(function(r, i) {
    const s = e(r, i);
    return s === 0 ? n.indexOf(r) - n.indexOf(i) : s;
  });
}, qT = function(t, e) {
  let n, r;
  return t.attributes.BANDWIDTH && (n = t.attributes.BANDWIDTH), n = n || pe.Number.MAX_VALUE, e.attributes.BANDWIDTH && (r = e.attributes.BANDWIDTH), r = r || pe.Number.MAX_VALUE, n - r;
}, YSe = function(t, e) {
  let n, r;
  return t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (n = t.attributes.RESOLUTION.width), n = n || pe.Number.MAX_VALUE, e.attributes.RESOLUTION && e.attributes.RESOLUTION.width && (r = e.attributes.RESOLUTION.width), r = r || pe.Number.MAX_VALUE, n === r && t.attributes.BANDWIDTH && e.attributes.BANDWIDTH ? t.attributes.BANDWIDTH - e.attributes.BANDWIDTH : n - r;
};
let DM = function(t) {
  const {
    main: e,
    bandwidth: n,
    playerWidth: r,
    playerHeight: i,
    playerObjectFit: s,
    limitRenditionByPlayerDimensions: a,
    playlistController: o
  } = t;
  if (!e)
    return;
  const u = {
    bandwidth: n,
    width: r,
    height: i,
    limitRenditionByPlayerDimensions: a
  };
  let c = e.playlists;
  Si.isAudioOnly(e) && (c = o.getAudioTrackPlaylists_(), u.audioOnly = !0);
  let d = c.map((M) => {
    let O;
    const T = M.attributes && M.attributes.RESOLUTION && M.attributes.RESOLUTION.width, N = M.attributes && M.attributes.RESOLUTION && M.attributes.RESOLUTION.height;
    return O = M.attributes && M.attributes.BANDWIDTH, O = O || pe.Number.MAX_VALUE, {
      bandwidth: O,
      width: T,
      height: N,
      playlist: M
    };
  });
  Zl(d, (M, O) => M.bandwidth - O.bandwidth), d = d.filter((M) => !Si.isIncompatible(M.playlist));
  let l = d.filter((M) => Si.isEnabled(M.playlist));
  l.length || (l = d.filter((M) => !Si.isDisabled(M.playlist)));
  const f = l.filter((M) => M.bandwidth * Ir.BANDWIDTH_VARIANCE < n);
  let p = f[f.length - 1];
  const m = f.filter((M) => M.bandwidth === p.bandwidth)[0];
  if (a === !1) {
    const M = m || l[0] || d[0];
    if (M && M.playlist) {
      let O = "sortedPlaylistReps";
      return m && (O = "bandwidthBestRep"), l[0] && (O = "enabledPlaylistReps"), Lp(`choosing ${yw(M)} using ${O} with options`, u), M.playlist;
    }
    return Lp("could not choose a playlist with options", u), null;
  }
  const g = f.filter((M) => M.width && M.height);
  Zl(g, (M, O) => M.width - O.width);
  const y = g.filter((M) => M.width === r && M.height === i);
  p = y[y.length - 1];
  const b = y.filter((M) => M.bandwidth === p.bandwidth)[0];
  let E, v, _;
  b || (E = g.filter((M) => s === "cover" ? M.width > r && M.height > i : M.width > r || M.height > i), v = E.filter((M) => M.width === E[0].width && M.height === E[0].height), p = v[v.length - 1], _ = v.filter((M) => M.bandwidth === p.bandwidth)[0]);
  let D;
  if (o.leastPixelDiffSelector) {
    const M = g.map((O) => (O.pixelDiff = Math.abs(O.width - r) + Math.abs(O.height - i), O));
    Zl(M, (O, T) => O.pixelDiff === T.pixelDiff ? T.bandwidth - O.bandwidth : O.pixelDiff - T.pixelDiff), D = M[0];
  }
  const S = D || _ || b || m || l[0] || d[0];
  if (S && S.playlist) {
    let M = "sortedPlaylistReps";
    return D ? M = "leastPixelDiffRep" : _ ? M = "resolutionPlusOneRep" : b ? M = "resolutionBestRep" : m ? M = "bandwidthBestRep" : l[0] && (M = "enabledPlaylistReps"), Lp(`choosing ${yw(S)} using ${M} with options`, u), S.playlist;
  }
  return Lp("could not choose a playlist with options", u), null;
};
const vw = function() {
  let t = this.useDevicePixelRatio && pe.devicePixelRatio || 1;
  return isNaN(this.customPixelRatio) || (t = this.customPixelRatio), DM({
    main: this.playlists.main,
    bandwidth: this.systemBandwidth,
    playerWidth: parseInt(Kl(this.tech_.el(), "width"), 10) * t,
    playerHeight: parseInt(Kl(this.tech_.el(), "height"), 10) * t,
    playerObjectFit: this.usePlayerObjectFit ? Kl(this.tech_.el(), "objectFit") : "",
    limitRenditionByPlayerDimensions: this.limitRenditionByPlayerDimensions,
    playlistController: this.playlistController_
  });
}, XSe = function(t) {
  let e = -1, n = -1;
  if (t < 0 || t > 1)
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  return function() {
    let r = this.useDevicePixelRatio && pe.devicePixelRatio || 1;
    return isNaN(this.customPixelRatio) || (r = this.customPixelRatio), e < 0 && (e = this.systemBandwidth, n = this.systemBandwidth), this.systemBandwidth > 0 && this.systemBandwidth !== n && (e = t * this.systemBandwidth + (1 - t) * e, n = this.systemBandwidth), DM({
      main: this.playlists.main,
      bandwidth: e,
      playerWidth: parseInt(Kl(this.tech_.el(), "width"), 10) * r,
      playerHeight: parseInt(Kl(this.tech_.el(), "height"), 10) * r,
      playerObjectFit: this.usePlayerObjectFit ? Kl(this.tech_.el(), "objectFit") : "",
      limitRenditionByPlayerDimensions: this.limitRenditionByPlayerDimensions,
      playlistController: this.playlistController_
    });
  };
}, KSe = function(t) {
  const {
    main: e,
    currentTime: n,
    bandwidth: r,
    duration: i,
    segmentDuration: s,
    timeUntilRebuffer: a,
    currentTimeline: o,
    syncController: u
  } = t, c = e.playlists.filter((m) => !Si.isIncompatible(m));
  let d = c.filter(Si.isEnabled);
  d.length || (d = c.filter((m) => !Si.isDisabled(m)));
  const f = d.filter(Si.hasAttribute.bind(null, "BANDWIDTH")).map((m) => {
    const y = u.getSyncPoint(m, i, o, n) ? 1 : 2, E = Si.estimateSegmentRequestTime(s, r, m) * y - a;
    return {
      playlist: m,
      rebufferingImpact: E
    };
  }), p = f.filter((m) => m.rebufferingImpact <= 0);
  return Zl(p, (m, g) => qT(g.playlist, m.playlist)), p.length ? p[0] : (Zl(f, (m, g) => m.rebufferingImpact - g.rebufferingImpact), f[0] || null);
}, ZSe = function() {
  const t = this.playlists.main.playlists.filter(Si.isEnabled);
  return Zl(t, (n, r) => qT(n, r)), t.filter((n) => !!vf(this.playlists.main, n).video)[0] || null;
}, JSe = (t) => {
  let e = 0, n;
  return t.bytes && (n = new Uint8Array(t.bytes), t.segments.forEach((r) => {
    n.set(r, e), e += r.byteLength;
  })), n;
};
function MM(t) {
  try {
    return new URL(t).pathname.split("/").slice(-2).join("/");
  } catch {
    return "";
  }
}
const e6e = function(t, e, n) {
  if (!t[n]) {
    e.trigger({
      type: "usage",
      name: "vhs-608"
    });
    let r = n;
    /^cc708_/.test(n) && (r = "SERVICE" + n.split("_")[1]);
    const i = e.textTracks().getTrackById(r);
    if (i)
      t[n] = i;
    else {
      const s = e.options_.vhs && e.options_.vhs.captionServices || {};
      let a = n, o = n, u = !1;
      const c = s[r];
      c && (a = c.label, o = c.language, u = c.default), t[n] = e.addRemoteTextTrack({
        kind: "captions",
        id: r,
        // TODO: investigate why this doesn't seem to turn the caption on by default
        default: u,
        label: a,
        language: o
      }, !1).track;
    }
  }
}, t6e = function({
  inbandTextTracks: t,
  captionArray: e,
  timestampOffset: n
}) {
  if (!e)
    return;
  const r = pe.WebKitDataCue || pe.VTTCue;
  e.forEach((i) => {
    const s = i.stream;
    i.content ? i.content.forEach((a) => {
      const o = new r(i.startTime + n, i.endTime + n, a.text);
      o.line = a.line, o.align = "left", o.position = a.position, o.positionAlign = "line-left", t[s].addCue(o);
    }) : t[s].addCue(new r(i.startTime + n, i.endTime + n, i.text));
  });
}, n6e = function(t) {
  Object.defineProperties(t.frame, {
    id: {
      get() {
        return Me.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), t.value.key;
      }
    },
    value: {
      get() {
        return Me.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), t.value.data;
      }
    },
    privateData: {
      get() {
        return Me.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), t.value.data;
      }
    }
  });
}, r6e = ({
  inbandTextTracks: t,
  metadataArray: e,
  timestampOffset: n,
  videoDuration: r
}) => {
  if (!e)
    return;
  const i = pe.WebKitDataCue || pe.VTTCue, s = t.metadataTrack_;
  if (!s || (e.forEach((d) => {
    const l = d.cueTime + n;
    typeof l != "number" || pe.isNaN(l) || l < 0 || !(l < 1 / 0) || !d.frames || !d.frames.length || d.frames.forEach((f) => {
      const p = new i(l, l, f.value || f.url || f.data || "");
      p.frame = f, p.value = f, n6e(p), s.addCue(p);
    });
  }), !s.cues || !s.cues.length))
    return;
  const a = s.cues, o = [];
  for (let d = 0; d < a.length; d++)
    a[d] && o.push(a[d]);
  const u = o.reduce((d, l) => {
    const f = d[l.startTime] || [];
    return f.push(l), d[l.startTime] = f, d;
  }, {}), c = Object.keys(u).sort((d, l) => Number(d) - Number(l));
  c.forEach((d, l) => {
    const f = u[d], p = isFinite(r) ? r : d, m = Number(c[l + 1]) || p;
    f.forEach((g) => {
      g.endTime = m;
    });
  });
}, i6e = {
  id: "ID",
  class: "CLASS",
  startDate: "START-DATE",
  duration: "DURATION",
  endDate: "END-DATE",
  endOnNext: "END-ON-NEXT",
  plannedDuration: "PLANNED-DURATION",
  scte35Out: "SCTE35-OUT",
  scte35In: "SCTE35-IN"
}, s6e = /* @__PURE__ */ new Set(["id", "class", "startDate", "duration", "endDate", "endOnNext", "startTime", "endTime", "processDateRange"]), a6e = ({
  inbandTextTracks: t,
  dateRanges: e
}) => {
  const n = t.metadataTrack_;
  if (!n)
    return;
  const r = pe.WebKitDataCue || pe.VTTCue;
  e.forEach((i) => {
    for (const s of Object.keys(i)) {
      if (s6e.has(s))
        continue;
      const a = new r(i.startTime, i.endTime, "");
      a.id = i.id, a.type = "com.apple.quicktime.HLS", a.value = {
        key: i6e[s],
        data: i[s]
      }, (s === "scte35Out" || s === "scte35In") && (a.value.data = new Uint8Array(a.value.data.match(/[\da-f]{2}/gi)).buffer), n.addCue(a);
    }
    i.processDateRange();
  });
}, Tw = (t, e, n) => {
  t.metadataTrack_ || (t.metadataTrack_ = n.addRemoteTextTrack({
    kind: "metadata",
    label: "Timed Metadata"
  }, !1).track, Me.browser.IS_ANY_SAFARI || (t.metadataTrack_.inBandMetadataTrackDispatchType = e));
}, Xd = function(t, e, n) {
  let r, i;
  if (n && n.cues)
    for (r = n.cues.length; r--; )
      i = n.cues[r], i.startTime >= t && i.endTime <= e && n.removeCue(i);
}, o6e = function(t) {
  const e = t.cues;
  if (!e)
    return;
  const n = {};
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r], s = `${i.startTime}-${i.endTime}-${i.text}`;
    n[s] ? t.removeCue(i) : n[s] = i;
  }
}, u6e = (t, e, n) => {
  if (typeof e > "u" || e === null || !t.length)
    return [];
  const r = Math.ceil((e - n + 3) * gu.ONE_SECOND_IN_TS);
  let i;
  for (i = 0; i < t.length && !(t[i].pts > r); i++)
    ;
  return t.slice(i);
}, l6e = (t, e, n) => {
  if (!e.length)
    return t;
  if (n)
    return e.slice();
  const r = e[0].pts;
  let i = 0;
  for (i; i < t.length && !(t[i].pts >= r); i++)
    ;
  return t.slice(0, i).concat(e);
}, c6e = (t, e, n, r) => {
  const i = Math.ceil((e - r) * gu.ONE_SECOND_IN_TS), s = Math.ceil((n - r) * gu.ONE_SECOND_IN_TS), a = t.slice();
  let o = t.length;
  for (; o-- && !(t[o].pts <= s); )
    ;
  if (o === -1)
    return a;
  let u = o + 1;
  for (; u-- && !(t[u].pts <= i); )
    ;
  return u = Math.max(u, 0), a.splice(u, o - u + 1), a;
}, d6e = function(t, e) {
  if (!t && !e || !t && e || t && !e)
    return !1;
  if (t === e)
    return !0;
  const n = Object.keys(t).sort(), r = Object.keys(e).sort();
  if (n.length !== r.length)
    return !1;
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    if (s !== r[i] || t[s] !== e[s])
      return !1;
  }
  return !0;
}, f6e = function(t, e, n) {
  e = e || [];
  const r = [];
  let i = 0;
  for (let s = 0; s < e.length; s++) {
    const a = e[s];
    if (t === a.timeline && (r.push(s), i += a.duration, i > n))
      return s;
  }
  return r.length === 0 ? 0 : r[r.length - 1];
}, Pd = 1, h6e = 500, _w = (t) => typeof t == "number" && isFinite(t), Pp = 1 / 60, p6e = (t, e, n) => t !== "main" || !e || !n ? null : !n.hasAudio && !n.hasVideo ? "Neither audio nor video found in segment." : e.hasVideo && !n.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !e.hasVideo && n.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null, m6e = (t, e, n) => {
  let r = e - Ir.BACK_BUFFER_LENGTH;
  t.length && (r = Math.max(r, t.start(0)));
  const i = e - n;
  return Math.min(i, r);
}, Sl = (t) => {
  const {
    startOfSegment: e,
    duration: n,
    segment: r,
    part: i,
    playlist: {
      mediaSequence: s,
      id: a,
      segments: o = []
    },
    mediaIndex: u,
    partIndex: c,
    timeline: d
  } = t, l = o.length - 1;
  let f = "mediaIndex/partIndex increment";
  t.getMediaInfoForTime ? f = `getMediaInfoForTime (${t.getMediaInfoForTime})` : t.isSyncRequest && (f = "getSyncSegmentCandidate (isSyncRequest)"), t.independent && (f += ` with independent ${t.independent}`);
  const p = typeof c == "number", m = t.segment.uri ? "segment" : "pre-segment", g = p ? Y8({
    preloadSegment: r
  }) - 1 : 0;
  return `${m} [${s + u}/${s + l}]` + (p ? ` part [${c}/${g}]` : "") + ` segment start/end [${r.start} => ${r.end}]` + (p ? ` part start/end [${i.start} => ${i.end}]` : "") + ` startOfSegment [${e}] duration [${n}] timeline [${d}] selected by [${f}] playlist [${a}]`;
}, Ew = (t) => `${t}TimingInfo`, g6e = ({
  segmentTimeline: t,
  currentTimeline: e,
  startOfSegment: n,
  buffered: r,
  overrideCheck: i
}) => !i && t === e ? null : t < e ? n : r.length ? r.end(r.length - 1) : n, fy = ({
  timelineChangeController: t,
  currentTimeline: e,
  segmentTimeline: n,
  loaderType: r,
  audioDisabled: i
}) => {
  if (e === n)
    return !1;
  if (r === "audio") {
    const s = t.lastTimelineChange({
      type: "main"
    });
    return !s || s.to !== n;
  }
  if (r === "main" && i) {
    const s = t.pendingTimelineChange({
      type: "audio"
    });
    return !(s && s.to === n);
  }
  return !1;
}, A6e = (t) => {
  if (!t)
    return !1;
  const e = t.pendingTimelineChange({
    type: "audio"
  }), n = t.pendingTimelineChange({
    type: "main"
  }), r = e && n, i = r && e.to !== n.to;
  return !!(r && e.from !== -1 && n.from !== -1 && i);
}, b6e = (t) => {
  const e = t.timelineChangeController_.pendingTimelineChange({
    type: "audio"
  }), n = t.timelineChangeController_.pendingTimelineChange({
    type: "main"
  });
  return e && n && e.to < n.to;
}, io = (t) => {
  const e = t.pendingSegment_;
  if (!e)
    return;
  if (fy({
    timelineChangeController: t.timelineChangeController_,
    currentTimeline: t.currentTimeline_,
    segmentTimeline: e.timeline,
    loaderType: t.loaderType_,
    audioDisabled: t.audioDisabled_
  }) && A6e(t.timelineChangeController_)) {
    if (b6e(t)) {
      t.timelineChangeController_.trigger("audioTimelineBehind");
      return;
    }
    t.timelineChangeController_.trigger("fixBadTimelineChange");
  }
}, y6e = (t) => {
  let e = 0;
  return ["video", "audio"].forEach(function(n) {
    const r = t[`${n}TimingInfo`];
    if (!r)
      return;
    const {
      start: i,
      end: s
    } = r;
    let a;
    typeof i == "bigint" || typeof s == "bigint" ? a = pe.BigInt(s) - pe.BigInt(i) : typeof i == "number" && typeof s == "number" && (a = s - i), typeof a < "u" && a > e && (e = a);
  }), typeof e == "bigint" && e < Number.MAX_SAFE_INTEGER && (e = Number(e)), e;
}, xw = ({
  segmentDuration: t,
  maxDuration: e
}) => t ? Math.round(t) > e + na : !1, v6e = (t, e) => {
  if (e !== "hls")
    return null;
  const n = y6e({
    audioTimingInfo: t.audioTimingInfo,
    videoTimingInfo: t.videoTimingInfo
  });
  if (!n)
    return null;
  const r = t.playlist.targetDuration, i = xw({
    segmentDuration: n,
    maxDuration: r * 2
  }), s = xw({
    segmentDuration: n,
    maxDuration: r
  }), a = `Segment with index ${t.mediaIndex} from playlist ${t.playlist.id} has a duration of ${n} when the reported duration is ${t.duration} and the target duration is ${r}. For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1`;
  return i || s ? {
    severity: i ? "warn" : "info",
    message: a
  } : null;
}, cu = ({
  type: t,
  segment: e
}) => {
  if (!e)
    return;
  const n = !!(e.key || e.map && e.map.ke), r = !!(e.map && !e.map.bytes), i = e.startOfSegment === void 0 ? e.start : e.startOfSegment;
  return {
    type: t || e.type,
    uri: e.resolvedUri || e.uri,
    start: i,
    duration: e.duration,
    isEncrypted: n,
    isMediaInitialization: r
  };
};
class hy extends Me.EventTarget {
  constructor(e, n = {}) {
    if (super(), !e)
      throw new TypeError("Initialization settings are required");
    if (typeof e.currentTime != "function")
      throw new TypeError("No currentTime getter specified");
    if (!e.mediaSource)
      throw new TypeError("No MediaSource specified");
    this.bandwidth = e.bandwidth, this.throughput = {
      rate: 0,
      count: 0
    }, this.roundTrip = NaN, this.resetStats_(), this.mediaIndex = null, this.partIndex = null, this.hasPlayed_ = e.hasPlayed, this.currentTime_ = e.currentTime, this.seekable_ = e.seekable, this.seeking_ = e.seeking, this.duration_ = e.duration, this.mediaSource_ = e.mediaSource, this.vhs_ = e.vhs, this.loaderType_ = e.loaderType, this.currentMediaInfo_ = void 0, this.startingMediaInfo_ = void 0, this.segmentMetadataTrack_ = e.segmentMetadataTrack, this.goalBufferLength_ = e.goalBufferLength, this.sourceType_ = e.sourceType, this.sourceUpdater_ = e.sourceUpdater, this.inbandTextTracks_ = e.inbandTextTracks, this.state_ = "INIT", this.timelineChangeController_ = e.timelineChangeController, this.shouldSaveSegmentTimingInfo_ = !0, this.parse708captions_ = e.parse708captions, this.useDtsForTimestampOffset_ = e.useDtsForTimestampOffset, this.captionServices_ = e.captionServices, this.exactManifestTimings = e.exactManifestTimings, this.addMetadataToTextTrack = e.addMetadataToTextTrack, this.checkBufferTimeout_ = null, this.error_ = void 0, this.currentTimeline_ = -1, this.shouldForceTimestampOffsetAfterResync_ = !1, this.pendingSegment_ = null, this.xhrOptions_ = null, this.pendingSegments_ = [], this.audioDisabled_ = !1, this.isPendingTimestampOffset_ = !1, this.gopBuffer_ = [], this.timeMapping_ = 0, this.safeAppend_ = !1, this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    }, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_ = {
      id3: [],
      caption: []
    }, this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = null, this.activeInitSegmentId_ = null, this.initSegments_ = {}, this.cacheEncryptionKeys_ = e.cacheEncryptionKeys, this.keyCache_ = {}, this.decrypter_ = e.decrypter, this.syncController_ = e.syncController, this.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    }, this.transmuxer_ = this.createTransmuxer_(), this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate"), this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_), this.mediaSource_.addEventListener("sourceopen", () => {
      this.isEndOfStream_() || (this.ended_ = !1);
    }), this.fetchAtBuffer_ = !1, this.logger_ = gs(`SegmentLoader[${this.loaderType_}]`), Object.defineProperty(this, "state", {
      get() {
        return this.state_;
      },
      set(r) {
        r !== this.state_ && (this.logger_(`${this.state_} -> ${r}`), this.state_ = r, this.trigger("statechange"));
      }
    }), this.sourceUpdater_.on("ready", () => {
      this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : io(this);
    }), this.sourceUpdater_.on("codecschange", (r) => {
      this.trigger(fr({
        type: "codecschange"
      }, r));
    }), this.loaderType_ === "main" && this.timelineChangeController_.on("pendingtimelinechange", () => {
      this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : io(this);
    }), this.loaderType_ === "audio" && this.timelineChangeController_.on("timelinechange", (r) => {
      this.trigger(fr({
        type: "timelinechange"
      }, r)), this.hasEnoughInfoToLoad_() ? this.processLoadQueue_() : io(this), this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : io(this);
    });
  }
  /**
   * TODO: Current sync controller consists of many hls-specific strategies
   * media sequence sync is also hls-specific, and we would like to be protocol-agnostic on this level
   * this should be a part of the sync-controller and sync controller should expect different strategy list based on the protocol.
   *
   * @return {MediaSequenceSync|null}
   * @private
   */
  get mediaSequenceSync_() {
    return this.syncController_.getMediaSequenceSync(this.loaderType_);
  }
  createTransmuxer_() {
    return c2.createTransmuxer({
      remux: !1,
      alignGopsAtEnd: this.safeAppend_,
      keepOriginalTimestamps: !0,
      parse708captions: this.parse708captions_,
      captionServices: this.captionServices_
    });
  }
  /**
   * reset all of our media stats
   *
   * @private
   */
  resetStats_() {
    this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0, this.mediaAppends = 0;
  }
  /**
   * dispose of the SegmentLoader and reset to the default state
   */
  dispose() {
    this.trigger("dispose"), this.state = "DISPOSED", this.pause(), this.abort_(), this.transmuxer_ && this.transmuxer_.terminate(), this.resetStats_(), this.checkBufferTimeout_ && pe.clearTimeout(this.checkBufferTimeout_), this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_), this.off();
  }
  setAudio(e) {
    this.audioDisabled_ = !e, e ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_());
  }
  /**
   * abort anything that is currently doing on with the SegmentLoader
   * and reset to a default state
   */
  abort() {
    if (this.state !== "WAITING") {
      this.pendingSegment_ && (this.pendingSegment_ = null), this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
      return;
    }
    this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_();
  }
  /**
   * abort all pending xhr requests and null any pending segements
   *
   * @private
   */
  abort_() {
    this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null, this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_), this.waitingOnRemove_ = !1, pe.clearTimeout(this.quotaExceededErrorRetryTimeout_), this.quotaExceededErrorRetryTimeout_ = null;
  }
  checkForAbort_(e) {
    return this.state === "APPENDING" && !this.pendingSegment_ ? (this.state = "READY", !0) : !this.pendingSegment_ || this.pendingSegment_.requestId !== e;
  }
  /**
   * set an error on the segment loader and null out any pending segements
   *
   * @param {Error} error the error to set on the SegmentLoader
   * @return {Error} the error that was set or that is currently set
   */
  error(e) {
    return typeof e < "u" && (this.logger_("error occurred:", e), this.error_ = e), this.pendingSegment_ = null, this.error_;
  }
  endOfStream() {
    this.ended_ = !0, this.transmuxer_ && c2.reset(this.transmuxer_), this.gopBuffer_.length = 0, this.pause(), this.trigger("ended");
  }
  /**
   * Indicates which time ranges are buffered
   *
   * @return {TimeRange}
   *         TimeRange object representing the current buffered ranges
   */
  buffered_() {
    const e = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !e)
      return Mr();
    if (this.loaderType_ === "main") {
      const {
        hasAudio: n,
        hasVideo: r,
        isMuxed: i
      } = e;
      if (r && n && !this.audioDisabled_ && !i)
        return this.sourceUpdater_.buffered();
      if (r)
        return this.sourceUpdater_.videoBuffered();
    }
    return this.sourceUpdater_.audioBuffered();
  }
  /**
   * Gets and sets init segment for the provided map
   *
   * @param {Object} map
   *        The map object representing the init segment to get or set
   * @param {boolean=} set
   *        If true, the init segment for the provided map should be saved
   * @return {Object}
   *         map object for desired init segment
   */
  initSegmentForMap(e, n = !1) {
    if (!e)
      return null;
    const r = T0(e);
    let i = this.initSegments_[r];
    return n && !i && e.bytes && (this.initSegments_[r] = i = {
      resolvedUri: e.resolvedUri,
      byterange: e.byterange,
      bytes: e.bytes,
      tracks: e.tracks,
      timescales: e.timescales
    }), i || e;
  }
  /**
   * Gets and sets key for the provided key
   *
   * @param {Object} key
   *        The key object representing the key to get or set
   * @param {boolean=} set
   *        If true, the key for the provided key should be saved
   * @return {Object}
   *         Key object for desired key
   */
  segmentKey(e, n = !1) {
    if (!e)
      return null;
    const r = pM(e);
    let i = this.keyCache_[r];
    this.cacheEncryptionKeys_ && n && !i && e.bytes && (this.keyCache_[r] = i = {
      resolvedUri: e.resolvedUri,
      bytes: e.bytes
    });
    const s = {
      resolvedUri: (i || e).resolvedUri
    };
    return i && (s.bytes = i.bytes), s;
  }
  /**
   * Returns true if all configuration required for loading is present, otherwise false.
   *
   * @return {boolean} True if the all configuration is ready for loading
   * @private
   */
  couldBeginLoading_() {
    return this.playlist_ && !this.paused();
  }
  /**
   * load a playlist and start to fill the buffer
   */
  load() {
    if (this.monitorBuffer_(), !!this.playlist_) {
      if (this.state === "INIT" && this.couldBeginLoading_())
        return this.init_();
      !this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT" || (this.state = "READY");
    }
  }
  /**
   * Once all the starting parameters have been specified, begin
   * operation. This method should only be invoked from the INIT
   * state.
   *
   * @private
   */
  init_() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }
  /**
   * set a playlist on the segment loader
   *
   * @param {PlaylistLoader} media the playlist to set on the segment loader
   */
  playlist(e, n = {}) {
    if (!e || this.playlist_ && this.playlist_.endList && e.endList && this.playlist_.uri === e.uri)
      return;
    const r = this.playlist_, i = this.pendingSegment_;
    this.playlist_ = e, this.xhrOptions_ = n, this.state === "INIT" && (e.syncInfo = {
      mediaSequence: e.mediaSequence,
      time: 0
    }, this.loaderType_ === "main" && this.syncController_.setDateTimeMappingForStart(e));
    let s = null;
    if (r && (r.id ? s = r.id : r.uri && (s = r.uri)), this.logger_(`playlist update [${s} => ${e.id || e.uri}]`), this.mediaSequenceSync_ && (this.mediaSequenceSync_.update(e, this.currentTime_()), this.logger_(`Playlist update:
currentTime: ${this.currentTime_()}
bufferedEnd: ${u2(this.buffered_())}
`, this.mediaSequenceSync_.diagnostics)), this.trigger("syncinfoupdate"), this.state === "INIT" && this.couldBeginLoading_())
      return this.init_();
    if (!r || r.uri !== e.uri) {
      this.mediaIndex !== null && (!e.endList && typeof e.partTargetDuration == "number" ? this.resetLoader() : this.resyncLoader()), this.currentMediaInfo_ = void 0, this.trigger("playlistupdate");
      return;
    }
    const a = e.mediaSequence - r.mediaSequence;
    if (this.logger_(`live window shift [${a}]`), this.mediaIndex !== null)
      if (this.mediaIndex -= a, this.mediaIndex < 0)
        this.mediaIndex = null, this.partIndex = null;
      else {
        const o = this.playlist_.segments[this.mediaIndex];
        if (this.partIndex && (!o.parts || !o.parts.length || !o.parts[this.partIndex])) {
          const u = this.mediaIndex;
          this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`), this.resetLoader(), this.mediaIndex = u;
        }
      }
    i && (i.mediaIndex -= a, i.mediaIndex < 0 ? (i.mediaIndex = null, i.partIndex = null) : (i.mediaIndex >= 0 && (i.segment = e.segments[i.mediaIndex]), i.partIndex >= 0 && i.segment.parts && (i.part = i.segment.parts[i.partIndex]))), this.syncController_.saveExpiredSegmentInfo(r, e);
  }
  /**
   * Prevent the loader from fetching additional segments. If there
   * is a segment request outstanding, it will finish processing
   * before the loader halts. A segment loader can be unpaused by
   * calling load().
   */
  pause() {
    this.checkBufferTimeout_ && (pe.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null);
  }
  /**
   * Returns whether the segment loader is fetching additional
   * segments when given the opportunity. This property can be
   * modified through calls to pause() and load().
   */
  paused() {
    return this.checkBufferTimeout_ === null;
  }
  /**
   * Delete all the buffered data and reset the SegmentLoader
   *
   * @param {Function} [done] an optional callback to be executed when the remove
   * operation is complete
   */
  resetEverything(e) {
    this.ended_ = !1, this.activeInitSegmentId_ = null, this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.resetLoader(), this.remove(0, 1 / 0, e), this.transmuxer_ && (this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), this.transmuxer_.postMessage({
      action: "reset"
    }));
  }
  /**
   * Force the SegmentLoader to resync and start loading around the currentTime instead
   * of starting at the end of the buffer
   *
   * Useful for fast quality changes
   */
  resetLoader() {
    this.fetchAtBuffer_ = !1, this.mediaSequenceSync_ && this.mediaSequenceSync_.resetAppendedStatus(), this.resyncLoader();
  }
  /**
   * Force the SegmentLoader to restart synchronization and make a conservative guess
   * before returning to the simple walk-forward method
   */
  resyncLoader() {
    this.transmuxer_ && c2.reset(this.transmuxer_), this.mediaIndex = null, this.partIndex = null, this.syncPoint_ = null, this.isPendingTimestampOffset_ = !1;
    const e = this.currentMediaInfo_ && this.currentMediaInfo_.isFmp4;
    this.sourceType_ === "hls" && !e && (this.shouldForceTimestampOffsetAfterResync_ = !0), this.callQueue_ = [], this.loadQueue_ = [], this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [], this.abort(), this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearParsedMp4Captions"
    });
  }
  /**
   * Remove any data in the source buffer between start and end times
   *
   * @param {number} start - the start time of the region to remove from the buffer
   * @param {number} end - the end time of the region to remove from the buffer
   * @param {Function} [done] - an optional callback to be executed when the remove
   * @param {boolean} force - force all remove operations to happen
   * operation is complete
   */
  remove(e, n, r = () => {
  }, i = !1) {
    if (n === 1 / 0 && (n = this.duration_()), n <= e) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_("skipping remove because no source updater or starting media info");
      return;
    }
    let s = 1;
    const a = () => {
      s--, s === 0 && r();
    };
    (i || !this.audioDisabled_) && (s++, this.sourceUpdater_.removeAudio(e, n, a)), (i || this.loaderType_ === "main") && (this.gopBuffer_ = c6e(this.gopBuffer_, e, n, this.timeMapping_), s++, this.sourceUpdater_.removeVideo(e, n, a));
    for (const o in this.inbandTextTracks_)
      Xd(e, n, this.inbandTextTracks_[o]);
    Xd(e, n, this.segmentMetadataTrack_), a();
  }
  /**
   * (re-)schedule monitorBufferTick_ to run as soon as possible
   *
   * @private
   */
  monitorBuffer_() {
    this.checkBufferTimeout_ && pe.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = pe.setTimeout(this.monitorBufferTick_.bind(this), 1);
  }
  /**
   * As long as the SegmentLoader is in the READY state, periodically
   * invoke fillBuffer_().
   *
   * @private
   */
  monitorBufferTick_() {
    this.state === "READY" && this.fillBuffer_(), this.checkBufferTimeout_ && pe.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = pe.setTimeout(this.monitorBufferTick_.bind(this), h6e);
  }
  /**
   * fill the buffer with segements unless the sourceBuffers are
   * currently updating
   *
   * Note: this function should only ever be called by monitorBuffer_
   * and never directly
   *
   * @private
   */
  fillBuffer_() {
    if (this.sourceUpdater_.updating())
      return;
    const e = this.chooseNextRequest_();
    if (!e)
      return;
    const n = {
      segmentInfo: cu({
        type: this.loaderType_,
        segment: e
      })
    };
    this.trigger({
      type: "segmentselected",
      metadata: n
    }), typeof e.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !1, this.timelineChangeController_.pendingTimelineChange({
      type: this.loaderType_,
      from: this.currentTimeline_,
      to: e.timeline
    })), this.loadSegment_(e);
  }
  /**
   * Determines if we should call endOfStream on the media source based
   * on the state of the buffer or if appened segment was the final
   * segment in the playlist.
   *
   * @param {number} [mediaIndex] the media index of segment we last appended
   * @param {Object} [playlist] a media playlist object
   * @return {boolean} do we need to call endOfStream on the MediaSource
   */
  isEndOfStream_(e = this.mediaIndex, n = this.playlist_, r = this.partIndex) {
    if (!n || !this.mediaSource_)
      return !1;
    const i = typeof e == "number" && n.segments[e], s = e + 1 === n.segments.length, a = !i || !i.parts || r + 1 === i.parts.length;
    return n.endList && this.mediaSource_.readyState === "open" && s && a;
  }
  /**
   * Determines what request should be made given current segment loader state.
   *
   * @return {Object} a request object that describes the segment/part to load
   */
  chooseNextRequest_() {
    const e = this.buffered_(), n = u2(e) || 0, r = UT(e, this.currentTime_()), i = !this.hasPlayed_() && r >= 1, s = r >= this.goalBufferLength_(), a = this.playlist_.segments;
    if (!a.length || i || s)
      return null;
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_(), this.loaderType_);
    const o = {
      partIndex: null,
      mediaIndex: null,
      startOfSegment: null,
      playlist: this.playlist_,
      isSyncRequest: !this.syncPoint_
    };
    if (o.isSyncRequest)
      o.mediaIndex = f6e(this.currentTimeline_, a, n), this.logger_(`choose next request. Can not find sync point. Fallback to media Index: ${o.mediaIndex}`);
    else if (this.mediaIndex !== null) {
      const f = a[this.mediaIndex], p = typeof this.partIndex == "number" ? this.partIndex : -1;
      o.startOfSegment = f.end ? f.end : n, f.parts && f.parts[p + 1] ? (o.mediaIndex = this.mediaIndex, o.partIndex = p + 1) : o.mediaIndex = this.mediaIndex + 1;
    } else {
      let f, p, m;
      const g = this.fetchAtBuffer_ ? n : this.currentTime_();
      if (this.mediaSequenceSync_ && this.logger_(`chooseNextRequest_ request after Quality Switch:
For TargetTime: ${g}.
CurrentTime: ${this.currentTime_()}
BufferedEnd: ${n}
Fetch At Buffer: ${this.fetchAtBuffer_}
`, this.mediaSequenceSync_.diagnostics), this.mediaSequenceSync_ && this.mediaSequenceSync_.isReliable) {
        const y = this.getSyncInfoFromMediaSequenceSync_(g);
        if (!y) {
          const b = "No sync info found while using media sequence sync";
          return this.error({
            message: b,
            metadata: {
              errorType: Me.Error.StreamingFailedToSelectNextSegment,
              error: new Error(b)
            }
          }), this.logger_("chooseNextRequest_ - no sync info found using media sequence sync"), null;
        }
        this.logger_(`chooseNextRequest_ mediaSequence syncInfo (${y.start} --> ${y.end})`), f = y.segmentIndex, p = y.partIndex, m = y.start;
      } else {
        this.logger_("chooseNextRequest_ - fallback to a regular segment selection algorithm, based on a syncPoint.");
        const y = Si.getMediaInfoForTime({
          exactManifestTimings: this.exactManifestTimings,
          playlist: this.playlist_,
          currentTime: g,
          startingPartIndex: this.syncPoint_.partIndex,
          startingSegmentIndex: this.syncPoint_.segmentIndex,
          startTime: this.syncPoint_.time
        });
        f = y.segmentIndex, p = y.partIndex, m = y.startTime;
      }
      o.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${g}` : `currentTime ${g}`, o.mediaIndex = f, o.startOfSegment = m, o.partIndex = p, this.logger_(`choose next request. Playlist switched and we have a sync point. Media Index: ${o.mediaIndex} `);
    }
    const u = a[o.mediaIndex];
    let c = u && typeof o.partIndex == "number" && u.parts && u.parts[o.partIndex];
    if (!u || typeof o.partIndex == "number" && !c)
      return null;
    typeof o.partIndex != "number" && u.parts && (o.partIndex = 0, c = u.parts[0]);
    const d = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments;
    if (!r && c && !d && !c.independent)
      if (o.partIndex === 0) {
        const f = a[o.mediaIndex - 1], p = f.parts && f.parts.length && f.parts[f.parts.length - 1];
        p && p.independent && (o.mediaIndex -= 1, o.partIndex = f.parts.length - 1, o.independent = "previous segment");
      } else u.parts[o.partIndex - 1].independent && (o.partIndex -= 1, o.independent = "previous part");
    const l = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    return o.mediaIndex >= a.length - 1 && l && !this.seeking_() ? null : (this.shouldForceTimestampOffsetAfterResync_ && (this.shouldForceTimestampOffsetAfterResync_ = !1, o.forceTimestampOffset = !0, this.logger_("choose next request. Force timestamp offset after loader resync")), this.generateSegmentInfo_(o));
  }
  getSyncInfoFromMediaSequenceSync_(e) {
    if (!this.mediaSequenceSync_)
      return null;
    const n = Math.max(e, this.mediaSequenceSync_.start);
    e !== n && this.logger_(`getSyncInfoFromMediaSequenceSync_. Pulled target time from ${e} to ${n}`);
    const r = this.mediaSequenceSync_.getSyncInfoForTime(n);
    if (!r)
      return null;
    if (!r.isAppended)
      return r;
    const i = this.mediaSequenceSync_.getSyncInfoForTime(r.end);
    return i ? (i.isAppended && this.logger_("getSyncInfoFromMediaSequenceSync_: We encounter unexpected scenario where next media sequence sync info is also appended!"), i) : null;
  }
  generateSegmentInfo_(e) {
    const {
      independent: n,
      playlist: r,
      mediaIndex: i,
      startOfSegment: s,
      isSyncRequest: a,
      partIndex: o,
      forceTimestampOffset: u,
      getMediaInfoForTime: c
    } = e, d = r.segments[i], l = typeof o == "number" && d.parts[o], f = {
      requestId: "segment-loader-" + Math.random(),
      // resolve the segment URL relative to the playlist
      uri: l && l.resolvedUri || d.resolvedUri,
      // the segment's mediaIndex at the time it was requested
      mediaIndex: i,
      partIndex: l ? o : null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest: a,
      startOfSegment: s,
      // the segment's playlist
      playlist: r,
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      // The timeline that the segment is in
      timeline: d.timeline,
      // The expected duration of the segment in seconds
      duration: l && l.duration || d.duration,
      // retain the segment in case the playlist updates while doing an async process
      segment: d,
      part: l,
      byteLength: 0,
      transmuxer: this.transmuxer_,
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: c,
      independent: n
    }, p = typeof u < "u" ? u : this.isPendingTimestampOffset_;
    f.timestampOffset = this.timestampOffsetForSegment_({
      segmentTimeline: d.timeline,
      currentTimeline: this.currentTimeline_,
      startOfSegment: s,
      buffered: this.buffered_(),
      overrideCheck: p
    });
    const m = u2(this.sourceUpdater_.audioBuffered());
    return typeof m == "number" && (f.audioAppendStart = m - this.sourceUpdater_.audioTimestampOffset()), this.sourceUpdater_.videoBuffered().length && (f.gopsToAlignWith = u6e(
      this.gopBuffer_,
      // since the transmuxer is using the actual timing values, but the time is
      // adjusted by the timestmap offset, we must adjust the value here
      this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
      this.timeMapping_
    )), f;
  }
  // get the timestampoffset for a segment,
  // added so that vtt segment loader can override and prevent
  // adding timestamp offsets.
  timestampOffsetForSegment_(e) {
    return g6e(e);
  }
  /**
   * Determines if the network has enough bandwidth to complete the current segment
   * request in a timely manner. If not, the request will be aborted early and bandwidth
   * updated to trigger a playlist switch.
   *
   * @param {Object} stats
   *        Object containing stats about the request timing and size
   * @private
   */
  earlyAbortWhenNeeded_(e) {
    if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH || Date.now() - (e.firstBytesReceivedAt || Date.now()) < 1e3)
      return;
    const n = this.currentTime_(), r = e.bandwidth, i = this.pendingSegment_.duration, s = Si.estimateSegmentRequestTime(i, r, this.playlist_, e.bytesReceived), a = FCe(this.buffered_(), n, this.vhs_.tech_.playbackRate()) - 1;
    if (s <= a)
      return;
    const o = KSe({
      main: this.vhs_.playlists.main,
      currentTime: n,
      bandwidth: r,
      duration: this.duration_(),
      segmentDuration: i,
      timeUntilRebuffer: a,
      currentTimeline: this.currentTimeline_,
      syncController: this.syncController_
    });
    if (!o)
      return;
    const c = s - a - o.rebufferingImpact;
    let d = 0.5;
    a <= na && (d = 1), !(!o.playlist || o.playlist.uri === this.playlist_.uri || c < d) && (this.bandwidth = o.playlist.attributes.BANDWIDTH * Ir.BANDWIDTH_VARIANCE + 1, this.trigger("earlyabort"));
  }
  handleAbort_(e) {
    this.logger_(`Aborting ${Sl(e)}`), this.mediaRequestsAborted += 1;
  }
  /**
   * XHR `progress` event handler
   *
   * @param {Event}
   *        The XHR `progress` event
   * @param {Object} simpleSegment
   *        A simplified segment object copy
   * @private
   */
  handleProgress_(e, n) {
    this.earlyAbortWhenNeeded_(n.stats), !this.checkForAbort_(n.requestId) && this.trigger("progress");
  }
  handleTrackInfo_(e, n) {
    const {
      hasAudio: r,
      hasVideo: i
    } = n, s = {
      segmentInfo: cu({
        type: this.loaderType_,
        segment: e
      }),
      trackInfo: {
        hasAudio: r,
        hasVideo: i
      }
    };
    this.trigger({
      type: "segmenttransmuxingtrackinfoavailable",
      metadata: s
    }), this.earlyAbortWhenNeeded_(e.stats), !this.checkForAbort_(e.requestId) && (this.checkForIllegalMediaSwitch(n) || (n = n || {}, d6e(this.currentMediaInfo_, n) || (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }, this.startingMediaInfo_ = n, this.currentMediaInfo_ = n, this.logger_("trackinfo update", n), this.trigger("trackinfo")), !this.checkForAbort_(e.requestId) && (this.pendingSegment_.trackInfo = n, this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : io(this))));
  }
  handleTimingInfo_(e, n, r, i) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    const s = this.pendingSegment_, a = Ew(n);
    s[a] = s[a] || {}, s[a][r] = i, this.logger_(`timinginfo: ${n} - ${r} - ${i}`), this.hasEnoughInfoToAppend_() ? this.processCallQueue_() : io(this);
  }
  handleCaptions_(e, n) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    if (n.length === 0) {
      this.logger_("SegmentLoader received no captions from a caption event");
      return;
    }
    if (!this.pendingSegment_.hasAppendedData_) {
      this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, e, n));
      return;
    }
    const i = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(), s = {};
    n.forEach((a) => {
      s[a.stream] = s[a.stream] || {
        // Infinity, as any other value will be less than this
        startTime: 1 / 0,
        captions: [],
        // 0 as an other value will be more than this
        endTime: 0
      };
      const o = s[a.stream];
      o.startTime = Math.min(o.startTime, a.startTime + i), o.endTime = Math.max(o.endTime, a.endTime + i), o.captions.push(a);
    }), Object.keys(s).forEach((a) => {
      const {
        startTime: o,
        endTime: u,
        captions: c
      } = s[a], d = this.inbandTextTracks_;
      this.logger_(`adding cues from ${o} -> ${u} for ${a}`), e6e(d, this.vhs_.tech_, a), Xd(o, u, d[a]), t6e({
        captionArray: c,
        inbandTextTracks: d,
        timestampOffset: i
      });
    }), this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearParsedMp4Captions"
    });
  }
  handleId3_(e, n, r) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    if (!this.pendingSegment_.hasAppendedData_) {
      this.metadataQueue_.id3.push(this.handleId3_.bind(this, e, n, r));
      return;
    }
    this.addMetadataToTextTrack(r, n, this.duration_());
  }
  processMetadataQueue_() {
    this.metadataQueue_.id3.forEach((e) => e()), this.metadataQueue_.caption.forEach((e) => e()), this.metadataQueue_.id3 = [], this.metadataQueue_.caption = [];
  }
  processCallQueue_() {
    const e = this.callQueue_;
    this.callQueue_ = [], e.forEach((n) => n());
  }
  processLoadQueue_() {
    const e = this.loadQueue_;
    this.loadQueue_ = [], e.forEach((n) => n());
  }
  /**
   * Determines whether the loader has enough info to load the next segment.
   *
   * @return {boolean}
   *         Whether or not the loader has enough info to load the next segment
   */
  hasEnoughInfoToLoad_() {
    if (this.loaderType_ !== "audio")
      return !0;
    const e = this.pendingSegment_;
    return e ? this.getCurrentMediaInfo_() ? (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      !fy({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: e.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })
    ) : !0 : !1;
  }
  getCurrentMediaInfo_(e = this.pendingSegment_) {
    return e && e.trackInfo || this.currentMediaInfo_;
  }
  getMediaInfo_(e = this.pendingSegment_) {
    return this.getCurrentMediaInfo_(e) || this.startingMediaInfo_;
  }
  getPendingSegmentPlaylist() {
    return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
  }
  hasEnoughInfoToAppend_() {
    if (!this.sourceUpdater_.ready() || this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_)
      return !1;
    const e = this.pendingSegment_, n = this.getCurrentMediaInfo_();
    if (!e || !n)
      return !1;
    const {
      hasAudio: r,
      hasVideo: i,
      isMuxed: s
    } = n;
    return !(i && !e.videoTimingInfo || r && !this.audioDisabled_ && !s && !e.audioTimingInfo || fy({
      timelineChangeController: this.timelineChangeController_,
      currentTimeline: this.currentTimeline_,
      segmentTimeline: e.timeline,
      loaderType: this.loaderType_,
      audioDisabled: this.audioDisabled_
    }));
  }
  handleData_(e, n) {
    if (this.earlyAbortWhenNeeded_(e.stats), this.checkForAbort_(e.requestId))
      return;
    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
      io(this), this.callQueue_.push(this.handleData_.bind(this, e, n));
      return;
    }
    const r = this.pendingSegment_;
    if (this.setTimeMapping_(r.timeline), this.updateMediaSecondsLoaded_(r.part || r.segment), this.mediaSource_.readyState !== "closed") {
      if (e.map && (e.map = this.initSegmentForMap(e.map, !0), r.segment.map = e.map), e.key && this.segmentKey(e.key, !0), r.isFmp4 = e.isFmp4, r.timingInfo = r.timingInfo || {}, r.isFmp4)
        this.trigger("fmp4"), r.timingInfo.start = r[Ew(n.type)].start;
      else {
        const i = this.getCurrentMediaInfo_(), s = this.loaderType_ === "main" && i && i.hasVideo;
        let a;
        s && (a = r.videoTimingInfo.start), r.timingInfo.start = this.trueSegmentStart_({
          currentStart: r.timingInfo.start,
          playlist: r.playlist,
          mediaIndex: r.mediaIndex,
          currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
          useVideoTimingInfo: s,
          firstVideoFrameTimeForData: a,
          videoTimingInfo: r.videoTimingInfo,
          audioTimingInfo: r.audioTimingInfo
        });
      }
      if (this.updateAppendInitSegmentStatus(r, n.type), this.updateSourceBufferTimestampOffset_(r), r.isSyncRequest) {
        this.updateTimingInfoEnd_(r), this.syncController_.saveSegmentTimingInfo({
          segmentInfo: r,
          shouldSaveTimelineMapping: this.loaderType_ === "main"
        });
        const i = this.chooseNextRequest_();
        if (i.mediaIndex !== r.mediaIndex || i.partIndex !== r.partIndex) {
          this.logger_("sync segment was incorrect, not appending");
          return;
        }
        this.logger_("sync segment was correct, appending");
      }
      r.hasAppendedData_ = !0, this.processMetadataQueue_(), this.appendData_(r, n);
    }
  }
  updateAppendInitSegmentStatus(e, n) {
    this.loaderType_ === "main" && typeof e.timestampOffset == "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !e.changedTimestampOffset && (this.appendInitSegment_ = {
      audio: !0,
      video: !0
    }), this.playlistOfLastInitSegment_[n] !== e.playlist && (this.appendInitSegment_[n] = !0);
  }
  getInitSegmentAndUpdateState_({
    type: e,
    initSegment: n,
    map: r,
    playlist: i
  }) {
    if (r) {
      const s = T0(r);
      if (this.activeInitSegmentId_ === s)
        return null;
      n = this.initSegmentForMap(r, !0).bytes, this.activeInitSegmentId_ = s;
    }
    return n && this.appendInitSegment_[e] ? (this.playlistOfLastInitSegment_[e] = i, this.appendInitSegment_[e] = !1, this.activeInitSegmentId_ = null, n) : null;
  }
  handleQuotaExceededError_({
    segmentInfo: e,
    type: n,
    bytes: r
  }, i) {
    const s = this.sourceUpdater_.audioBuffered(), a = this.sourceUpdater_.videoBuffered();
    s.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + Au(s).join(", ")), a.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + Au(a).join(", "));
    const o = s.length ? s.start(0) : 0, u = s.length ? s.end(s.length - 1) : 0, c = a.length ? a.start(0) : 0, d = a.length ? a.end(a.length - 1) : 0;
    if (u - o <= Pd && d - c <= Pd) {
      this.logger_(`On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: ${r.byteLength}, audio buffer: ${Au(s).join(", ")}, video buffer: ${Au(a).join(", ")}, `), this.error({
        message: "Quota exceeded error with append of a single segment of content",
        excludeUntil: 1 / 0
      }), this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = !0, this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
      segmentInfo: e,
      type: n,
      bytes: r
    }));
    const f = this.currentTime_() - Pd;
    this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${f}`), this.remove(0, f, () => {
      this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${Pd}s`), this.waitingOnRemove_ = !1, this.quotaExceededErrorRetryTimeout_ = pe.setTimeout(() => {
        this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"), this.quotaExceededErrorRetryTimeout_ = null, this.processCallQueue_();
      }, Pd * 1e3);
    }, !0);
  }
  handleAppendError_({
    segmentInfo: e,
    type: n,
    bytes: r
  }, i) {
    if (i) {
      if (i.code === aM) {
        this.handleQuotaExceededError_({
          segmentInfo: e,
          type: n,
          bytes: r
        });
        return;
      }
      this.logger_("Received non QUOTA_EXCEEDED_ERR on append", i), this.error({
        message: `${n} append of ${r.length}b failed for segment #${e.mediaIndex} in playlist ${e.playlist.id}`,
        metadata: {
          errorType: Me.Error.StreamingFailedToAppendSegment
        }
      }), this.trigger("appenderror");
    }
  }
  appendToSourceBuffer_({
    segmentInfo: e,
    type: n,
    initSegment: r,
    data: i,
    bytes: s
  }) {
    if (!s) {
      const o = [i];
      let u = i.byteLength;
      r && (o.unshift(r), u += r.byteLength), s = JSe({
        bytes: u,
        segments: o
      });
    }
    const a = {
      segmentInfo: cu({
        type: this.loaderType_,
        segment: e
      })
    };
    this.trigger({
      type: "segmentappendstart",
      metadata: a
    }), this.sourceUpdater_.appendBuffer({
      segmentInfo: e,
      type: n,
      bytes: s
    }, this.handleAppendError_.bind(this, {
      segmentInfo: e,
      type: n,
      bytes: s
    }));
  }
  handleSegmentTimingInfo_(e, n, r) {
    if (!this.pendingSegment_ || n !== this.pendingSegment_.requestId)
      return;
    const i = this.pendingSegment_.segment, s = `${e}TimingInfo`;
    i[s] || (i[s] = {}), i[s].transmuxerPrependedSeconds = r.prependedContentDuration || 0, i[s].transmuxedPresentationStart = r.start.presentation, i[s].transmuxedDecodeStart = r.start.decode, i[s].transmuxedPresentationEnd = r.end.presentation, i[s].transmuxedDecodeEnd = r.end.decode, i[s].baseMediaDecodeTime = r.baseMediaDecodeTime;
  }
  appendData_(e, n) {
    const {
      type: r,
      data: i
    } = n;
    if (!i || !i.byteLength || r === "audio" && this.audioDisabled_)
      return;
    const s = this.getInitSegmentAndUpdateState_({
      type: r,
      initSegment: n.initSegment,
      playlist: e.playlist,
      map: e.isFmp4 ? e.segment.map : null
    });
    this.appendToSourceBuffer_({
      segmentInfo: e,
      type: r,
      initSegment: s,
      data: i
    });
  }
  /**
   * load a specific segment from a request into the buffer
   *
   * @private
   */
  loadSegment_(e) {
    if (this.state = "WAITING", this.pendingSegment_ = e, this.trimBackBuffer_(e), typeof e.timestampOffset == "number" && this.transmuxer_ && this.transmuxer_.postMessage({
      action: "clearAllMp4Captions"
    }), !this.hasEnoughInfoToLoad_()) {
      io(this), this.loadQueue_.push(() => {
        const n = fr({}, e, {
          forceTimestampOffset: !0
        });
        fr(e, this.generateSegmentInfo_(n)), this.isPendingTimestampOffset_ = !1, this.updateTransmuxerAndRequestSegment_(e);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(e);
  }
  updateTransmuxerAndRequestSegment_(e) {
    this.shouldUpdateTransmuxerTimestampOffset_(e.timestampOffset) && (this.gopBuffer_.length = 0, e.gopsToAlignWith = [], this.timeMapping_ = 0, this.transmuxer_.postMessage({
      action: "reset"
    }), this.transmuxer_.postMessage({
      action: "setTimestampOffset",
      timestampOffset: e.timestampOffset
    }));
    const n = this.createSimplifiedSegmentObj_(e), r = this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex), i = this.mediaIndex !== null, s = e.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    e.timeline > 0, a = r || i && s;
    this.logger_(`Requesting
${MM(e.uri)}
${Sl(e)}`), n.map && !n.map.bytes && (this.logger_("going to request init segment."), this.appendInitSegment_ = {
      video: !0,
      audio: !0
    }), e.abortRequests = GSe({
      xhr: this.vhs_.xhr,
      xhrOptions: this.xhrOptions_,
      decryptionWorker: this.decrypter_,
      segment: n,
      abortFn: this.handleAbort_.bind(this, e),
      progressFn: this.handleProgress_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      timingInfoFn: this.handleTimingInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", e.requestId),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", e.requestId),
      captionsFn: this.handleCaptions_.bind(this),
      isEndOfTimeline: a,
      endedTimelineFn: () => {
        this.logger_("received endedtimeline callback");
      },
      id3Fn: this.handleId3_.bind(this),
      dataFn: this.handleData_.bind(this),
      doneFn: this.segmentRequestFinished_.bind(this),
      onTransmuxerLog: ({
        message: o,
        level: u,
        stream: c
      }) => {
        this.logger_(`${Sl(e)} logged from transmuxer stream ${c} as a ${u}: ${o}`);
      },
      triggerSegmentEventFn: ({
        type: o,
        segment: u,
        keyInfo: c,
        trackInfo: d,
        timingInfo: l
      }) => {
        const p = {
          segmentInfo: cu({
            segment: u
          })
        };
        c && (p.keyInfo = c), d && (p.trackInfo = d), l && (p.timingInfo = l), this.trigger({
          type: o,
          metadata: p
        });
      }
    });
  }
  /**
   * trim the back buffer so that we don't have too much data
   * in the source buffer
   *
   * @private
   *
   * @param {Object} segmentInfo - the current segment
   */
  trimBackBuffer_(e) {
    const n = m6e(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
    n > 0 && this.remove(0, n);
  }
  /**
   * created a simplified copy of the segment object with just the
   * information necessary to perform the XHR and decryption
   *
   * @private
   *
   * @param {Object} segmentInfo - the current segment
   * @return {Object} a simplified segment object copy
   */
  createSimplifiedSegmentObj_(e) {
    const n = e.segment, r = e.part, i = e.segment.key || e.segment.map && e.segment.map.key, s = e.segment.map && !e.segment.map.bytes, a = {
      resolvedUri: r ? r.resolvedUri : n.resolvedUri,
      byterange: r ? r.byterange : n.byterange,
      requestId: e.requestId,
      transmuxer: e.transmuxer,
      audioAppendStart: e.audioAppendStart,
      gopsToAlignWith: e.gopsToAlignWith,
      part: e.part,
      type: this.loaderType_,
      start: e.startOfSegment,
      duration: e.duration,
      isEncrypted: i,
      isMediaInitialization: s
    }, o = e.playlist.segments[e.mediaIndex - 1];
    if (o && o.timeline === n.timeline && (o.videoTimingInfo ? a.baseStartTime = o.videoTimingInfo.transmuxedDecodeEnd : o.audioTimingInfo && (a.baseStartTime = o.audioTimingInfo.transmuxedDecodeEnd)), n.key) {
      const u = n.key.iv || new Uint32Array([0, 0, 0, e.mediaIndex + e.playlist.mediaSequence]);
      a.key = this.segmentKey(n.key), a.key.iv = u;
    }
    return n.map && (a.map = this.initSegmentForMap(n.map)), a;
  }
  saveTransferStats_(e) {
    this.mediaRequests += 1, e && (this.mediaBytesTransferred += e.bytesReceived, this.mediaTransferDuration += e.roundTripTime);
  }
  saveBandwidthRelatedStats_(e, n) {
    if (this.pendingSegment_.byteLength = n.bytesReceived, e < Pp) {
      this.logger_(`Ignoring segment's bandwidth because its duration of ${e} is less than the min to record ${Pp}`);
      return;
    }
    const r = {
      bandwidthInfo: {
        from: this.bandwidth,
        to: n.bandwidth
      }
    };
    this.trigger({
      type: "bandwidthupdated",
      metadata: r
    }), this.bandwidth = n.bandwidth, this.roundTrip = n.roundTripTime;
  }
  handleTimeout_() {
    this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, this.trigger("bandwidthupdate"), this.trigger("timeout");
  }
  /**
   * Handle the callback from the segmentRequest function and set the
   * associated SegmentLoader state and errors if necessary
   *
   * @private
   */
  segmentRequestFinished_(e, n, r) {
    if (this.callQueue_.length) {
      this.callQueue_.push(this.segmentRequestFinished_.bind(this, e, n, r));
      return;
    }
    if (this.saveTransferStats_(n.stats), !this.pendingSegment_ || n.requestId !== this.pendingSegment_.requestId)
      return;
    if (e) {
      if (this.pendingSegment_ = null, this.state = "READY", e.code === ia.ABORTED)
        return;
      if (this.pause(), e.code === ia.TIMEOUT) {
        this.handleTimeout_();
        return;
      }
      this.mediaRequestsErrored += 1, this.error(e), this.trigger("error");
      return;
    }
    const i = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(i.duration, n.stats), i.endOfAllRequests = n.endOfAllRequests, r.gopInfo && (this.gopBuffer_ = l6e(this.gopBuffer_, r.gopInfo, this.safeAppend_)), this.state = "APPENDING", this.trigger("appending"), this.waitForAppendsToComplete_(i);
  }
  setTimeMapping_(e) {
    const n = this.syncController_.mappingForTimeline(e);
    n !== null && (this.timeMapping_ = n);
  }
  updateMediaSecondsLoaded_(e) {
    typeof e.start == "number" && typeof e.end == "number" ? this.mediaSecondsLoaded += e.end - e.start : this.mediaSecondsLoaded += e.duration;
  }
  shouldUpdateTransmuxerTimestampOffset_(e) {
    return e === null ? !1 : this.loaderType_ === "main" && e !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && e !== this.sourceUpdater_.audioTimestampOffset();
  }
  trueSegmentStart_({
    currentStart: e,
    playlist: n,
    mediaIndex: r,
    firstVideoFrameTimeForData: i,
    currentVideoTimestampOffset: s,
    useVideoTimingInfo: a,
    videoTimingInfo: o,
    audioTimingInfo: u
  }) {
    if (typeof e < "u")
      return e;
    if (!a)
      return u.start;
    const c = n.segments[r - 1];
    return r === 0 || !c || typeof c.start > "u" || c.end !== i + s ? i : o.start;
  }
  waitForAppendsToComplete_(e) {
    const n = this.getCurrentMediaInfo_(e);
    if (!n) {
      this.error({
        message: "No starting media returned, likely due to an unsupported media format.",
        playlistExclusionDuration: 1 / 0
      }), this.trigger("error");
      return;
    }
    const {
      hasAudio: r,
      hasVideo: i,
      isMuxed: s
    } = n, a = this.loaderType_ === "main" && i, o = !this.audioDisabled_ && r && !s;
    if (e.waitingOnAppends = 0, !e.hasAppendedData_) {
      !e.timingInfo && typeof e.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !0), e.timingInfo = {
        start: 0
      }, e.waitingOnAppends++, this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(e), this.processMetadataQueue_()), this.checkAppendsDone_(e);
      return;
    }
    a && e.waitingOnAppends++, o && e.waitingOnAppends++, a && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, e)), o && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, e));
  }
  checkAppendsDone_(e) {
    this.checkForAbort_(e.requestId) || (e.waitingOnAppends--, e.waitingOnAppends === 0 && this.handleAppendsDone_());
  }
  checkForIllegalMediaSwitch(e) {
    const n = p6e(this.loaderType_, this.getCurrentMediaInfo_(), e);
    return n ? (this.error({
      message: n,
      playlistExclusionDuration: 1 / 0
    }), this.trigger("error"), !0) : !1;
  }
  updateSourceBufferTimestampOffset_(e) {
    if (e.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof e.timingInfo.start != "number" || // already updated the timestamp offset for this segment
    e.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main")
      return;
    let n = !1;
    e.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
      videoTimingInfo: e.segment.videoTimingInfo,
      audioTimingInfo: e.segment.audioTimingInfo,
      timingInfo: e.timingInfo
    }), e.changedTimestampOffset = !0, e.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(e.timestampOffset), n = !0), e.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(e.timestampOffset), n = !0), n && this.trigger("timestampoffset");
  }
  getSegmentStartTimeForTimestampOffsetCalculation_({
    videoTimingInfo: e,
    audioTimingInfo: n,
    timingInfo: r
  }) {
    return this.useDtsForTimestampOffset_ ? e && typeof e.transmuxedDecodeStart == "number" ? e.transmuxedDecodeStart : n && typeof n.transmuxedDecodeStart == "number" ? n.transmuxedDecodeStart : r.start : r.start;
  }
  updateTimingInfoEnd_(e) {
    e.timingInfo = e.timingInfo || {};
    const n = this.getMediaInfo_(), i = this.loaderType_ === "main" && n && n.hasVideo && e.videoTimingInfo ? e.videoTimingInfo : e.audioTimingInfo;
    i && (e.timingInfo.end = typeof i.end == "number" ? (
      // End time may not exist in a case where we aren't parsing the full segment (one
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      i.end
    ) : i.start + e.duration);
  }
  /**
   * callback to run when appendBuffer is finished. detects if we are
   * in a good state to do things with the data we got, or if we need
   * to wait for more
   *
   * @private
   */
  handleAppendsDone_() {
    if (this.pendingSegment_) {
      const u = {
        segmentInfo: cu({
          type: this.loaderType_,
          segment: this.pendingSegment_
        })
      };
      this.trigger({
        type: "appendsdone",
        metadata: u
      });
    }
    if (!this.pendingSegment_) {
      this.state = "READY", this.paused() || this.monitorBuffer_();
      return;
    }
    const e = this.pendingSegment_;
    e.part && e.part.syncInfo ? e.part.syncInfo.markAppended() : e.segment.syncInfo && e.segment.syncInfo.markAppended(), this.updateTimingInfoEnd_(e), this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({
      segmentInfo: e,
      shouldSaveTimelineMapping: this.loaderType_ === "main"
    });
    const n = v6e(e, this.sourceType_);
    if (n && (n.severity === "warn" ? Me.log.warn(n.message) : this.logger_(n.message)), this.recordThroughput_(e), this.pendingSegment_ = null, this.state = "READY", e.isSyncRequest && (this.trigger("syncinfoupdate"), !e.hasAppendedData_)) {
      this.logger_(`Throwing away un-appended sync request ${Sl(e)}`);
      return;
    }
    this.logger_(`Appended ${Sl(e)}`), this.addSegmentMetadataCue_(e), this.fetchAtBuffer_ = !0, this.currentTimeline_ !== e.timeline && (this.timelineChangeController_.lastTimelineChange({
      type: this.loaderType_,
      from: this.currentTimeline_,
      to: e.timeline
    }), this.loaderType_ === "main" && !this.audioDisabled_ && this.timelineChangeController_.lastTimelineChange({
      type: "audio",
      from: this.currentTimeline_,
      to: e.timeline
    })), this.currentTimeline_ = e.timeline, this.trigger("syncinfoupdate");
    const r = e.segment, i = e.part, s = r.end && this.currentTime_() - r.end > e.playlist.targetDuration * 3, a = i && i.end && this.currentTime_() - i.end > e.playlist.partTargetDuration * 3;
    if (s || a) {
      this.logger_(`bad ${s ? "segment" : "part"} ${Sl(e)}`), this.resetEverything();
      return;
    }
    this.mediaIndex !== null && this.trigger("bandwidthupdate"), this.trigger("progress"), this.mediaIndex = e.mediaIndex, this.partIndex = e.partIndex, this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) && this.endOfStream(), this.trigger("appended"), e.hasAppendedData_ && this.mediaAppends++, this.paused() || this.monitorBuffer_();
  }
  /**
   * Records the current throughput of the decrypt, transmux, and append
   * portion of the semgment pipeline. `throughput.rate` is a the cumulative
   * moving average of the throughput. `throughput.count` is the number of
   * data points in the average.
   *
   * @private
   * @param {Object} segmentInfo the object returned by loadSegment
   */
  recordThroughput_(e) {
    if (e.duration < Pp) {
      this.logger_(`Ignoring segment's throughput because its duration of ${e.duration} is less than the min to record ${Pp}`);
      return;
    }
    const n = this.throughput.rate, r = Date.now() - e.endOfAllRequests + 1, i = Math.floor(e.byteLength / r * 8 * 1e3);
    this.throughput.rate += (i - n) / ++this.throughput.count;
  }
  /**
   * Adds a cue to the segment-metadata track with some metadata information about the
   * segment
   *
   * @private
   * @param {Object} segmentInfo
   *        the object returned by loadSegment
   * @method addSegmentMetadataCue_
   */
  addSegmentMetadataCue_(e) {
    if (!this.segmentMetadataTrack_)
      return;
    const n = e.segment, r = n.start, i = n.end;
    if (!_w(r) || !_w(i))
      return;
    Xd(r, i, this.segmentMetadataTrack_);
    const s = pe.WebKitDataCue || pe.VTTCue, a = {
      custom: n.custom,
      dateTimeObject: n.dateTimeObject,
      dateTimeString: n.dateTimeString,
      programDateTime: n.programDateTime,
      bandwidth: e.playlist.attributes.BANDWIDTH,
      resolution: e.playlist.attributes.RESOLUTION,
      codecs: e.playlist.attributes.CODECS,
      byteLength: e.byteLength,
      uri: e.uri,
      timeline: e.timeline,
      playlist: e.playlist.id,
      start: r,
      end: i
    }, o = JSON.stringify(a), u = new s(r, i, o);
    u.value = a, this.segmentMetadataTrack_.addCue(u);
  }
}
function Na() {
}
const OM = function(t) {
  return typeof t != "string" ? t : t.replace(/./, (e) => e.toUpperCase());
}, T6e = ["video", "audio"], py = (t, e) => {
  const n = e[`${t}Buffer`];
  return n && n.updating || e.queuePending[t];
}, _6e = (t, e) => {
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (r.type === "mediaSource")
      return null;
    if (r.type === t)
      return n;
  }
  return null;
}, Jl = (t, e) => {
  if (e.queue.length === 0)
    return;
  let n = 0, r = e.queue[n];
  if (r.type === "mediaSource") {
    !e.updating() && e.mediaSource.readyState !== "closed" && (e.queue.shift(), r.action(e), r.doneFn && r.doneFn(), Jl("audio", e), Jl("video", e));
    return;
  }
  if (t !== "mediaSource" && !(!e.ready() || e.mediaSource.readyState === "closed" || py(t, e))) {
    if (r.type !== t) {
      if (n = _6e(t, e.queue), n === null)
        return;
      r = e.queue[n];
    }
    if (e.queue.splice(n, 1), e.queuePending[t] = r, r.action(t, e), !r.doneFn) {
      e.queuePending[t] = null, Jl(t, e);
      return;
    }
  }
}, NM = (t, e) => {
  const n = e[`${t}Buffer`], r = OM(t);
  n && (n.removeEventListener("updateend", e[`on${r}UpdateEnd_`]), n.removeEventListener("error", e[`on${r}Error_`]), e.codecs[t] = null, e[`${t}Buffer`] = null);
}, Ks = (t, e) => t && e && Array.prototype.indexOf.call(t.sourceBuffers, e) !== -1, $i = {
  appendBuffer: (t, e, n) => (r, i) => {
    const s = i[`${r}Buffer`];
    if (Ks(i.mediaSource, s)) {
      i.logger_(`Appending segment ${e.mediaIndex}'s ${t.length} bytes to ${r}Buffer`);
      try {
        s.appendBuffer(t);
      } catch (a) {
        i.logger_(`Error with code ${a.code} ` + (a.code === aM ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${e.mediaIndex} to ${r}Buffer`), i.queuePending[r] = null, n(a);
      }
    }
  },
  remove: (t, e) => (n, r) => {
    const i = r[`${n}Buffer`];
    if (Ks(r.mediaSource, i)) {
      r.logger_(`Removing ${t} to ${e} from ${n}Buffer`);
      try {
        i.remove(t, e);
      } catch {
        r.logger_(`Remove ${t} to ${e} from ${n}Buffer failed`);
      }
    }
  },
  timestampOffset: (t) => (e, n) => {
    const r = n[`${e}Buffer`];
    Ks(n.mediaSource, r) && (n.logger_(`Setting ${e}timestampOffset to ${t}`), r.timestampOffset = t);
  },
  callback: (t) => (e, n) => {
    t();
  },
  endOfStream: (t) => (e) => {
    if (e.mediaSource.readyState === "open") {
      e.logger_(`Calling mediaSource endOfStream(${t || ""})`);
      try {
        e.mediaSource.endOfStream(t);
      } catch (n) {
        Me.log.warn("Failed to call media source endOfStream", n);
      }
    }
  },
  duration: (t) => (e) => {
    e.logger_(`Setting mediaSource duration to ${t}`);
    try {
      e.mediaSource.duration = t;
    } catch (n) {
      Me.log.warn("Failed to set media source duration", n);
    }
  },
  abort: () => (t, e) => {
    if (e.mediaSource.readyState !== "open")
      return;
    const n = e[`${t}Buffer`];
    if (Ks(e.mediaSource, n)) {
      e.logger_(`calling abort on ${t}Buffer`);
      try {
        n.abort();
      } catch (r) {
        Me.log.warn(`Failed to abort on ${t}Buffer`, r);
      }
    }
  },
  addSourceBuffer: (t, e) => (n) => {
    const r = OM(t), i = uc(e);
    n.logger_(`Adding ${t}Buffer with codec ${e} to mediaSource`);
    const s = n.mediaSource.addSourceBuffer(i);
    s.addEventListener("updateend", n[`on${r}UpdateEnd_`]), s.addEventListener("error", n[`on${r}Error_`]), n.codecs[t] = e, n[`${t}Buffer`] = s;
  },
  removeSourceBuffer: (t) => (e) => {
    const n = e[`${t}Buffer`];
    if (NM(t, e), !!Ks(e.mediaSource, n)) {
      e.logger_(`Removing ${t}Buffer with codec ${e.codecs[t]} from mediaSource`);
      try {
        e.mediaSource.removeSourceBuffer(n);
      } catch (r) {
        Me.log.warn(`Failed to removeSourceBuffer ${t}Buffer`, r);
      }
    }
  },
  changeType: (t) => (e, n) => {
    const r = n[`${e}Buffer`], i = uc(t);
    if (!Ks(n.mediaSource, r))
      return;
    const s = t.substring(0, t.indexOf(".")), a = n.codecs[e];
    if (a.substring(0, a.indexOf(".")) === s)
      return;
    const u = {
      codecsChangeInfo: {
        from: a,
        to: t
      }
    };
    n.trigger({
      type: "codecschange",
      metadata: u
    }), n.logger_(`changing ${e}Buffer codec from ${a} to ${t}`);
    try {
      r.changeType(i), n.codecs[e] = t;
    } catch (c) {
      u.errorType = Me.Error.StreamingCodecsChangeError, u.error = c, c.metadata = u, n.error_ = c, n.trigger("error"), Me.log.warn(`Failed to changeType on ${e}Buffer`, c);
    }
  }
}, Hi = ({
  type: t,
  sourceUpdater: e,
  action: n,
  doneFn: r,
  name: i
}) => {
  e.queue.push({
    type: t,
    action: n,
    doneFn: r,
    name: i
  }), Jl(t, e);
}, ww = (t, e) => (n) => {
  const r = e[`${t}Buffered`](), i = PCe(r);
  if (e.logger_(`received "updateend" event for ${t} Source Buffer: `, i), e.queuePending[t]) {
    const s = e.queuePending[t].doneFn;
    e.queuePending[t] = null, s && s(e[`${t}Error_`]);
  }
  Jl(t, e);
};
class LM extends Me.EventTarget {
  constructor(e) {
    super(), this.mediaSource = e, this.sourceopenListener_ = () => Jl("mediaSource", this), this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_), this.logger_ = gs("SourceUpdater"), this.audioTimestampOffset_ = 0, this.videoTimestampOffset_ = 0, this.queue = [], this.queuePending = {
      audio: null,
      video: null
    }, this.delayedAudioAppendQueue_ = [], this.videoAppendQueued_ = !1, this.codecs = {}, this.onVideoUpdateEnd_ = ww("video", this), this.onAudioUpdateEnd_ = ww("audio", this), this.onVideoError_ = (n) => {
      this.videoError_ = n;
    }, this.onAudioError_ = (n) => {
      this.audioError_ = n;
    }, this.createdSourceBuffers_ = !1, this.initializedEme_ = !1, this.triggeredReady_ = !1;
  }
  initializedEme() {
    this.initializedEme_ = !0, this.triggerReady();
  }
  hasCreatedSourceBuffers() {
    return this.createdSourceBuffers_;
  }
  hasInitializedAnyEme() {
    return this.initializedEme_;
  }
  ready() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  }
  createSourceBuffers(e) {
    this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(e), this.createdSourceBuffers_ = !0, this.trigger("createdsourcebuffers"), this.triggerReady());
  }
  triggerReady() {
    this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0, this.trigger("ready"));
  }
  /**
   * Add a type of source buffer to the media source.
   *
   * @param {string} type
   *        The type of source buffer to add.
   *
   * @param {string} codec
   *        The codec to add the source buffer with.
   */
  addSourceBuffer(e, n) {
    Hi({
      type: "mediaSource",
      sourceUpdater: this,
      action: $i.addSourceBuffer(e, n),
      name: "addSourceBuffer"
    });
  }
  /**
   * call abort on a source buffer.
   *
   * @param {string} type
   *        The type of source buffer to call abort on.
   */
  abort(e) {
    Hi({
      type: e,
      sourceUpdater: this,
      action: $i.abort(e),
      name: "abort"
    });
  }
  /**
   * Call removeSourceBuffer and remove a specific type
   * of source buffer on the mediaSource.
   *
   * @param {string} type
   *        The type of source buffer to remove.
   */
  removeSourceBuffer(e) {
    if (!this.canRemoveSourceBuffer()) {
      Me.log.error("removeSourceBuffer is not supported!");
      return;
    }
    Hi({
      type: "mediaSource",
      sourceUpdater: this,
      action: $i.removeSourceBuffer(e),
      name: "removeSourceBuffer"
    });
  }
  /**
   * Whether or not the removeSourceBuffer function is supported
   * on the mediaSource.
   *
   * @return {boolean}
   *          if removeSourceBuffer can be called.
   */
  canRemoveSourceBuffer() {
    return !Me.browser.IS_FIREFOX && pe.MediaSource && pe.MediaSource.prototype && typeof pe.MediaSource.prototype.removeSourceBuffer == "function";
  }
  /**
   * Whether or not the changeType function is supported
   * on our SourceBuffers.
   *
   * @return {boolean}
   *         if changeType can be called.
   */
  static canChangeType() {
    return pe.SourceBuffer && pe.SourceBuffer.prototype && typeof pe.SourceBuffer.prototype.changeType == "function";
  }
  /**
   * Whether or not the changeType function is supported
   * on our SourceBuffers.
   *
   * @return {boolean}
   *         if changeType can be called.
   */
  canChangeType() {
    return this.constructor.canChangeType();
  }
  /**
   * Call the changeType function on a source buffer, given the code and type.
   *
   * @param {string} type
   *        The type of source buffer to call changeType on.
   *
   * @param {string} codec
   *        The codec string to change type with on the source buffer.
   */
  changeType(e, n) {
    if (!this.canChangeType()) {
      Me.log.error("changeType is not supported!");
      return;
    }
    Hi({
      type: e,
      sourceUpdater: this,
      action: $i.changeType(n),
      name: "changeType"
    });
  }
  /**
   * Add source buffers with a codec or, if they are already created,
   * call changeType on source buffers using changeType.
   *
   * @param {Object} codecs
   *        Codecs to switch to
   */
  addOrChangeSourceBuffers(e) {
    if (!e || typeof e != "object" || Object.keys(e).length === 0)
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    Object.keys(e).forEach((n) => {
      const r = e[n];
      if (!this.hasCreatedSourceBuffers())
        return this.addSourceBuffer(n, r);
      this.canChangeType() && this.changeType(n, r);
    });
  }
  /**
   * Queue an update to append an ArrayBuffer.
   *
   * @param {MediaObject} object containing audioBytes and/or videoBytes
   * @param {Function} done the function to call when done
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data
   */
  appendBuffer(e, n) {
    const {
      segmentInfo: r,
      type: i,
      bytes: s
    } = e;
    if (this.processedAppend_ = !0, i === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([e, n]), this.logger_(`delayed audio append of ${s.length} until video append`);
      return;
    }
    const a = n;
    if (Hi({
      type: i,
      sourceUpdater: this,
      action: $i.appendBuffer(s, r || {
        mediaIndex: -1
      }, a),
      doneFn: n,
      name: "appendBuffer"
    }), i === "video") {
      if (this.videoAppendQueued_ = !0, !this.delayedAudioAppendQueue_.length)
        return;
      const o = this.delayedAudioAppendQueue_.slice();
      this.logger_(`queuing delayed audio ${o.length} appendBuffers`), this.delayedAudioAppendQueue_.length = 0, o.forEach((u) => {
        this.appendBuffer.apply(this, u);
      });
    }
  }
  /**
   * Get the audio buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         The audio buffer's buffered time range
   */
  audioBuffered() {
    return Ks(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : Mr();
  }
  /**
   * Get the video buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         The video buffer's buffered time range
   */
  videoBuffered() {
    return Ks(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : Mr();
  }
  /**
   * Get a combined video/audio buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         the combined time range
   */
  buffered() {
    const e = Ks(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null, n = Ks(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    return n && !e ? this.audioBuffered() : e && !n ? this.videoBuffered() : BCe(this.audioBuffered(), this.videoBuffered());
  }
  /**
   * Add a callback to the queue that will set duration on the mediaSource.
   *
   * @param {number} duration
   *        The duration to set
   *
   * @param {Function} [doneFn]
   *        function to run after duration has been set.
   */
  setDuration(e, n = Na) {
    Hi({
      type: "mediaSource",
      sourceUpdater: this,
      action: $i.duration(e),
      name: "duration",
      doneFn: n
    });
  }
  /**
   * Add a mediaSource endOfStream call to the queue
   *
   * @param {Error} [error]
   *        Call endOfStream with an error
   *
   * @param {Function} [doneFn]
   *        A function that should be called when the
   *        endOfStream call has finished.
   */
  endOfStream(e = null, n = Na) {
    typeof e != "string" && (e = void 0), Hi({
      type: "mediaSource",
      sourceUpdater: this,
      action: $i.endOfStream(e),
      name: "endOfStream",
      doneFn: n
    });
  }
  /**
   * Queue an update to remove a time range from the buffer.
   *
   * @param {number} start where to start the removal
   * @param {number} end where to end the removal
   * @param {Function} [done=noop] optional callback to be executed when the remove
   * operation is complete
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
   */
  removeAudio(e, n, r = Na) {
    if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      r();
      return;
    }
    Hi({
      type: "audio",
      sourceUpdater: this,
      action: $i.remove(e, n),
      doneFn: r,
      name: "remove"
    });
  }
  /**
   * Queue an update to remove a time range from the buffer.
   *
   * @param {number} start where to start the removal
   * @param {number} end where to end the removal
   * @param {Function} [done=noop] optional callback to be executed when the remove
   * operation is complete
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
   */
  removeVideo(e, n, r = Na) {
    if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      r();
      return;
    }
    Hi({
      type: "video",
      sourceUpdater: this,
      action: $i.remove(e, n),
      doneFn: r,
      name: "remove"
    });
  }
  /**
   * Whether the underlying sourceBuffer is updating or not
   *
   * @return {boolean} the updating status of the SourceBuffer
   */
  updating() {
    return !!(py("audio", this) || py("video", this));
  }
  /**
   * Set/get the timestampoffset on the audio SourceBuffer
   *
   * @return {number} the timestamp offset
   */
  audioTimestampOffset(e) {
    return typeof e < "u" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== e && (Hi({
      type: "audio",
      sourceUpdater: this,
      action: $i.timestampOffset(e),
      name: "timestampOffset"
    }), this.audioTimestampOffset_ = e), this.audioTimestampOffset_;
  }
  /**
   * Set/get the timestampoffset on the video SourceBuffer
   *
   * @return {number} the timestamp offset
   */
  videoTimestampOffset(e) {
    return typeof e < "u" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset_ !== e && (Hi({
      type: "video",
      sourceUpdater: this,
      action: $i.timestampOffset(e),
      name: "timestampOffset"
    }), this.videoTimestampOffset_ = e), this.videoTimestampOffset_;
  }
  /**
   * Add a function to the queue that will be called
   * when it is its turn to run in the audio queue.
   *
   * @param {Function} callback
   *        The callback to queue.
   */
  audioQueueCallback(e) {
    this.audioBuffer && Hi({
      type: "audio",
      sourceUpdater: this,
      action: $i.callback(e),
      name: "callback"
    });
  }
  /**
   * Add a function to the queue that will be called
   * when it is its turn to run in the video queue.
   *
   * @param {Function} callback
   *        The callback to queue.
   */
  videoQueueCallback(e) {
    this.videoBuffer && Hi({
      type: "video",
      sourceUpdater: this,
      action: $i.callback(e),
      name: "callback"
    });
  }
  /**
   * dispose of the source updater and the underlying sourceBuffer
   */
  dispose() {
    this.trigger("dispose"), T6e.forEach((e) => {
      this.abort(e), this.canRemoveSourceBuffer() ? this.removeSourceBuffer(e) : this[`${e}QueueCallback`](() => NM(e, this));
    }), this.videoAppendQueued_ = !1, this.delayedAudioAppendQueue_.length = 0, this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_), this.off();
  }
}
const Cw = (t) => decodeURIComponent(escape(String.fromCharCode.apply(null, t))), E6e = (t) => {
  const e = new Uint8Array(t);
  return Array.from(e).map((n) => n.toString(16).padStart(2, "0")).join("");
}, Sw = new Uint8Array(`

`.split("").map((t) => t.charCodeAt(0)));
class x6e extends Error {
  constructor() {
    super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.");
  }
}
class w6e extends hy {
  constructor(e, n = {}) {
    super(e, n), this.mediaSource_ = null, this.subtitlesTrack_ = null, this.featuresNativeTextTracks_ = e.featuresNativeTextTracks, this.loadVttJs = e.loadVttJs, this.shouldSaveSegmentTimingInfo_ = !1;
  }
  /**
   * Indicates which time ranges are buffered
   *
   * @return {TimeRange}
   *         TimeRange object representing the current buffered ranges
   */
  buffered_() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length)
      return Mr();
    const e = this.subtitlesTrack_.cues, n = e[0].startTime, r = e[e.length - 1].startTime;
    return Mr([[n, r]]);
  }
  /**
   * Gets and sets init segment for the provided map
   *
   * @param {Object} map
   *        The map object representing the init segment to get or set
   * @param {boolean=} set
   *        If true, the init segment for the provided map should be saved
   * @return {Object}
   *         map object for desired init segment
   */
  initSegmentForMap(e, n = !1) {
    if (!e)
      return null;
    const r = T0(e);
    let i = this.initSegments_[r];
    if (n && !i && e.bytes) {
      const s = Sw.byteLength + e.bytes.byteLength, a = new Uint8Array(s);
      a.set(e.bytes), a.set(Sw, e.bytes.byteLength), this.initSegments_[r] = i = {
        resolvedUri: e.resolvedUri,
        byterange: e.byterange,
        bytes: a
      };
    }
    return i || e;
  }
  /**
   * Returns true if all configuration required for loading is present, otherwise false.
   *
   * @return {boolean} True if the all configuration is ready for loading
   * @private
   */
  couldBeginLoading_() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  }
  /**
   * Once all the starting parameters have been specified, begin
   * operation. This method should only be invoked from the INIT
   * state.
   *
   * @private
   */
  init_() {
    return this.state = "READY", this.resetEverything(), this.monitorBuffer_();
  }
  /**
   * Set a subtitle track on the segment loader to add subtitles to
   *
   * @param {TextTrack=} track
   *        The text track to add loaded subtitles to
   * @return {TextTrack}
   *        Returns the subtitles track
   */
  track(e) {
    return typeof e > "u" ? this.subtitlesTrack_ : (this.subtitlesTrack_ = e, this.state === "INIT" && this.couldBeginLoading_() && this.init_(), this.subtitlesTrack_);
  }
  /**
   * Remove any data in the source buffer between start and end times
   *
   * @param {number} start - the start time of the region to remove from the buffer
   * @param {number} end - the end time of the region to remove from the buffer
   */
  remove(e, n) {
    Xd(e, n, this.subtitlesTrack_);
  }
  /**
   * fill the buffer with segements unless the sourceBuffers are
   * currently updating
   *
   * Note: this function should only ever be called by monitorBuffer_
   * and never directly
   *
   * @private
   */
  fillBuffer_() {
    const e = this.chooseNextRequest_();
    if (e) {
      if (this.syncController_.timestampOffsetForTimeline(e.timeline) === null) {
        const n = () => {
          this.state = "READY", this.paused() || this.monitorBuffer_();
        };
        this.syncController_.one("timestampoffset", n), this.state = "WAITING_ON_TIMELINE";
        return;
      }
      this.loadSegment_(e);
    }
  }
  // never set a timestamp offset for vtt segments.
  timestampOffsetForSegment_() {
    return null;
  }
  chooseNextRequest_() {
    return this.skipEmptySegments_(super.chooseNextRequest_());
  }
  /**
   * Prevents the segment loader from requesting segments we know contain no subtitles
   * by walking forward until we find the next segment that we don't know whether it is
   * empty or not.
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @return {Object}
   *         a segment info object that describes the current segment
   */
  skipEmptySegments_(e) {
    for (; e && e.segment.empty; ) {
      if (e.mediaIndex + 1 >= e.playlist.segments.length) {
        e = null;
        break;
      }
      e = this.generateSegmentInfo_({
        playlist: e.playlist,
        mediaIndex: e.mediaIndex + 1,
        startOfSegment: e.startOfSegment + e.duration,
        isSyncRequest: e.isSyncRequest
      });
    }
    return e;
  }
  stopForError(e) {
    this.error(e), this.state = "READY", this.pause(), this.trigger("error");
  }
  /**
   * append a decrypted segement to the SourceBuffer through a SourceUpdater
   *
   * @private
   */
  segmentRequestFinished_(e, n, r) {
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    if (this.saveTransferStats_(n.stats), !this.pendingSegment_) {
      this.state = "READY", this.mediaRequestsAborted += 1;
      return;
    }
    if (e) {
      e.code === ia.TIMEOUT && this.handleTimeout_(), e.code === ia.ABORTED ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1, this.stopForError(e);
      return;
    }
    const i = this.pendingSegment_, s = r.mp4VttCues && r.mp4VttCues.length;
    s && (i.mp4VttCues = r.mp4VttCues), this.saveBandwidthRelatedStats_(i.duration, n.stats), n.key && this.segmentKey(n.key, !0), this.state = "APPENDING", this.trigger("appending");
    const a = i.segment;
    if (a.map && (a.map.bytes = n.map.bytes), i.bytes = n.bytes, typeof pe.WebVTT != "function" && typeof this.loadVttJs == "function") {
      this.state = "WAITING_ON_VTTJS", this.loadVttJs().then(() => this.segmentRequestFinished_(e, n, r), () => this.stopForError({
        message: "Error loading vtt.js"
      }));
      return;
    }
    a.requested = !0;
    try {
      this.parseVTTCues_(i);
    } catch (o) {
      this.stopForError({
        message: o.message,
        metadata: {
          errorType: Me.Error.StreamingVttParserError,
          error: o
        }
      });
      return;
    }
    if (s || this.updateTimeMapping_(i, this.syncController_.timelines[i.timeline], this.playlist_), i.cues.length ? i.timingInfo = {
      start: i.cues[0].startTime,
      end: i.cues[i.cues.length - 1].endTime
    } : i.timingInfo = {
      start: i.startOfSegment,
      end: i.startOfSegment + i.duration
    }, i.isSyncRequest) {
      this.trigger("syncinfoupdate"), this.pendingSegment_ = null, this.state = "READY";
      return;
    }
    i.byteLength = i.bytes.byteLength, this.mediaSecondsLoaded += a.duration, i.cues.forEach((o) => {
      this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new pe.VTTCue(o.startTime, o.endTime, o.text) : o);
    }), o6e(this.subtitlesTrack_), this.handleAppendsDone_();
  }
  handleData_(e, n) {
    const r = e && e.type === "vtt", i = n && n.type === "text";
    r && i && super.handleData_(e, n);
  }
  updateTimingInfoEnd_() {
  }
  /**
   * Utility function for converting mp4 webvtt cue objects into VTTCues.
   *
   * @param {Object} segmentInfo with mp4 webvtt cues for parsing into VTTCue objecs
   */
  parseMp4VttCues_(e) {
    const n = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    e.mp4VttCues.forEach((r) => {
      const i = r.start + n, s = r.end + n, a = new pe.VTTCue(i, s, r.cueText);
      r.settings && r.settings.split(" ").forEach((o) => {
        const u = o.split(":"), c = u[0], d = u[1];
        a[c] = isNaN(d) ? d : Number(d);
      }), e.cues.push(a);
    });
  }
  /**
   * Uses the WebVTT parser to parse the segment response
   *
   * @throws NoVttJsError
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @private
   */
  parseVTTCues_(e) {
    let n, r = !1;
    if (typeof pe.WebVTT != "function")
      throw new x6e();
    if (e.cues = [], e.timestampmap = {
      MPEGTS: 0,
      LOCAL: 0
    }, e.mp4VttCues) {
      this.parseMp4VttCues_(e);
      return;
    }
    typeof pe.TextDecoder == "function" ? n = new pe.TextDecoder("utf8") : (n = pe.WebVTT.StringDecoder(), r = !0);
    const i = new pe.WebVTT.Parser(pe, pe.vttjs, n);
    if (i.oncue = e.cues.push.bind(e.cues), i.ontimestampmap = (a) => {
      e.timestampmap = a;
    }, i.onparsingerror = (a) => {
      Me.log.warn("Error encountered when parsing cues: " + a.message);
    }, e.segment.map) {
      let a = e.segment.map.bytes;
      r && (a = Cw(a)), i.parse(a);
    }
    let s = e.bytes;
    r && (s = Cw(s)), i.parse(s), i.flush();
  }
  /**
   * Updates the start and end times of any cues parsed by the WebVTT parser using
   * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping
   * from the SyncController
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @param {Object} mappingObj
   *        object containing a mapping from TS to media time
   * @param {Object} playlist
   *        the playlist object containing the segment
   * @private
   */
  updateTimeMapping_(e, n, r) {
    const i = e.segment;
    if (!n)
      return;
    if (!e.cues.length) {
      i.empty = !0;
      return;
    }
    const {
      MPEGTS: s,
      LOCAL: a
    } = e.timestampmap, u = s / gu.ONE_SECOND_IN_TS - a + n.mapping;
    if (e.cues.forEach((c) => {
      const d = c.endTime - c.startTime, l = this.handleRollover_(c.startTime + u, n.time);
      c.startTime = Math.max(l, 0), c.endTime = Math.max(l + d, 0);
    }), !r.syncInfo) {
      const c = e.cues[0].startTime, d = e.cues[e.cues.length - 1].startTime;
      r.syncInfo = {
        mediaSequence: r.mediaSequence + e.mediaIndex,
        time: Math.min(c, d - i.duration)
      };
    }
  }
  /**
   * MPEG-TS PES timestamps are limited to 2^33.
   * Once they reach 2^33, they roll over to 0.
   * mux.js handles PES timestamp rollover for the following scenarios:
   * [forward rollover(right)] ->
   *    PES timestamps monotonically increase, and once they reach 2^33, they roll over to 0
   * [backward rollover(left)] -->
   *    we seek back to position before rollover.
   *
   * According to the HLS SPEC:
   * When synchronizing WebVTT with PES timestamps, clients SHOULD account
   * for cases where the 33-bit PES timestamps have wrapped and the WebVTT
   * cue times have not.  When the PES timestamp wraps, the WebVTT Segment
   * SHOULD have a X-TIMESTAMP-MAP header that maps the current WebVTT
   * time to the new (low valued) PES timestamp.
   *
   * So we want to handle rollover here and align VTT Cue start/end time to the player's time.
   */
  handleRollover_(e, n) {
    if (n === null)
      return e;
    let r = e * gu.ONE_SECOND_IN_TS;
    const i = n * gu.ONE_SECOND_IN_TS;
    let s;
    for (i < r ? s = -8589934592 : s = 8589934592; Math.abs(r - i) > 4294967296; )
      r += s;
    return r / gu.ONE_SECOND_IN_TS;
  }
}
const C6e = function(t, e) {
  const n = t.cues;
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    if (e >= i.adStartTime && e <= i.adEndTime)
      return i;
  }
  return null;
}, S6e = function(t, e, n = 0) {
  if (!t.segments)
    return;
  let r = n, i;
  for (let s = 0; s < t.segments.length; s++) {
    const a = t.segments[s];
    if (i || (i = C6e(e, r + a.duration / 2)), i) {
      if ("cueIn" in a) {
        i.endTime = r, i.adEndTime = r, r += a.duration, i = null;
        continue;
      }
      if (r < i.endTime) {
        r += a.duration;
        continue;
      }
      i.endTime += a.duration;
    } else if ("cueOut" in a && (i = new pe.VTTCue(r, r + a.duration, a.cueOut), i.adStartTime = r, i.adEndTime = r + parseFloat(a.cueOut), e.addCue(i)), "cueOutCont" in a) {
      const [o, u] = a.cueOutCont.split("/").map(parseFloat);
      i = new pe.VTTCue(r, r + a.duration, ""), i.adStartTime = r - o, i.adEndTime = i.adStartTime + u, e.addCue(i);
    }
    r += a.duration;
  }
};
class Iw {
  /**
   * @param {number} start - media sequence start
   * @param {number} end - media sequence end
   * @param {number} segmentIndex - index for associated segment
   * @param {number|null} [partIndex] - index for associated part
   * @param {boolean} [appended] - appended indicator
   *
   */
  constructor({
    start: e,
    end: n,
    segmentIndex: r,
    partIndex: i = null,
    appended: s = !1
  }) {
    this.start_ = e, this.end_ = n, this.segmentIndex_ = r, this.partIndex_ = i, this.appended_ = s;
  }
  isInRange(e) {
    return e >= this.start && e < this.end;
  }
  markAppended() {
    this.appended_ = !0;
  }
  resetAppendedStatus() {
    this.appended_ = !1;
  }
  get isAppended() {
    return this.appended_;
  }
  get start() {
    return this.start_;
  }
  get end() {
    return this.end_;
  }
  get segmentIndex() {
    return this.segmentIndex_;
  }
  get partIndex() {
    return this.partIndex_;
  }
}
class I6e {
  /**
   *
   * @param {SyncInfo} segmentSyncInfo - sync info for a given segment
   * @param {Array<SyncInfo>} [partsSyncInfo] - sync infos for a list of parts for a given segment
   */
  constructor(e, n = []) {
    this.segmentSyncInfo_ = e, this.partsSyncInfo_ = n;
  }
  get segmentSyncInfo() {
    return this.segmentSyncInfo_;
  }
  get partsSyncInfo() {
    return this.partsSyncInfo_;
  }
  get hasPartsSyncInfo() {
    return this.partsSyncInfo_.length > 0;
  }
  resetAppendStatus() {
    this.segmentSyncInfo_.resetAppendedStatus(), this.partsSyncInfo_.forEach((e) => e.resetAppendedStatus());
  }
}
class PM {
  constructor() {
    this.storage_ = /* @__PURE__ */ new Map(), this.diagnostics_ = "", this.isReliable_ = !1, this.start_ = -1 / 0, this.end_ = 1 / 0;
  }
  get start() {
    return this.start_;
  }
  get end() {
    return this.end_;
  }
  get diagnostics() {
    return this.diagnostics_;
  }
  get isReliable() {
    return this.isReliable_;
  }
  resetAppendedStatus() {
    this.storage_.forEach((e) => e.resetAppendStatus());
  }
  /**
   * update sync storage
   *
   * @param {Object} playlist
   * @param {number} currentTime
   *
   * @return {void}
   */
  update(e, n) {
    const {
      mediaSequence: r,
      segments: i
    } = e;
    if (this.isReliable_ = this.isReliablePlaylist_(r, i), !!this.isReliable_)
      return this.updateStorage_(i, r, this.calculateBaseTime_(r, i, n));
  }
  /**
   * @param {number} targetTime
   * @return {SyncInfo|null}
   */
  getSyncInfoForTime(e) {
    for (const {
      segmentSyncInfo: n,
      partsSyncInfo: r
    } of this.storage_.values())
      if (r.length) {
        for (const i of r)
          if (i.isInRange(e))
            return i;
      } else if (n.isInRange(e))
        return n;
    return null;
  }
  getSyncInfoForMediaSequence(e) {
    return this.storage_.get(e);
  }
  updateStorage_(e, n, r) {
    const i = /* @__PURE__ */ new Map();
    let s = `
`, a = r, o = n;
    this.start_ = a, e.forEach((u, c) => {
      const d = this.storage_.get(o), l = a, f = l + u.duration, p = !!(d && d.segmentSyncInfo && d.segmentSyncInfo.isAppended), m = new Iw({
        start: l,
        end: f,
        appended: p,
        segmentIndex: c
      });
      u.syncInfo = m;
      let g = a;
      const y = (u.parts || []).map((b, E) => {
        const v = g, _ = g + b.duration, D = !!(d && d.partsSyncInfo && d.partsSyncInfo[E] && d.partsSyncInfo[E].isAppended), S = new Iw({
          start: v,
          end: _,
          appended: D,
          segmentIndex: c,
          partIndex: E
        });
        return g = _, s += `Media Sequence: ${o}.${E} | Range: ${v} --> ${_} | Appended: ${D}
`, b.syncInfo = S, S;
      });
      i.set(o, new I6e(m, y)), s += `${MM(u.resolvedUri)} | Media Sequence: ${o} | Range: ${l} --> ${f} | Appended: ${p}
`, o++, a = f;
    }), this.end_ = a, this.storage_ = i, this.diagnostics_ = s;
  }
  calculateBaseTime_(e, n, r) {
    if (!this.storage_.size)
      return 0;
    if (this.storage_.has(e))
      return this.storage_.get(e).segmentSyncInfo.start;
    const i = Math.min(...this.storage_.keys());
    if (e < i) {
      const s = i - e;
      let a = this.storage_.get(i).segmentSyncInfo.start;
      for (let o = 0; o < s; o++) {
        const u = n[o];
        a -= u.duration;
      }
      return a;
    }
    return r;
  }
  isReliablePlaylist_(e, n) {
    return e != null && Array.isArray(n) && n.length;
  }
}
class kw extends PM {
  constructor(e) {
    super(), this.parent_ = e;
  }
  calculateBaseTime_(e, n, r) {
    if (!this.storage_.size) {
      const i = this.parent_.getSyncInfoForMediaSequence(e);
      return i ? i.segmentSyncInfo.start : 0;
    }
    return super.calculateBaseTime_(e, n, r);
  }
}
const k6e = 86400, d2 = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: (t, e, n, r, i) => n !== 1 / 0 ? {
      time: 0,
      segmentIndex: 0,
      partIndex: null
    } : null
  },
  {
    name: "MediaSequence",
    /**
     * run media sequence strategy
     *
     * @param {SyncController} syncController
     * @param {Object} playlist
     * @param {number} duration
     * @param {number} currentTimeline
     * @param {number} currentTime
     * @param {string} type
     */
    run: (t, e, n, r, i, s) => {
      const a = t.getMediaSequenceSync(s);
      if (!a || !a.isReliable)
        return null;
      const o = a.getSyncInfoForTime(i);
      return o ? {
        time: o.start,
        partIndex: o.partIndex,
        segmentIndex: o.segmentIndex
      } : null;
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: (t, e, n, r, i) => {
      if (!Object.keys(t.timelineToDatetimeMappings).length)
        return null;
      let s = null, a = null;
      const o = iy(e);
      i = i || 0;
      for (let u = 0; u < o.length; u++) {
        const c = e.endList || i === 0 ? u : o.length - (u + 1), d = o[c], l = d.segment, f = t.timelineToDatetimeMappings[l.timeline];
        if (!f || !l.dateTimeObject)
          continue;
        let m = l.dateTimeObject.getTime() / 1e3 + f;
        if (l.parts && typeof d.partIndex == "number")
          for (let y = 0; y < d.partIndex; y++)
            m += l.parts[y].duration;
        const g = Math.abs(i - m);
        if (a !== null && (g === 0 || a < g))
          break;
        a = g, s = {
          time: m,
          segmentIndex: d.segmentIndex,
          partIndex: d.partIndex
        };
      }
      return s;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: (t, e, n, r, i) => {
      let s = null, a = null;
      i = i || 0;
      const o = iy(e);
      for (let u = 0; u < o.length; u++) {
        const c = e.endList || i === 0 ? u : o.length - (u + 1), d = o[c], l = d.segment, f = d.part && d.part.start || l && l.start;
        if (l.timeline === r && typeof f < "u") {
          const p = Math.abs(i - f);
          if (a !== null && a < p)
            break;
          (!s || a === null || a >= p) && (a = p, s = {
            time: f,
            segmentIndex: d.segmentIndex,
            partIndex: d.partIndex
          });
        }
      }
      return s;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: (t, e, n, r, i) => {
      let s = null;
      if (i = i || 0, e.discontinuityStarts && e.discontinuityStarts.length) {
        let a = null;
        for (let o = 0; o < e.discontinuityStarts.length; o++) {
          const u = e.discontinuityStarts[o], c = e.discontinuitySequence + o + 1, d = t.discontinuities[c];
          if (d) {
            const l = Math.abs(i - d.time);
            if (a !== null && a < l)
              break;
            (!s || a === null || a >= l) && (a = l, s = {
              time: d.time,
              segmentIndex: u,
              partIndex: null
            });
          }
        }
      }
      return s;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: (t, e, n, r, i) => e.syncInfo ? {
      time: e.syncInfo.time,
      segmentIndex: e.syncInfo.mediaSequence - e.mediaSequence,
      partIndex: null
    } : null
  }
];
class D6e extends Me.EventTarget {
  constructor(e = {}) {
    super(), this.timelines = [], this.discontinuities = [], this.timelineToDatetimeMappings = {};
    const n = new PM(), r = new kw(n), i = new kw(n);
    this.mediaSequenceStorage_ = {
      main: n,
      audio: r,
      vtt: i
    }, this.logger_ = gs("SyncController");
  }
  /**
   *
   * @param {string} loaderType
   * @return {MediaSequenceSync|null}
   */
  getMediaSequenceSync(e) {
    return this.mediaSequenceStorage_[e] || null;
  }
  /**
   * Find a sync-point for the playlist specified
   *
   * A sync-point is defined as a known mapping from display-time to
   * a segment-index in the current playlist.
   *
   * @param {Playlist} playlist
   *        The playlist that needs a sync-point
   * @param {number} duration
   *        Duration of the MediaSource (Infinite if playing a live source)
   * @param {number} currentTimeline
   *        The last timeline from which a segment was loaded
   * @param {number} currentTime
   *        Current player's time
   * @param {string} type
   *        Segment loader type
   * @return {Object}
   *          A sync-point object
   */
  getSyncPoint(e, n, r, i, s) {
    if (n !== 1 / 0)
      return d2.find(({
        name: u
      }) => u === "VOD").run(this, e, n);
    const a = this.runStrategies_(e, n, r, i, s);
    if (!a.length)
      return null;
    for (const o of a) {
      const {
        syncPoint: u,
        strategy: c
      } = o, {
        segmentIndex: d,
        time: l
      } = u;
      if (d < 0)
        continue;
      const f = e.segments[d], p = l, m = p + f.duration;
      if (this.logger_(`Strategy: ${c}. Current time: ${i}. selected segment: ${d}. Time: [${p} -> ${m}]}`), i >= p && i < m)
        return this.logger_("Found sync point with exact match: ", u), u;
    }
    return this.selectSyncPoint_(a, {
      key: "time",
      value: i
    });
  }
  /**
   * Calculate the amount of time that has expired off the playlist during playback
   *
   * @param {Playlist} playlist
   *        Playlist object to calculate expired from
   * @param {number} duration
   *        Duration of the MediaSource (Infinity if playling a live source)
   * @return {number|null}
   *          The amount of time that has expired off the playlist during playback. Null
   *          if no sync-points for the playlist can be found.
   */
  getExpiredTime(e, n) {
    if (!e || !e.segments)
      return null;
    const r = this.runStrategies_(e, n, e.discontinuitySequence, 0);
    if (!r.length)
      return null;
    const i = this.selectSyncPoint_(r, {
      key: "segmentIndex",
      value: 0
    });
    return i.segmentIndex > 0 && (i.time *= -1), Math.abs(i.time + yf({
      defaultDuration: e.targetDuration,
      durationList: e.segments,
      startIndex: i.segmentIndex,
      endIndex: 0
    }));
  }
  /**
   * Runs each sync-point strategy and returns a list of sync-points returned by the
   * strategies
   *
   * @private
   * @param {Playlist} playlist
   *        The playlist that needs a sync-point
   * @param {number} duration
   *        Duration of the MediaSource (Infinity if playing a live source)
   * @param {number} currentTimeline
   *        The last timeline from which a segment was loaded
   * @param {number} currentTime
   *        Current player's time
   * @param {string} type
   *        Segment loader type
   * @return {Array}
   *          A list of sync-point objects
   */
  runStrategies_(e, n, r, i, s) {
    const a = [];
    for (let o = 0; o < d2.length; o++) {
      const u = d2[o], c = u.run(this, e, n, r, i, s);
      c && (c.strategy = u.name, a.push({
        strategy: u.name,
        syncPoint: c
      }));
    }
    return a;
  }
  /**
   * Selects the sync-point nearest the specified target
   *
   * @private
   * @param {Array} syncPoints
   *        List of sync-points to select from
   * @param {Object} target
   *        Object specifying the property and value we are targeting
   * @param {string} target.key
   *        Specifies the property to target. Must be either 'time' or 'segmentIndex'
   * @param {number} target.value
   *        The value to target for the specified key.
   * @return {Object}
   *          The sync-point nearest the target
   */
  selectSyncPoint_(e, n) {
    let r = e[0].syncPoint, i = Math.abs(e[0].syncPoint[n.key] - n.value), s = e[0].strategy;
    for (let a = 1; a < e.length; a++) {
      const o = Math.abs(e[a].syncPoint[n.key] - n.value);
      o < i && (i = o, r = e[a].syncPoint, s = e[a].strategy);
    }
    return this.logger_(`syncPoint for [${n.key}: ${n.value}] chosen with strategy [${s}]: [time:${r.time}, segmentIndex:${r.segmentIndex}` + (typeof r.partIndex == "number" ? `,partIndex:${r.partIndex}` : "") + "]"), r;
  }
  /**
   * Save any meta-data present on the segments when segments leave
   * the live window to the playlist to allow for synchronization at the
   * playlist level later.
   *
   * @param {Playlist} oldPlaylist - The previous active playlist
   * @param {Playlist} newPlaylist - The updated and most current playlist
   */
  saveExpiredSegmentInfo(e, n) {
    const r = n.mediaSequence - e.mediaSequence;
    if (r > k6e) {
      Me.log.warn(`Not saving expired segment info. Media sequence gap ${r} is too large.`);
      return;
    }
    for (let i = r - 1; i >= 0; i--) {
      const s = e.segments[i];
      if (s && typeof s.start < "u") {
        n.syncInfo = {
          mediaSequence: e.mediaSequence + i,
          time: s.start
        }, this.logger_(`playlist refresh sync: [time:${n.syncInfo.time}, mediaSequence: ${n.syncInfo.mediaSequence}]`), this.trigger("syncinfoupdate");
        break;
      }
    }
  }
  /**
   * Save the mapping from playlist's ProgramDateTime to display. This should only happen
   * before segments start to load.
   *
   * @param {Playlist} playlist - The currently active playlist
   */
  setDateTimeMappingForStart(e) {
    if (this.timelineToDatetimeMappings = {}, e.segments && e.segments.length && e.segments[0].dateTimeObject) {
      const n = e.segments[0], r = n.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[n.timeline] = -r;
    }
  }
  /**
   * Calculates and saves timeline mappings, playlist sync info, and segment timing values
   * based on the latest timing information.
   *
   * @param {Object} options
   *        Options object
   * @param {SegmentInfo} options.segmentInfo
   *        The current active request information
   * @param {boolean} options.shouldSaveTimelineMapping
   *        If there's a timeline change, determines if the timeline mapping should be
   *        saved for timeline mapping and program date time mappings.
   */
  saveSegmentTimingInfo({
    segmentInfo: e,
    shouldSaveTimelineMapping: n
  }) {
    const r = this.calculateSegmentTimeMapping_(e, e.timingInfo, n), i = e.segment;
    r && (this.saveDiscontinuitySyncInfo_(e), e.playlist.syncInfo || (e.playlist.syncInfo = {
      mediaSequence: e.playlist.mediaSequence + e.mediaIndex,
      time: i.start
    }));
    const s = i.dateTimeObject;
    i.discontinuity && n && s && (this.timelineToDatetimeMappings[i.timeline] = -(s.getTime() / 1e3));
  }
  timestampOffsetForTimeline(e) {
    return typeof this.timelines[e] > "u" ? null : this.timelines[e].time;
  }
  mappingForTimeline(e) {
    return typeof this.timelines[e] > "u" ? null : this.timelines[e].mapping;
  }
  /**
   * Use the "media time" for a segment to generate a mapping to "display time" and
   * save that display time to the segment.
   *
   * @private
   * @param {SegmentInfo} segmentInfo
   *        The current active request information
   * @param {Object} timingInfo
   *        The start and end time of the current segment in "media time"
   * @param {boolean} shouldSaveTimelineMapping
   *        If there's a timeline change, determines if the timeline mapping should be
   *        saved in timelines.
   * @return {boolean}
   *          Returns false if segment time mapping could not be calculated
   */
  calculateSegmentTimeMapping_(e, n, r) {
    const i = e.segment, s = e.part;
    let a = this.timelines[e.timeline], o, u;
    if (typeof e.timestampOffset == "number")
      a = {
        time: e.startOfSegment,
        mapping: e.startOfSegment - n.start
      }, r && (this.timelines[e.timeline] = a, this.trigger("timestampoffset"), this.logger_(`time mapping for timeline ${e.timeline}: [time: ${a.time}] [mapping: ${a.mapping}]`)), o = e.startOfSegment, u = n.end + a.mapping;
    else if (a)
      o = n.start + a.mapping, u = n.end + a.mapping;
    else
      return !1;
    return s && (s.start = o, s.end = u), (!i.start || o < i.start) && (i.start = o), i.end = u, !0;
  }
  /**
   * Each time we have discontinuity in the playlist, attempt to calculate the location
   * in display of the start of the discontinuity and save that. We also save an accuracy
   * value so that we save values with the most accuracy (closest to 0.)
   *
   * @private
   * @param {SegmentInfo} segmentInfo - The current active request information
   */
  saveDiscontinuitySyncInfo_(e) {
    const n = e.playlist, r = e.segment;
    if (r.discontinuity)
      this.discontinuities[r.timeline] = {
        time: r.start,
        accuracy: 0
      };
    else if (n.discontinuityStarts && n.discontinuityStarts.length)
      for (let i = 0; i < n.discontinuityStarts.length; i++) {
        const s = n.discontinuityStarts[i], a = n.discontinuitySequence + i + 1, o = s - e.mediaIndex, u = Math.abs(o);
        if (!this.discontinuities[a] || this.discontinuities[a].accuracy > u) {
          let c;
          o < 0 ? c = r.start - yf({
            defaultDuration: n.targetDuration,
            durationList: n.segments,
            startIndex: e.mediaIndex,
            endIndex: s
          }) : c = r.end + yf({
            defaultDuration: n.targetDuration,
            durationList: n.segments,
            startIndex: e.mediaIndex + 1,
            endIndex: s
          }), this.discontinuities[a] = {
            time: c,
            accuracy: u
          };
        }
      }
  }
  dispose() {
    this.trigger("dispose"), this.off();
  }
}
class M6e extends Me.EventTarget {
  constructor() {
    super(), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {};
  }
  clearPendingTimelineChange(e) {
    this.pendingTimelineChanges_[e] = null, this.trigger("pendingtimelinechange");
  }
  pendingTimelineChange({
    type: e,
    from: n,
    to: r
  }) {
    return typeof n == "number" && typeof r == "number" && (this.pendingTimelineChanges_[e] = {
      type: e,
      from: n,
      to: r
    }, this.trigger("pendingtimelinechange")), this.pendingTimelineChanges_[e];
  }
  lastTimelineChange({
    type: e,
    from: n,
    to: r
  }) {
    if (typeof n == "number" && typeof r == "number") {
      this.lastTimelineChanges_[e] = {
        type: e,
        from: n,
        to: r
      }, delete this.pendingTimelineChanges_[e];
      const i = {
        timelineChangeInfo: {
          from: n,
          to: r
        }
      };
      this.trigger({
        type: "timelinechange",
        metadata: i
      });
    }
    return this.lastTimelineChanges_[e];
  }
  dispose() {
    this.trigger("dispose"), this.pendingTimelineChanges_ = {}, this.lastTimelineChanges_ = {}, this.off();
  }
}
const O6e = vM(TM(function() {
  var t = /* @__PURE__ */ function() {
    function g() {
      this.listeners = {};
    }
    var y = g.prototype;
    return y.on = function(E, v) {
      this.listeners[E] || (this.listeners[E] = []), this.listeners[E].push(v);
    }, y.off = function(E, v) {
      if (!this.listeners[E])
        return !1;
      var _ = this.listeners[E].indexOf(v);
      return this.listeners[E] = this.listeners[E].slice(0), this.listeners[E].splice(_, 1), _ > -1;
    }, y.trigger = function(E) {
      var v = this.listeners[E];
      if (v)
        if (arguments.length === 2)
          for (var _ = v.length, D = 0; D < _; ++D)
            v[D].call(this, arguments[1]);
        else
          for (var S = Array.prototype.slice.call(arguments, 1), M = v.length, O = 0; O < M; ++O)
            v[O].apply(this, S);
    }, y.dispose = function() {
      this.listeners = {};
    }, y.pipe = function(E) {
      this.on("data", function(v) {
        E.push(v);
      });
    }, g;
  }();
  /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
  function e(g) {
    return g.subarray(0, g.byteLength - g[g.byteLength - 1]);
  }
  /*! @name aes-decrypter @version 4.0.2 @license Apache-2.0 */
  const n = function() {
    const g = [[[], [], [], [], []], [[], [], [], [], []]], y = g[0], b = g[1], E = y[4], v = b[4];
    let _, D, S;
    const M = [], O = [];
    let T, N, H, $, j, U;
    for (_ = 0; _ < 256; _++)
      O[(M[_] = _ << 1 ^ (_ >> 7) * 283) ^ _] = _;
    for (D = S = 0; !E[D]; D ^= T || 1, S = O[S] || 1)
      for ($ = S ^ S << 1 ^ S << 2 ^ S << 3 ^ S << 4, $ = $ >> 8 ^ $ & 255 ^ 99, E[D] = $, v[$] = D, H = M[N = M[T = M[D]]], U = H * 16843009 ^ N * 65537 ^ T * 257 ^ D * 16843008, j = M[$] * 257 ^ $ * 16843008, _ = 0; _ < 4; _++)
        y[_][D] = j = j << 24 ^ j >>> 8, b[_][$] = U = U << 24 ^ U >>> 8;
    for (_ = 0; _ < 5; _++)
      y[_] = y[_].slice(0), b[_] = b[_].slice(0);
    return g;
  };
  let r = null;
  class i {
    constructor(y) {
      r || (r = n()), this._tables = [[r[0][0].slice(), r[0][1].slice(), r[0][2].slice(), r[0][3].slice(), r[0][4].slice()], [r[1][0].slice(), r[1][1].slice(), r[1][2].slice(), r[1][3].slice(), r[1][4].slice()]];
      let b, E, v;
      const _ = this._tables[0][4], D = this._tables[1], S = y.length;
      let M = 1;
      if (S !== 4 && S !== 6 && S !== 8)
        throw new Error("Invalid aes key size");
      const O = y.slice(0), T = [];
      for (this._key = [O, T], b = S; b < 4 * S + 28; b++)
        v = O[b - 1], (b % S === 0 || S === 8 && b % S === 4) && (v = _[v >>> 24] << 24 ^ _[v >> 16 & 255] << 16 ^ _[v >> 8 & 255] << 8 ^ _[v & 255], b % S === 0 && (v = v << 8 ^ v >>> 24 ^ M << 24, M = M << 1 ^ (M >> 7) * 283)), O[b] = O[b - S] ^ v;
      for (E = 0; b; E++, b--)
        v = O[E & 3 ? b : b - 4], b <= 4 || E < 4 ? T[E] = v : T[E] = D[0][_[v >>> 24]] ^ D[1][_[v >> 16 & 255]] ^ D[2][_[v >> 8 & 255]] ^ D[3][_[v & 255]];
    }
    /**
     * Decrypt 16 bytes, specified as four 32-bit words.
     *
     * @param {number} encrypted0 the first word to decrypt
     * @param {number} encrypted1 the second word to decrypt
     * @param {number} encrypted2 the third word to decrypt
     * @param {number} encrypted3 the fourth word to decrypt
     * @param {Int32Array} out the array to write the decrypted words
     * into
     * @param {number} offset the offset into the output array to start
     * writing results
     * @return {Array} The plaintext.
     */
    decrypt(y, b, E, v, _, D) {
      const S = this._key[1];
      let M = y ^ S[0], O = v ^ S[1], T = E ^ S[2], N = b ^ S[3], H, $, j;
      const U = S.length / 4 - 2;
      let V, B = 4;
      const R = this._tables[1], K = R[0], Q = R[1], P = R[2], I = R[3], G = R[4];
      for (V = 0; V < U; V++)
        H = K[M >>> 24] ^ Q[O >> 16 & 255] ^ P[T >> 8 & 255] ^ I[N & 255] ^ S[B], $ = K[O >>> 24] ^ Q[T >> 16 & 255] ^ P[N >> 8 & 255] ^ I[M & 255] ^ S[B + 1], j = K[T >>> 24] ^ Q[N >> 16 & 255] ^ P[M >> 8 & 255] ^ I[O & 255] ^ S[B + 2], N = K[N >>> 24] ^ Q[M >> 16 & 255] ^ P[O >> 8 & 255] ^ I[T & 255] ^ S[B + 3], B += 4, M = H, O = $, T = j;
      for (V = 0; V < 4; V++)
        _[(3 & -V) + D] = G[M >>> 24] << 24 ^ G[O >> 16 & 255] << 16 ^ G[T >> 8 & 255] << 8 ^ G[N & 255] ^ S[B++], H = M, M = O, O = T, T = N, N = H;
    }
  }
  class s extends t {
    constructor() {
      super(t), this.jobs = [], this.delay = 1, this.timeout_ = null;
    }
    /**
     * process an async job
     *
     * @private
     */
    processJob_() {
      this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null;
    }
    /**
     * push a job into the stream
     *
     * @param {Function} job the job to push into the stream
     */
    push(y) {
      this.jobs.push(y), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay));
    }
  }
  const a = function(g) {
    return g << 24 | (g & 65280) << 8 | (g & 16711680) >> 8 | g >>> 24;
  }, o = function(g, y, b) {
    const E = new Int32Array(g.buffer, g.byteOffset, g.byteLength >> 2), v = new i(Array.prototype.slice.call(y)), _ = new Uint8Array(g.byteLength), D = new Int32Array(_.buffer);
    let S, M, O, T, N, H, $, j, U;
    for (S = b[0], M = b[1], O = b[2], T = b[3], U = 0; U < E.length; U += 4)
      N = a(E[U]), H = a(E[U + 1]), $ = a(E[U + 2]), j = a(E[U + 3]), v.decrypt(N, H, $, j, D, U), D[U] = a(D[U] ^ S), D[U + 1] = a(D[U + 1] ^ M), D[U + 2] = a(D[U + 2] ^ O), D[U + 3] = a(D[U + 3] ^ T), S = N, M = H, O = $, T = j;
    return _;
  };
  class u {
    constructor(y, b, E, v) {
      const _ = u.STEP, D = new Int32Array(y.buffer), S = new Uint8Array(y.byteLength);
      let M = 0;
      for (this.asyncStream_ = new s(), this.asyncStream_.push(this.decryptChunk_(D.subarray(M, M + _), b, E, S)), M = _; M < D.length; M += _)
        E = new Uint32Array([a(D[M - 4]), a(D[M - 3]), a(D[M - 2]), a(D[M - 1])]), this.asyncStream_.push(this.decryptChunk_(D.subarray(M, M + _), b, E, S));
      this.asyncStream_.push(function() {
        v(null, e(S));
      });
    }
    /**
     * a getter for step the maximum number of bytes to process at one time
     *
     * @return {number} the value of step 32000
     */
    static get STEP() {
      return 32e3;
    }
    /**
     * @private
     */
    decryptChunk_(y, b, E, v) {
      return function() {
        const _ = o(y, b, E);
        v.set(_, y.byteOffset);
      };
    }
  }
  var c = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, d;
  typeof window < "u" ? d = window : typeof c < "u" ? d = c : typeof self < "u" ? d = self : d = {};
  var l = d, f = function(y) {
    return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(y) : y && y.buffer instanceof ArrayBuffer;
  }, p = l.BigInt || Number;
  p("0x1"), p("0x100"), p("0x10000"), p("0x1000000"), p("0x100000000"), p("0x10000000000"), p("0x1000000000000"), p("0x100000000000000"), p("0x10000000000000000"), function() {
    var g = new Uint16Array([65484]), y = new Uint8Array(g.buffer, g.byteOffset, g.byteLength);
    return y[0] === 255 ? "big" : y[0] === 204 ? "little" : "unknown";
  }();
  const m = function(g) {
    const y = {};
    return Object.keys(g).forEach((b) => {
      const E = g[b];
      f(E) ? y[b] = {
        bytes: E.buffer,
        byteOffset: E.byteOffset,
        byteLength: E.byteLength
      } : y[b] = E;
    }), y;
  };
  self.onmessage = function(g) {
    const y = g.data, b = new Uint8Array(y.encrypted.bytes, y.encrypted.byteOffset, y.encrypted.byteLength), E = new Uint32Array(y.key.bytes, y.key.byteOffset, y.key.byteLength / 4), v = new Uint32Array(y.iv.bytes, y.iv.byteOffset, y.iv.byteLength / 4);
    new u(b, E, v, function(_, D) {
      self.postMessage(m({
        source: y.source,
        decrypted: D
      }), [D.buffer]);
    });
  };
}));
var N6e = yM(O6e);
const L6e = (t) => {
  let e = t.default ? "main" : "alternative";
  return t.characteristics && t.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (e = "main-desc"), e;
}, RM = (t, e) => {
  t.abort(), t.pause(), e && e.activePlaylistLoader && (e.activePlaylistLoader.pause(), e.activePlaylistLoader = null);
}, my = (t, e) => {
  e.activePlaylistLoader = t, t.load();
}, P6e = (t, e) => () => {
  const {
    segmentLoaders: {
      [t]: n,
      main: r
    },
    mediaTypes: {
      [t]: i
    }
  } = e, s = i.activeTrack(), a = i.getActiveGroup(), o = i.activePlaylistLoader, u = i.lastGroup_;
  if (!(a && u && a.id === u.id) && (i.lastGroup_ = a, i.lastTrack_ = s, RM(n, i), !(!a || a.isMainPlaylist))) {
    if (!a.playlistLoader) {
      o && r.resetEverything();
      return;
    }
    n.resyncLoader(), my(a.playlistLoader, i);
  }
}, R6e = (t, e) => () => {
  const {
    segmentLoaders: {
      [t]: n
    },
    mediaTypes: {
      [t]: r
    }
  } = e;
  r.lastGroup_ = null, n.abort(), n.pause();
}, B6e = (t, e) => () => {
  const {
    mainPlaylistLoader: n,
    segmentLoaders: {
      [t]: r,
      main: i
    },
    mediaTypes: {
      [t]: s
    }
  } = e, a = s.activeTrack(), o = s.getActiveGroup(), u = s.activePlaylistLoader, c = s.lastTrack_;
  if (!(c && a && c.id === a.id) && (s.lastGroup_ = o, s.lastTrack_ = a, RM(r, s), !!o)) {
    if (o.isMainPlaylist) {
      if (!a || !c || a.id === c.id)
        return;
      const d = e.vhs.playlistController_, l = d.selectPlaylist();
      if (d.media() === l)
        return;
      s.logger_(`track change. Switching main audio from ${c.id} to ${a.id}`), n.pause(), i.resetEverything(), d.fastQualityChange_(l);
      return;
    }
    if (t === "AUDIO") {
      if (!o.playlistLoader) {
        i.setAudio(!0), i.resetEverything();
        return;
      }
      r.setAudio(!0), i.setAudio(!1);
    }
    if (u === o.playlistLoader) {
      my(o.playlistLoader, s);
      return;
    }
    r.track && r.track(a), r.resetEverything(), my(o.playlistLoader, s);
  }
}, _0 = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is excluded) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: (t, e) => () => {
    const {
      mediaTypes: {
        [t]: n
      },
      excludePlaylist: r
    } = e, i = n.activeTrack(), s = n.activeGroup(), a = (s.filter((u) => u.default)[0] || s[0]).id, o = n.tracks[a];
    if (i === o) {
      r({
        error: {
          message: "Problem encountered loading the default audio track."
        }
      });
      return;
    }
    Me.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
    for (const u in n.tracks)
      n.tracks[u].enabled = n.tracks[u] === o;
    n.onTrackChanged();
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: (t, e) => () => {
    const {
      mediaTypes: {
        [t]: n
      }
    } = e;
    Me.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
    const r = n.activeTrack();
    r && (r.mode = "disabled"), n.onTrackChanged();
  }
}, Dw = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: (t, e, n) => {
    if (!e)
      return;
    const {
      tech: r,
      requestOptions: i,
      segmentLoaders: {
        [t]: s
      }
    } = n;
    e.on("loadedmetadata", () => {
      const a = e.media();
      s.playlist(a, i), (!r.paused() || a.endList && r.preload() !== "none") && s.load();
    }), e.on("loadedplaylist", () => {
      s.playlist(e.media(), i), r.paused() || s.load();
    }), e.on("error", _0[t](t, n));
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: (t, e, n) => {
    const {
      tech: r,
      requestOptions: i,
      segmentLoaders: {
        [t]: s
      },
      mediaTypes: {
        [t]: a
      }
    } = n;
    e.on("loadedmetadata", () => {
      const o = e.media();
      s.playlist(o, i), s.track(a.activeTrack()), (!r.paused() || o.endList && r.preload() !== "none") && s.load();
    }), e.on("loadedplaylist", () => {
      s.playlist(e.media(), i), r.paused() || s.load();
    }), e.on("error", _0[t](t, n));
  }
}, F6e = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  AUDIO: (t, e) => {
    const {
      vhs: n,
      sourceType: r,
      segmentLoaders: {
        [t]: i
      },
      requestOptions: s,
      main: {
        mediaGroups: a
      },
      mediaTypes: {
        [t]: {
          groups: o,
          tracks: u,
          logger_: c
        }
      },
      mainPlaylistLoader: d
    } = e, l = xh(d.main);
    (!a[t] || Object.keys(a[t]).length === 0) && (a[t] = {
      main: {
        default: {
          default: !0
        }
      }
    }, l && (a[t].main.default.playlists = d.main.playlists));
    for (const f in a[t]) {
      o[f] || (o[f] = []);
      for (const p in a[t][f]) {
        let m = a[t][f][p], g;
        if (l ? (c(`AUDIO group '${f}' label '${p}' is a main playlist`), m.isMainPlaylist = !0, g = null) : r === "vhs-json" && m.playlists ? g = new Fl(m.playlists[0], n, s) : m.resolvedUri ? g = new Fl(m.resolvedUri, n, s) : m.playlists && r === "dash" ? g = new cy(m.playlists[0], n, s, d) : g = null, m = xn({
          id: p,
          playlistLoader: g
        }, m), Dw[t](t, m.playlistLoader, e), o[f].push(m), typeof u[p] > "u") {
          const y = new Me.AudioTrack({
            id: p,
            kind: L6e(m),
            enabled: !1,
            language: m.language,
            default: m.default,
            label: p
          });
          u[p] = y;
        }
      }
    }
    i.on("error", _0[t](t, e));
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  SUBTITLES: (t, e) => {
    const {
      tech: n,
      vhs: r,
      sourceType: i,
      segmentLoaders: {
        [t]: s
      },
      requestOptions: a,
      main: {
        mediaGroups: o
      },
      mediaTypes: {
        [t]: {
          groups: u,
          tracks: c
        }
      },
      mainPlaylistLoader: d
    } = e;
    for (const l in o[t]) {
      u[l] || (u[l] = []);
      for (const f in o[t][l]) {
        if (!r.options_.useForcedSubtitles && o[t][l][f].forced)
          continue;
        let p = o[t][l][f], m;
        if (i === "hls")
          m = new Fl(p.resolvedUri, r, a);
        else if (i === "dash") {
          if (!p.playlists.filter((y) => y.excludeUntil !== 1 / 0).length)
            return;
          m = new cy(p.playlists[0], r, a, d);
        } else i === "vhs-json" && (m = new Fl(
          // if the vhs-json object included the media playlist, use the media playlist
          // as provided, otherwise use the resolved URI to load the playlist
          p.playlists ? p.playlists[0] : p.resolvedUri,
          r,
          a
        ));
        if (p = xn({
          id: f,
          playlistLoader: m
        }, p), Dw[t](t, p.playlistLoader, e), u[l].push(p), typeof c[f] > "u") {
          const g = n.addRemoteTextTrack({
            id: f,
            kind: "subtitles",
            default: p.default && p.autoselect,
            language: p.language,
            label: f
          }, !1).track;
          c[f] = g;
        }
      }
    }
    s.on("error", _0[t](t, e));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": (t, e) => {
    const {
      tech: n,
      main: {
        mediaGroups: r
      },
      mediaTypes: {
        [t]: {
          groups: i,
          tracks: s
        }
      }
    } = e;
    for (const a in r[t]) {
      i[a] || (i[a] = []);
      for (const o in r[t][a]) {
        const u = r[t][a][o];
        if (!/^(?:CC|SERVICE)/.test(u.instreamId))
          continue;
        const c = n.options_.vhs && n.options_.vhs.captionServices || {};
        let d = {
          label: o,
          language: u.language,
          instreamId: u.instreamId,
          default: u.default && u.autoselect
        };
        if (c[d.instreamId] && (d = xn(d, c[d.instreamId])), d.default === void 0 && delete d.default, i[a].push(xn({
          id: o
        }, u)), typeof s[o] > "u") {
          const l = n.addRemoteTextTrack({
            id: d.instreamId,
            kind: "captions",
            default: d.default,
            language: d.language,
            label: d.label
          }, !1).track;
          s[o] = l;
        }
      }
    }
  }
}, BM = (t, e) => {
  for (let n = 0; n < t.length; n++)
    if (jT(e, t[n]) || t[n].playlists && BM(t[n].playlists, e))
      return !0;
  return !1;
}, U6e = (t, e) => (n) => {
  const {
    mainPlaylistLoader: r,
    mediaTypes: {
      [t]: {
        groups: i
      }
    }
  } = e, s = r.media();
  if (!s)
    return null;
  let a = null;
  s.attributes[t] && (a = i[s.attributes[t]]);
  const o = Object.keys(i);
  if (!a)
    if (t === "AUDIO" && o.length > 1 && xh(e.main))
      for (let u = 0; u < o.length; u++) {
        const c = i[o[u]];
        if (BM(c, s)) {
          a = c;
          break;
        }
      }
    else i.main ? a = i.main : o.length === 1 && (a = i[o[0]]);
  return typeof n > "u" ? a : n === null || !a ? null : a.filter((u) => u.id === n.id)[0] || null;
}, $6e = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: (t, e) => () => {
    const {
      mediaTypes: {
        [t]: {
          tracks: n
        }
      }
    } = e;
    for (const r in n)
      if (n[r].enabled)
        return n[r];
    return null;
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: (t, e) => () => {
    const {
      mediaTypes: {
        [t]: {
          tracks: n
        }
      }
    } = e;
    for (const r in n)
      if (n[r].mode === "showing" || n[r].mode === "hidden")
        return n[r];
    return null;
  }
}, H6e = (t, {
  mediaTypes: e
}) => () => {
  const n = e[t].activeTrack();
  return n ? e[t].activeGroup(n) : null;
}, j6e = (t) => {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((c) => {
    F6e[c](c, t);
  });
  const {
    mediaTypes: e,
    mainPlaylistLoader: n,
    tech: r,
    vhs: i,
    segmentLoaders: {
      ["AUDIO"]: s,
      main: a
    }
  } = t;
  ["AUDIO", "SUBTITLES"].forEach((c) => {
    e[c].activeGroup = U6e(c, t), e[c].activeTrack = $6e[c](c, t), e[c].onGroupChanged = P6e(c, t), e[c].onGroupChanging = R6e(c, t), e[c].onTrackChanged = B6e(c, t), e[c].getActiveGroup = H6e(c, t);
  });
  const o = e.AUDIO.activeGroup();
  if (o) {
    const c = (o.filter((l) => l.default)[0] || o[0]).id;
    e.AUDIO.tracks[c].enabled = !0, e.AUDIO.onGroupChanged(), e.AUDIO.onTrackChanged(), e.AUDIO.getActiveGroup().playlistLoader ? (a.setAudio(!1), s.setAudio(!0)) : a.setAudio(!0);
  }
  n.on("mediachange", () => {
    ["AUDIO", "SUBTITLES"].forEach((c) => e[c].onGroupChanged());
  }), n.on("mediachanging", () => {
    ["AUDIO", "SUBTITLES"].forEach((c) => e[c].onGroupChanging());
  });
  const u = () => {
    e.AUDIO.onTrackChanged(), r.trigger({
      type: "usage",
      name: "vhs-audio-change"
    });
  };
  r.audioTracks().addEventListener("change", u), r.remoteTextTracks().addEventListener("change", e.SUBTITLES.onTrackChanged), i.on("dispose", () => {
    r.audioTracks().removeEventListener("change", u), r.remoteTextTracks().removeEventListener("change", e.SUBTITLES.onTrackChanged);
  }), r.clearTracks("audio");
  for (const c in e.AUDIO.tracks)
    r.audioTracks().addTrack(e.AUDIO.tracks[c]);
}, z6e = () => {
  const t = {};
  return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((e) => {
    t[e] = {
      groups: {},
      tracks: {},
      activePlaylistLoader: null,
      activeGroup: Na,
      activeTrack: Na,
      getActiveGroup: Na,
      onGroupChanged: Na,
      onTrackChanged: Na,
      lastTrack_: null,
      logger_: gs(`MediaGroups[${e}]`)
    };
  }), t;
};
class Mw {
  constructor() {
    this.priority_ = [], this.pathwayClones_ = /* @__PURE__ */ new Map();
  }
  set version(e) {
    e === 1 && (this.version_ = e);
  }
  set ttl(e) {
    this.ttl_ = e || 300;
  }
  set reloadUri(e) {
    e && (this.reloadUri_ = wi(this.reloadUri_, e));
  }
  set priority(e) {
    e && e.length && (this.priority_ = e);
  }
  set pathwayClones(e) {
    e && e.length && (this.pathwayClones_ = new Map(e.map((n) => [n.ID, n])));
  }
  get version() {
    return this.version_;
  }
  get ttl() {
    return this.ttl_;
  }
  get reloadUri() {
    return this.reloadUri_;
  }
  get priority() {
    return this.priority_;
  }
  get pathwayClones() {
    return this.pathwayClones_;
  }
}
class q6e extends Me.EventTarget {
  constructor(e, n) {
    super(), this.currentPathway = null, this.defaultPathway = null, this.queryBeforeStart = !1, this.availablePathways_ = /* @__PURE__ */ new Set(), this.steeringManifest = new Mw(), this.proxyServerUrl_ = null, this.manifestType_ = null, this.ttlTimeout_ = null, this.request_ = null, this.currentPathwayClones = /* @__PURE__ */ new Map(), this.nextPathwayClones = /* @__PURE__ */ new Map(), this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set(), this.logger_ = gs("Content Steering"), this.xhr_ = e, this.getBandwidth_ = n;
  }
  /**
   * Assigns the content steering tag properties to the steering controller
   *
   * @param {string} baseUrl the baseURL from the main manifest for resolving the steering manifest url
   * @param {Object} steeringTag the content steering tag from the main manifest
   */
  assignTagProperties(e, n) {
    this.manifestType_ = n.serverUri ? "HLS" : "DASH";
    const r = n.serverUri || n.serverURL;
    if (!r) {
      this.logger_(`steering manifest URL is ${r}, cannot request steering manifest.`), this.trigger("error");
      return;
    }
    if (r.startsWith("data:")) {
      this.decodeDataUriManifest_(r.substring(r.indexOf(",") + 1));
      return;
    }
    this.steeringManifest.reloadUri = wi(e, r), this.defaultPathway = n.pathwayId || n.defaultServiceLocation, this.queryBeforeStart = n.queryBeforeStart, this.proxyServerUrl_ = n.proxyServerURL, this.defaultPathway && !this.queryBeforeStart && this.trigger("content-steering");
  }
  /**
   * Requests the content steering manifest and parse the response. This should only be called after
   * assignTagProperties was called with a content steering tag.
   *
   * @param {string} initialUri The optional uri to make the request with.
   *    If set, the request should be made with exactly what is passed in this variable.
   *    This scenario should only happen once on initalization.
   */
  requestSteeringManifest(e) {
    const n = this.steeringManifest.reloadUri;
    if (!n)
      return;
    const r = e ? n : this.getRequestURI(n);
    if (!r) {
      this.logger_("No valid content steering manifest URIs. Stopping content steering."), this.trigger("error"), this.dispose();
      return;
    }
    const i = {
      contentSteeringInfo: {
        uri: r
      }
    };
    this.trigger({
      type: "contentsteeringloadstart",
      metadata: i
    }), this.request_ = this.xhr_({
      uri: r,
      requestType: "content-steering-manifest"
    }, (s, a) => {
      if (s) {
        if (a.status === 410) {
          this.logger_(`manifest request 410 ${s}.`), this.logger_(`There will be no more content steering requests to ${r} this session.`), this.excludedSteeringManifestURLs.add(r);
          return;
        }
        if (a.status === 429) {
          const c = a.responseHeaders["retry-after"];
          this.logger_(`manifest request 429 ${s}.`), this.logger_(`content steering will retry in ${c} seconds.`), this.startTTLTimeout_(parseInt(c, 10));
          return;
        }
        this.logger_(`manifest failed to load ${s}.`), this.startTTLTimeout_();
        return;
      }
      this.trigger({
        type: "contentsteeringloadcomplete",
        metadata: i
      });
      let o;
      try {
        o = JSON.parse(this.request_.responseText);
      } catch (c) {
        const d = {
          errorType: Me.Error.StreamingContentSteeringParserError,
          error: c
        };
        this.trigger({
          type: "error",
          metadata: d
        });
      }
      this.assignSteeringProperties_(o);
      const u = {
        contentSteeringInfo: i.contentSteeringInfo,
        contentSteeringManifest: {
          version: this.steeringManifest.version,
          reloadUri: this.steeringManifest.reloadUri,
          priority: this.steeringManifest.priority
        }
      };
      this.trigger({
        type: "contentsteeringparsed",
        metadata: u
      }), this.startTTLTimeout_();
    });
  }
  /**
   * Set the proxy server URL and add the steering manifest url as a URI encoded parameter.
   *
   * @param {string} steeringUrl the steering manifest url
   * @return the steering manifest url to a proxy server with all parameters set
   */
  setProxyServerUrl_(e) {
    const n = new pe.URL(e), r = new pe.URL(this.proxyServerUrl_);
    return r.searchParams.set("url", encodeURI(n.toString())), this.setSteeringParams_(r.toString());
  }
  /**
   * Decodes and parses the data uri encoded steering manifest
   *
   * @param {string} dataUri the data uri to be decoded and parsed.
   */
  decodeDataUriManifest_(e) {
    const n = JSON.parse(pe.atob(e));
    this.assignSteeringProperties_(n);
  }
  /**
   * Set the HLS or DASH content steering manifest request query parameters. For example:
   * _HLS_pathway="<CURRENT-PATHWAY-ID>" and _HLS_throughput=<THROUGHPUT>
   * _DASH_pathway and _DASH_throughput
   *
   * @param {string} uri to add content steering server parameters to.
   * @return a new uri as a string with the added steering query parameters.
   */
  setSteeringParams_(e) {
    const n = new pe.URL(e), r = this.getPathway(), i = this.getBandwidth_();
    if (r) {
      const s = `_${this.manifestType_}_pathway`;
      n.searchParams.set(s, r);
    }
    if (i) {
      const s = `_${this.manifestType_}_throughput`;
      n.searchParams.set(s, i);
    }
    return n.toString();
  }
  /**
   * Assigns the current steering manifest properties and to the SteeringManifest object
   *
   * @param {Object} steeringJson the raw JSON steering manifest
   */
  assignSteeringProperties_(e) {
    if (this.steeringManifest.version = e.VERSION, !this.steeringManifest.version) {
      this.logger_(`manifest version is ${e.VERSION}, which is not supported.`), this.trigger("error");
      return;
    }
    this.steeringManifest.ttl = e.TTL, this.steeringManifest.reloadUri = e["RELOAD-URI"], this.steeringManifest.priority = e["PATHWAY-PRIORITY"] || e["SERVICE-LOCATION-PRIORITY"], this.steeringManifest.pathwayClones = e["PATHWAY-CLONES"], this.nextPathwayClones = this.steeringManifest.pathwayClones, this.availablePathways_.size || (this.logger_("There are no available pathways for content steering. Ending content steering."), this.trigger("error"), this.dispose());
    const r = ((i) => {
      for (const s of i)
        if (this.availablePathways_.has(s))
          return s;
      return [...this.availablePathways_][0];
    })(this.steeringManifest.priority);
    this.currentPathway !== r && (this.currentPathway = r, this.trigger("content-steering"));
  }
  /**
   * Returns the pathway to use for steering decisions
   *
   * @return {string} returns the current pathway or the default
   */
  getPathway() {
    return this.currentPathway || this.defaultPathway;
  }
  /**
   * Chooses the manifest request URI based on proxy URIs and server URLs.
   * Also accounts for exclusion on certain manifest URIs.
   *
   * @param {string} reloadUri the base uri before parameters
   *
   * @return {string} the final URI for the request to the manifest server.
   */
  getRequestURI(e) {
    if (!e)
      return null;
    const n = (i) => this.excludedSteeringManifestURLs.has(i);
    if (this.proxyServerUrl_) {
      const i = this.setProxyServerUrl_(e);
      if (!n(i))
        return i;
    }
    const r = this.setSteeringParams_(e);
    return n(r) ? null : r;
  }
  /**
   * Start the timeout for re-requesting the steering manifest at the TTL interval.
   *
   * @param {number} ttl time in seconds of the timeout. Defaults to the
   *        ttl interval in the steering manifest
   */
  startTTLTimeout_(e = this.steeringManifest.ttl) {
    const n = e * 1e3;
    this.ttlTimeout_ = pe.setTimeout(() => {
      this.requestSteeringManifest();
    }, n);
  }
  /**
   * Clear the TTL timeout if necessary.
   */
  clearTTLTimeout_() {
    pe.clearTimeout(this.ttlTimeout_), this.ttlTimeout_ = null;
  }
  /**
   * aborts any current steering xhr and sets the current request object to null
   */
  abort() {
    this.request_ && this.request_.abort(), this.request_ = null;
  }
  /**
   * aborts steering requests clears the ttl timeout and resets all properties.
   */
  dispose() {
    this.off("content-steering"), this.off("error"), this.abort(), this.clearTTLTimeout_(), this.currentPathway = null, this.defaultPathway = null, this.queryBeforeStart = null, this.proxyServerUrl_ = null, this.manifestType_ = null, this.ttlTimeout_ = null, this.request_ = null, this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set(), this.availablePathways_ = /* @__PURE__ */ new Set(), this.steeringManifest = new Mw();
  }
  /**
   * adds a pathway to the available pathways set
   *
   * @param {string} pathway the pathway string to add
   */
  addAvailablePathway(e) {
    e && this.availablePathways_.add(e);
  }
  /**
   * Clears all pathways from the available pathways set
   */
  clearAvailablePathways() {
    this.availablePathways_.clear();
  }
  /**
   * Removes a pathway from the available pathways set.
   */
  excludePathway(e) {
    return this.availablePathways_.delete(e);
  }
  /**
   * Checks the refreshed DASH manifest content steering tag for changes.
   *
   * @param {string} baseURL new steering tag on DASH manifest refresh
   * @param {Object} newTag the new tag to check for changes
   * @return a true or false whether the new tag has different values
   */
  didDASHTagChange(e, n) {
    return !n && this.steeringManifest.reloadUri || n && (wi(e, n.serverURL) !== this.steeringManifest.reloadUri || n.defaultServiceLocation !== this.defaultPathway || n.queryBeforeStart !== this.queryBeforeStart || n.proxyServerURL !== this.proxyServerUrl_);
  }
  getAvailablePathways() {
    return this.availablePathways_;
  }
}
const V6e = (t, e) => {
  let n = null;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => {
      t.apply(null, r);
    }, e);
  };
}, W6e = 10;
let so;
const Q6e = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"], G6e = function(t) {
  return this.audioSegmentLoader_[t] + this.mainSegmentLoader_[t];
}, Y6e = function({
  currentPlaylist: t,
  buffered: e,
  currentTime: n,
  nextPlaylist: r,
  bufferLowWaterLine: i,
  bufferHighWaterLine: s,
  duration: a,
  bufferBasedABR: o,
  log: u
}) {
  if (!r)
    return Me.log.warn("We received no playlist to switch to. Please check your stream."), !1;
  const c = `allowing switch ${t && t.id || "null"} -> ${r.id}`;
  if (!t)
    return u(`${c} as current playlist is not set`), !0;
  if (r.id === t.id)
    return !1;
  const d = !!Bl(e, n).length;
  if (!t.endList)
    return !d && typeof t.partTargetDuration == "number" ? (u(`not ${c} as current playlist is live llhls, but currentTime isn't in buffered.`), !1) : (u(`${c} as current playlist is live`), !0);
  const l = UT(e, n), f = o ? Ir.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Ir.MAX_BUFFER_LOW_WATER_LINE;
  if (a < f)
    return u(`${c} as duration < max low water line (${a} < ${f})`), !0;
  const p = r.attributes.BANDWIDTH, m = t.attributes.BANDWIDTH;
  if (p < m && (!o || l < s)) {
    let g = `${c} as next bandwidth < current bandwidth (${p} < ${m})`;
    return o && (g += ` and forwardBuffer < bufferHighWaterLine (${l} < ${s})`), u(g), !0;
  }
  if ((!o || p > m) && l >= i) {
    let g = `${c} as forwardBuffer >= bufferLowWaterLine (${l} >= ${i})`;
    return o && (g += ` and next bandwidth > current bandwidth (${p} > ${m})`), u(g), !0;
  }
  return u(`not ${c} as no switching criteria met`), !1;
};
class X6e extends Me.EventTarget {
  constructor(e) {
    super(), this.fastQualityChange_ = V6e(this.fastQualityChange_.bind(this), 100);
    const {
      src: n,
      withCredentials: r,
      tech: i,
      bandwidth: s,
      externVhs: a,
      useCueTags: o,
      playlistExclusionDuration: u,
      enableLowInitialPlaylist: c,
      sourceType: d,
      cacheEncryptionKeys: l,
      bufferBasedABR: f,
      leastPixelDiffSelector: p,
      captionServices: m,
      experimentalUseMMS: g
    } = e;
    if (!n)
      throw new Error("A non-empty playlist URL or JSON manifest string is required");
    let {
      maxPlaylistRetries: y
    } = e;
    (y === null || typeof y > "u") && (y = 1 / 0), so = a, this.bufferBasedABR = !!f, this.leastPixelDiffSelector = !!p, this.withCredentials = r, this.tech_ = i, this.vhs_ = i.vhs, this.player_ = e.player_, this.sourceType_ = d, this.useCueTags_ = o, this.playlistExclusionDuration = u, this.maxPlaylistRetries = y, this.enableLowInitialPlaylist = c, this.usingManagedMediaSource_ = !1, this.useCueTags_ && (this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues"), this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), this.requestOptions_ = {
      withCredentials: r,
      maxPlaylistRetries: y,
      timeout: null
    }, this.on("error", this.pauseLoading), this.mediaTypes_ = z6e(), g && pe.ManagedMediaSource ? (this.tech_.el_.disableRemotePlayback = !0, this.mediaSource = new pe.ManagedMediaSource(), this.usingManagedMediaSource_ = !0, Me.log("Using ManagedMediaSource")) : pe.MediaSource && (this.mediaSource = new pe.MediaSource()), this.handleDurationChange_ = this.handleDurationChange_.bind(this), this.handleSourceOpen_ = this.handleSourceOpen_.bind(this), this.handleSourceEnded_ = this.handleSourceEnded_.bind(this), this.load = this.load.bind(this), this.pause = this.pause.bind(this), this.mediaSource.addEventListener("durationchange", this.handleDurationChange_), this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_), this.mediaSource.addEventListener("startstreaming", this.load), this.mediaSource.addEventListener("endstreaming", this.pause), this.seekable_ = Mr(), this.hasPlayed_ = !1, this.syncController_ = new D6e(e), this.segmentMetadataTrack_ = i.addRemoteTextTrack({
      kind: "metadata",
      label: "segment-metadata"
    }, !1).track, this.segmentMetadataTrack_.mode = "hidden", this.decrypter_ = new N6e(), this.sourceUpdater_ = new LM(this.mediaSource), this.inbandTextTracks_ = {}, this.timelineChangeController_ = new M6e(), this.keyStatusMap_ = /* @__PURE__ */ new Map();
    const b = {
      vhs: this.vhs_,
      parse708captions: e.parse708captions,
      useDtsForTimestampOffset: e.useDtsForTimestampOffset,
      captionServices: m,
      mediaSource: this.mediaSource,
      currentTime: this.tech_.currentTime.bind(this.tech_),
      seekable: () => this.seekable(),
      seeking: () => this.tech_.seeking(),
      duration: () => this.duration(),
      hasPlayed: () => this.hasPlayed_,
      goalBufferLength: () => this.goalBufferLength(),
      bandwidth: s,
      syncController: this.syncController_,
      decrypter: this.decrypter_,
      sourceType: this.sourceType_,
      inbandTextTracks: this.inbandTextTracks_,
      cacheEncryptionKeys: l,
      sourceUpdater: this.sourceUpdater_,
      timelineChangeController: this.timelineChangeController_,
      exactManifestTimings: e.exactManifestTimings,
      addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
    };
    this.mainPlaylistLoader_ = this.sourceType_ === "dash" ? new cy(n, this.vhs_, xn(this.requestOptions_, {
      addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
    })) : new Fl(n, this.vhs_, xn(this.requestOptions_, {
      addDateRangesToTextTrack: this.addDateRangesToTextTrack_.bind(this)
    })), this.setupMainPlaylistLoaderListeners_(), this.mainSegmentLoader_ = new hy(xn(b, {
      segmentMetadataTrack: this.segmentMetadataTrack_,
      loaderType: "main"
    }), e), this.audioSegmentLoader_ = new hy(xn(b, {
      loaderType: "audio"
    }), e), this.subtitleSegmentLoader_ = new w6e(xn(b, {
      loaderType: "vtt",
      featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,
      loadVttJs: () => new Promise((_, D) => {
        function S() {
          i.off("vttjserror", M), _();
        }
        function M() {
          i.off("vttjsloaded", S), D();
        }
        i.one("vttjsloaded", S), i.one("vttjserror", M), i.addWebVttScript_();
      })
    }), e);
    const E = () => this.mainSegmentLoader_.bandwidth;
    this.contentSteeringController_ = new q6e(this.vhs_.xhr, E), this.setupSegmentLoaderListeners_(), this.bufferBasedABR && (this.mainPlaylistLoader_.one("loadedplaylist", () => this.startABRTimer_()), this.tech_.on("pause", () => this.stopABRTimer_()), this.tech_.on("play", () => this.startABRTimer_())), Q6e.forEach((_) => {
      this[_ + "_"] = G6e.bind(this, _);
    }), this.logger_ = gs("pc"), this.triggeredFmp4Usage = !1, this.tech_.preload() === "none" ? (this.loadOnPlay_ = () => {
      this.loadOnPlay_ = null, this.mainPlaylistLoader_.load();
    }, this.tech_.one("play", this.loadOnPlay_)) : this.mainPlaylistLoader_.load(), this.timeToLoadedData__ = -1, this.mainAppendsToLoadedData__ = -1, this.audioAppendsToLoadedData__ = -1;
    const v = this.tech_.preload() === "none" ? "play" : "loadstart";
    this.tech_.one(v, () => {
      const _ = Date.now();
      this.tech_.one("loadeddata", () => {
        this.timeToLoadedData__ = Date.now() - _, this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends, this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;
      });
    });
  }
  mainAppendsToLoadedData_() {
    return this.mainAppendsToLoadedData__;
  }
  audioAppendsToLoadedData_() {
    return this.audioAppendsToLoadedData__;
  }
  appendsToLoadedData_() {
    const e = this.mainAppendsToLoadedData_(), n = this.audioAppendsToLoadedData_();
    return e === -1 || n === -1 ? -1 : e + n;
  }
  timeToLoadedData_() {
    return this.timeToLoadedData__;
  }
  /**
   * Run selectPlaylist and switch to the new playlist if we should
   *
   * @param {string} [reason=abr] a reason for why the ABR check is made
   * @private
   */
  checkABR_(e = "abr") {
    const n = this.selectPlaylist();
    n && this.shouldSwitchToMedia_(n) && this.switchMedia_(n, e);
  }
  switchMedia_(e, n, r) {
    const i = this.media(), s = i && (i.id || i.uri), a = e && (e.id || e.uri);
    if (s && s !== a) {
      this.logger_(`switch media ${s} -> ${a} from ${n}`);
      const o = {
        renditionInfo: {
          id: a,
          bandwidth: e.attributes.BANDWIDTH,
          resolution: e.attributes.RESOLUTION,
          codecs: e.attributes.CODECS
        },
        cause: n
      };
      this.trigger({
        type: "renditionselected",
        metadata: o
      }), this.tech_.trigger({
        type: "usage",
        name: `vhs-rendition-change-${n}`
      });
    }
    this.mainPlaylistLoader_.media(e, r);
  }
  /**
   * A function that ensures we switch our playlists inside of `mediaTypes`
   * to match the current `serviceLocation` provided by the contentSteering controller.
   * We want to check media types of `AUDIO`, `SUBTITLES`, and `CLOSED-CAPTIONS`.
   *
   * This should only be called on a DASH playback scenario while using content steering.
   * This is necessary due to differences in how media in HLS manifests are generally tied to
   * a video playlist, where in DASH that is not always the case.
   */
  switchMediaForDASHContentSteering_() {
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((e) => {
      const n = this.mediaTypes_[e], r = n ? n.activeGroup() : null, i = this.contentSteeringController_.getPathway();
      if (r && i) {
        const a = (r.length ? r[0].playlists : r.playlists).filter((o) => o.attributes.serviceLocation === i);
        a.length && this.mediaTypes_[e].activePlaylistLoader.media(a[0]);
      }
    });
  }
  /**
   * Start a timer that periodically calls checkABR_
   *
   * @private
   */
  startABRTimer_() {
    this.stopABRTimer_(), this.abrTimer_ = pe.setInterval(() => this.checkABR_(), 250);
  }
  /**
   * Stop the timer that periodically calls checkABR_
   *
   * @private
   */
  stopABRTimer_() {
    this.tech_.scrubbing && this.tech_.scrubbing() || (pe.clearInterval(this.abrTimer_), this.abrTimer_ = null);
  }
  /**
   * Get a list of playlists for the currently selected audio playlist
   *
   * @return {Array} the array of audio playlists
   */
  getAudioTrackPlaylists_() {
    const e = this.main(), n = e && e.playlists || [];
    if (!e || !e.mediaGroups || !e.mediaGroups.AUDIO)
      return n;
    const r = e.mediaGroups.AUDIO, i = Object.keys(r);
    let s;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length)
      s = this.mediaTypes_.AUDIO.activeTrack();
    else {
      const o = r.main || i.length && r[i[0]];
      for (const u in o)
        if (o[u].default) {
          s = {
            label: u
          };
          break;
        }
    }
    if (!s)
      return n;
    const a = [];
    for (const o in r)
      if (r[o][s.label]) {
        const u = r[o][s.label];
        if (u.playlists && u.playlists.length)
          a.push.apply(a, u.playlists);
        else if (u.uri)
          a.push(u);
        else if (e.playlists.length)
          for (let c = 0; c < e.playlists.length; c++) {
            const d = e.playlists[c];
            d.attributes && d.attributes.AUDIO && d.attributes.AUDIO === o && a.push(d);
          }
      }
    return a.length ? a : n;
  }
  /**
   * Register event handlers on the main playlist loader. A helper
   * function for construction time.
   *
   * @private
   */
  setupMainPlaylistLoaderListeners_() {
    this.mainPlaylistLoader_.on("loadedmetadata", () => {
      const n = this.mainPlaylistLoader_.media(), r = n.targetDuration * 1.5 * 1e3;
      sy(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = r, n.endList && this.tech_.preload() !== "none" && (this.mainSegmentLoader_.playlist(n, this.requestOptions_), this.mainSegmentLoader_.load()), j6e({
        sourceType: this.sourceType_,
        segmentLoaders: {
          AUDIO: this.audioSegmentLoader_,
          SUBTITLES: this.subtitleSegmentLoader_,
          main: this.mainSegmentLoader_
        },
        tech: this.tech_,
        requestOptions: this.requestOptions_,
        mainPlaylistLoader: this.mainPlaylistLoader_,
        vhs: this.vhs_,
        main: this.main(),
        mediaTypes: this.mediaTypes_,
        excludePlaylist: this.excludePlaylist.bind(this)
      }), this.triggerPresenceUsage_(this.main(), n), this.setupFirstPlay(), !this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media() ? this.trigger("selectedinitialmedia") : this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", () => {
        this.trigger("selectedinitialmedia");
      });
    }), this.mainPlaylistLoader_.on("loadedplaylist", () => {
      this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_);
      let n = this.mainPlaylistLoader_.media();
      if (!n) {
        this.attachContentSteeringListeners_(), this.initContentSteeringController_(), this.excludeUnsupportedVariants_();
        let r;
        if (this.enableLowInitialPlaylist && (r = this.selectInitialPlaylist()), r || (r = this.selectPlaylist()), !r || !this.shouldSwitchToMedia_(r) || (this.initialMedia_ = r, this.switchMedia_(this.initialMedia_, "initial"), !(this.sourceType_ === "vhs-json" && this.initialMedia_.segments)))
          return;
        n = this.initialMedia_;
      }
      this.handleUpdatedMediaPlaylist(n);
    }), this.mainPlaylistLoader_.on("error", () => {
      const n = this.mainPlaylistLoader_.error;
      this.excludePlaylist({
        playlistToExclude: n.playlist,
        error: n
      });
    }), this.mainPlaylistLoader_.on("mediachanging", () => {
      this.mainSegmentLoader_.abort(), this.mainSegmentLoader_.pause();
    }), this.mainPlaylistLoader_.on("mediachange", () => {
      const n = this.mainPlaylistLoader_.media(), r = n.targetDuration * 1.5 * 1e3;
      sy(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = r, this.sourceType_ === "dash" && this.mainPlaylistLoader_.isPaused && this.mainPlaylistLoader_.load(), this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.playlist(n, this.requestOptions_), this.waitingForFastQualityPlaylistReceived_ ? this.runFastQualitySwitch_() : this.mainSegmentLoader_.load(), this.tech_.trigger({
        type: "mediachange",
        bubbles: !0
      });
    }), this.mainPlaylistLoader_.on("playlistunchanged", () => {
      const n = this.mainPlaylistLoader_.media();
      if (n.lastExcludeReason_ === "playlist-unchanged")
        return;
      this.stuckAtPlaylistEnd_(n) && (this.excludePlaylist({
        error: {
          message: "Playlist no longer updating.",
          reason: "playlist-unchanged"
        }
      }), this.tech_.trigger("playliststuck"));
    }), this.mainPlaylistLoader_.on("renditiondisabled", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-disabled"
      });
    }), this.mainPlaylistLoader_.on("renditionenabled", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-enabled"
      });
    }), ["manifestrequeststart", "manifestrequestcomplete", "manifestparsestart", "manifestparsecomplete", "playlistrequeststart", "playlistrequestcomplete", "playlistparsestart", "playlistparsecomplete", "renditiondisabled", "renditionenabled"].forEach((n) => {
      this.mainPlaylistLoader_.on(n, (r) => {
        this.player_.trigger(fr({}, r));
      });
    });
  }
  /**
   * Given an updated media playlist (whether it was loaded for the first time, or
   * refreshed for live playlists), update any relevant properties and state to reflect
   * changes in the media that should be accounted for (e.g., cues and duration).
   *
   * @param {Object} updatedPlaylist the updated media playlist object
   *
   * @private
   */
  handleUpdatedMediaPlaylist(e) {
    this.useCueTags_ && this.updateAdCues_(e), this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.playlist(e, this.requestOptions_), this.waitingForFastQualityPlaylistReceived_ && this.runFastQualitySwitch_(), this.updateDuration(!e.endList), this.tech_.paused() || (this.mainSegmentLoader_.load(), this.audioSegmentLoader_ && this.audioSegmentLoader_.load());
  }
  /**
   * A helper function for triggerring presence usage events once per source
   *
   * @private
   */
  triggerPresenceUsage_(e, n) {
    const r = e.mediaGroups || {};
    let i = !0;
    const s = Object.keys(r.AUDIO);
    for (const a in r.AUDIO)
      for (const o in r.AUDIO[a])
        r.AUDIO[a][o].uri || (i = !1);
    i && this.tech_.trigger({
      type: "usage",
      name: "vhs-demuxed"
    }), Object.keys(r.SUBTITLES).length && this.tech_.trigger({
      type: "usage",
      name: "vhs-webvtt"
    }), so.Playlist.isAes(n) && this.tech_.trigger({
      type: "usage",
      name: "vhs-aes"
    }), s.length && Object.keys(r.AUDIO[s[0]]).length > 1 && this.tech_.trigger({
      type: "usage",
      name: "vhs-alternate-audio"
    }), this.useCueTags_ && this.tech_.trigger({
      type: "usage",
      name: "vhs-playlist-cue-tags"
    });
  }
  shouldSwitchToMedia_(e) {
    const n = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_, r = this.tech_.currentTime(), i = this.bufferLowWaterLine(), s = this.bufferHighWaterLine(), a = this.tech_.buffered();
    return Y6e({
      buffered: a,
      currentTime: r,
      currentPlaylist: n,
      nextPlaylist: e,
      bufferLowWaterLine: i,
      bufferHighWaterLine: s,
      duration: this.duration(),
      bufferBasedABR: this.bufferBasedABR,
      log: this.logger_
    });
  }
  /**
   * Register event handlers on the segment loaders. A helper function
   * for construction time.
   *
   * @private
   */
  setupSegmentLoaderListeners_() {
    this.mainSegmentLoader_.on("bandwidthupdate", () => {
      this.checkABR_("bandwidthupdate"), this.tech_.trigger("bandwidthupdate");
    }), this.mainSegmentLoader_.on("timeout", () => {
      this.bufferBasedABR && this.mainSegmentLoader_.load();
    }), this.bufferBasedABR || this.mainSegmentLoader_.on("progress", () => {
      this.trigger("progress");
    }), this.mainSegmentLoader_.on("error", () => {
      const r = this.mainSegmentLoader_.error();
      this.excludePlaylist({
        playlistToExclude: r.playlist,
        error: r
      });
    }), this.mainSegmentLoader_.on("appenderror", () => {
      this.error = this.mainSegmentLoader_.error_, this.trigger("error");
    }), this.mainSegmentLoader_.on("syncinfoupdate", () => {
      this.onSyncInfoUpdate_();
    }), this.mainSegmentLoader_.on("timestampoffset", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-timestamp-offset"
      });
    }), this.audioSegmentLoader_.on("syncinfoupdate", () => {
      this.onSyncInfoUpdate_();
    }), this.audioSegmentLoader_.on("appenderror", () => {
      this.error = this.audioSegmentLoader_.error_, this.trigger("error");
    }), this.mainSegmentLoader_.on("ended", () => {
      this.logger_("main segment loader ended"), this.onEndOfStream();
    }), this.timelineChangeController_.on("audioTimelineBehind", () => {
      const r = this.audioSegmentLoader_.pendingSegment_;
      if (!r || !r.segment || !r.segment.syncInfo)
        return;
      const i = r.segment.syncInfo.end + 0.01;
      this.tech_.setCurrentTime(i);
    }), this.timelineChangeController_.on("fixBadTimelineChange", () => {
      this.logger_("Fix bad timeline change. Restarting al segment loaders..."), this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.resetEverything(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.pause(), this.audioSegmentLoader_.resetEverything()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.pause(), this.subtitleSegmentLoader_.resetEverything()), this.load();
    }), this.mainSegmentLoader_.on("earlyabort", (r) => {
      this.bufferBasedABR || (this.delegateLoaders_("all", ["abort"]), this.excludePlaylist({
        error: {
          message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
        },
        playlistExclusionDuration: W6e
      }));
    });
    const e = () => {
      if (!this.sourceUpdater_.hasCreatedSourceBuffers())
        return this.tryToCreateSourceBuffers_();
      const r = this.getCodecsOrExclude_();
      r && this.sourceUpdater_.addOrChangeSourceBuffers(r);
    };
    this.mainSegmentLoader_.on("trackinfo", e), this.audioSegmentLoader_.on("trackinfo", e), this.mainSegmentLoader_.on("fmp4", () => {
      this.triggeredFmp4Usage || (this.tech_.trigger({
        type: "usage",
        name: "vhs-fmp4"
      }), this.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("fmp4", () => {
      this.triggeredFmp4Usage || (this.tech_.trigger({
        type: "usage",
        name: "vhs-fmp4"
      }), this.triggeredFmp4Usage = !0);
    }), this.audioSegmentLoader_.on("ended", () => {
      this.logger_("audioSegmentLoader ended"), this.onEndOfStream();
    }), ["segmentselected", "segmentloadstart", "segmentloaded", "segmentkeyloadstart", "segmentkeyloadcomplete", "segmentdecryptionstart", "segmentdecryptioncomplete", "segmenttransmuxingstart", "segmenttransmuxingcomplete", "segmenttransmuxingtrackinfoavailable", "segmenttransmuxingtiminginfoavailable", "segmentappendstart", "appendsdone", "bandwidthupdated", "timelinechange", "codecschange"].forEach((r) => {
      this.mainSegmentLoader_.on(r, (i) => {
        this.player_.trigger(fr({}, i));
      }), this.audioSegmentLoader_.on(r, (i) => {
        this.player_.trigger(fr({}, i));
      }), this.subtitleSegmentLoader_.on(r, (i) => {
        this.player_.trigger(fr({}, i));
      });
    });
  }
  mediaSecondsLoaded_() {
    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
  }
  /**
   * Call load on our SegmentLoaders
   */
  load() {
    this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load();
  }
  /**
   * Call pause on our SegmentLoaders
   */
  pause() {
    this.mainSegmentLoader_.pause(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.pause(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.pause();
  }
  /**
   * Re-tune playback quality level for the current player
   * conditions. This method will perform destructive actions like removing
   * already buffered content in order to readjust the currently active
   * playlist quickly. This is good for manual quality changes
   *
   * @private
   */
  fastQualityChange_(e = this.selectPlaylist()) {
    if (e && e === this.mainPlaylistLoader_.media()) {
      this.logger_("skipping fastQualityChange because new media is same as old");
      return;
    }
    this.switchMedia_(e, "fast-quality"), this.waitingForFastQualityPlaylistReceived_ = !0;
  }
  runFastQualitySwitch_() {
    this.waitingForFastQualityPlaylistReceived_ = !1, this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.resetEverything(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.pause(), this.audioSegmentLoader_.resetEverything()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.pause(), this.subtitleSegmentLoader_.resetEverything()), this.load();
  }
  /**
   * Begin playback.
   */
  play() {
    if (this.setupFirstPlay())
      return;
    this.tech_.ended() && this.tech_.setCurrentTime(0), this.hasPlayed_ && this.load();
    const e = this.tech_.seekable();
    if (this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < e.start(0))
      return this.tech_.setCurrentTime(e.end(e.length - 1));
  }
  /**
   * Seek to the latest media position if this is a live video and the
   * player and video are loaded and initialized.
   */
  setupFirstPlay() {
    const e = this.mainPlaylistLoader_.media();
    if (!e || this.tech_.paused() || this.hasPlayed_)
      return !1;
    if (!e.endList || e.start) {
      const n = this.seekable();
      if (!n.length)
        return !1;
      const r = n.end(0);
      let i = r;
      if (e.start) {
        const s = e.start.timeOffset;
        s < 0 ? i = Math.max(r + s, n.start(0)) : i = Math.min(r, s);
      }
      this.trigger("firstplay"), this.tech_.setCurrentTime(i);
    }
    return this.hasPlayed_ = !0, this.load(), !0;
  }
  /**
   * handle the sourceopen event on the MediaSource
   *
   * @private
   */
  handleSourceOpen_() {
    if (this.tryToCreateSourceBuffers_(), this.tech_.autoplay()) {
      const e = this.tech_.play();
      typeof e < "u" && typeof e.then == "function" && e.then(null, (n) => {
      });
    }
    this.trigger("sourceopen");
  }
  /**
   * handle the sourceended event on the MediaSource
   *
   * @private
   */
  handleSourceEnded_() {
    if (!this.inbandTextTracks_.metadataTrack_)
      return;
    const e = this.inbandTextTracks_.metadataTrack_.cues;
    if (!e || !e.length)
      return;
    const n = this.duration();
    e[e.length - 1].endTime = isNaN(n) || Math.abs(n) === 1 / 0 ? Number.MAX_VALUE : n;
  }
  /**
   * handle the durationchange event on the MediaSource
   *
   * @private
   */
  handleDurationChange_() {
    this.tech_.trigger("durationchange");
  }
  /**
   * Calls endOfStream on the media source when all active stream types have called
   * endOfStream
   *
   * @param {string} streamType
   *        Stream type of the segment loader that called endOfStream
   * @private
   */
  onEndOfStream() {
    let e = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      const n = this.mainSegmentLoader_.getCurrentMediaInfo_();
      !n || n.hasVideo ? e = e && this.audioSegmentLoader_.ended_ : e = this.audioSegmentLoader_.ended_;
    }
    e && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream());
  }
  /**
   * Check if a playlist has stopped being updated
   *
   * @param {Object} playlist the media playlist object
   * @return {boolean} whether the playlist has stopped being updated or not
   */
  stuckAtPlaylistEnd_(e) {
    if (!this.seekable().length)
      return !1;
    const r = this.syncController_.getExpiredTime(e, this.duration());
    if (r === null)
      return !1;
    const i = so.Playlist.playlistEnd(e, r), s = this.tech_.currentTime(), a = this.tech_.buffered();
    if (!a.length)
      return i - s <= ra;
    const o = a.end(a.length - 1);
    return o - s <= ra && i - o <= ra;
  }
  /**
   * Exclude a playlist for a set amount of time, making it unavailable for selection by
   * the rendition selection algorithm, then force a new playlist (rendition) selection.
   *
   * @param {Object=} playlistToExclude
   *                  the playlist to exclude, defaults to the currently selected playlist
   * @param {Object=} error
   *                  an optional error
   * @param {number=} playlistExclusionDuration
   *                  an optional number of seconds to exclude the playlist
   */
  excludePlaylist({
    playlistToExclude: e = this.mainPlaylistLoader_.media(),
    error: n = {},
    playlistExclusionDuration: r
  }) {
    if (e = e || this.mainPlaylistLoader_.media(), r = r || n.playlistExclusionDuration || this.playlistExclusionDuration, !e) {
      this.error = n, this.mediaSource.readyState !== "open" ? this.trigger("error") : this.sourceUpdater_.endOfStream("network");
      return;
    }
    e.playlistErrors_++;
    const i = this.mainPlaylistLoader_.main.playlists, s = i.filter(Hg), a = s.length === 1 && s[0] === e;
    if (i.length === 1 && r !== 1 / 0)
      return Me.log.warn(`Problem encountered with playlist ${e.id}. Trying again since it is the only playlist.`), this.tech_.trigger("retryplaylist"), this.mainPlaylistLoader_.load(a);
    if (a) {
      if (this.main().contentSteering) {
        const m = this.pathwayAttribute_(e), g = this.contentSteeringController_.steeringManifest.ttl * 1e3;
        this.contentSteeringController_.excludePathway(m), this.excludeThenChangePathway_(), setTimeout(() => {
          this.contentSteeringController_.addAvailablePathway(m);
        }, g);
        return;
      }
      let p = !1;
      i.forEach((m) => {
        if (m === e)
          return;
        const g = m.excludeUntil;
        typeof g < "u" && g !== 1 / 0 && (p = !0, delete m.excludeUntil);
      }), p && (Me.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."), this.tech_.trigger("retryplaylist"));
    }
    let o;
    e.playlistErrors_ > this.maxPlaylistRetries ? o = 1 / 0 : o = Date.now() + r * 1e3, e.excludeUntil = o, n.reason && (e.lastExcludeReason_ = n.reason), this.tech_.trigger("excludeplaylist"), this.tech_.trigger({
      type: "usage",
      name: "vhs-rendition-excluded"
    });
    const u = this.selectPlaylist();
    if (!u) {
      this.error = "Playback cannot continue. No available working or supported playlists.", this.trigger("error");
      return;
    }
    const c = n.internal ? this.logger_ : Me.log.warn, d = n.message ? " " + n.message : "";
    c(`${n.internal ? "Internal problem" : "Problem"} encountered with playlist ${e.id}.${d} Switching to playlist ${u.id}.`), u.attributes.AUDIO !== e.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]), u.attributes.SUBTITLES !== e.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]), this.delegateLoaders_("main", ["abort", "pause"]);
    const l = u.targetDuration / 2 * 1e3 || 5 * 1e3, f = typeof u.lastRequest == "number" && Date.now() - u.lastRequest <= l;
    return this.switchMedia_(u, "exclude", a || f);
  }
  /**
   * Pause all segment/playlist loaders
   */
  pauseLoading() {
    this.delegateLoaders_("all", ["abort", "pause"]), this.stopABRTimer_();
  }
  /**
   * Call a set of functions in order on playlist loaders, segment loaders,
   * or both types of loaders.
   *
   * @param {string} filter
   *        Filter loaders that should call fnNames using a string. Can be:
   *        * all - run on all loaders
   *        * audio - run on all audio loaders
   *        * subtitle - run on all subtitle loaders
   *        * main - run on the main loaders
   *
   * @param {Array|string} fnNames
   *        A string or array of function names to call.
   */
  delegateLoaders_(e, n) {
    const r = [], i = e === "all";
    (i || e === "main") && r.push(this.mainPlaylistLoader_);
    const s = [];
    (i || e === "audio") && s.push("AUDIO"), (i || e === "subtitle") && (s.push("CLOSED-CAPTIONS"), s.push("SUBTITLES")), s.forEach((a) => {
      const o = this.mediaTypes_[a] && this.mediaTypes_[a].activePlaylistLoader;
      o && r.push(o);
    }), ["main", "audio", "subtitle"].forEach((a) => {
      const o = this[`${a}SegmentLoader_`];
      o && (e === a || e === "all") && r.push(o);
    }), r.forEach((a) => n.forEach((o) => {
      typeof a[o] == "function" && a[o]();
    }));
  }
  /**
   * set the current time on all segment loaders
   *
   * @param {TimeRange} currentTime the current time to set
   * @return {TimeRange} the current time
   */
  setCurrentTime(e) {
    const n = Bl(this.tech_.buffered(), e);
    if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media()) || !this.mainPlaylistLoader_.media().segments)
      return 0;
    if (n && n.length)
      return e;
    this.mainSegmentLoader_.pause(), this.mainSegmentLoader_.resetEverything(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.pause(), this.audioSegmentLoader_.resetEverything()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.pause(), this.subtitleSegmentLoader_.resetEverything()), this.load();
  }
  /**
   * get the current duration
   *
   * @return {TimeRange} the duration
   */
  duration() {
    if (!this.mainPlaylistLoader_)
      return 0;
    const e = this.mainPlaylistLoader_.media();
    return e ? e.endList ? this.mediaSource ? this.mediaSource.duration : so.Playlist.duration(e) : 1 / 0 : 0;
  }
  /**
   * check the seekable range
   *
   * @return {TimeRange} the seekable range
   */
  seekable() {
    return this.seekable_;
  }
  getSeekableRange_(e, n) {
    const r = e.media();
    if (!r)
      return null;
    const i = this.syncController_.getMediaSequenceSync(n);
    if (i && i.isReliable) {
      const o = i.start, u = i.end;
      if (!isFinite(o) || !isFinite(u))
        return null;
      const c = so.Playlist.liveEdgeDelay(this.mainPlaylistLoader_.main, r), d = Math.max(o, u - c);
      return Mr([[o, d]]);
    }
    const s = this.syncController_.getExpiredTime(r, this.duration());
    if (s === null)
      return null;
    const a = so.Playlist.seekable(r, s, so.Playlist.liveEdgeDelay(this.mainPlaylistLoader_.main, r));
    return a.length ? a : null;
  }
  computeFinalSeekable_(e, n) {
    if (!n)
      return e;
    const r = e.start(0), i = e.end(0), s = n.start(0), a = n.end(0);
    return s > i || r > a ? e : Mr([[Math.max(r, s), Math.min(i, a)]]);
  }
  onSyncInfoUpdate_() {
    if (!this.mainPlaylistLoader_)
      return;
    const e = this.getSeekableRange_(this.mainPlaylistLoader_, "main");
    if (!e)
      return;
    let n;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader && (n = this.getSeekableRange_(this.mediaTypes_.AUDIO.activePlaylistLoader, "audio"), !n))
      return;
    const r = this.seekable_;
    if (this.seekable_ = this.computeFinalSeekable_(e, n), !this.seekable_ || r && r.length && this.seekable_.length && r.start(0) === this.seekable_.start(0) && r.end(0) === this.seekable_.end(0))
      return;
    this.logger_(`seekable updated [${Q8(this.seekable_)}]`);
    const i = {
      seekableRanges: this.seekable_
    };
    this.trigger({
      type: "seekablerangeschanged",
      metadata: i
    }), this.tech_.trigger("seekablechanged");
  }
  /**
   * Update the player duration
   */
  updateDuration(e) {
    if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.updateDuration_ = null), this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, e), this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (e) {
      const i = this.seekable();
      if (!i.length)
        return;
      (isNaN(this.mediaSource.duration) || this.mediaSource.duration < i.end(i.length - 1)) && this.sourceUpdater_.setDuration(i.end(i.length - 1));
      return;
    }
    const n = this.tech_.buffered();
    let r = so.Playlist.duration(this.mainPlaylistLoader_.media());
    n.length > 0 && (r = Math.max(r, n.end(n.length - 1))), this.mediaSource.duration !== r && this.sourceUpdater_.setDuration(r);
  }
  /**
   * dispose of the PlaylistController and everything
   * that it controls
   */
  dispose() {
    this.trigger("dispose"), this.decrypter_.terminate(), this.mainPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), this.contentSteeringController_.dispose(), this.keyStatusMap_.clear(), this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_), ["AUDIO", "SUBTITLES"].forEach((e) => {
      const n = this.mediaTypes_[e].groups;
      for (const r in n)
        n[r].forEach((i) => {
          i.playlistLoader && i.playlistLoader.dispose();
        });
    }), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose(), this.sourceUpdater_.dispose(), this.timelineChangeController_.dispose(), this.stopABRTimer_(), this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_), this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_), this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_), this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_), this.off();
  }
  /**
   * return the main playlist object if we have one
   *
   * @return {Object} the main playlist object that we parsed
   */
  main() {
    return this.mainPlaylistLoader_.main;
  }
  /**
   * return the currently selected playlist
   *
   * @return {Object} the currently selected playlist object that we parsed
   */
  media() {
    return this.mainPlaylistLoader_.media() || this.initialMedia_;
  }
  areMediaTypesKnown_() {
    const e = !!this.mediaTypes_.AUDIO.activePlaylistLoader, n = !!this.mainSegmentLoader_.getCurrentMediaInfo_(), r = e ? !!this.audioSegmentLoader_.getCurrentMediaInfo_() : !0;
    return !(!n || !r);
  }
  // find from and to for codec switch event
  getCodecsOrExclude_() {
    const e = {
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
    }, n = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
    e.video = e.main;
    const r = vf(this.main(), n), i = {}, s = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (e.main.hasVideo && (i.video = r.video || e.main.videoCodec || F4e), e.main.isMuxed && (i.video += `,${r.audio || e.main.audioCodec || vx}`), (e.main.hasAudio && !e.main.isMuxed || e.audio.hasAudio || s) && (i.audio = r.audio || e.main.audioCodec || e.audio.audioCodec || vx, e.audio.isFmp4 = e.main.hasAudio && !e.main.isMuxed ? e.main.isFmp4 : e.audio.isFmp4), !i.audio && !i.video) {
      this.excludePlaylist({
        playlistToExclude: n,
        error: {
          message: "Could not determine codecs for playlist."
        },
        playlistExclusionDuration: 1 / 0
      });
      return;
    }
    const a = (c, d) => c ? mf(d, this.usingManagedMediaSource_) : VA(d), o = {};
    let u;
    if (["video", "audio"].forEach(function(c) {
      if (i.hasOwnProperty(c) && !a(e[c].isFmp4, i[c])) {
        const d = e[c].isFmp4 ? "browser" : "muxer";
        o[d] = o[d] || [], o[d].push(i[c]), c === "audio" && (u = d);
      }
    }), s && u && n.attributes.AUDIO) {
      const c = n.attributes.AUDIO;
      this.main().playlists.forEach((d) => {
        (d.attributes && d.attributes.AUDIO) === c && d !== n && (d.excludeUntil = 1 / 0);
      }), this.logger_(`excluding audio group ${c} as ${u} does not support codec(s): "${i.audio}"`);
    }
    if (Object.keys(o).length) {
      const c = Object.keys(o).reduce((d, l) => (d && (d += ", "), d += `${l} does not support codec(s): "${o[l].join(",")}"`, d), "") + ".";
      this.excludePlaylist({
        playlistToExclude: n,
        error: {
          internal: !0,
          message: c
        },
        playlistExclusionDuration: 1 / 0
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      const c = [];
      if (["video", "audio"].forEach((d) => {
        const l = (Gs(this.sourceUpdater_.codecs[d] || "")[0] || {}).type, f = (Gs(i[d] || "")[0] || {}).type;
        l && f && l.toLowerCase() !== f.toLowerCase() && c.push(`"${this.sourceUpdater_.codecs[d]}" -> "${i[d]}"`);
      }), c.length) {
        this.excludePlaylist({
          playlistToExclude: n,
          error: {
            message: `Codec switching not supported: ${c.join(", ")}.`,
            internal: !0
          },
          playlistExclusionDuration: 1 / 0
        });
        return;
      }
    }
    return i;
  }
  /**
   * Create source buffers and exlude any incompatible renditions.
   *
   * @private
   */
  tryToCreateSourceBuffers_() {
    if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers() || !this.areMediaTypesKnown_())
      return;
    const e = this.getCodecsOrExclude_();
    if (!e)
      return;
    this.sourceUpdater_.createSourceBuffers(e);
    const n = [e.video, e.audio].filter(Boolean).join(",");
    this.excludeIncompatibleVariants_(n);
  }
  /**
   * Excludes playlists with codecs that are unsupported by the muxer and browser.
   */
  excludeUnsupportedVariants_() {
    const e = this.main().playlists, n = [];
    Object.keys(e).forEach((r) => {
      const i = e[r];
      if (n.indexOf(i.id) !== -1)
        return;
      n.push(i.id);
      const s = vf(this.main, i), a = [];
      s.audio && !VA(s.audio) && !mf(s.audio, this.usingManagedMediaSource_) && a.push(`audio codec ${s.audio}`), s.video && !VA(s.video) && !mf(s.video, this.usingManagedMediaSource_) && a.push(`video codec ${s.video}`), s.text && s.text === "stpp.ttml.im1t" && a.push(`text codec ${s.text}`), a.length && (i.excludeUntil = 1 / 0, this.logger_(`excluding ${i.id} for unsupported: ${a.join(", ")}`));
    });
  }
  /**
   * Exclude playlists that are known to be codec or
   * stream-incompatible with the SourceBuffer configuration. For
   * instance, Media Source Extensions would cause the video element to
   * stall waiting for video data if you switched from a variant with
   * video and audio to an audio-only one.
   *
   * @param {Object} media a media playlist compatible with the current
   * set of SourceBuffers. Variants in the current main playlist that
   * do not appear to have compatible codec or stream configurations
   * will be excluded from the default playlist selection algorithm
   * indefinitely.
   * @private
   */
  excludeIncompatibleVariants_(e) {
    const n = [], r = this.main().playlists, i = Kf(Gs(e)), s = hw(i), a = i.video && Gs(i.video)[0] || null, o = i.audio && Gs(i.audio)[0] || null;
    Object.keys(r).forEach((u) => {
      const c = r[u];
      if (n.indexOf(c.id) !== -1 || c.excludeUntil === 1 / 0)
        return;
      n.push(c.id);
      const d = [], l = vf(this.mainPlaylistLoader_.main, c), f = hw(l);
      if (!(!l.audio && !l.video)) {
        if (f !== s && d.push(`codec count "${f}" !== "${s}"`), !this.sourceUpdater_.canChangeType()) {
          const p = l.video && Gs(l.video)[0] || null, m = l.audio && Gs(l.audio)[0] || null;
          p && a && p.type.toLowerCase() !== a.type.toLowerCase() && d.push(`video codec "${p.type}" !== "${a.type}"`), m && o && m.type.toLowerCase() !== o.type.toLowerCase() && d.push(`audio codec "${m.type}" !== "${o.type}"`);
        }
        d.length && (c.excludeUntil = 1 / 0, this.logger_(`excluding ${c.id}: ${d.join(" && ")}`));
      }
    });
  }
  updateAdCues_(e) {
    let n = 0;
    const r = this.seekable();
    r.length && (n = r.start(0)), S6e(e, this.cueTagsTrack_, n);
  }
  /**
   * Calculates the desired forward buffer length based on current time
   *
   * @return {number} Desired forward buffer length in seconds
   */
  goalBufferLength() {
    const e = this.tech_.currentTime(), n = Ir.GOAL_BUFFER_LENGTH, r = Ir.GOAL_BUFFER_LENGTH_RATE, i = Math.max(n, Ir.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(n + e * r, i);
  }
  /**
   * Calculates the desired buffer low water line based on current time
   *
   * @return {number} Desired buffer low water line in seconds
   */
  bufferLowWaterLine() {
    const e = this.tech_.currentTime(), n = Ir.BUFFER_LOW_WATER_LINE, r = Ir.BUFFER_LOW_WATER_LINE_RATE, i = Math.max(n, Ir.MAX_BUFFER_LOW_WATER_LINE), s = Math.max(n, Ir.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
    return Math.min(n + e * r, this.bufferBasedABR ? s : i);
  }
  bufferHighWaterLine() {
    return Ir.BUFFER_HIGH_WATER_LINE;
  }
  addDateRangesToTextTrack_(e) {
    Tw(this.inbandTextTracks_, "com.apple.streaming", this.tech_), a6e({
      inbandTextTracks: this.inbandTextTracks_,
      dateRanges: e
    });
  }
  addMetadataToTextTrack(e, n, r) {
    const i = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset();
    Tw(this.inbandTextTracks_, e, this.tech_), r6e({
      inbandTextTracks: this.inbandTextTracks_,
      metadataArray: n,
      timestampOffset: i,
      videoDuration: r
    });
  }
  /**
   * Utility for getting the pathway or service location from an HLS or DASH playlist.
   *
   * @param {Object} playlist for getting pathway from.
   * @return the pathway attribute of a playlist
   */
  pathwayAttribute_(e) {
    return e.attributes["PATHWAY-ID"] || e.attributes.serviceLocation;
  }
  /**
   * Initialize available pathways and apply the tag properties.
   */
  initContentSteeringController_() {
    const e = this.main();
    if (e.contentSteering) {
      for (const n of e.playlists)
        this.contentSteeringController_.addAvailablePathway(this.pathwayAttribute_(n));
      if (this.contentSteeringController_.assignTagProperties(e.uri, e.contentSteering), this.contentSteeringController_.queryBeforeStart) {
        this.contentSteeringController_.requestSteeringManifest(!0);
        return;
      }
      this.tech_.one("canplay", () => {
        this.contentSteeringController_.requestSteeringManifest();
      });
    }
  }
  /**
   * Reset the content steering controller and re-init.
   */
  resetContentSteeringController_() {
    this.contentSteeringController_.clearAvailablePathways(), this.contentSteeringController_.dispose(), this.initContentSteeringController_();
  }
  /**
   * Attaches the listeners for content steering.
   */
  attachContentSteeringListeners_() {
    this.contentSteeringController_.on("content-steering", this.excludeThenChangePathway_.bind(this)), ["contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed"].forEach((n) => {
      this.contentSteeringController_.on(n, (r) => {
        this.trigger(fr({}, r));
      });
    }), this.sourceType_ === "dash" && this.mainPlaylistLoader_.on("loadedplaylist", () => {
      const n = this.main();
      (this.contentSteeringController_.didDASHTagChange(n.uri, n.contentSteering) || (() => {
        const s = this.contentSteeringController_.getAvailablePathways(), a = [];
        for (const o of n.playlists) {
          const u = o.attributes.serviceLocation;
          if (u && (a.push(u), !s.has(u)))
            return !0;
        }
        return !!(!a.length && s.size);
      })()) && this.resetContentSteeringController_();
    });
  }
  /**
   * Simple exclude and change playlist logic for content steering.
   */
  excludeThenChangePathway_() {
    const e = this.contentSteeringController_.getPathway();
    if (!e)
      return;
    this.handlePathwayClones_();
    const r = this.main().playlists, i = /* @__PURE__ */ new Set();
    let s = !1;
    Object.keys(r).forEach((a) => {
      const o = r[a], u = this.pathwayAttribute_(o), c = u && e !== u;
      o.excludeUntil === 1 / 0 && o.lastExcludeReason_ === "content-steering" && !c && (delete o.excludeUntil, delete o.lastExcludeReason_, s = !0);
      const l = !o.excludeUntil && o.excludeUntil !== 1 / 0;
      !i.has(o.id) && c && l && (i.add(o.id), o.excludeUntil = 1 / 0, o.lastExcludeReason_ = "content-steering", this.logger_(`excluding ${o.id} for ${o.lastExcludeReason_}`));
    }), this.contentSteeringController_.manifestType_ === "DASH" && Object.keys(this.mediaTypes_).forEach((a) => {
      const o = this.mediaTypes_[a];
      if (o.activePlaylistLoader) {
        const u = o.activePlaylistLoader.media_;
        u && u.attributes.serviceLocation !== e && (s = !0);
      }
    }), s && this.changeSegmentPathway_();
  }
  /**
   * Add, update, or delete playlists and media groups for
   * the pathway clones for HLS Content Steering.
   *
   * See https://datatracker.ietf.org/doc/draft-pantos-hls-rfc8216bis/
   *
   * NOTE: Pathway cloning does not currently support the `PER_VARIANT_URIS` and
   * `PER_RENDITION_URIS` as we do not handle `STABLE-VARIANT-ID` or
   * `STABLE-RENDITION-ID` values.
   */
  handlePathwayClones_() {
    const n = this.main().playlists, r = this.contentSteeringController_.currentPathwayClones, i = this.contentSteeringController_.nextPathwayClones;
    if (r && r.size || i && i.size) {
      for (const [a, o] of r.entries())
        i.get(a) || (this.mainPlaylistLoader_.updateOrDeleteClone(o), this.contentSteeringController_.excludePathway(a));
      for (const [a, o] of i.entries()) {
        const u = r.get(a);
        if (!u) {
          n.filter((d) => d.attributes["PATHWAY-ID"] === o["BASE-ID"]).forEach((d) => {
            this.mainPlaylistLoader_.addClonePathway(o, d);
          }), this.contentSteeringController_.addAvailablePathway(a);
          continue;
        }
        this.equalPathwayClones_(u, o) || (this.mainPlaylistLoader_.updateOrDeleteClone(o, !0), this.contentSteeringController_.addAvailablePathway(a));
      }
      this.contentSteeringController_.currentPathwayClones = new Map(JSON.parse(JSON.stringify([...i])));
    }
  }
  /**
   * Determines whether two pathway clone objects are equivalent.
   *
   * @param {Object} a The first pathway clone object.
   * @param {Object} b The second pathway clone object.
   * @return {boolean} True if the pathway clone objects are equal, false otherwise.
   */
  equalPathwayClones_(e, n) {
    if (e["BASE-ID"] !== n["BASE-ID"] || e.ID !== n.ID || e["URI-REPLACEMENT"].HOST !== n["URI-REPLACEMENT"].HOST)
      return !1;
    const r = e["URI-REPLACEMENT"].PARAMS, i = n["URI-REPLACEMENT"].PARAMS;
    for (const s in r)
      if (r[s] !== i[s])
        return !1;
    for (const s in i)
      if (r[s] !== i[s])
        return !1;
    return !0;
  }
  /**
   * Changes the current playlists for audio, video and subtitles after a new pathway
   * is chosen from content steering.
   */
  changeSegmentPathway_() {
    const e = this.selectPlaylist();
    this.pauseLoading(), this.contentSteeringController_.manifestType_ === "DASH" && this.switchMediaForDASHContentSteering_(), this.switchMedia_(e, "content-steering");
  }
  /**
   * Iterates through playlists and check their keyId set and compare with the
   * keyStatusMap, only enable playlists that have a usable key. If the playlist
   * has no keyId leave it enabled by default.
   */
  excludeNonUsablePlaylistsByKeyId_() {
    if (!this.mainPlaylistLoader_ || !this.mainPlaylistLoader_.main)
      return;
    let e = 0;
    const n = "non-usable";
    this.mainPlaylistLoader_.main.playlists.forEach((r) => {
      const i = this.mainPlaylistLoader_.getKeyIdSet(r);
      !i || !i.size || i.forEach((s) => {
        const a = "usable", o = this.keyStatusMap_.has(s) && this.keyStatusMap_.get(s) === a, u = r.lastExcludeReason_ === n && r.excludeUntil === 1 / 0;
        o ? o && u && (delete r.excludeUntil, delete r.lastExcludeReason_, this.logger_(`enabling playlist ${r.id} because key ID ${s} is ${a}`)) : (r.excludeUntil !== 1 / 0 && r.lastExcludeReason_ !== n && (r.excludeUntil = 1 / 0, r.lastExcludeReason_ = n, this.logger_(`excluding playlist ${r.id} because the key ID ${s} doesn't exist in the keyStatusMap or is not ${a}`)), e++);
      });
    }), e >= this.mainPlaylistLoader_.main.playlists.length && this.mainPlaylistLoader_.main.playlists.forEach((r) => {
      const i = r && r.attributes && r.attributes.RESOLUTION && r.attributes.RESOLUTION.height < 720, s = r.excludeUntil === 1 / 0 && r.lastExcludeReason_ === n;
      i && s && (delete r.excludeUntil, Me.log.warn(`enabling non-HD playlist ${r.id} because all playlists were excluded due to ${n} key IDs`));
    });
  }
  /**
   * Adds a keystatus to the keystatus map, tries to convert to string if necessary.
   *
   * @param {any} keyId the keyId to add a status for
   * @param {string} status the status of the keyId
   */
  addKeyStatus_(e, n) {
    const s = (typeof e == "string" ? e : E6e(e)).slice(0, 32).toLowerCase();
    this.logger_(`KeyStatus '${n}' with key ID ${s} added to the keyStatusMap`), this.keyStatusMap_.set(s, n);
  }
  /**
   * Utility function for adding key status to the keyStatusMap and filtering usable encrypted playlists.
   *
   * @param {any} keyId the keyId from the keystatuschange event
   * @param {string} status the key status string
   */
  updatePlaylistByKeyStatus(e, n) {
    this.addKeyStatus_(e, n), this.waitingForFastQualityPlaylistReceived_ || this.excludeNonUsableThenChangePlaylist_(), this.mainPlaylistLoader_.off("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this)), this.mainPlaylistLoader_.on("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
  }
  excludeNonUsableThenChangePlaylist_() {
    this.excludeNonUsablePlaylistsByKeyId_(), this.fastQualityChange_();
  }
}
const K6e = (t, e, n) => (r) => {
  const i = t.main.playlists[e], s = HT(i), a = Hg(i);
  if (typeof r > "u")
    return a;
  r ? delete i.disabled : i.disabled = !0;
  const o = {
    renditionInfo: {
      id: e,
      bandwidth: i.attributes.BANDWIDTH,
      resolution: i.attributes.RESOLUTION,
      codecs: i.attributes.CODECS
    },
    cause: "fast-quality"
  };
  return r !== a && !s && (r ? (n(i), t.trigger({
    type: "renditionenabled",
    metadata: o
  })) : t.trigger({
    type: "renditiondisabled",
    metadata: o
  })), r;
};
class Z6e {
  constructor(e, n, r) {
    const {
      playlistController_: i
    } = e, s = i.fastQualityChange_.bind(i);
    if (n.attributes) {
      const a = n.attributes.RESOLUTION;
      this.width = a && a.width, this.height = a && a.height, this.bandwidth = n.attributes.BANDWIDTH, this.frameRate = n.attributes["FRAME-RATE"];
    }
    this.codecs = vf(i.main(), n), this.playlist = n, this.id = r, this.enabled = K6e(e.playlists, n.id, s);
  }
}
const J6e = function(t) {
  t.representations = () => {
    const e = t.playlistController_.main(), n = xh(e) ? t.playlistController_.getAudioTrackPlaylists_() : e.playlists;
    return n ? n.filter((r) => !HT(r)).map((r, i) => new Z6e(t, r, r.id)) : [];
  };
}, Ow = ["seeking", "seeked", "pause", "playing", "error"];
class eIe extends Me.EventTarget {
  /**
   * Represents an PlaybackWatcher object.
   *
   * @class
   * @param {Object} options an object that includes the tech and settings
   */
  constructor(e) {
    super(), this.playlistController_ = e.playlistController, this.tech_ = e.tech, this.seekable = e.seekable, this.allowSeeksWithinUnsafeLiveWindow = e.allowSeeksWithinUnsafeLiveWindow, this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta, this.media = e.media, this.playedRanges_ = [], this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = gs("PlaybackWatcher"), this.logger_("initialize");
    const n = () => this.monitorCurrentTime_(), r = () => this.monitorCurrentTime_(), i = () => this.techWaiting_(), s = () => this.resetTimeUpdate_(), a = this.playlistController_, o = ["main", "subtitle", "audio"], u = {};
    o.forEach((d) => {
      u[d] = {
        reset: () => this.resetSegmentDownloads_(d),
        updateend: () => this.checkSegmentDownloads_(d)
      }, a[`${d}SegmentLoader_`].on("appendsdone", u[d].updateend), a[`${d}SegmentLoader_`].on("playlistupdate", u[d].reset), this.tech_.on(["seeked", "seeking"], u[d].reset);
    });
    const c = (d) => {
      ["main", "audio"].forEach((l) => {
        a[`${l}SegmentLoader_`][d]("appended", this.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = () => {
      this.fixesBadSeeks_() && (this.consecutiveUpdates = 0, this.lastRecordedTime = this.tech_.currentTime(), c("off"));
    }, this.clearSeekingAppendCheck_ = () => c("off"), this.watchForBadSeeking_ = () => {
      this.clearSeekingAppendCheck_(), c("on");
    }, this.tech_.on("seeked", this.clearSeekingAppendCheck_), this.tech_.on("seeking", this.watchForBadSeeking_), this.tech_.on("waiting", i), this.tech_.on(Ow, s), this.tech_.on("canplay", r), this.tech_.one("play", n), this.dispose = () => {
      this.clearSeekingAppendCheck_(), this.logger_("dispose"), this.tech_.off("waiting", i), this.tech_.off(Ow, s), this.tech_.off("canplay", r), this.tech_.off("play", n), this.tech_.off("seeking", this.watchForBadSeeking_), this.tech_.off("seeked", this.clearSeekingAppendCheck_), o.forEach((d) => {
        a[`${d}SegmentLoader_`].off("appendsdone", u[d].updateend), a[`${d}SegmentLoader_`].off("playlistupdate", u[d].reset), this.tech_.off(["seeked", "seeking"], u[d].reset);
      }), this.checkCurrentTimeTimeout_ && pe.clearTimeout(this.checkCurrentTimeTimeout_), this.resetTimeUpdate_();
    };
  }
  /**
   * Periodically check current time to see if playback stopped
   *
   * @private
   */
  monitorCurrentTime_() {
    this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && pe.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = pe.setTimeout(this.monitorCurrentTime_.bind(this), 250);
  }
  /**
   * Reset stalled download stats for a specific type of loader
   *
   * @param {string} type
   *        The segment loader type to check.
   *
   * @listens SegmentLoader#playlistupdate
   * @listens Tech#seeking
   * @listens Tech#seeked
   */
  resetSegmentDownloads_(e) {
    const n = this.playlistController_[`${e}SegmentLoader_`];
    this[`${e}StalledDownloads_`] > 0 && this.logger_(`resetting possible stalled download count for ${e} loader`), this[`${e}StalledDownloads_`] = 0, this[`${e}Buffered_`] = n.buffered_();
  }
  /**
   * Checks on every segment `appendsdone` to see
   * if segment appends are making progress. If they are not
   * and we are still downloading bytes. We exclude the playlist.
   *
   * @param {string} type
   *        The segment loader type to check.
   *
   * @listens SegmentLoader#appendsdone
   */
  checkSegmentDownloads_(e) {
    const n = this.playlistController_, r = n[`${e}SegmentLoader_`], i = r.buffered_(), s = UCe(this[`${e}Buffered_`], i);
    if (this[`${e}Buffered_`] = i, s) {
      const a = {
        bufferedRanges: i
      };
      n.trigger({
        type: "bufferedrangeschanged",
        metadata: a
      }), this.resetSegmentDownloads_(e);
      return;
    }
    this[`${e}StalledDownloads_`]++, this.logger_(`found #${this[`${e}StalledDownloads_`]} ${e} appends that did not increase buffer (possible stalled download)`, {
      playlistId: r.playlist_ && r.playlist_.id,
      buffered: Au(i)
    }), !(this[`${e}StalledDownloads_`] < 10) && (this.logger_(`${e} loader stalled download exclusion`), this.resetSegmentDownloads_(e), this.tech_.trigger({
      type: "usage",
      name: `vhs-${e}-download-exclusion`
    }), e !== "subtitle" && n.excludePlaylist({
      error: {
        message: `Excessive ${e} segment downloading detected.`
      },
      playlistExclusionDuration: 1 / 0
    }));
  }
  /**
   * The purpose of this function is to emulate the "waiting" event on
   * browsers that do not emit it when they are waiting for more
   * data to continue playback
   *
   * @private
   */
  checkCurrentTime_() {
    if (this.tech_.paused() || this.tech_.seeking())
      return;
    const e = this.tech_.currentTime(), n = this.tech_.buffered();
    if (this.lastRecordedTime === e && (!n.length || e + ra >= n.end(n.length - 1)))
      return this.techWaiting_();
    if (this.consecutiveUpdates >= 5 && e === this.lastRecordedTime)
      this.consecutiveUpdates++, this.waiting_();
    else if (e === this.lastRecordedTime)
      this.consecutiveUpdates++;
    else {
      this.playedRanges_.push(Mr([this.lastRecordedTime, e]));
      const r = {
        playedRanges: this.playedRanges_
      };
      this.playlistController_.trigger({
        type: "playedrangeschanged",
        metadata: r
      }), this.consecutiveUpdates = 0, this.lastRecordedTime = e;
    }
  }
  /**
   * Resets the 'timeupdate' mechanism designed to detect that we are stalled
   *
   * @private
   */
  resetTimeUpdate_() {
    this.consecutiveUpdates = 0;
  }
  /**
   * Fixes situations where there's a bad seek
   *
   * @return {boolean} whether an action was taken to fix the seek
   * @private
   */
  fixesBadSeeks_() {
    if (!this.tech_.seeking())
      return !1;
    const n = this.seekable(), r = this.tech_.currentTime(), i = this.afterSeekableWindow_(n, r, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
    let s;
    if (i && (s = n.end(n.length - 1)), this.beforeSeekableWindow_(n, r)) {
      const m = n.start(0);
      s = m + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (m === n.end(0) ? 0 : ra);
    }
    if (typeof s < "u")
      return this.logger_(`Trying to seek outside of seekable at time ${r} with seekable range ${Q8(n)}. Seeking to ${s}.`), this.tech_.setCurrentTime(s), !0;
    const a = this.playlistController_.sourceUpdater_, o = this.tech_.buffered(), u = a.audioBuffer ? a.audioBuffered() : null, c = a.videoBuffer ? a.videoBuffered() : null, d = this.media(), l = d.partTargetDuration ? d.partTargetDuration : (d.targetDuration - na) * 2, f = [u, c];
    for (let m = 0; m < f.length; m++) {
      if (!f[m])
        continue;
      if (UT(f[m], r) < l)
        return !1;
    }
    const p = Np(o, r);
    return p.length === 0 ? !1 : (s = p.start(0) + ra, this.logger_(`Buffered region starts (${p.start(0)})  just beyond seek point (${r}). Seeking to ${s}.`), this.tech_.setCurrentTime(s), !0);
  }
  /**
   * Handler for situations when we determine the player is waiting.
   *
   * @private
   */
  waiting_() {
    if (this.techWaiting_())
      return;
    const e = this.tech_.currentTime(), n = this.tech_.buffered(), r = Bl(n, e);
    if (r.length && e + 3 <= r.end(0)) {
      this.resetTimeUpdate_(), this.tech_.setCurrentTime(e), this.logger_(`Stopped at ${e} while inside a buffered region [${r.start(0)} -> ${r.end(0)}]. Attempting to resume playback by seeking to the current time.`), this.tech_.trigger({
        type: "usage",
        name: "vhs-unknown-waiting"
      });
      return;
    }
  }
  /**
   * Handler for situations when the tech fires a `waiting` event
   *
   * @return {boolean}
   *         True if an action (or none) was needed to correct the waiting. False if no
   *         checks passed
   * @private
   */
  techWaiting_() {
    const e = this.seekable(), n = this.tech_.currentTime();
    if (this.tech_.seeking())
      return !0;
    if (this.beforeSeekableWindow_(e, n)) {
      const o = e.end(e.length - 1);
      return this.logger_(`Fell out of live window at time ${n}. Seeking to live point (seekable end) ${o}`), this.resetTimeUpdate_(), this.tech_.setCurrentTime(o), this.tech_.trigger({
        type: "usage",
        name: "vhs-live-resync"
      }), !0;
    }
    const r = this.tech_.vhs.playlistController_.sourceUpdater_, i = this.tech_.buffered();
    if (this.videoUnderflow_({
      audioBuffered: r.audioBuffered(),
      videoBuffered: r.videoBuffered(),
      currentTime: n
    }))
      return this.resetTimeUpdate_(), this.tech_.setCurrentTime(n), this.tech_.trigger({
        type: "usage",
        name: "vhs-video-underflow"
      }), !0;
    const a = Np(i, n);
    return a.length > 0 ? (this.logger_(`Stopped at ${n} and seeking to ${a.start(0)}`), this.resetTimeUpdate_(), this.skipTheGap_(n), !0) : !1;
  }
  afterSeekableWindow_(e, n, r, i = !1) {
    if (!e.length)
      return !1;
    let s = e.end(e.length - 1) + ra;
    const a = !r.endList, o = typeof r.partTargetDuration == "number";
    return a && (o || i) && (s = e.end(e.length - 1) + r.targetDuration * 3), n > s;
  }
  beforeSeekableWindow_(e, n) {
    return !!(e.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    e.start(0) > 0 && n < e.start(0) - this.liveRangeSafeTimeDelta);
  }
  videoUnderflow_({
    videoBuffered: e,
    audioBuffered: n,
    currentTime: r
  }) {
    if (!e)
      return;
    let i;
    if (e.length && n.length) {
      const s = Bl(e, r - 3), a = Bl(e, r), o = Bl(n, r);
      o.length && !a.length && s.length && (i = {
        start: s.end(0),
        end: o.end(0)
      });
    } else
      Np(e, r).length || (i = this.gapFromVideoUnderflow_(e, r));
    return i ? (this.logger_(`Encountered a gap in video from ${i.start} to ${i.end}. Seeking to current time ${r}`), !0) : !1;
  }
  /**
   * Timer callback. If playback still has not proceeded, then we seek
   * to the start of the next buffered region.
   *
   * @private
   */
  skipTheGap_(e) {
    const n = this.tech_.buffered(), r = this.tech_.currentTime(), i = Np(n, r);
    if (this.resetTimeUpdate_(), i.length === 0 || r !== e)
      return;
    this.logger_("skipTheGap_:", "currentTime:", r, "scheduled currentTime:", e, "nextRange start:", i.start(0)), this.tech_.setCurrentTime(i.start(0) + na);
    const s = {
      gapInfo: {
        from: r,
        to: i.start(0)
      }
    };
    this.playlistController_.trigger({
      type: "gapjumped",
      metadata: s
    }), this.tech_.trigger({
      type: "usage",
      name: "vhs-gap-skip"
    });
  }
  gapFromVideoUnderflow_(e, n) {
    const r = RCe(e);
    for (let i = 0; i < r.length; i++) {
      const s = r.start(i), a = r.end(i);
      if (n - s < 4 && n - s > 2)
        return {
          start: s,
          end: a
        };
    }
    return null;
  }
}
const tIe = {
  errorInterval: 30,
  getSource(t) {
    const n = this.tech({
      IWillNotUseThisInPlugins: !0
    }).currentSource_ || this.currentSource();
    return t(n);
  }
}, FM = function(t, e) {
  let n = 0, r = 0;
  const i = xn(tIe, e);
  t.ready(() => {
    t.trigger({
      type: "usage",
      name: "vhs-error-reload-initialized"
    });
  });
  const s = function() {
    r && t.currentTime(r);
  }, a = function(d) {
    d != null && (r = t.duration() !== 1 / 0 && t.currentTime() || 0, t.one("loadedmetadata", s), t.src(d), t.trigger({
      type: "usage",
      name: "vhs-error-reload"
    }), t.play());
  }, o = function() {
    if (Date.now() - n < i.errorInterval * 1e3) {
      t.trigger({
        type: "usage",
        name: "vhs-error-reload-canceled"
      });
      return;
    }
    if (!i.getSource || typeof i.getSource != "function") {
      Me.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
      return;
    }
    return n = Date.now(), i.getSource.call(t, a);
  }, u = function() {
    t.off("loadedmetadata", s), t.off("error", o), t.off("dispose", u);
  }, c = function(d) {
    u(), FM(t, d);
  };
  t.on("error", o), t.on("dispose", u), t.reloadSourceOnError = c;
}, nIe = function(t) {
  FM(this, t);
};
var UM = "3.17.0", rIe = "7.1.0", iIe = "1.3.1", sIe = "7.2.0", aIe = "4.0.2";
const er = {
  PlaylistLoader: Fl,
  Playlist: Si,
  utils: dSe,
  STANDARD_PLAYLIST_SELECTOR: vw,
  INITIAL_PLAYLIST_SELECTOR: ZSe,
  lastBandwidthSelector: vw,
  movingAverageBandwidthSelector: XSe,
  comparePlaylistBandwidth: qT,
  comparePlaylistResolution: YSe,
  xhr: fM()
};
Object.keys(Ir).forEach((t) => {
  Object.defineProperty(er, t, {
    get() {
      return Me.log.warn(`using Vhs.${t} is UNSAFE be sure you know what you are doing`), Ir[t];
    },
    set(e) {
      if (Me.log.warn(`using Vhs.${t} is UNSAFE be sure you know what you are doing`), typeof e != "number" || e < 0) {
        Me.log.warn(`value of Vhs.${t} must be greater than or equal to 0`);
        return;
      }
      Ir[t] = e;
    }
  });
});
const $M = "videojs-vhs", HM = function(t, e) {
  const n = e.media();
  let r = -1;
  for (let i = 0; i < t.length; i++)
    if (t[i].id === n.id) {
      r = i;
      break;
    }
  t.selectedIndex_ = r, t.trigger({
    selectedIndex: r,
    type: "change"
  });
}, oIe = function(t, e) {
  e.representations().forEach((n) => {
    t.addQualityLevel(n);
  }), HM(t, e.playlists);
};
er.canPlaySource = function() {
  return Me.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
};
const uIe = (t, e, n) => {
  if (!t)
    return t;
  let r = {};
  e && e.attributes && e.attributes.CODECS && (r = Kf(Gs(e.attributes.CODECS))), n && n.attributes && n.attributes.CODECS && (r.audio = n.attributes.CODECS);
  const i = uc(r.video), s = uc(r.audio), a = {};
  for (const o in t)
    a[o] = {}, s && (a[o].audioContentType = s), i && (a[o].videoContentType = i), e.contentProtection && e.contentProtection[o] && e.contentProtection[o].pssh && (a[o].pssh = e.contentProtection[o].pssh), typeof t[o] == "string" && (a[o].url = t[o]);
  return xn(t, a);
}, lIe = (t, e) => t.reduce((n, r) => {
  if (!r.contentProtection)
    return n;
  const i = e.reduce((s, a) => {
    const o = r.contentProtection[a];
    return o && o.pssh && (s[a] = {
      pssh: o.pssh
    }), s;
  }, {});
  return Object.keys(i).length && n.push(i), n;
}, []), cIe = ({
  player: t,
  sourceKeySystems: e,
  audioMedia: n,
  mainPlaylists: r
}) => {
  if (!t.eme.initializeMediaKeys)
    return Promise.resolve();
  const i = n ? r.concat([n]) : r, s = lIe(i, Object.keys(e)), a = [], o = [];
  return s.forEach((u) => {
    o.push(new Promise((c, d) => {
      t.tech_.one("keysessioncreated", c);
    })), a.push(new Promise((c, d) => {
      t.eme.initializeMediaKeys({
        keySystems: u
      }, (l) => {
        if (l) {
          d(l);
          return;
        }
        c();
      });
    }));
  }), Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(a),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(o)
  ]);
}, dIe = ({
  player: t,
  sourceKeySystems: e,
  media: n,
  audioMedia: r
}) => {
  const i = uIe(e, n, r);
  return i ? (t.currentSource().keySystems = i, i && !t.eme ? (Me.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"), !1) : !0) : !1;
}, jM = () => {
  if (!pe.localStorage)
    return null;
  const t = pe.localStorage.getItem($M);
  if (!t)
    return null;
  try {
    return JSON.parse(t);
  } catch {
    return null;
  }
}, fIe = (t) => {
  if (!pe.localStorage)
    return !1;
  let e = jM();
  e = e ? xn(e, t) : t;
  try {
    pe.localStorage.setItem($M, JSON.stringify(e));
  } catch {
    return !1;
  }
  return e;
}, hIe = (t) => t.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0 ? JSON.parse(t.substring(t.indexOf(",") + 1)) : t, zM = (t, e) => {
  t._requestCallbackSet || (t._requestCallbackSet = /* @__PURE__ */ new Set()), t._requestCallbackSet.add(e);
}, qM = (t, e) => {
  t._responseCallbackSet || (t._responseCallbackSet = /* @__PURE__ */ new Set()), t._responseCallbackSet.add(e);
}, VM = (t, e) => {
  t._requestCallbackSet && (t._requestCallbackSet.delete(e), t._requestCallbackSet.size || delete t._requestCallbackSet);
}, WM = (t, e) => {
  t._responseCallbackSet && (t._responseCallbackSet.delete(e), t._responseCallbackSet.size || delete t._responseCallbackSet);
};
er.supportsNativeHls = function() {
  if (!ot || !ot.createElement)
    return !1;
  const t = ot.createElement("video");
  return Me.getTech("Html5").isSupported() ? [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ].some(function(n) {
    return /maybe|probably/i.test(t.canPlayType(n));
  }) : !1;
}();
er.supportsNativeDash = function() {
  return !ot || !ot.createElement || !Me.getTech("Html5").isSupported() ? !1 : /maybe|probably/i.test(ot.createElement("video").canPlayType("application/dash+xml"));
}();
er.supportsTypeNatively = (t) => t === "hls" ? er.supportsNativeHls : t === "dash" ? er.supportsNativeDash : !1;
er.isSupported = function() {
  return Me.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
};
er.xhr.onRequest = function(t) {
  zM(er.xhr, t);
};
er.xhr.onResponse = function(t) {
  qM(er.xhr, t);
};
er.xhr.offRequest = function(t) {
  VM(er.xhr, t);
};
er.xhr.offResponse = function(t) {
  WM(er.xhr, t);
};
const pIe = Me.getComponent("Component");
class QM extends pIe {
  constructor(e, n, r) {
    if (super(n, r.vhs), typeof r.initialBandwidth == "number" && (this.options_.bandwidth = r.initialBandwidth), this.logger_ = gs("VhsHandler"), n.options_ && n.options_.playerId) {
      const i = Me.getPlayer(n.options_.playerId);
      this.player_ = i;
    }
    if (this.tech_ = n, this.source_ = e, this.stats = {}, this.ignoreNextSeekingEvent_ = !1, this.setOptions_(), this.options_.overrideNative && n.overrideNativeAudioTracks && n.overrideNativeVideoTracks)
      n.overrideNativeAudioTracks(!0), n.overrideNativeVideoTracks(!0);
    else if (this.options_.overrideNative && (n.featuresNativeVideoTracks || n.featuresNativeAudioTracks))
      throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB");
    this.on(ot, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (i) => {
      const s = ot.fullscreenElement || ot.webkitFullscreenElement || ot.mozFullScreenElement || ot.msFullscreenElement;
      s && s.contains(this.tech_.el()) ? this.playlistController_.fastQualityChange_() : this.playlistController_.checkABR_();
    }), this.on(this.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = !1;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    }), this.on(this.tech_, "error", function() {
      this.tech_.error() && this.playlistController_ && this.playlistController_.pauseLoading();
    }), this.on(this.tech_, "play", this.play);
  }
  /**
   * Set VHS options based on options from configuration, as well as partial
   * options to be passed at a later time.
   *
   * @param {Object} options A partial chunk of config options
   */
  setOptions_(e = {}) {
    if (this.options_ = xn(this.options_, e), this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions !== !1, this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1, this.options_.usePlayerObjectFit = this.options_.usePlayerObjectFit || !1, this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage < "u" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || !1, this.options_.useNetworkInformationApi = typeof this.options_.useNetworkInformationApi < "u" ? this.options_.useNetworkInformationApi : !0, this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1, this.options_.customTagParsers = this.options_.customTagParsers || [], this.options_.customTagMappers = this.options_.customTagMappers || [], this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1, this.options_.llhls = this.options_.llhls !== !1, this.options_.bufferBasedABR = this.options_.bufferBasedABR || !1, typeof this.options_.playlistExclusionDuration != "number" && (this.options_.playlistExclusionDuration = 60), typeof this.options_.bandwidth != "number" && this.options_.useBandwidthFromLocalStorage) {
      const r = jM();
      r && r.bandwidth && (this.options_.bandwidth = r.bandwidth, this.tech_.trigger({
        type: "usage",
        name: "vhs-bandwidth-from-local-storage"
      })), r && r.throughput && (this.options_.throughput = r.throughput, this.tech_.trigger({
        type: "usage",
        name: "vhs-throughput-from-local-storage"
      }));
    }
    typeof this.options_.bandwidth != "number" && (this.options_.bandwidth = Ir.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Ir.INITIAL_BANDWIDTH, ["withCredentials", "useDevicePixelRatio", "usePlayerObjectFit", "customPixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach((r) => {
      typeof this.source_[r] < "u" && (this.options_[r] = this.source_[r]);
    }), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions, this.useDevicePixelRatio = this.options_.useDevicePixelRatio, this.usePlayerObjectFit = this.options_.usePlayerObjectFit;
    const n = this.options_.customPixelRatio;
    typeof n == "number" && n >= 0 && (this.customPixelRatio = n);
  }
  // alias for public method to set options
  setOptions(e = {}) {
    this.setOptions_(e);
  }
  /**
   * called when player.src gets called, handle a new source
   *
   * @param {Object} src the source object to handle
   */
  src(e, n) {
    if (!e)
      return;
    this.setOptions_(), this.options_.src = hIe(this.source_.src), this.options_.tech = this.tech_, this.options_.externVhs = er, this.options_.sourceType = pD(n), this.options_.seekTo = (s) => {
      this.tech_.setCurrentTime(s);
    }, this.options_.player_ = this.player_, this.playlistController_ = new X6e(this.options_);
    const r = xn({
      liveRangeSafeTimeDelta: ra
    }, this.options_, {
      seekable: () => this.seekable(),
      media: () => this.playlistController_.media(),
      playlistController: this.playlistController_
    });
    this.playbackWatcher_ = new eIe(r), this.attachStreamingEventListeners_(), this.playlistController_.on("error", () => {
      const s = Me.players[this.tech_.options_.playerId];
      let a = this.playlistController_.error;
      typeof a == "object" && !a.code ? a.code = 3 : typeof a == "string" && (a = {
        message: a,
        code: 3
      }), s.error(a);
    });
    const i = this.options_.bufferBasedABR ? er.movingAverageBandwidthSelector(0.55) : er.STANDARD_PLAYLIST_SELECTOR;
    this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : i.bind(this), this.playlistController_.selectInitialPlaylist = er.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.playlistController_.mainPlaylistLoader_, this.mediaSource = this.playlistController_.mediaSource, Object.defineProperties(this, {
      selectPlaylist: {
        get() {
          return this.playlistController_.selectPlaylist;
        },
        set(s) {
          this.playlistController_.selectPlaylist = s.bind(this);
        }
      },
      throughput: {
        get() {
          return this.playlistController_.mainSegmentLoader_.throughput.rate;
        },
        set(s) {
          this.playlistController_.mainSegmentLoader_.throughput.rate = s, this.playlistController_.mainSegmentLoader_.throughput.count = 1;
        }
      },
      bandwidth: {
        get() {
          let s = this.playlistController_.mainSegmentLoader_.bandwidth;
          const a = pe.navigator.connection || pe.navigator.mozConnection || pe.navigator.webkitConnection, o = 1e7;
          if (this.options_.useNetworkInformationApi && a) {
            const u = a.downlink * 1e3 * 1e3;
            u >= o && s >= o ? s = Math.max(s, u) : s = u;
          }
          return s;
        },
        set(s) {
          this.playlistController_.mainSegmentLoader_.bandwidth = s, this.playlistController_.mainSegmentLoader_.throughput = {
            rate: 0,
            count: 0
          };
        }
      },
      /**
       * `systemBandwidth` is a combination of two serial processes bit-rates. The first
       * is the network bitrate provided by `bandwidth` and the second is the bitrate of
       * the entire process after that - decryption, transmuxing, and appending - provided
       * by `throughput`.
       *
       * Since the two process are serial, the overall system bandwidth is given by:
       *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
       */
      systemBandwidth: {
        get() {
          const s = 1 / (this.bandwidth || 1);
          let a;
          return this.throughput > 0 ? a = 1 / this.throughput : a = 0, Math.floor(1 / (s + a));
        },
        set() {
          Me.log.error('The "systemBandwidth" property is read-only');
        }
      }
    }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, {
      bandwidth: {
        get: () => this.bandwidth || 0,
        enumerable: !0
      },
      mediaRequests: {
        get: () => this.playlistController_.mediaRequests_() || 0,
        enumerable: !0
      },
      mediaRequestsAborted: {
        get: () => this.playlistController_.mediaRequestsAborted_() || 0,
        enumerable: !0
      },
      mediaRequestsTimedout: {
        get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
        enumerable: !0
      },
      mediaRequestsErrored: {
        get: () => this.playlistController_.mediaRequestsErrored_() || 0,
        enumerable: !0
      },
      mediaTransferDuration: {
        get: () => this.playlistController_.mediaTransferDuration_() || 0,
        enumerable: !0
      },
      mediaBytesTransferred: {
        get: () => this.playlistController_.mediaBytesTransferred_() || 0,
        enumerable: !0
      },
      mediaSecondsLoaded: {
        get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
        enumerable: !0
      },
      mediaAppends: {
        get: () => this.playlistController_.mediaAppends_() || 0,
        enumerable: !0
      },
      mainAppendsToLoadedData: {
        get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
        enumerable: !0
      },
      audioAppendsToLoadedData: {
        get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
        enumerable: !0
      },
      appendsToLoadedData: {
        get: () => this.playlistController_.appendsToLoadedData_() || 0,
        enumerable: !0
      },
      timeToLoadedData: {
        get: () => this.playlistController_.timeToLoadedData_() || 0,
        enumerable: !0
      },
      buffered: {
        get: () => Au(this.tech_.buffered()),
        enumerable: !0
      },
      currentTime: {
        get: () => this.tech_.currentTime(),
        enumerable: !0
      },
      currentSource: {
        get: () => this.tech_.currentSource_,
        enumerable: !0
      },
      currentTech: {
        get: () => this.tech_.name_,
        enumerable: !0
      },
      duration: {
        get: () => this.tech_.duration(),
        enumerable: !0
      },
      main: {
        get: () => this.playlists.main,
        enumerable: !0
      },
      playerDimensions: {
        get: () => this.tech_.currentDimensions(),
        enumerable: !0
      },
      seekable: {
        get: () => Au(this.tech_.seekable()),
        enumerable: !0
      },
      timestamp: {
        get: () => Date.now(),
        enumerable: !0
      },
      videoPlaybackQuality: {
        get: () => this.tech_.getVideoPlaybackQuality(),
        enumerable: !0
      }
    }), this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_)), this.tech_.on("bandwidthupdate", () => {
      this.options_.useBandwidthFromLocalStorage && fIe({
        bandwidth: this.bandwidth,
        throughput: Math.round(this.throughput)
      });
    }), this.playlistController_.on("selectedinitialmedia", () => {
      J6e(this);
    }), this.playlistController_.sourceUpdater_.on("createdsourcebuffers", () => {
      this.setupEme_();
    }), this.on(this.playlistController_, "progress", function() {
      this.tech_.trigger("progress");
    }), this.on(this.playlistController_, "firstplay", function() {
      this.ignoreNextSeekingEvent_ = !0;
    }), this.setupQualityLevels_(), this.tech_.el() && (this.mediaSourceUrl_ = pe.URL.createObjectURL(this.playlistController_.mediaSource), (Me.browser.IS_ANY_SAFARI || Me.browser.IS_IOS) && this.options_.overrideNative && this.options_.sourceType === "hls" && typeof this.tech_.addSourceElement == "function" ? (this.tech_.addSourceElement(this.mediaSourceUrl_), this.tech_.addSourceElement(this.source_.src)) : this.tech_.src(this.mediaSourceUrl_));
  }
  createKeySessions_() {
    const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation"), cIe({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      audioMedia: e && e.media(),
      mainPlaylists: this.playlists.main.playlists
    }).then(() => {
      this.logger_("created EME key session"), this.playlistController_.sourceUpdater_.initializedEme();
    }).catch((n) => {
      this.logger_("error while creating EME key session", n), this.player_.error({
        message: "Failed to initialize media keys for EME",
        code: 3
      });
    });
  }
  handleWaitingForKey_() {
    this.logger_("waitingforkey fired, attempting to create any new key sessions"), this.createKeySessions_();
  }
  /**
   * If necessary and EME is available, sets up EME options and waits for key session
   * creation.
   *
   * This function also updates the source updater so taht it can be used, as for some
   * browsers, EME must be configured before content is appended (if appending unencrypted
   * content before encrypted content).
   */
  setupEme_() {
    const e = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader, n = dIe({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      media: this.playlists.media(),
      audioMedia: e && e.media()
    });
    if (this.player_.tech_.on("keystatuschange", (r) => {
      this.playlistController_.updatePlaylistByKeyStatus(r.keyId, r.status);
    }), this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this), this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_), !n) {
      this.playlistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  }
  /**
   * Initializes the quality levels and sets listeners to update them.
   *
   * @method setupQualityLevels_
   * @private
   */
  setupQualityLevels_() {
    const e = Me.players[this.tech_.options_.playerId];
    !e || !e.qualityLevels || this.qualityLevels_ || (this.qualityLevels_ = e.qualityLevels(), this.playlistController_.on("selectedinitialmedia", () => {
      oIe(this.qualityLevels_, this);
    }), this.playlists.on("mediachange", () => {
      HM(this.qualityLevels_, this.playlists);
    }));
  }
  /**
   * return the version
   */
  static version() {
    return {
      "@videojs/http-streaming": UM,
      "mux.js": rIe,
      "mpd-parser": iIe,
      "m3u8-parser": sIe,
      "aes-decrypter": aIe
    };
  }
  /**
   * return the version
   */
  version() {
    return this.constructor.version();
  }
  canChangeType() {
    return LM.canChangeType();
  }
  /**
   * Begin playing the video.
   */
  play() {
    this.playlistController_.play();
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  setCurrentTime(e) {
    this.playlistController_.setCurrentTime(e);
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  duration() {
    return this.playlistController_.duration();
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  seekable() {
    return this.playlistController_.seekable();
  }
  /**
   * Abort all outstanding work and cleanup.
   */
  dispose() {
    this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.playlistController_ && this.playlistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.tech_ && this.tech_.vhs && delete this.tech_.vhs, this.mediaSourceUrl_ && pe.URL.revokeObjectURL && (pe.URL.revokeObjectURL(this.mediaSourceUrl_), this.mediaSourceUrl_ = null), this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_), super.dispose();
  }
  convertToProgramTime(e, n) {
    return bSe({
      playlist: this.playlistController_.media(),
      time: e,
      callback: n
    });
  }
  // the player must be playing before calling this
  seekToProgramTime(e, n, r = !0, i = 2) {
    return AM({
      programTime: e,
      playlist: this.playlistController_.media(),
      retryCount: i,
      pauseAfterSeek: r,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech,
      callback: n
    });
  }
  /**
   * Adds the onRequest, onResponse, offRequest and offResponse functions
   * to the VhsHandler xhr Object.
   */
  setupXhrHooks_() {
    this.xhr.onRequest = (e) => {
      zM(this.xhr, e);
    }, this.xhr.onResponse = (e) => {
      qM(this.xhr, e);
    }, this.xhr.offRequest = (e) => {
      VM(this.xhr, e);
    }, this.xhr.offResponse = (e) => {
      WM(this.xhr, e);
    }, this.player_.trigger("xhr-hooks-ready");
  }
  attachStreamingEventListeners_() {
    const e = ["seekablerangeschanged", "bufferedrangeschanged", "contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed"], n = ["gapjumped", "playedrangeschanged"];
    e.forEach((r) => {
      this.playlistController_.on(r, (i) => {
        this.player_.trigger(fr({}, i));
      });
    }), n.forEach((r) => {
      this.playbackWatcher_.on(r, (i) => {
        this.player_.trigger(fr({}, i));
      });
    });
  }
}
const E0 = {
  name: "videojs-http-streaming",
  VERSION: UM,
  canHandleSource(t, e = {}) {
    const n = xn(Me.options, e);
    return !n.vhs.experimentalUseMMS && !mf("avc1.4d400d,mp4a.40.2", !1) ? !1 : E0.canPlayType(t.type, n);
  },
  handleSource(t, e, n = {}) {
    const r = xn(Me.options, n);
    return e.vhs = new QM(t, e, r), e.vhs.xhr = fM(), e.vhs.setupXhrHooks_(), e.vhs.src(t.src, t.type), e.vhs;
  },
  canPlayType(t, e) {
    const n = pD(t);
    if (!n)
      return "";
    const r = E0.getOverrideNative(e);
    return !er.supportsTypeNatively(n) || r ? "maybe" : "";
  },
  getOverrideNative(t = {}) {
    const {
      vhs: e = {}
    } = t, n = !(Me.browser.IS_ANY_SAFARI || Me.browser.IS_IOS), {
      overrideNative: r = n
    } = e;
    return r;
  }
}, mIe = () => mf("avc1.4d400d,mp4a.40.2", !0);
mIe() && Me.getTech("Html5").registerSourceHandler(E0, 0);
Me.VhsHandler = QM;
Me.VhsSourceHandler = E0;
Me.Vhs = er;
Me.use || Me.registerComponent("Vhs", er);
Me.options.vhs = Me.options.vhs || {};
(!Me.getPlugin || !Me.getPlugin("reloadSourceOnError")) && Me.registerPlugin("reloadSourceOnError", nIe);
const gIe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAHoSURBVHgB7dvfTcJQFIDx05vyzggdQTfADdxA3UAfSZqICf8e3UDdgA1kA93AO4Lv0OCpQFJJC5eekkjz/RJTaBqTfhwuEKgIAAAAAAAAACBIdOiANE17q9XqIoqirpyn+XA4nMuJVAYcDAbJYrF40Zs9OX++0+lc6Tl5aVhpwE28d72ZSHvkES/13L6lQa5sp8Z7lHbFyyXL5fJeGuYq9vekhXQtv5GGxRX7E2mnRIzyF1Xd9LIs+5xMJrNYEETXzq4uAS86xdf5feec9Pv9Byc4SENda7yvbbwtjfjIBO5RnDr9KzukywRWqJq6XUzgjoCp+4MJLAiduiImUI6fuiICyu8nrw+p+R6Rp/BaIjUR0IiARgQ0IqARAY0IaERAIwIaEdCIgEYENCKgEQGNCGhEQCMCGhHQiIBrXmoioMqy7Eo3b1IDAdV0OvWj0ehWv5G7kyOnkYAF4/H49dhpJOCOY6eRgBVCp5GAewRMoydggKppjKLojZ92BMqnUTe3aZrOdHshm+tPSgPqyHqtm0j7eDHSaHnA2fZ+6VPYOVfrTeUZmEvDSgPGcfwsDTxa/4zXdexJGlYaML+aZ7NoemkBXY7m+fls1rFm//ehA7bXRcgZ0rX8W+N9nvJiQwAAAAAAAABAoB/jLtifdP2J4AAAAABJRU5ErkJggg==", AIe = {
  key: 0,
  class: "flex w-dvw items-center justify-center"
}, bIe = ["src"], yIe = {
  src: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
  class: "h-full w-full border-0 object-cover transition"
}, vIe = {
  key: 0,
  class: "absolute bottom-2 right-2 rounded-full bg-black/30 px-2 py-1 text-xs font-bold text-white"
}, TIe = /* @__PURE__ */ Ze({
  __name: "VideoMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = `vp-${Math.random()}`, r = Se(), i = Se(), s = Se(!1), a = de(() => {
      const { width: f, height: p } = e.message.video;
      return `${f} / ${p}`;
    }), o = Yt(), u = async () => {
      if (s.value) return;
      s.value = !0;
      const f = await o.dispatch(
        "imkit/fetchVideoBlob",
        e.message.video.originalUrl
      );
      r.value && (r.value.src = URL.createObjectURL(f)), i.value = Me(n);
    }, c = de(() => o.state.imkit.uploadProgresses), d = de(() => e.message.video.duration <= 0 || e.message.video.duration === void 0), l = de(() => e.message.senderId.includes("LINE::"));
    return (f, p) => {
      const m = Mc("src");
      return X(), se("div", {
        class: "-mx-3 -my-2 flex max-h-[400px] max-w-[400px] cursor-pointer items-center justify-center",
        style: Qt({ aspectRatio: a.value }),
        onClick: u
      }, [
        Gt(W("video", {
          id: n,
          ref_key: "videoPlayer",
          ref: r,
          class: "w-dvw",
          controls: "",
          preload: "auto",
          autoplay: "",
          style: Qt({ aspectRatio: a.value })
        }, null, 4), [
          [Ra, s.value]
        ]),
        s.value ? Fe("", !0) : (X(), se(wt, { key: 0 }, [
          l.value ? (X(), se("div", AIe, [
            W("img", {
              src: ke(gIe),
              class: "h-[80px] w-[80px] border-0 object-cover transition"
            }, null, 8, bIe)
          ])) : Fe("", !0),
          Gt(W("img", yIe, null, 512), [
            [m, f.message.video.thumbnailUrl]
          ]),
          f.message.video.thumbnailUrl.startsWith("data") ? (X(), se(wt, { key: 1 }, [
            p[0] || (p[0] = W("div", { class: "absolute inset-0 bg-gray-800/50 fill-blue-300" }, null, -1)),
            et(ke(yg), {
              class: "absolute!",
              diameter: 40,
              "completed-steps": c.value[f.message.video.id] * 100,
              "total-steps": 100,
              "start-color": "#60a5fa",
              "stop-color": "#60a5fa",
              "stroke-width": 4,
              "inner-stroke-width": 4
            }, null, 8, ["completed-steps"])
          ], 64)) : (X(), se(wt, { key: 2 }, [
            p[1] || (p[1] = W("img", {
              class: "pointer-events-none absolute",
              src: uD,
              width: "24",
              height: "24"
            }, null, -1)),
            d.value ? Fe("", !0) : (X(), se("div", vIe, _e(Math.floor(f.message.video.duration / 60)) + ":" + _e(`${Math.floor(f.message.video.duration % 60)}`.padStart(2, "0")), 1))
          ], 64))
        ], 64))
      ], 4);
    };
  }
}), _Ie = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAABV0lEQVR4nO3aMUpDQRSF4VmI1m5HtLCxkMxxA86JazAz2Ygi2LkgbVWMpQpKFCyihSZ33r0x58As4GP+F17gpaRp2sbs6GS6nUu7RGlPYHuzPrm029HJdDdFwYL1vgd0Af2Sx5MDb2/6uNnO2FBodMr4C8n6HAqN/re6t4gG62tmPfyX4PT52MRBYwBwKDQGAodBY0BwCDQGBruj4QB2RcMJ7IaGI9gFDWfwfMes+z+9kXX5w4HOYJyebS2LBuvN2oEz6/Uq6LUDY4BH4k/zBglM3bDtECBbPcPUj5bdECBbJU0lbTcEyFZJU0nbDQGyVdJU0nZDgGyVNJW03RAgWyVNJW03BMhWSVNJ2w0BslXSVNJ2Q4BslTSVtN2wcUmXvh+XrnJyaY/2YNarsGDWc3PwaDzZyaU9eOO+ndLufvupxHJfxZd2AdaZO5R1Nr/ZblhN01LEvQM/68r6Ex4bqgAAAABJRU5ErkJggg==", EIe = { class: "flex flex-col gap-0.5 font-normal" }, xIe = { class: "text-base break-words" }, wIe = /* @__PURE__ */ Ze({
  __name: "FileMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = Yt(), n = t, r = de(() => n.message.isIncoming), i = de(() => e.state.imkit.uploadProgresses), s = de(() => {
      const o = n.message.bytes;
      return o < 1e3 ? o + "B" : o < 1e3 * 1e3 ? (o / 1e3).toFixed(1) + "KB" : o < 1e3 * 1e3 * 1e3 ? (o / 1e3 / 1e3).toFixed(1) + "MB" : (o / 1e3 / 1e3 / 1e3).toFixed(1) + "GB";
    }), a = async () => {
      try {
        const { url: o, fileName: u, fileExtension: c } = n.message, d = await e.state.imkit.axios.get(o, {
          responseType: "blob",
          onDownloadProgress: (p) => {
            const { total: m } = p;
            m && e.commit("imkit/updateField", {
              key: "downloadProgresses",
              value: { [o]: p.loaded / m }
            });
          }
        }), l = window.URL.createObjectURL(d.data), f = document.createElement("a");
        f.href = l, f.download = `${u}.${c}`, document.body.appendChild(f), f.click(), document.body.removeChild(f), window.URL.revokeObjectURL(l);
      } catch (o) {
        console.error(o);
      }
    };
    return (o, u) => (X(), se("div", {
      class: "relative flex cursor-pointer items-center justify-center gap-2",
      onClick: a
    }, [
      u[1] || (u[1] = W("img", {
        class: "w-8 object-contain",
        src: _Ie
      }, null, -1)),
      W("div", EIe, [
        W("div", xIe, _e(o.message.fileName) + "." + _e(o.message.fileExtension), 1),
        W("div", {
          class: vt(["text-sm", { "text-gray-500 dark:text-gray-300": r.value }])
        }, _e(o.$t("fileSize")) + ": " + _e(s.value), 3)
      ]),
      o.message.url === "" ? (X(), se(wt, { key: 0 }, [
        u[0] || (u[0] = W("div", { class: "absolute inset-0 -m-2 bg-gray-800/50 fill-blue-300" }, null, -1)),
        et(ke(yg), {
          class: "absolute!",
          diameter: 40,
          "completed-steps": i.value[o.message.id] * 100,
          "total-steps": 100,
          "start-color": "#60a5fa",
          "stop-color": "#60a5fa",
          "stroke-width": 4,
          "inner-stroke-width": 4
        }, null, 8, ["completed-steps"])
      ], 64)) : Fe("", !0)
    ]));
  }
}), CIe = /* @__PURE__ */ mn(wIe, [["__scopeId", "data-v-a368d51d"]]), aa = (t, e) => {
  switch (e.type) {
    case "message":
    case "text": {
      const n = {
        roomId: t,
        messageType: "text",
        message: e.text
      };
      Wf.dispatch("imkit/sendMessage", n);
      break;
    }
    case "uri":
      window.open(e.uri, "_blank");
      break;
    default:
      console.error(`Unsupported action type: ${e.type}`);
      break;
  }
}, SIe = { class: "w-[235px] cursor-pointer overflow-hidden text-base" }, IIe = ["src"], kIe = {
  key: 1,
  class: "flex flex-col gap-2 border-t border-gray-200 py-3 dark:border-gray-500"
}, DIe = ["onClick"], MIe = /* @__PURE__ */ Ze({
  __name: "TemplateMessageButtonsContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = de(() => e.message.isIncoming), r = de(() => !n.value);
    return (i, s) => {
      var a;
      return X(), se("div", SIe, [
        i.message.template.thumbnailImageUrl ? (X(), se("img", {
          key: 0,
          class: vt(["object-cover text-gray-900 dark:text-gray-200", {
            "object-contain": i.message.template.imageSize === "contain"
          }]),
          style: Qt({
            "background-color": i.message.template.imageBackgroundColor ?? "#ffffff",
            height: `${i.message.template.imageAspectRatio === "square" ? 250 : 250 / 1.51}px`
          }),
          src: i.message.template.thumbnailImageUrl,
          onClick: s[0] || (s[0] = (o) => ke(aa)(i.message.roomId, i.message.template.defaultAction))
        }, null, 14, IIe)) : Fe("", !0),
        W("div", {
          class: "flex flex-col gap-1 p-3 text-sm",
          onClick: s[1] || (s[1] = (o) => ke(aa)(i.message.roomId, i.message.template.defaultAction))
        }, [
          W("div", null, _e((a = i.message.template.title) == null ? void 0 : a.substring(0, 40)), 1),
          i.message.template.text ? (X(), se("div", {
            key: 0,
            class: vt(["text-sm", {
              "text-gray-500 dark:text-gray-300": n.value,
              "text-gray-100": r.value
            }])
          }, _e(!i.message.template.thumbnailImageUrl && !i.message.template.title ? i.message.template.text.substring(0, 160) : i.message.template.text.substring(0, 60)), 3)) : Fe("", !0)
        ]),
        i.message.template.actions.length > 0 ? (X(), se("div", kIe, [
          (X(!0), se(wt, null, on(i.message.template.actions, (o) => (X(), se("div", {
            key: o.label,
            class: vt(["flex items-center justify-center p-0.5 text-sm", {
              "text-slate-500 dark:text-slate-300": n.value,
              "text-slate-100": r.value
            }]),
            onClick: (u) => ke(aa)(i.message.roomId, o)
          }, _e(o.label), 11, DIe))), 128))
        ])) : Fe("", !0)
      ]);
    };
  }
}), OIe = { class: "w-[250px] overflow-hidden text-base" }, NIe = { class: "p-3" }, LIe = { class: "flex divide-x border-t" }, PIe = ["onClick"], RIe = /* @__PURE__ */ Ze({
  __name: "TemplateMessageConfirmContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = de(() => e.message.isIncoming), r = de(() => !n.value);
    return (i, s) => (X(), se("div", OIe, [
      W("div", NIe, _e(i.message.template.text.substring(0, 240)), 1),
      W("div", LIe, [
        (X(!0), se(wt, null, on(i.message.template.actions.slice(0, 2), (a) => (X(), se("div", {
          key: a.label,
          class: vt(["flex grow cursor-pointer items-center justify-center p-2", {
            "text-slate-500": n.value,
            "text-slate-100": r.value
          }]),
          onClick: (o) => ke(aa)(i.message.roomId, a)
        }, _e(a.label), 11, PIe))), 128))
      ])
    ]));
  }
}), BIe = { class: "flex cursor-pointer gap-2 overflow-auto text-base" }, FIe = ["src", "onClick"], UIe = ["onClick"], $Ie = {
  key: 1,
  class: "flex flex-col gap-2 border-t border-gray-200 py-3 dark:border-gray-500"
}, HIe = ["onClick"], jIe = /* @__PURE__ */ Ze({
  __name: "TemplateMessageCarouselContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = de(() => e.message.isIncoming), r = de(() => !n.value);
    return (i, s) => (X(), se("div", BIe, [
      (X(!0), se(wt, null, on(i.message.template.columns, (a, o) => {
        var u;
        return X(), se("div", {
          key: o,
          class: vt(["w-[235px] cursor-pointer overflow-hidden rounded-xl text-base", [
            n.value ? "bg-gray-100 text-gray-900 dark:bg-zinc-700 dark:text-gray-200" : "bg-blue-400 text-white"
          ]])
        }, [
          a.thumbnailImageUrl ? (X(), se("img", {
            key: 0,
            class: vt(["object-cover", {
              "object-contain": i.message.template.imageSize === "contain"
            }]),
            style: Qt({
              "background-color": a.imageBackgroundColor ?? "#ffffff",
              height: `${i.message.template.imageAspectRatio === "square" ? 250 : 250 / 1.51}px`
            }),
            src: a.thumbnailImageUrl,
            onClick: (c) => ke(aa)(i.message.roomId, a.defaultAction)
          }, null, 14, FIe)) : Fe("", !0),
          W("div", {
            class: "flex flex-col gap-1 p-3 text-sm",
            onClick: (c) => ke(aa)(i.message.roomId, a.defaultAction)
          }, [
            W("div", null, _e((u = a.title) == null ? void 0 : u.substring(0, 100)), 1),
            a.text ? (X(), se("div", {
              key: 0,
              class: vt(["text-sm", {
                "text-gray-500 dark:text-gray-300": n.value,
                "text-gray-100": r.value
              }])
            }, _e(!a.thumbnailImageUrl && !a.title ? a.text.substring(0, 160) : a.text.substring(0, 300)), 3)) : Fe("", !0)
          ], 8, UIe),
          a.actions.length > 0 ? (X(), se("div", $Ie, [
            (X(!0), se(wt, null, on(a.actions, (c) => (X(), se("div", {
              key: c.label,
              class: vt(["flex items-center justify-center p-0.5 text-sm", {
                "text-slate-500 dark:text-slate-300": n.value,
                "text-slate-100": r.value
              }]),
              onClick: (d) => ke(aa)(i.message.roomId, c)
            }, _e(c.label), 11, HIe))), 128))
          ])) : Fe("", !0)
        ], 2);
      }), 128))
    ]));
  }
}), zIe = { class: "flex cursor-pointer gap-2 overflow-auto text-base" }, qIe = ["src", "onClick"], VIe = /* @__PURE__ */ Ze({
  __name: "TemplateMessageImageCarouselContent",
  props: {
    message: {}
  },
  setup(t) {
    return (e, n) => (X(), se("div", zIe, [
      (X(!0), se(wt, null, on(e.message.template.columns, (r, i) => (X(), se("img", {
        key: i,
        src: r.imageUrl,
        class: "h-[250px] w-[250px] rounded-xl object-cover",
        onClick: (s) => ke(aa)(e.message.roomId, r.action)
      }, null, 8, qIe))), 128))
    ]));
  }
}), WIe = /* @__PURE__ */ Ze({
  __name: "TemplateMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = {
      [Pa.Buttons]: MIe,
      [Pa.Confirm]: RIe,
      [Pa.Carousel]: jIe,
      [Pa.ImageCarousel]: VIe
    };
    return (n, r) => (X(), gt(xu(e[n.message.templateType]), { message: n.message }, null, 8, ["message"]));
  }
}), QIe = /* @__PURE__ */ Ze({
  __name: "FlexMessageBoxComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = (n) => ({
      none: "0",
      xs: "2px",
      sm: "4px",
      md: "8px",
      lg: "12px",
      xl: "16px",
      xxl: "20px"
    })[n] ?? n;
    return (n, r) => (X(), se("div", {
      class: vt(["flex", {
        "flex-col": n.content.layout === "vertical",
        "flex-row": n.content.layout === "horizontal",
        "flex-row items-baseline": n.content.layout === "baseline"
      }]),
      style: Qt({
        backgroundColor: n.content.backgroundColor ?? "#00000000",
        borderColor: n.content.borderColor,
        borderWidth: n.content.borderWidth,
        borderRadius: n.content.cornerRadius,
        width: n.content.width,
        maxWidth: n.content.maxWidth,
        height: n.content.height,
        maxHeight: n.content.maxHeight
      })
    }, [
      (X(!0), se(wt, null, on(n.content.contents, (i, s) => (X(), gt(Kd, {
        key: s,
        content: i,
        style: Qt(
          n.content.layout === "vertical" ? {
            marginTop: i.margin ? e(i.margin) : s === 0 ? 0 : e(n.content.spacing)
          } : {
            marginLeft: i.margin ? e(i.margin) : s === 0 ? 0 : e(n.content.spacing)
          }
        )
      }, null, 8, ["content", "style"]))), 128))
    ], 6));
  }
}), GIe = /* @__PURE__ */ Ze({
  __name: "FlexMessageButtonComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = t, n = Yt(), r = pn("messageId"), i = de(
      () => {
        var o;
        return (o = n.state.imkit.messageMultiList.main) == null ? void 0 : o.map.get(r);
      }
    ), s = de(() => e.content.style === "primary" ? "#ffffff" : e.content.style === "secondary" ? "#000000" : e.content.color || "#42659a"), a = de(() => e.content.style === "primary" ? e.content.color || "#17c950" : e.content.style === "secondary" ? e.content.color || "#dcdfe5" : "");
    return (o, u) => (X(), se("button", {
      class: vt([[o.content.size === "md" ? "h-52px" : "h-10"], "rounded-lg"]),
      style: Qt({
        color: s.value,
        backgroundColor: a.value
      }),
      onClick: u[0] || (u[0] = (c) => ke(aa)(i.value.roomId, o.content.action))
    }, _e(o.content.action.label), 7));
  }
}), YIe = ["src"], XIe = /* @__PURE__ */ Ze({
  __name: "FlexMessageImageComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = t, n = de(() => e.content.aspectRatio ? e.content.aspectRatio.replace(":", "/") : "1/1");
    return (r, i) => (X(), se("div", {
      class: vt(["w-full overflow-hidden bg-gray-300", [
        r.content.aspectMode === "cover" ? "object-cover" : "object-contain"
      ]]),
      style: Qt({
        "aspect-ratio": n.value
      })
    }, [
      W("img", {
        class: "h-full w-full",
        src: r.content.url
      }, null, 8, YIe)
    ], 6));
  }
}), KIe = ["src"], ZIe = /* @__PURE__ */ Ze({
  __name: "FlexMessageVideoComponent",
  props: {
    content: {}
  },
  setup(t) {
    return (e, n) => (X(), se("video", {
      src: e.content.url
    }, null, 8, KIe));
  }
}), JIe = /* @__PURE__ */ Ze({
  __name: "FlexMessageIconComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = t, n = de(() => {
      const r = e.content.size;
      return {
        xxs: "12px",
        xs: "13px",
        sm: "14px",
        md: "16px",
        lg: "19px",
        xl: "22px",
        xxl: "29px",
        "3xl": "35px",
        "4xl": "48px",
        "5xl": "74px"
      }[r] ?? "16px";
    });
    return (r, i) => (X(), se("span", {
      style: Qt({
        overflow: "hidden",
        background: "no-repeat center",
        backgroundSize: "contain",
        backgroundImage: "url(" + r.content.url + ")",
        width: n.value,
        height: n.value
      })
    }, null, 4));
  }
}), eke = /* @__PURE__ */ Ze({
  __name: "FlexMessageTextComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = t, n = de(() => {
      const r = e.content.size;
      return {
        xxs: "12px",
        xs: "13px",
        sm: "14px",
        md: "16px",
        lg: "19px",
        xl: "22px",
        xxl: "29px",
        "3xl": "35px",
        "4xl": "48px",
        "5xl": "74px"
      }[r] ?? "16px";
    });
    return (r, i) => (X(), se("div", {
      class: "basis-0",
      style: Qt({ flexGrow: r.content.flex ?? 0 })
    }, [
      W("p", {
        class: vt([
          "text-gray-900 dark:text-gray-100",
          r.content.weight === "bold" ? "font-bold" : "font-normal",
          r.content.wrap ? "overflow-clip overflow-hidden break-words whitespace-normal" : "truncate overflow-hidden whitespace-nowrap"
        ]),
        style: Qt({ fontSize: n.value, color: r.content.color, "text-size-adjust": "100%" })
      }, _e(r.content.text), 7)
    ], 4));
  }
}), tke = /* @__PURE__ */ Ze({
  __name: "FlexMessageSpanComponent",
  props: {
    content: {}
  },
  setup(t) {
    return (e, n) => (X(), se("span", null, _e(e.content.text), 1));
  }
}), nke = /* @__PURE__ */ Ze({
  __name: "FlexMessageSeparatorComponent",
  props: {
    content: {}
  },
  setup(t) {
    return (e, n) => (X(), se("div"));
  }
}), rke = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAACE4AAAhOAFFljFgAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMtSURBVHgB7Zq/b9NAFMffPUfthigDEgvtn4DogJAobSdUVW1aOgELY+hQpg5MhAE2mJAoA0IsCCEqWhEhBIjWGYIYGNnbhZklHRrnjncObpOSH75nO7Gj+yy1nUvarz+XZ79zASwWi8VisQwKAcPI1tQ1RMyDglHa+yW92iasVPb1S8MV+P3MaYHqNYWaazmu1G8JogBL7ofhCfz28hkcGf0MQk12GHEondqkA8NA6coYipFvFPZil1EOSOds9g2X5sfQq+qwF0KM/pPtwGZhNV52p7Sexl7dJCwooX5k07AfNmcUVkOV+nYOsgYzLPl9Cnn3FUKW+Dh3ihl2Qy6W1/RWdqY03+yGzJfvBHvZMMwOKx6T2dWWI5B2opjVYQXdUTeRbsNRzZ4I678CaSVmswHpNMwNK+BZt7CNIWkjIbMBxzceW7OXEOqrCsV5uiXR73snsfoSFn8eQL9ohP2SVFiNbxi3p+/Rj4fwv/E9KcUsLO/uQdKYNwINlHoul/zrbM+wGuGUpuZVHUtdxiQfOko1zu+uQ8iwGpSeWOsxZgJR7cDm1DlIAt9sjmd20SysBoUQ0yHGTWAOK7RmNAFx4put8swulQthvrMnQTpT9ZBjG6bjCh2pGvtmWaASomIwPp7Q7OssTWPdCDDMBiC98xGYES10lBZv4bjr4YLUFO+AVEUwgxdamz08cAdhNsC/tZTL5Qd0Botghllofxo7ZBbMC1QMZo8+rXkHt6/ep0NFMKP3dZobVptdiMdsQEvzQNOGaRo+dTQd1WyMYf1PbXcwNtMpMhvQtj3km276TrPN/qvGCYTVdG0P2aY9uYIOvkiT2aNf0WsAL7SiP1gY9trhW7wo9HzUot7su+LGOG2JGQiNYVhttg9hNaGeLfFCh0UvuLl3+xFWE/phWiKhfbP9C6sxWsRjVu9OPKFpXOhnWA1rEY9ZvZvoT4FqB3vVkh26UaAKMCDY69K86R1PixeFyOvSoU0P2GxA5CcP4UzH2+JFIZb/8fAvWTfHPdqkBUHRehIlVeO8uz6IAtWOeB+1UOOAjrwFSoxS0pqs41e47n4Hi8VisVgsFuIvEZa9647Q61sAAAAASUVORK5CYII=", ike = {}, ske = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "18",
  height: "18",
  viewBox: "0 0 18 18",
  fill: "none"
};
function ake(t, e) {
  return X(), se("svg", ske, e[0] || (e[0] = [
    W("path", {
      d: "M16.0298 8.98913C16.0303 9.18957 15.9773 9.38651 15.8762 9.55957C15.775 9.73264 15.6295 9.87554 15.4547 9.97351L3.64778 16.7242C3.47835 16.8202 3.28706 16.8711 3.09231 16.8719C2.91286 16.8709 2.73625 16.827 2.57722 16.7439C2.41819 16.6608 2.28135 16.5408 2.17812 16.394C2.0749 16.2472 2.00828 16.0779 1.98384 15.9001C1.9594 15.7223 1.97784 15.5413 2.03762 15.3721L3.93606 9.75062C3.95461 9.69565 3.9897 9.64778 4.03653 9.61354C4.08335 9.5793 4.13962 9.56038 4.19762 9.55937H9.27981C9.35692 9.55953 9.43324 9.54385 9.50404 9.51328C9.57483 9.48271 9.63858 9.43791 9.69133 9.38166C9.74408 9.32542 9.78471 9.25893 9.81068 9.18632C9.83665 9.11371 9.84742 9.03654 9.84231 8.9596C9.82955 8.81496 9.76263 8.68047 9.65493 8.58307C9.54723 8.48568 9.40672 8.43256 9.26153 8.43437H4.19903C4.14018 8.43437 4.08282 8.41592 4.03502 8.38161C3.98721 8.3473 3.95137 8.29886 3.93254 8.24311L2.0341 2.62233C1.95854 2.40689 1.95032 2.17356 2.01053 1.95333C2.07073 1.7331 2.19652 1.5364 2.37118 1.38937C2.54584 1.24233 2.7611 1.15192 2.98836 1.13013C3.21563 1.10835 3.44415 1.15623 3.64356 1.26741L15.4561 8.00968C15.6299 8.10742 15.7747 8.24963 15.8755 8.42173C15.9763 8.59384 16.0296 8.78967 16.0298 8.98913Z",
      fill: "white"
    }, null, -1)
  ]));
}
const oke = /* @__PURE__ */ mn(ike, [["render", ake]]), uke = ["placeholder"], lke = ["disabled"], cke = {
  key: 1,
  width: "20",
  height: "20",
  src: rke,
  alt: ""
}, dke = {
  key: 0,
  class: "mt-2 text-[#fe4d4f]"
}, fke = /* @__PURE__ */ Ze({
  inheritAttrs: !1,
  __name: "FlexMessageInputComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = t, n = Se("");
    n.value = e.content.text;
    const r = Se(!1), i = Yt(), s = de(() => i.state.imkit.config.callbacks), a = pn("messageId"), o = de(
      () => {
        var c;
        return (c = i.state.imkit.messageMultiList.main) == null ? void 0 : c.map.get(a);
      }
    ), u = () => {
      if (!e.content.completed) {
        if (e.content.subtype === "email") {
          if (!/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/.test(n.value)) {
            r.value = !0;
            return;
          }
          r.value = !1;
        }
        s.value.flexMessageInputSubmitted(o.value, n.value);
      }
    };
    return (c, d) => (X(), se(wt, null, [
      W("div", ea({ class: "flex items-center gap-2 rounded bg-white p-2" }, c.$attrs), [
        Gt(W("input", {
          "onUpdate:modelValue": d[0] || (d[0] = (l) => n.value = l),
          class: "w-full focus:outline-none",
          placeholder: c.$t(`Request.Message.${c.content.subtype}.placeholder`),
          onKeypress: lh(u, ["enter"])
        }, null, 40, uke), [
          [ds, n.value]
        ]),
        W("button", {
          disabled: !n.value,
          class: vt(["rounded-lg p-[6px] disabled:cursor-not-allowed disabled:bg-gray-400", { "bg-[#02b13f]": !c.content.completed }]),
          onClick: u
        }, [
          c.content.completed ? (X(), se("img", cke)) : (X(), gt(oke, { key: 0 }))
        ], 10, lke)
      ], 16),
      r.value ? (X(), se("div", dke, _e(c.$t("emailFromatError")), 1)) : Fe("", !0)
    ], 64));
  }
}), hke = {
  key: 0,
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "star",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512",
  class: "svg-inline--fa fa-star fa-w-18 fa-2x"
}, pke = {
  key: 1,
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "far",
  "data-icon": "star",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512",
  class: "svg-inline--fa fa-star fa-w-18 fa-2x"
}, mke = /* @__PURE__ */ Ze({
  __name: "StarSvg",
  props: {
    fill: { type: Boolean }
  },
  setup(t) {
    return (e, n) => e.fill ? (X(), se("svg", hke, n[0] || (n[0] = [
      W("path", {
        fill: "currentColor",
        d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z",
        class: ""
      }, null, -1)
    ]))) : (X(), se("svg", pke, n[1] || (n[1] = [
      W("path", {
        fill: "currentColor",
        d: "M528.1 171.5L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6zM388.6 312.3l23.7 138.4L288 385.4l-124.3 65.3 23.7-138.4-100.6-98 139-20.2 62.2-126 62.2 126 139 20.2-100.6 98z",
        class: ""
      }, null, -1)
    ])));
  }
}), gke = { class: "p-1.5" }, Ake = /* @__PURE__ */ Ze({
  __name: "FlexMessageRatingComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = t, n = Se("");
    n.value = e.content.text;
    const r = Yt(), i = de(() => r.state.imkit.config.callbacks), s = pn("messageId"), a = de(
      () => {
        var u;
        return (u = r.state.imkit.messageMultiList.main) == null ? void 0 : u.map.get(s);
      }
    ), o = () => {
      !e.content.action || "fill" in e.content.action || i.value.flexMessageRatingSubmitted(
        a.value,
        e.content.action.text
      );
    };
    return (u, c) => {
      var d;
      return X(), se("div", gke, [
        et(mke, {
          class: "h-8 w-8 text-yellow-300",
          fill: (d = u.content.action) == null ? void 0 : d.fill,
          onClick: o
        }, null, 8, ["fill"])
      ]);
    };
  }
}), bke = /* @__PURE__ */ mn(Ake, [["__scopeId", "data-v-71f9e243"]]), Kd = /* @__PURE__ */ Ze({
  inheritAttrs: !1,
  __name: "FlexMessageComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = {
      box: QIe,
      button: GIe,
      image: XIe,
      video: ZIe,
      icon: JIe,
      text: eke,
      span: tke,
      separator: nke,
      input: fke,
      rating: bke
    }, n = t, r = de(() => n.content.type);
    return (i, s) => (X(), gt(xu(e[r.value]), ea({ content: i.content }, i.$attrs), null, 16, ["content"]));
  }
}), GM = /* @__PURE__ */ Ze({
  __name: "FlexMessageBubbleComponent",
  props: {
    content: {}
  },
  setup(t) {
    const e = t, n = de(() => e.content.header), r = de(() => e.content.hero), i = de(() => e.content.body), s = de(() => e.content.footer), a = de(() => {
      var l;
      return (l = e.content.styles) == null ? void 0 : l.header;
    }), o = de(() => {
      var l;
      return (l = e.content.styles) == null ? void 0 : l.hero;
    }), u = de(() => {
      var l;
      return (l = e.content.styles) == null ? void 0 : l.body;
    }), c = de(() => {
      var l;
      return (l = e.content.styles) == null ? void 0 : l.footer;
    }), d = de(() => {
      switch (e.content.size) {
        case "nano":
          return "10px";
        case "micro":
          return "13px";
        case "kilo":
          return s.value ? "13px 13px 17px 13px" : "13px";
        case "mega":
          return s.value ? "19px 20px 10px 20px" : "20px";
        case "giga":
          return s.value ? "19px 20px 10px 20px" : "20px";
        default:
          return "16px";
      }
    });
    return (l, f) => {
      var p, m, g, y, b, E, v, _, D, S, M, O;
      return X(), se("div", {
        class: vt(["overflow-hidden bg-gray-100 text-[#444444] dark:bg-zinc-700", {
          "w-[120px]": l.content.size === "nano",
          "w-[160px]": l.content.size === "micro",
          "w-[260px]": l.content.size === "kilo",
          "w-[300px]": l.content.size === "mega",
          "w-[386px]": l.content.size === "giga"
        }])
      }, [
        n.value ? (X(), gt(Kd, {
          key: 0,
          content: n.value,
          style: Qt({
            backgroundColor: (p = a.value) == null ? void 0 : p.backgroundColor,
            borderBottom: (m = a.value) != null && m.separator ? `1px solid ${(g = a.value) == null ? void 0 : g.separatorColor}` : "none"
          })
        }, null, 8, ["content", "style"])) : Fe("", !0),
        r.value ? (X(), gt(Kd, {
          key: 1,
          content: r.value,
          style: Qt({
            backgroundColor: (y = o.value) == null ? void 0 : y.backgroundColor,
            borderBottom: (b = o.value) != null && b.separator ? `1px solid ${(E = o.value) == null ? void 0 : E.separatorColor}` : "none"
          })
        }, null, 8, ["content", "style"])) : Fe("", !0),
        i.value ? (X(), gt(Kd, {
          key: 2,
          content: i.value,
          style: Qt({
            backgroundColor: (v = u.value) == null ? void 0 : v.backgroundColor,
            borderBottom: (_ = u.value) != null && _.separator ? `1px solid ${(D = u.value) == null ? void 0 : D.separatorColor}` : "none",
            padding: d.value
          })
        }, null, 8, ["content", "style"])) : Fe("", !0),
        s.value ? (X(), gt(Kd, {
          key: 3,
          content: s.value,
          class: "p-2.5",
          style: Qt({
            backgroundColor: (S = c.value) == null ? void 0 : S.backgroundColor,
            borderBottom: (M = c.value) != null && M.separator ? `1px solid ${(O = c.value) == null ? void 0 : O.separatorColor}` : "none"
          })
        }, null, 8, ["content", "style"])) : Fe("", !0)
      ], 2);
    };
  }
}), yke = /* @__PURE__ */ Ze({
  __name: "FlexMessageBubbleContent",
  props: {
    message: {}
  },
  setup(t) {
    return (e, n) => (X(), gt(GM, {
      content: e.message.contents
    }, null, 8, ["content"]));
  }
}), vke = { class: "flex items-start gap-2 overflow-auto" }, Tke = /* @__PURE__ */ Ze({
  __name: "FlexMessageCarouselContent",
  props: {
    message: {}
  },
  setup(t) {
    return (e, n) => (X(), se("div", vke, [
      (X(!0), se(wt, null, on(e.message.contents.contents, (r, i) => (X(), gt(GM, {
        key: i,
        content: r
      }, null, 8, ["content"]))), 128))
    ]));
  }
}), _ke = /* @__PURE__ */ Ze({
  __name: "FlexMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = {
      [jb.Bubble]: yke,
      [jb.Carousel]: Tke
    };
    return (n, r) => (X(), gt(xu(e[n.message.flexType || "bubble"]), { message: n.message }, null, 8, ["message"]));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.appendChild(document.createTextNode(".mapdiv[data-v-e7ebb206]{width:100%;height:100%}.advanced-marker-wrapper{display:none}.mapdiv .advanced-marker-wrapper{display:inline-block}.custom-control-wrapper[data-v-d099a3a6]{display:none}.mapdiv .custom-control-wrapper[data-v-d099a3a6]{display:inline-block}.info-window-wrapper[data-v-cbe1707b]{display:none}.mapdiv .info-window-wrapper[data-v-cbe1707b]{display:inline-block}.custom-marker-wrapper[data-v-2d2d343a]{display:none}.mapdiv .custom-marker-wrapper[data-v-2d2d343a]{display:inline-block}")), document.head.appendChild(t);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
var Eke = Object.defineProperty, xke = (t, e, n) => e in t ? Eke(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Nw = (t, e, n) => (xke(t, typeof e != "symbol" ? e + "" : e, n), n);
const Zu = Symbol("map"), Ju = Symbol("api"), VT = Symbol("marker"), WT = Symbol("markerCluster"), jg = Symbol("CustomMarker"), YM = Symbol("mapTilesLoaded"), Ac = [
  "click",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "rightclick"
];
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function wke(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(a) {
      a(s);
    });
  }
  return new (n || (n = Promise))(function(s, a) {
    function o(d) {
      try {
        c(r.next(d));
      } catch (l) {
        a(l);
      }
    }
    function u(d) {
      try {
        c(r.throw(d));
      } catch (l) {
        a(l);
      }
    }
    function c(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    c((r = r.apply(t, [])).next());
  });
}
var Cke = function t(e, n) {
  if (e === n)
    return !0;
  if (e && n && typeof e == "object" && typeof n == "object") {
    if (e.constructor !== n.constructor)
      return !1;
    var r, i, s;
    if (Array.isArray(e)) {
      if (r = e.length, r != n.length)
        return !1;
      for (i = r; i-- !== 0; )
        if (!t(e[i], n[i]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === n.source && e.flags === n.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === n.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === n.toString();
    if (s = Object.keys(e), r = s.length, r !== Object.keys(n).length)
      return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, s[i]))
        return !1;
    for (i = r; i-- !== 0; ) {
      var a = s[i];
      if (!t(e[a], n[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && n !== n;
};
const Lw = "__googleMapsScriptId";
var Ul;
(function(t) {
  t[t.INITIALIZED = 0] = "INITIALIZED", t[t.LOADING = 1] = "LOADING", t[t.SUCCESS = 2] = "SUCCESS", t[t.FAILURE = 3] = "FAILURE";
})(Ul || (Ul = {}));
class du {
  /**
   * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set
   * using this library, instead the defaults are set by the Google Maps
   * JavaScript API server.
   *
   * ```
   * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});
   * ```
   */
  constructor({ apiKey: e, authReferrerPolicy: n, channel: r, client: i, id: s = Lw, language: a, libraries: o = [], mapIds: u, nonce: c, region: d, retries: l = 3, url: f = "https://maps.googleapis.com/maps/api/js", version: p }) {
    if (this.callbacks = [], this.done = !1, this.loading = !1, this.errors = [], this.apiKey = e, this.authReferrerPolicy = n, this.channel = r, this.client = i, this.id = s || Lw, this.language = a, this.libraries = o, this.mapIds = u, this.nonce = c, this.region = d, this.retries = l, this.url = f, this.version = p, du.instance) {
      if (!Cke(this.options, du.instance.options))
        throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(du.instance.options)}`);
      return du.instance;
    }
    du.instance = this;
  }
  get options() {
    return {
      version: this.version,
      apiKey: this.apiKey,
      channel: this.channel,
      client: this.client,
      id: this.id,
      libraries: this.libraries,
      language: this.language,
      region: this.region,
      mapIds: this.mapIds,
      nonce: this.nonce,
      url: this.url,
      authReferrerPolicy: this.authReferrerPolicy
    };
  }
  get status() {
    return this.errors.length ? Ul.FAILURE : this.done ? Ul.SUCCESS : this.loading ? Ul.LOADING : Ul.INITIALIZED;
  }
  get failed() {
    return this.done && !this.loading && this.errors.length >= this.retries + 1;
  }
  /**
   * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].
   *
   * @ignore
   * @deprecated
   */
  createUrl() {
    let e = this.url;
    return e += "?callback=__googleMapsCallback", this.apiKey && (e += `&key=${this.apiKey}`), this.channel && (e += `&channel=${this.channel}`), this.client && (e += `&client=${this.client}`), this.libraries.length > 0 && (e += `&libraries=${this.libraries.join(",")}`), this.language && (e += `&language=${this.language}`), this.region && (e += `&region=${this.region}`), this.version && (e += `&v=${this.version}`), this.mapIds && (e += `&map_ids=${this.mapIds.join(",")}`), this.authReferrerPolicy && (e += `&auth_referrer_policy=${this.authReferrerPolicy}`), e;
  }
  deleteScript() {
    const e = document.getElementById(this.id);
    e && e.remove();
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   * @deprecated, use importLibrary() instead.
   */
  load() {
    return this.loadPromise();
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   *
   * @ignore
   * @deprecated, use importLibrary() instead.
   */
  loadPromise() {
    return new Promise((e, n) => {
      this.loadCallback((r) => {
        r ? n(r.error) : e(window.google);
      });
    });
  }
  importLibrary(e) {
    return this.execute(), google.maps.importLibrary(e);
  }
  /**
   * Load the Google Maps JavaScript API script with a callback.
   * @deprecated, use importLibrary() instead.
   */
  loadCallback(e) {
    this.callbacks.push(e), this.execute();
  }
  /**
   * Set the script on document.
   */
  setScript() {
    var e, n;
    if (document.getElementById(this.id)) {
      this.callback();
      return;
    }
    const r = {
      key: this.apiKey,
      channel: this.channel,
      client: this.client,
      libraries: this.libraries.length && this.libraries,
      v: this.version,
      mapIds: this.mapIds,
      language: this.language,
      region: this.region,
      authReferrerPolicy: this.authReferrerPolicy
    };
    Object.keys(r).forEach(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (s) => !r[s] && delete r[s]
    ), !((n = (e = window == null ? void 0 : window.google) === null || e === void 0 ? void 0 : e.maps) === null || n === void 0) && n.importLibrary || ((s) => {
      let a, o, u, c = "The Google Maps JavaScript API", d = "google", l = "importLibrary", f = "__ib__", p = document, m = window;
      m = m[d] || (m[d] = {});
      const g = m.maps || (m.maps = {}), y = /* @__PURE__ */ new Set(), b = new URLSearchParams(), E = () => (
        // @ts-ignore
        a || (a = new Promise((v, _) => wke(this, void 0, void 0, function* () {
          var D;
          yield o = p.createElement("script"), o.id = this.id, b.set("libraries", [...y] + "");
          for (u in s)
            b.set(u.replace(/[A-Z]/g, (S) => "_" + S[0].toLowerCase()), s[u]);
          b.set("callback", d + ".maps." + f), o.src = this.url + "?" + b, g[f] = v, o.onerror = () => a = _(Error(c + " could not load.")), o.nonce = this.nonce || ((D = p.querySelector("script[nonce]")) === null || D === void 0 ? void 0 : D.nonce) || "", p.head.append(o);
        })))
      );
      g[l] ? console.warn(c + " only loads once. Ignoring:", s) : g[l] = (v, ..._) => y.add(v) && E().then(() => g[l](v, ..._));
    })(r);
    const i = this.libraries.map((s) => this.importLibrary(s));
    i.length || i.push(this.importLibrary("core")), Promise.all(i).then(() => this.callback(), (s) => {
      const a = new ErrorEvent("error", { error: s });
      this.loadErrorCallback(a);
    });
  }
  /**
   * Reset the loader state.
   */
  reset() {
    this.deleteScript(), this.done = !1, this.loading = !1, this.errors = [], this.onerrorEvent = null;
  }
  resetIfRetryingFailed() {
    this.failed && this.reset();
  }
  loadErrorCallback(e) {
    if (this.errors.push(e), this.errors.length <= this.retries) {
      const n = this.errors.length * Math.pow(2, this.errors.length);
      console.error(`Failed to load Google Maps script, retrying in ${n} ms.`), setTimeout(() => {
        this.deleteScript(), this.setScript();
      }, n);
    } else
      this.onerrorEvent = e, this.callback();
  }
  callback() {
    this.done = !0, this.loading = !1, this.callbacks.forEach((e) => {
      e(this.onerrorEvent);
    }), this.callbacks = [];
  }
  execute() {
    if (this.resetIfRetryingFailed(), this.done)
      this.callback();
    else {
      if (window.google && window.google.maps && window.google.maps.version) {
        console.warn("Google Maps already loaded outside @googlemaps/js-api-loader.This may result in undesirable behavior as options and script parameters may not match."), this.callback();
        return;
      }
      this.loading || (this.loading = !0, this.setScript());
    }
  }
}
function Ske(t) {
  return class extends t.OverlayView {
    constructor(e) {
      super(), Nw(this, "element"), Nw(this, "opts");
      const { element: n, ...r } = e;
      this.element = n, this.opts = r, this.opts.map && this.setMap(this.opts.map);
    }
    getPosition() {
      return this.opts.position ? this.opts.position instanceof t.LatLng ? this.opts.position : new t.LatLng(this.opts.position) : null;
    }
    getVisible() {
      if (!this.element)
        return !1;
      const e = this.element;
      return e.style.display !== "none" && e.style.visibility !== "hidden" && (e.style.opacity === "" || Number(e.style.opacity) > 0.01);
    }
    onAdd() {
      if (!this.element)
        return;
      const e = this.getPanes();
      e && e.overlayMouseTarget.appendChild(this.element);
    }
    draw() {
      if (!this.element)
        return;
      const e = this.getProjection(), n = e == null ? void 0 : e.fromLatLngToDivPixel(this.getPosition());
      if (n) {
        this.element.style.position = "absolute";
        let r, i;
        switch (this.opts.anchorPoint) {
          case "TOP_CENTER":
            r = "-50%", i = "-100%";
            break;
          case "BOTTOM_CENTER":
            r = "-50%", i = "0";
            break;
          case "LEFT_CENTER":
            r = "-100%", i = "-50%";
            break;
          case "RIGHT_CENTER":
            r = "0", i = "-50%";
            break;
          case "TOP_LEFT":
            r = "-100%", i = "-100%";
            break;
          case "TOP_RIGHT":
            r = "0", i = "-100%";
            break;
          case "BOTTOM_LEFT":
            r = "-100%", i = "0";
            break;
          case "BOTTOM_RIGHT":
            r = "0", i = "0";
            break;
          default:
            r = "-50%", i = "-50%";
        }
        const s = n.x + (this.opts.offsetX || 0) + "px", a = n.y + (this.opts.offsetY || 0) + "px";
        this.element.style.transform = `translateX(${r}) translateX(${s}) translateY(${i}) translateY(${a})`, this.opts.zIndex && (this.element.style.zIndex = this.opts.zIndex.toString());
      }
    }
    onRemove() {
      this.element && this.element.remove();
    }
    setOptions(e) {
      const { element: n, ...r } = e;
      this.element = n, this.opts = r, this.draw();
    }
  };
}
let Pw;
const Rw = [
  "bounds_changed",
  "center_changed",
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "heading_changed",
  "idle",
  "isfractionalzoomenabled_changed",
  "mapcapabilities_changed",
  "maptypeid_changed",
  "mousemove",
  "mouseout",
  "mouseover",
  "projection_changed",
  "renderingtype_changed",
  "rightclick",
  "tilesloaded",
  "tilt_changed",
  "zoom_changed"
], Ike = Ze({
  props: {
    apiPromise: {
      type: Promise
    },
    apiKey: {
      type: String,
      default: ""
    },
    version: {
      type: String,
      default: "weekly"
    },
    libraries: {
      type: Array,
      default: () => ["places", "marker"]
    },
    region: {
      type: String,
      required: !1
    },
    language: {
      type: String,
      required: !1
    },
    backgroundColor: {
      type: String,
      required: !1
    },
    center: {
      type: Object,
      default: () => ({ lat: 0, lng: 0 })
    },
    clickableIcons: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    colorScheme: {
      type: String,
      required: !1
    },
    controlSize: {
      type: Number,
      required: !1
    },
    disableDefaultUi: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disableDoubleClickZoom: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    draggable: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    draggableCursor: {
      type: String,
      required: !1
    },
    draggingCursor: {
      type: String,
      required: !1
    },
    fullscreenControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    fullscreenControlPosition: {
      type: String,
      required: !1
    },
    gestureHandling: {
      type: String,
      required: !1
    },
    heading: {
      type: Number,
      required: !1
    },
    isFractionalZoomEnabled: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    keyboardShortcuts: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    mapTypeControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    mapTypeControlOptions: {
      type: Object,
      required: !1
    },
    mapTypeId: {
      type: [Number, String],
      required: !1
    },
    mapId: {
      type: String,
      required: !1
    },
    maxZoom: {
      type: Number,
      required: !1
    },
    minZoom: {
      type: Number,
      required: !1
    },
    noClear: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    panControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    panControlPosition: {
      type: String,
      required: !1
    },
    restriction: {
      type: Object,
      required: !1
    },
    rotateControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    rotateControlPosition: {
      type: String,
      required: !1
    },
    scaleControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    scaleControlStyle: {
      type: Number,
      required: !1
    },
    scrollwheel: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    streetView: {
      type: Object,
      required: !1
    },
    streetViewControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    streetViewControlPosition: {
      type: String,
      required: !1
    },
    styles: {
      type: Array,
      required: !1
    },
    tilt: {
      type: Number,
      required: !1
    },
    zoom: {
      type: Number,
      required: !1
    },
    zoomControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    zoomControlPosition: {
      type: String,
      required: !1
    },
    cameraControl: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    cameraControlPosition: {
      type: String,
      required: !1
    },
    nonce: {
      type: String,
      default: ""
    }
  },
  emits: Rw,
  setup(t, { emit: e }) {
    const n = Se(), r = Se(!1), i = Se(), s = Se(), a = Se(!1);
    Ba(Zu, i), Ba(Ju, s), Ba(YM, a);
    const o = () => {
      const l = { ...t };
      Object.keys(l).forEach((m) => {
        l[m] === void 0 && delete l[m];
      });
      const f = (m) => {
        var g;
        return m ? { position: (g = s.value) == null ? void 0 : g.ControlPosition[m] } : {};
      }, p = {
        scaleControlOptions: t.scaleControlStyle ? { style: t.scaleControlStyle } : {},
        panControlOptions: f(t.panControlPosition),
        zoomControlOptions: f(t.zoomControlPosition),
        rotateControlOptions: f(t.rotateControlPosition),
        streetViewControlOptions: f(t.streetViewControlPosition),
        fullscreenControlOptions: f(t.fullscreenControlPosition),
        cameraControlOptions: f(t.cameraControlPosition),
        disableDefaultUI: t.disableDefaultUi
      };
      return { ...l, ...p };
    }, u = Ct(
      [s, i],
      ([l, f]) => {
        const p = l, m = f;
        p && m && (p.event.addListenerOnce(m, "tilesloaded", () => {
          a.value = !0;
        }), setTimeout(u, 0));
      },
      { immediate: !0 }
    ), c = () => {
      try {
        const { apiKey: l, region: f, version: p, language: m, libraries: g, nonce: y } = t;
        Pw = new du({ apiKey: l, region: f, version: p, language: m, libraries: g, nonce: y });
      } catch (l) {
        console.error(l);
      }
    }, d = (l) => {
      s.value = Vi(l.maps), i.value = Vi(new l.maps.Map(n.value, o()));
      const f = Ske(s.value);
      s.value[jg] = f, Rw.forEach((m) => {
        var g;
        (g = i.value) == null || g.addListener(m, (y) => e(m, y));
      }), r.value = !0;
      const p = Object.keys(t).filter(
        (m) => !["apiPromise", "apiKey", "version", "libraries", "region", "language", "center", "zoom", "nonce"].includes(m)
      ).map((m) => Ii(t, m));
      Ct(
        [() => t.center, () => t.zoom, ...p],
        ([m, g], [y, b]) => {
          var E, v, _;
          const { center: D, zoom: S, ...M } = o();
          (E = i.value) == null || E.setOptions(M), g !== void 0 && g !== b && ((v = i.value) == null || v.setZoom(g));
          const O = !y || m.lng !== y.lng || m.lat !== y.lat;
          m && O && ((_ = i.value) == null || _.panTo(m));
        }
      );
    };
    return Tr(() => {
      t.apiPromise && t.apiPromise instanceof Promise ? t.apiPromise.then(d) : (c(), Pw.load().then(d));
    }), mi(() => {
      var l;
      a.value = !1, i.value && ((l = s.value) == null || l.event.clearInstanceListeners(i.value));
    }), { mapRef: n, ready: r, map: i, api: s, mapTilesLoaded: a };
  }
}), kke = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
}, Dke = {
  ref: "mapRef",
  class: "mapdiv"
};
function Mke(t, e, n, r, i, s) {
  return X(), se("div", null, [
    W("div", Dke, null, 512),
    Jr(t.$slots, "default", Yy(YS({ ready: t.ready, map: t.map, api: t.api, mapTilesLoaded: t.mapTilesLoaded })), void 0, !0)
  ]);
}
const XM = /* @__PURE__ */ kke(Ike, [["render", Mke], ["__scopeId", "data-v-e7ebb206"]]);
function Oke(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Nke = function t(e, n) {
  if (e === n)
    return !0;
  if (e && n && typeof e == "object" && typeof n == "object") {
    if (e.constructor !== n.constructor)
      return !1;
    var r, i, s;
    if (Array.isArray(e)) {
      if (r = e.length, r != n.length)
        return !1;
      for (i = r; i-- !== 0; )
        if (!t(e[i], n[i]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === n.source && e.flags === n.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === n.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === n.toString();
    if (s = Object.keys(e), r = s.length, r !== Object.keys(n).length)
      return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, s[i]))
        return !1;
    for (i = r; i-- !== 0; ) {
      var a = s[i];
      if (!t(e[a], n[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && n !== n;
};
const Va = /* @__PURE__ */ Oke(Nke), Bw = ["click", "drag", "dragend", "dragstart", "gmp-click"];
Ze({
  name: "AdvancedMarker",
  props: {
    options: {
      type: Object,
      required: !0
    },
    pinOptions: {
      type: Object,
      required: !1
    }
  },
  emits: Bw,
  setup(t, { emit: e, expose: n, slots: r }) {
    const i = Se(), s = de(() => {
      var p;
      return (p = r.default) == null ? void 0 : p.call(r).some((m) => m.type !== U0);
    }), a = Ii(t, "options"), o = Ii(t, "pinOptions"), u = Se(), c = pn(Zu, Se()), d = pn(Ju, Se()), l = pn(WT, Se()), f = de(
      () => !!(l.value && d.value && u.value instanceof google.maps.marker.AdvancedMarkerElement)
    );
    return Ct(
      [c, a, o],
      async (p, [m, g, y]) => {
        var b, E, v;
        const _ = !Va(a.value, g) || !Va(o.value, y) || c.value !== m;
        if (!c.value || !d.value || !_)
          return;
        const { AdvancedMarkerElement: D, PinElement: S } = d.value.marker;
        if (u.value) {
          const { map: M, content: O, ...T } = a.value;
          Object.assign(u.value, {
            content: s.value ? i.value : o.value ? new S(o.value).element : O,
            ...T
          }), f.value && ((b = l.value) == null || b.removeMarker(u.value), (E = l.value) == null || E.addMarker(u.value));
        } else
          s.value ? a.value.content = i.value : o.value && (a.value.content = new S(o.value).element), u.value = Vi(new D(a.value)), f.value ? (v = l.value) == null || v.addMarker(u.value) : u.value.map = c.value, Bw.forEach((M) => {
            var O;
            (O = u.value) == null || O.addListener(M, (T) => e(M, T));
          });
      },
      {
        immediate: !0
      }
    ), mi(() => {
      var p, m;
      u.value && ((p = d.value) == null || p.event.clearInstanceListeners(u.value), f.value ? (m = l.value) == null || m.removeMarker(u.value) : u.value.map = null);
    }), Ba(VT, u), n({ marker: u }), { hasSlotContent: s, markerRef: i };
  }
});
const Lke = (t) => t === "Marker", Pke = (t) => t === jg, Qc = (t, e, n, r) => {
  const i = Se(), s = pn(Zu, Se()), a = pn(Ju, Se()), o = pn(WT, Se()), u = de(
    () => !!(o.value && a.value && (i.value instanceof a.value.Marker || i.value instanceof a.value[jg]))
  );
  return Ct(
    [s, n],
    (c, [d, l]) => {
      var f, p, m;
      const g = !Va(n.value, l) || s.value !== d;
      !s.value || !a.value || !g || (i.value ? (i.value.setOptions(n.value), u.value && ((f = o.value) == null || f.removeMarker(i.value), (p = o.value) == null || p.addMarker(i.value))) : (Lke(t) ? i.value = Vi(
        new a.value[t](n.value)
      ) : Pke(t) ? i.value = Vi(
        new a.value[t](n.value)
      ) : i.value = Vi(
        new a.value[t]({
          ...n.value,
          map: s.value
        })
      ), u.value ? (m = o.value) == null || m.addMarker(i.value) : i.value.setMap(s.value), e.forEach((y) => {
        var b;
        (b = i.value) == null || b.addListener(y, (E) => r(y, E));
      })));
    },
    {
      immediate: !0
    }
  ), mi(() => {
    var c, d;
    i.value && ((c = a.value) == null || c.event.clearInstanceListeners(i.value), u.value ? (d = o.value) == null || d.removeMarker(i.value) : i.value.setMap(null));
  }), i;
}, Fw = [
  "animation_changed",
  "click",
  "dblclick",
  "rightclick",
  "dragstart",
  "dragend",
  "drag",
  "mouseover",
  "mousedown",
  "mouseout",
  "mouseup",
  "draggable_changed",
  "clickable_changed",
  "contextmenu",
  "cursor_changed",
  "flat_changed",
  "rightclick",
  "zindex_changed",
  "icon_changed",
  "position_changed",
  "shape_changed",
  "title_changed",
  "visible_changed"
], KM = Ze({
  name: "Marker",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: Fw,
  setup(t, { emit: e, expose: n, slots: r }) {
    const i = Ii(t, "options"), s = Qc("Marker", Fw, i, e);
    return Ba(VT, s), n({ marker: s }), () => {
      var a;
      return (a = r.default) == null ? void 0 : a.call(r);
    };
  }
});
Ze({
  name: "Polyline",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: Ac,
  setup(t, { emit: e }) {
    const n = Ii(t, "options");
    return { polyline: Qc("Polyline", Ac, n, e) };
  },
  render: () => null
});
Ze({
  name: "Polygon",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: Ac,
  setup(t, { emit: e }) {
    const n = Ii(t, "options");
    return { polygon: Qc("Polygon", Ac, n, e) };
  },
  render: () => null
});
const Uw = Ac.concat(["bounds_changed"]);
Ze({
  name: "Rectangle",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: Uw,
  setup(t, { emit: e }) {
    const n = Ii(t, "options");
    return { rectangle: Qc("Rectangle", Uw, n, e) };
  },
  render: () => null
});
const $w = Ac.concat(["center_changed", "radius_changed"]);
Ze({
  name: "Circle",
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  emits: $w,
  setup(t, { emit: e }) {
    const n = Ii(t, "options");
    return { circle: Qc("Circle", $w, n, e) };
  },
  render: () => null
});
Ze({
  props: {
    position: {
      type: String,
      required: !0
    },
    index: {
      type: Number,
      default: 1
    }
  },
  emits: ["content:loaded"],
  setup(t, { emit: e }) {
    const n = Se(null), r = pn(Zu, Se()), i = pn(Ju, Se()), s = pn(YM, Se(!1)), a = Ct(
      [s, i, n],
      ([c, d, l]) => {
        d && c && l && (o(t.position), e("content:loaded"), setTimeout(a, 0));
      },
      { immediate: !0 }
    ), o = (c) => {
      if (r.value && i.value && n.value) {
        const d = i.value.ControlPosition[c];
        r.value.controls[d].push(n.value);
      }
    }, u = (c) => {
      if (r.value && i.value) {
        let d = null;
        const l = i.value.ControlPosition[c];
        r.value.controls[l].forEach((f, p) => {
          f === n.value && (d = p);
        }), d !== null && r.value.controls[l].removeAt(d);
      }
    };
    return mi(() => u(t.position)), Ct(
      () => t.position,
      (c, d) => {
        u(d), o(c);
      }
    ), Ct(
      () => t.index,
      (c) => {
        c && n.value && (n.value.index = t.index);
      }
    ), { controlRef: n };
  }
});
const Hw = ["closeclick", "content_changed", "domready", "position_changed", "visible", "zindex_changed"];
Ze({
  inheritAttrs: !1,
  props: {
    options: {
      type: Object,
      default: () => ({})
    },
    modelValue: {
      type: Boolean
    }
  },
  emits: [...Hw, "update:modelValue"],
  setup(t, { slots: e, emit: n, expose: r }) {
    const i = Se(), s = Se(), a = pn(Zu, Se()), o = pn(Ju, Se()), u = pn(VT, Se());
    let c, d = t.modelValue;
    const l = de(() => {
      var g;
      return (g = e.default) == null ? void 0 : g.call(e).some((y) => y.type !== U0);
    }), f = (g) => {
      d = g, n("update:modelValue", g);
    }, p = (g) => {
      i.value && (i.value.open({ map: a.value, anchor: u.value, ...g }), f(!0));
    }, m = () => {
      i.value && (i.value.close(), f(!1));
    };
    return Tr(() => {
      Ct(
        [a, () => t.options],
        ([g, y], [b, E]) => {
          var v;
          const _ = !Va(y, E) || a.value !== b;
          a.value && o.value && _ && (i.value ? (i.value.setOptions({
            ...y,
            content: l.value ? s.value : y.content
          }), u.value || p()) : (i.value = Vi(
            new o.value.InfoWindow({
              ...y,
              content: l.value ? s.value : y.content
            })
          ), u.value && (c = u.value.addListener("click", () => {
            p();
          })), (!u.value || d) && p(), Hw.forEach((D) => {
            var S;
            (S = i.value) == null || S.addListener(D, (M) => n(D, M));
          }), (v = i.value) == null || v.addListener("closeclick", () => f(!1))));
        },
        {
          immediate: !0
        }
      ), Ct(
        () => t.modelValue,
        (g) => {
          g !== d && (g ? p() : m());
        }
      );
    }), mi(() => {
      var g;
      c && c.remove(), i.value && ((g = o.value) == null || g.event.clearInstanceListeners(i.value), m());
    }), r({ infoWindow: i, open: p, close: m }), { infoWindow: i, infoWindowRef: s, hasSlotContent: l, open: p, close: m };
  }
});
const jw = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], f2 = 1, Rd = 8;
class QT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(e) {
    if (!(e instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(e, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const i = r >> 4;
    if (i !== f2)
      throw new Error(`Got v${i} data when expected v${f2}.`);
    const s = jw[r & 15];
    if (!s)
      throw new Error("Unrecognized array type.");
    const [a] = new Uint16Array(e, 2, 1), [o] = new Uint32Array(e, 4, 1);
    return new QT(o, a, s, e);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(e, n = 64, r = Float64Array, i) {
    if (isNaN(e) || e < 0)
      throw new Error(`Unpexpected numItems value: ${e}.`);
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    const s = jw.indexOf(this.ArrayType), a = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, o = e * this.IndexArrayType.BYTES_PER_ELEMENT, u = (8 - o % 8) % 8;
    if (s < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    i && i instanceof ArrayBuffer ? (this.data = i, this.ids = new this.IndexArrayType(this.data, Rd, e), this.coords = new this.ArrayType(this.data, Rd + o + u, e * 2), this._pos = e * 2, this._finished = !0) : (this.data = new ArrayBuffer(Rd + a + o + u), this.ids = new this.IndexArrayType(this.data, Rd, e), this.coords = new this.ArrayType(this.data, Rd + o + u, e * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (f2 << 4) + s]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(e, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = e, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const e = this._pos >> 1;
    if (e !== this.numItems)
      throw new Error(`Added ${e} items when expected ${this.numItems}.`);
    return gy(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(e, n, r, i) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids: s, coords: a, nodeSize: o } = this, u = [0, s.length - 1, 0], c = [];
    for (; u.length; ) {
      const d = u.pop() || 0, l = u.pop() || 0, f = u.pop() || 0;
      if (l - f <= o) {
        for (let y = f; y <= l; y++) {
          const b = a[2 * y], E = a[2 * y + 1];
          b >= e && b <= r && E >= n && E <= i && c.push(s[y]);
        }
        continue;
      }
      const p = f + l >> 1, m = a[2 * p], g = a[2 * p + 1];
      m >= e && m <= r && g >= n && g <= i && c.push(s[p]), (d === 0 ? e <= m : n <= g) && (u.push(f), u.push(p - 1), u.push(1 - d)), (d === 0 ? r >= m : i >= g) && (u.push(p + 1), u.push(l), u.push(1 - d));
    }
    return c;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(e, n, r) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, o = [0, i.length - 1, 0], u = [], c = r * r;
    for (; o.length; ) {
      const d = o.pop() || 0, l = o.pop() || 0, f = o.pop() || 0;
      if (l - f <= a) {
        for (let y = f; y <= l; y++)
          zw(s[2 * y], s[2 * y + 1], e, n) <= c && u.push(i[y]);
        continue;
      }
      const p = f + l >> 1, m = s[2 * p], g = s[2 * p + 1];
      zw(m, g, e, n) <= c && u.push(i[p]), (d === 0 ? e - r <= m : n - r <= g) && (o.push(f), o.push(p - 1), o.push(1 - d)), (d === 0 ? e + r >= m : n + r >= g) && (o.push(p + 1), o.push(l), o.push(1 - d));
    }
    return u;
  }
}
function gy(t, e, n, r, i, s) {
  if (i - r <= n)
    return;
  const a = r + i >> 1;
  ZM(t, e, a, r, i, s), gy(t, e, n, r, a - 1, 1 - s), gy(t, e, n, a + 1, i, 1 - s);
}
function ZM(t, e, n, r, i, s) {
  for (; i > r; ) {
    if (i - r > 600) {
      const c = i - r + 1, d = n - r + 1, l = Math.log(c), f = 0.5 * Math.exp(2 * l / 3), p = 0.5 * Math.sqrt(l * f * (c - f) / c) * (d - c / 2 < 0 ? -1 : 1), m = Math.max(r, Math.floor(n - d * f / c + p)), g = Math.min(i, Math.floor(n + (c - d) * f / c + p));
      ZM(t, e, n, m, g, s);
    }
    const a = e[2 * n + s];
    let o = r, u = i;
    for (Bd(t, e, r, n), e[2 * i + s] > a && Bd(t, e, r, i); o < u; ) {
      for (Bd(t, e, o, u), o++, u--; e[2 * o + s] < a; )
        o++;
      for (; e[2 * u + s] > a; )
        u--;
    }
    e[2 * r + s] === a ? Bd(t, e, r, u) : (u++, Bd(t, e, u, i)), u <= n && (r = u + 1), n <= u && (i = u - 1);
  }
}
function Bd(t, e, n, r) {
  h2(t, n, r), h2(e, 2 * n, 2 * r), h2(e, 2 * n + 1, 2 * r + 1);
}
function h2(t, e, n) {
  const r = t[e];
  t[e] = t[n], t[n] = r;
}
function zw(t, e, n, r) {
  const i = t - n, s = e - r;
  return i * i + s * s;
}
const Rke = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (t) => t
  // props => ({sum: props.my_value})
}, qw = Math.fround || /* @__PURE__ */ ((t) => (e) => (t[0] = +e, t[0]))(new Float32Array(1)), eu = 2, Ao = 3, p2 = 4, co = 5, JM = 6;
let eO = class {
  constructor(e) {
    this.options = Object.assign(Object.create(Rke), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(e) {
    const { log: n, minZoom: r, maxZoom: i } = this.options;
    n && console.time("total time");
    const s = `prepare ${e.length} points`;
    n && console.time(s), this.points = e;
    const a = [];
    for (let u = 0; u < e.length; u++) {
      const c = e[u];
      if (!c.geometry)
        continue;
      const [d, l] = c.geometry.coordinates, f = qw(Rp(d)), p = qw(Bp(l));
      a.push(
        f,
        p,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        u,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && a.push(0);
    }
    let o = this.trees[i + 1] = this._createTree(a);
    n && console.timeEnd(s);
    for (let u = i; u >= r; u--) {
      const c = +Date.now();
      o = this.trees[u] = this._createTree(this._cluster(o, u)), n && console.log("z%d: %d clusters in %dms", u, o.numItems, +Date.now() - c);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(e, n) {
    let r = ((e[0] + 180) % 360 + 360) % 360 - 180;
    const i = Math.max(-90, Math.min(90, e[1]));
    let s = e[2] === 180 ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
    const a = Math.max(-90, Math.min(90, e[3]));
    if (e[2] - e[0] >= 360)
      r = -180, s = 180;
    else if (r > s) {
      const l = this.getClusters([r, i, 180, a], n), f = this.getClusters([-180, i, s, a], n);
      return l.concat(f);
    }
    const o = this.trees[this._limitZoom(n)], u = o.range(Rp(r), Bp(a), Rp(s), Bp(i)), c = o.data, d = [];
    for (const l of u) {
      const f = this.stride * l;
      d.push(c[f + co] > 1 ? Vw(c, f, this.clusterProps) : this.points[c[f + Ao]]);
    }
    return d;
  }
  getChildren(e) {
    const n = this._getOriginId(e), r = this._getOriginZoom(e), i = "No cluster with the specified id.", s = this.trees[r];
    if (!s)
      throw new Error(i);
    const a = s.data;
    if (n * this.stride >= a.length)
      throw new Error(i);
    const o = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), u = a[n * this.stride], c = a[n * this.stride + 1], d = s.within(u, c, o), l = [];
    for (const f of d) {
      const p = f * this.stride;
      a[p + p2] === e && l.push(a[p + co] > 1 ? Vw(a, p, this.clusterProps) : this.points[a[p + Ao]]);
    }
    if (l.length === 0)
      throw new Error(i);
    return l;
  }
  getLeaves(e, n, r) {
    n = n || 10, r = r || 0;
    const i = [];
    return this._appendLeaves(i, e, n, r, 0), i;
  }
  getTile(e, n, r) {
    const i = this.trees[this._limitZoom(e)], s = Math.pow(2, e), { extent: a, radius: o } = this.options, u = o / a, c = (r - u) / s, d = (r + 1 + u) / s, l = {
      features: []
    };
    return this._addTileFeatures(
      i.range((n - u) / s, c, (n + 1 + u) / s, d),
      i.data,
      n,
      r,
      s,
      l
    ), n === 0 && this._addTileFeatures(
      i.range(1 - u / s, c, 1, d),
      i.data,
      s,
      r,
      s,
      l
    ), n === s - 1 && this._addTileFeatures(
      i.range(0, c, u / s, d),
      i.data,
      -1,
      r,
      s,
      l
    ), l.features.length ? l : null;
  }
  getClusterExpansionZoom(e) {
    let n = this._getOriginZoom(e) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(e);
      if (n++, r.length !== 1)
        break;
      e = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(e, n, r, i, s) {
    const a = this.getChildren(n);
    for (const o of a) {
      const u = o.properties;
      if (u && u.cluster ? s + u.point_count <= i ? s += u.point_count : s = this._appendLeaves(e, u.cluster_id, r, i, s) : s < i ? s++ : e.push(o), e.length === r)
        break;
    }
    return s;
  }
  _createTree(e) {
    const n = new QT(e.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < e.length; r += this.stride)
      n.add(e[r], e[r + 1]);
    return n.finish(), n.data = e, n;
  }
  _addTileFeatures(e, n, r, i, s, a) {
    for (const o of e) {
      const u = o * this.stride, c = n[u + co] > 1;
      let d, l, f;
      if (c)
        d = tO(n, u, this.clusterProps), l = n[u], f = n[u + 1];
      else {
        const g = this.points[n[u + Ao]];
        d = g.properties;
        const [y, b] = g.geometry.coordinates;
        l = Rp(y), f = Bp(b);
      }
      const p = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (l * s - r)),
          Math.round(this.options.extent * (f * s - i))
        ]],
        tags: d
      };
      let m;
      c || this.options.generateId ? m = n[u + Ao] : m = this.points[n[u + Ao]].id, m !== void 0 && (p.id = m), a.features.push(p);
    }
  }
  _limitZoom(e) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
  }
  _cluster(e, n) {
    const { radius: r, extent: i, reduce: s, minPoints: a } = this.options, o = r / (i * Math.pow(2, n)), u = e.data, c = [], d = this.stride;
    for (let l = 0; l < u.length; l += d) {
      if (u[l + eu] <= n)
        continue;
      u[l + eu] = n;
      const f = u[l], p = u[l + 1], m = e.within(u[l], u[l + 1], o), g = u[l + co];
      let y = g;
      for (const b of m) {
        const E = b * d;
        u[E + eu] > n && (y += u[E + co]);
      }
      if (y > g && y >= a) {
        let b = f * g, E = p * g, v, _ = -1;
        const D = ((l / d | 0) << 5) + (n + 1) + this.points.length;
        for (const S of m) {
          const M = S * d;
          if (u[M + eu] <= n)
            continue;
          u[M + eu] = n;
          const O = u[M + co];
          b += u[M] * O, E += u[M + 1] * O, u[M + p2] = D, s && (v || (v = this._map(u, l, !0), _ = this.clusterProps.length, this.clusterProps.push(v)), s(v, this._map(u, M)));
        }
        u[l + p2] = D, c.push(b / y, E / y, 1 / 0, D, -1, y), s && c.push(_);
      } else {
        for (let b = 0; b < d; b++)
          c.push(u[l + b]);
        if (y > 1)
          for (const b of m) {
            const E = b * d;
            if (!(u[E + eu] <= n)) {
              u[E + eu] = n;
              for (let v = 0; v < d; v++)
                c.push(u[E + v]);
            }
          }
      }
    }
    return c;
  }
  // get index of the point from which the cluster originated
  _getOriginId(e) {
    return e - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(e) {
    return (e - this.points.length) % 32;
  }
  _map(e, n, r) {
    if (e[n + co] > 1) {
      const a = this.clusterProps[e[n + JM]];
      return r ? Object.assign({}, a) : a;
    }
    const i = this.points[e[n + Ao]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
};
function Vw(t, e, n) {
  return {
    type: "Feature",
    id: t[e + Ao],
    properties: tO(t, e, n),
    geometry: {
      type: "Point",
      coordinates: [Bke(t[e]), Fke(t[e + 1])]
    }
  };
}
function tO(t, e, n) {
  const r = t[e + co], i = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, s = t[e + JM], a = s === -1 ? {} : Object.assign({}, n[s]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: t[e + Ao],
    point_count: r,
    point_count_abbreviated: i
  });
}
function Rp(t) {
  return t / 360 + 0.5;
}
function Bp(t) {
  const e = Math.sin(t * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + e) / (1 - e)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Bke(t) {
  return (t - 0.5) * 360;
}
function Fke(t) {
  const e = (180 - t * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(e)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function GT(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
class Qr {
  static isAdvancedMarkerAvailable(e) {
    return google.maps.marker && e.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(e) {
    return google.maps.marker && e instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(e, n) {
    this.isAdvancedMarker(e) ? e.map = n : e.setMap(n);
  }
  static getPosition(e) {
    if (this.isAdvancedMarker(e)) {
      if (e.position) {
        if (e.position instanceof google.maps.LatLng)
          return e.position;
        if (e.position.lat && e.position.lng)
          return new google.maps.LatLng(e.position.lat, e.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return e.getPosition();
  }
  static getVisible(e) {
    return this.isAdvancedMarker(e) ? !0 : e.getVisible();
  }
}
class Zf {
  constructor({ markers: e, position: n }) {
    this.markers = e, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const e = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      e.extend(Qr.getPosition(n));
    return e;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((e) => Qr.getVisible(e)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(e) {
    this.markers.push(e);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Qr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
const Uke = (t, e, n, r) => {
  const i = nO(t.getBounds(), e, r);
  return n.filter((s) => i.contains(Qr.getPosition(s)));
}, nO = (t, e, n) => {
  const { northEast: r, southWest: i } = $ke(t, e), s = Hke({ northEast: r, southWest: i }, n);
  return jke(s, e);
}, Ww = (t, e, n) => {
  const r = nO(t, e, n), i = r.getNorthEast(), s = r.getSouthWest();
  return [s.lng(), s.lat(), i.lng(), i.lat()];
}, $ke = (t, e) => ({
  northEast: e.fromLatLngToDivPixel(t.getNorthEast()),
  southWest: e.fromLatLngToDivPixel(t.getSouthWest())
}), Hke = ({ northEast: t, southWest: e }, n) => (t.x += n, t.y -= n, e.x -= n, e.y += n, { northEast: t, southWest: e }), jke = ({ northEast: t, southWest: e }, n) => {
  const r = n.fromDivPixelToLatLng(e), i = n.fromDivPixelToLatLng(t);
  return new google.maps.LatLngBounds(r, i);
};
let rO = class {
  constructor({ maxZoom: e = 16 }) {
    this.maxZoom = e;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: e }) {
    return qke(e);
  }
}, zke = class extends rO {
  constructor(e) {
    var { viewportPadding: n = 60 } = e, r = GT(e, ["viewportPadding"]);
    super(r), this.viewportPadding = 60, this.viewportPadding = n;
  }
  calculate({ markers: e, map: n, mapCanvasProjection: r }) {
    return n.getZoom() >= this.maxZoom ? {
      clusters: this.noop({
        markers: e
      }),
      changed: !1
    } : {
      clusters: this.cluster({
        markers: Uke(n, r, e, this.viewportPadding),
        map: n,
        mapCanvasProjection: r
      })
    };
  }
};
const qke = (t) => t.map((e) => new Zf({
  position: Qr.getPosition(e),
  markers: [e]
}));
let Vke = class extends rO {
  constructor(e) {
    var { maxZoom: n, radius: r = 60 } = e, i = GT(e, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new eO(Object.assign({ maxZoom: this.maxZoom, radius: r }, i));
  }
  calculate(e) {
    let n = !1;
    const r = { zoom: e.map.getZoom() };
    if (!Va(e.markers, this.markers)) {
      n = !0, this.markers = [...e.markers];
      const i = this.markers.map((s) => {
        const a = Qr.getPosition(s);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [a.lng(), a.lat()]
          },
          properties: { marker: s }
        };
      });
      this.superCluster.load(i);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Va(this.state, r)), this.state = r, n && (this.clusters = this.cluster(e)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: e }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(e.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [e, n] }, properties: r }) {
    if (r.cluster)
      return new Zf({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: { lat: n, lng: e }
      });
    const i = r.marker;
    return new Zf({
      markers: [i],
      position: Qr.getPosition(i)
    });
  }
};
class Wke extends zke {
  constructor(e) {
    var { maxZoom: n, radius: r = 60, viewportPadding: i = 60 } = e, s = GT(e, ["maxZoom", "radius", "viewportPadding"]);
    super({ maxZoom: n, viewportPadding: i }), this.superCluster = new eO(Object.assign({ maxZoom: this.maxZoom, radius: r }, s)), this.state = { zoom: -1, view: [0, 0, 0, 0] };
  }
  calculate(e) {
    const n = {
      zoom: Math.round(e.map.getZoom()),
      view: Ww(e.map.getBounds(), e.mapCanvasProjection, this.viewportPadding)
    };
    let r = !Va(this.state, n);
    if (!Va(e.markers, this.markers)) {
      r = !0, this.markers = [...e.markers];
      const i = this.markers.map((s) => {
        const a = Qr.getPosition(s);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [a.lng(), a.lat()]
          },
          properties: { marker: s }
        };
      });
      this.superCluster.load(i);
    }
    return r && (this.clusters = this.cluster(e), this.state = n), { clusters: this.clusters, changed: r };
  }
  cluster({ map: e, mapCanvasProjection: n }) {
    const r = {
      zoom: Math.round(e.getZoom()),
      view: Ww(e.getBounds(), n, this.viewportPadding)
    };
    return this.superCluster.getClusters(r.view, r.zoom).map((i) => this.transformCluster(i));
  }
  transformCluster({ geometry: { coordinates: [e, n] }, properties: r }) {
    if (r.cluster)
      return new Zf({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: { lat: n, lng: e }
      });
    const i = r.marker;
    return new Zf({
      markers: [i],
      position: Qr.getPosition(i)
    });
  }
}
let Qke = class {
  constructor(e, n) {
    this.markers = { sum: e.length };
    const r = n.map((s) => s.count), i = r.reduce((s, a) => s + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: i / n.length,
        sum: i,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}, Gke = class {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: e, position: n }, r, i) {
    const s = `<svg fill="${e > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${e}</text>
</svg>`, a = `Cluster of ${e} markers`, o = Number(google.maps.Marker.MAX_ZINDEX) + e;
    if (Qr.isAdvancedMarkerAvailable(i)) {
      const c = document.createElement("div");
      c.innerHTML = s;
      const d = c.firstElementChild;
      d.setAttribute("transform", "translate(0 25)");
      const l = {
        map: i,
        position: n,
        zIndex: o,
        title: a,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(l);
    }
    const u = {
      position: n,
      zIndex: o,
      title: a,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(s)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(u);
  }
};
function Yke(t, e) {
  for (let n in e.prototype)
    t.prototype[n] = e.prototype[n];
}
let Xke = class iO {
  constructor() {
    Yke(iO, google.maps.OverlayView);
  }
};
var ec;
(function(t) {
  t.CLUSTERING_BEGIN = "clusteringbegin", t.CLUSTERING_END = "clusteringend", t.CLUSTER_CLICK = "click";
})(ec || (ec = {}));
const Kke = (t, e, n) => {
  n.fitBounds(e.bounds);
};
class Zke extends Xke {
  constructor({ map: e, markers: n = [], algorithmOptions: r = {}, algorithm: i = new Vke(r), renderer: s = new Gke(), onClusterClick: a = Kke }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, e && this.setMap(e);
  }
  addMarker(e, n) {
    this.markers.includes(e) || (this.markers.push(e), n || this.render());
  }
  addMarkers(e, n) {
    e.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(e, n) {
    const r = this.markers.indexOf(e);
    return r === -1 ? !1 : (Qr.setMap(e, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(e, n) {
    let r = !1;
    return e.forEach((i) => {
      r = this.removeMarker(i, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(e) {
    this.markers.length = 0, e || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const e = this.getMap();
    if (e instanceof google.maps.Map && e.getProjection()) {
      google.maps.event.trigger(this, ec.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: e,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const i = /* @__PURE__ */ new Set();
        for (const a of n)
          a.markers.length == 1 && i.add(a.markers[0]);
        const s = [];
        for (const a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? i.has(a.marker) || Qr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((a) => Qr.setMap(a, null)));
      }
      google.maps.event.trigger(this, ec.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((e) => Qr.setMap(e, null)), this.clusters.forEach((e) => e.delete()), this.clusters = [];
  }
  renderClusters() {
    const e = new Qke(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, e, n), r.markers.forEach((i) => Qr.setMap(i, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (i) => {
          google.maps.event.trigger(this, ec.CLUSTER_CLICK, r), this.onClusterClick(i, r, n);
        }
      )), Qr.setMap(r.marker, n);
    });
  }
}
const Qw = Object.values(ec);
Ze({
  name: "MarkerCluster",
  props: {
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: Qw,
  setup(t, { emit: e, expose: n, slots: r }) {
    const i = Se(), s = pn(Zu, Se()), a = pn(Ju, Se());
    return Ba(WT, i), Ct(
      s,
      () => {
        s.value && (i.value = Vi(
          new Zke({
            map: s.value,
            // Better perf than the default `SuperClusterAlgorithm`. See:
            // https://github.com/googlemaps/js-markerclusterer/pull/640
            algorithm: new Wke(t.options.algorithmOptions ?? {}),
            ...t.options
          })
        ), Qw.forEach((o) => {
          var u;
          (u = i.value) == null || u.addListener(o, (c) => e(o, c));
        }));
      },
      {
        immediate: !0
      }
    ), mi(() => {
      var o;
      i.value && ((o = a.value) == null || o.event.clearInstanceListeners(i.value), i.value.clearMarkers(), i.value.setMap(null));
    }), n({ markerCluster: i }), () => {
      var o;
      return (o = r.default) == null ? void 0 : o.call(r);
    };
  }
});
Ze({
  inheritAttrs: !1,
  props: {
    options: {
      type: Object,
      required: !0
    }
  },
  setup(t, { slots: e, emit: n, expose: r }) {
    const i = Se(), s = de(() => {
      var u;
      return (u = e.default) == null ? void 0 : u.call(e).some((c) => c.type !== U0);
    }), a = de(() => ({
      ...t.options,
      element: i.value
    })), o = Qc(jg, [], a, n);
    return r({
      customMarker: o
    }), { customMarkerRef: i, customMarker: o, hasSlotContent: s };
  }
});
Ze({
  name: "HeatmapLayer",
  props: {
    options: {
      type: Object,
      default: () => ({})
    }
  },
  setup(t) {
    const e = Se(), n = pn(Zu, Se()), r = pn(Ju, Se());
    return Ct(
      [n, () => t.options],
      ([i, s], [a, o]) => {
        var u;
        const c = !Va(s, o) || n.value !== a;
        if (n.value && r.value && c) {
          const d = structuredClone(s);
          if (d.data && !(d.data instanceof r.value.MVCArray)) {
            const l = r.value.LatLng;
            d.data = (u = d.data) == null ? void 0 : u.map((f) => f instanceof l || "location" in f && (f.location instanceof l || f.location === null) ? f : "location" in f ? { ...f, location: new l(f.location) } : new l(f));
          }
          e.value ? e.value.setOptions(d) : e.value = Vi(
            new r.value.visualization.HeatmapLayer({
              ...d,
              map: n.value
            })
          );
        }
      },
      { immediate: !0 }
    ), mi(() => {
      e.value && e.value.setMap(null);
    }), { heatmapLayer: e };
  },
  render: () => null
});
const Jke = { class: "w-[250px] p-2 underline sm:w-[300px]" }, e5e = /* @__PURE__ */ Ze({
  __name: "LocationMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, r = Yt().state.imkit.config.mapApiKey, i = de(() => ({
      lat: e.message.latitude,
      lng: e.message.longitude
    })), s = () => {
      window.open(
        `https://www.google.com/maps/search/?api=1&query=${e.message.address}`,
        "_blank"
      );
    };
    return (a, o) => (X(), se("div", {
      class: "relative -mx-3 -my-2 flex cursor-pointer flex-col",
      onClick: s
    }, [
      et(ke(XM), {
        "api-key": ke(r),
        center: i.value,
        zoom: 15,
        "disable-default-ui": !0,
        class: "h-[150px] w-[250px] sm:h-[200px] sm:w-[300px]"
      }, {
        default: Zt(() => [
          et(ke(KM), {
            options: { position: i.value }
          }, null, 8, ["options"])
        ]),
        _: 1
      }, 8, ["api-key", "center"]),
      W("div", Jke, _e(a.message.address), 1),
      o[0] || (o[0] = W("div", { class: "absolute inset-0" }, null, -1))
    ]));
  }
}), t5e = /* @__PURE__ */ mn(e5e, [["__scopeId", "data-v-69917d13"]]), n5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAACS0lEQVR4nO2bPYsUQRCGG1E0MRAFTQSNTjRSQxE0M9NfoGCwOv3O3k7XKpxR9e7hdyRGlxoan2B+4AcamBmYGKhgZqAmoitzB87eMh93595uz877QCcbLQ9dNV3V1cYQQgghhBBCpswV1T3Anf3T/h/BYZP+Cev0uXX+N8QPIPoFzt9qtx/tNk0HiZ6C+B9rYtYv6/z7OOmdMU0GTt/myRmSlO6qx1dv3t9rmkbcXTxaJmfdcvrROr1gmkSc9M5uWFAm6kljEjm6em7TglYl+a+R08tm1sFWBWW7aTmSxcNmVsH/ClqT9A3iO6q6w8waGIegLOxWrnf6c2aWwDgFpUcC0Z9w6lutpV1mFsCYBQ2Jehd1+6dN3cE2CVqV5PwvK3ovre9MXcE2ChpaHyLXO2/qCCYjKC1+/1jnl2pXrmBigv6F3Web9C6auoAJCxpK4k9bogdM6GBKgmpTrmCagrL1LNhyBWEICrdcQSiCsrBbiUWPmVBAaIJCK1cQoKBMlH9pb+ghCpJSSa9VdSd3kBRLikUvUZCU7CLnH1KQlOUjfUBBwhAbbO1cpK+YpKXwPPRifv72QX7mhQfFwcZDiqXGoCDXsFhF8c5huwP54cSGGYq/UGy5Ir9sYNMe+eUCr31QnIR5cYj8cOLVM4qTMIcXEHo/eRyAA1TlcASvAg5xVsAx4Ao4SF7BtY4e2UT7s3lPEVKs+DcV1y7NfcyS0pb+Sev0e4EcPodKaXf1+MiDuk9WdIEP6kZIhUQLd/eN/k4IIYQQQggxDeMvr6MHGaopSLgAAAAASUVORK5CYII=", r5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB4klEQVR4nO2bzy5DQRTGJ8GaDQ+ANZ4FXbDxZ9HoGTc1p01scA5SGmshfQLBAu+gkYgXYqEyjUhEae/0Ti/y/ZJZ3vnO/e733d0xBgAAAAAAgFhsVGSCKrJoK1L8cpwsJ9XDqaw1ycm0v7uz5v5CktTGTd6IyLBlObEsL5a19f2RV8t6WS7LWL+a/g7r9PpnPW2R02fr9NjPaPKCnDa6DfrpOG32M3Cx2Bgh1od0mnJm8oDKMveejN6H9V+WZTVYk2U9rZ6fsVSVGTNorJO99MO2B74N1SSndyGaxLqb7dv3MizreZBBTh5DNf2zgQadm1///+EPg55CNf2zQQY5bZhBQzAIBiFBMSFUDAYhQTEhVAwGIUExIVQMBiFBMSFUDAYhQTEhVAwGIUExIVQMBiFBMSFUDAYhQTEhVAwGIUExIVQMBiFBMSFUDAYhQTEhVAwGIUExIVQMBiFBMSFUDAb1lyDGKkKUZRZyemMGvcziZMcMmk13MBuyDmW3dCVU0zpd+zPrUCE1I5b7fhbq2huOTpsp03Nq8kJEhoml3l5/7PIVifWiuF0fzWIlk1iueqjyM7EcFQpXQyZvkqQ2XqrIfKcFW2JdKm3JZNaa/k5/dydNP8uvWOoFAAAAAADm3/IGGLsxyp+ApQ8AAAAASUVORK5CYII=", i5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVR4nO3bTy5DYRSG8ZuosU5qAWWMtZQJE38GVkGHiHGj6QoEA+yBSJpuiIFXGtesvPee77sp+vwS057zPcXsFAUAAADQFEmrknYkHc/42ZO01sDM9fKzZ83cltTJPTOyZEvSpaQ3/exd0o2kdoaZbUl38l4lnU93zPPa2LIj1fOcsrCkZUkvNWde5X119WW3yt+Mug4SZh4F5k133Mj7+mrL9hXzkDDzMTjzNO/rqy07DC47Tpg5Ds4c5n19M/9/vkwSZk4UM8r7+mrLjoLLEsggkEEgg0AGgQwCGQQyCGQQyCCQQSCDQAaBDAIZBDIIZBDIIJBBIINABoEMAhkEMghkEMggkEEgg0AGgQwCGQQyCGQQyCCQQSCDQAaBDAIZBDIIZCxMoGFw2YU5RegHl72fwzHLSd7XV1t2M3gOtZ8w8/DPnEMF/8yeEg/qWuVRXh2DYl70ufBFef7ovsVrSSuZTjJvK4SZ7nQmaSnPa9OW7kjqfXNguyup28DMbvnZs2b2fsVRLwAAAIp/6wPxkEFCV8mUxgAAAABJRU5ErkJggg==";
var m2 = {};
/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */
var Gw;
function s5e() {
  return Gw || (Gw = 1, function(t) {
    (function() {
      var e = function() {
        this.init();
      };
      e.prototype = {
        /**
         * Initialize the global Howler object.
         * @return {Howler}
         */
        init: function() {
          var l = this || n;
          return l._counter = 1e3, l._html5AudioPool = [], l.html5PoolSize = 10, l._codecs = {}, l._howls = [], l._muted = !1, l._volume = 1, l._canPlayEvent = "canplaythrough", l._navigator = typeof window < "u" && window.navigator ? window.navigator : null, l.masterGain = null, l.noAudio = !1, l.usingWebAudio = !0, l.autoSuspend = !0, l.ctx = null, l.autoUnlock = !0, l._setup(), l;
        },
        /**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */
        volume: function(l) {
          var f = this || n;
          if (l = parseFloat(l), f.ctx || d(), typeof l < "u" && l >= 0 && l <= 1) {
            if (f._volume = l, f._muted)
              return f;
            f.usingWebAudio && f.masterGain.gain.setValueAtTime(l, n.ctx.currentTime);
            for (var p = 0; p < f._howls.length; p++)
              if (!f._howls[p]._webAudio)
                for (var m = f._howls[p]._getSoundIds(), g = 0; g < m.length; g++) {
                  var y = f._howls[p]._soundById(m[g]);
                  y && y._node && (y._node.volume = y._volume * l);
                }
            return f;
          }
          return f._volume;
        },
        /**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */
        mute: function(l) {
          var f = this || n;
          f.ctx || d(), f._muted = l, f.usingWebAudio && f.masterGain.gain.setValueAtTime(l ? 0 : f._volume, n.ctx.currentTime);
          for (var p = 0; p < f._howls.length; p++)
            if (!f._howls[p]._webAudio)
              for (var m = f._howls[p]._getSoundIds(), g = 0; g < m.length; g++) {
                var y = f._howls[p]._soundById(m[g]);
                y && y._node && (y._node.muted = l ? !0 : y._muted);
              }
          return f;
        },
        /**
         * Handle stopping all sounds globally.
         */
        stop: function() {
          for (var l = this || n, f = 0; f < l._howls.length; f++)
            l._howls[f].stop();
          return l;
        },
        /**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */
        unload: function() {
          for (var l = this || n, f = l._howls.length - 1; f >= 0; f--)
            l._howls[f].unload();
          return l.usingWebAudio && l.ctx && typeof l.ctx.close < "u" && (l.ctx.close(), l.ctx = null, d()), l;
        },
        /**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */
        codecs: function(l) {
          return (this || n)._codecs[l.replace(/^x-/, "")];
        },
        /**
         * Setup various state values for global tracking.
         * @return {Howler}
         */
        _setup: function() {
          var l = this || n;
          if (l.state = l.ctx && l.ctx.state || "suspended", l._autoSuspend(), !l.usingWebAudio)
            if (typeof Audio < "u")
              try {
                var f = new Audio();
                typeof f.oncanplaythrough > "u" && (l._canPlayEvent = "canplay");
              } catch {
                l.noAudio = !0;
              }
            else
              l.noAudio = !0;
          try {
            var f = new Audio();
            f.muted && (l.noAudio = !0);
          } catch {
          }
          return l.noAudio || l._setupCodecs(), l;
        },
        /**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */
        _setupCodecs: function() {
          var l = this || n, f = null;
          try {
            f = typeof Audio < "u" ? new Audio() : null;
          } catch {
            return l;
          }
          if (!f || typeof f.canPlayType != "function")
            return l;
          var p = f.canPlayType("audio/mpeg;").replace(/^no$/, ""), m = l._navigator ? l._navigator.userAgent : "", g = m.match(/OPR\/(\d+)/g), y = g && parseInt(g[0].split("/")[1], 10) < 33, b = m.indexOf("Safari") !== -1 && m.indexOf("Chrome") === -1, E = m.match(/Version\/(.*?) /), v = b && E && parseInt(E[1], 10) < 15;
          return l._codecs = {
            mp3: !!(!y && (p || f.canPlayType("audio/mp3;").replace(/^no$/, ""))),
            mpeg: !!p,
            opus: !!f.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
            ogg: !!f.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            oga: !!f.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            wav: !!(f.canPlayType('audio/wav; codecs="1"') || f.canPlayType("audio/wav")).replace(/^no$/, ""),
            aac: !!f.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!f.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(f.canPlayType("audio/x-m4a;") || f.canPlayType("audio/m4a;") || f.canPlayType("audio/aac;")).replace(/^no$/, ""),
            m4b: !!(f.canPlayType("audio/x-m4b;") || f.canPlayType("audio/m4b;") || f.canPlayType("audio/aac;")).replace(/^no$/, ""),
            mp4: !!(f.canPlayType("audio/x-mp4;") || f.canPlayType("audio/mp4;") || f.canPlayType("audio/aac;")).replace(/^no$/, ""),
            weba: !!(!v && f.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            webm: !!(!v && f.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            dolby: !!f.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
            flac: !!(f.canPlayType("audio/x-flac;") || f.canPlayType("audio/flac;")).replace(/^no$/, "")
          }, l;
        },
        /**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */
        _unlockAudio: function() {
          var l = this || n;
          if (!(l._audioUnlocked || !l.ctx)) {
            l._audioUnlocked = !1, l.autoUnlock = !1, !l._mobileUnloaded && l.ctx.sampleRate !== 44100 && (l._mobileUnloaded = !0, l.unload()), l._scratchBuffer = l.ctx.createBuffer(1, 1, 22050);
            var f = function(p) {
              for (; l._html5AudioPool.length < l.html5PoolSize; )
                try {
                  var m = new Audio();
                  m._unlocked = !0, l._releaseHtml5Audio(m);
                } catch {
                  l.noAudio = !0;
                  break;
                }
              for (var g = 0; g < l._howls.length; g++)
                if (!l._howls[g]._webAudio)
                  for (var y = l._howls[g]._getSoundIds(), b = 0; b < y.length; b++) {
                    var E = l._howls[g]._soundById(y[b]);
                    E && E._node && !E._node._unlocked && (E._node._unlocked = !0, E._node.load());
                  }
              l._autoResume();
              var v = l.ctx.createBufferSource();
              v.buffer = l._scratchBuffer, v.connect(l.ctx.destination), typeof v.start > "u" ? v.noteOn(0) : v.start(0), typeof l.ctx.resume == "function" && l.ctx.resume(), v.onended = function() {
                v.disconnect(0), l._audioUnlocked = !0, document.removeEventListener("touchstart", f, !0), document.removeEventListener("touchend", f, !0), document.removeEventListener("click", f, !0), document.removeEventListener("keydown", f, !0);
                for (var _ = 0; _ < l._howls.length; _++)
                  l._howls[_]._emit("unlock");
              };
            };
            return document.addEventListener("touchstart", f, !0), document.addEventListener("touchend", f, !0), document.addEventListener("click", f, !0), document.addEventListener("keydown", f, !0), l;
          }
        },
        /**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */
        _obtainHtml5Audio: function() {
          var l = this || n;
          if (l._html5AudioPool.length)
            return l._html5AudioPool.pop();
          var f = new Audio().play();
          return f && typeof Promise < "u" && (f instanceof Promise || typeof f.then == "function") && f.catch(function() {
            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
          }), new Audio();
        },
        /**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */
        _releaseHtml5Audio: function(l) {
          var f = this || n;
          return l._unlocked && f._html5AudioPool.push(l), f;
        },
        /**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */
        _autoSuspend: function() {
          var l = this;
          if (!(!l.autoSuspend || !l.ctx || typeof l.ctx.suspend > "u" || !n.usingWebAudio)) {
            for (var f = 0; f < l._howls.length; f++)
              if (l._howls[f]._webAudio) {
                for (var p = 0; p < l._howls[f]._sounds.length; p++)
                  if (!l._howls[f]._sounds[p]._paused)
                    return l;
              }
            return l._suspendTimer && clearTimeout(l._suspendTimer), l._suspendTimer = setTimeout(function() {
              if (l.autoSuspend) {
                l._suspendTimer = null, l.state = "suspending";
                var m = function() {
                  l.state = "suspended", l._resumeAfterSuspend && (delete l._resumeAfterSuspend, l._autoResume());
                };
                l.ctx.suspend().then(m, m);
              }
            }, 3e4), l;
          }
        },
        /**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */
        _autoResume: function() {
          var l = this;
          if (!(!l.ctx || typeof l.ctx.resume > "u" || !n.usingWebAudio))
            return l.state === "running" && l.ctx.state !== "interrupted" && l._suspendTimer ? (clearTimeout(l._suspendTimer), l._suspendTimer = null) : l.state === "suspended" || l.state === "running" && l.ctx.state === "interrupted" ? (l.ctx.resume().then(function() {
              l.state = "running";
              for (var f = 0; f < l._howls.length; f++)
                l._howls[f]._emit("resume");
            }), l._suspendTimer && (clearTimeout(l._suspendTimer), l._suspendTimer = null)) : l.state === "suspending" && (l._resumeAfterSuspend = !0), l;
        }
      };
      var n = new e(), r = function(l) {
        var f = this;
        if (!l.src || l.src.length === 0) {
          console.error("An array of source files must be passed with any new Howl.");
          return;
        }
        f.init(l);
      };
      r.prototype = {
        /**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */
        init: function(l) {
          var f = this;
          return n.ctx || d(), f._autoplay = l.autoplay || !1, f._format = typeof l.format != "string" ? l.format : [l.format], f._html5 = l.html5 || !1, f._muted = l.mute || !1, f._loop = l.loop || !1, f._pool = l.pool || 5, f._preload = typeof l.preload == "boolean" || l.preload === "metadata" ? l.preload : !0, f._rate = l.rate || 1, f._sprite = l.sprite || {}, f._src = typeof l.src != "string" ? l.src : [l.src], f._volume = l.volume !== void 0 ? l.volume : 1, f._xhr = {
            method: l.xhr && l.xhr.method ? l.xhr.method : "GET",
            headers: l.xhr && l.xhr.headers ? l.xhr.headers : null,
            withCredentials: l.xhr && l.xhr.withCredentials ? l.xhr.withCredentials : !1
          }, f._duration = 0, f._state = "unloaded", f._sounds = [], f._endTimers = {}, f._queue = [], f._playLock = !1, f._onend = l.onend ? [{ fn: l.onend }] : [], f._onfade = l.onfade ? [{ fn: l.onfade }] : [], f._onload = l.onload ? [{ fn: l.onload }] : [], f._onloaderror = l.onloaderror ? [{ fn: l.onloaderror }] : [], f._onplayerror = l.onplayerror ? [{ fn: l.onplayerror }] : [], f._onpause = l.onpause ? [{ fn: l.onpause }] : [], f._onplay = l.onplay ? [{ fn: l.onplay }] : [], f._onstop = l.onstop ? [{ fn: l.onstop }] : [], f._onmute = l.onmute ? [{ fn: l.onmute }] : [], f._onvolume = l.onvolume ? [{ fn: l.onvolume }] : [], f._onrate = l.onrate ? [{ fn: l.onrate }] : [], f._onseek = l.onseek ? [{ fn: l.onseek }] : [], f._onunlock = l.onunlock ? [{ fn: l.onunlock }] : [], f._onresume = [], f._webAudio = n.usingWebAudio && !f._html5, typeof n.ctx < "u" && n.ctx && n.autoUnlock && n._unlockAudio(), n._howls.push(f), f._autoplay && f._queue.push({
            event: "play",
            action: function() {
              f.play();
            }
          }), f._preload && f._preload !== "none" && f.load(), f;
        },
        /**
         * Load the audio file.
         * @return {Howler}
         */
        load: function() {
          var l = this, f = null;
          if (n.noAudio) {
            l._emit("loaderror", null, "No audio support.");
            return;
          }
          typeof l._src == "string" && (l._src = [l._src]);
          for (var p = 0; p < l._src.length; p++) {
            var m, g;
            if (l._format && l._format[p])
              m = l._format[p];
            else {
              if (g = l._src[p], typeof g != "string") {
                l._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              m = /^data:audio\/([^;,]+);/i.exec(g), m || (m = /\.([^.]+)$/.exec(g.split("?", 1)[0])), m && (m = m[1].toLowerCase());
            }
            if (m || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), m && n.codecs(m)) {
              f = l._src[p];
              break;
            }
          }
          if (!f) {
            l._emit("loaderror", null, "No codec support for selected audio sources.");
            return;
          }
          return l._src = f, l._state = "loading", window.location.protocol === "https:" && f.slice(0, 5) === "http:" && (l._html5 = !0, l._webAudio = !1), new i(l), l._webAudio && a(l), l;
        },
        /**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */
        play: function(l, f) {
          var p = this, m = null;
          if (typeof l == "number")
            m = l, l = null;
          else {
            if (typeof l == "string" && p._state === "loaded" && !p._sprite[l])
              return null;
            if (typeof l > "u" && (l = "__default", !p._playLock)) {
              for (var g = 0, y = 0; y < p._sounds.length; y++)
                p._sounds[y]._paused && !p._sounds[y]._ended && (g++, m = p._sounds[y]._id);
              g === 1 ? l = null : m = null;
            }
          }
          var b = m ? p._soundById(m) : p._inactiveSound();
          if (!b)
            return null;
          if (m && !l && (l = b._sprite || "__default"), p._state !== "loaded") {
            b._sprite = l, b._ended = !1;
            var E = b._id;
            return p._queue.push({
              event: "play",
              action: function() {
                p.play(E);
              }
            }), E;
          }
          if (m && !b._paused)
            return f || p._loadQueue("play"), b._id;
          p._webAudio && n._autoResume();
          var v = Math.max(0, b._seek > 0 ? b._seek : p._sprite[l][0] / 1e3), _ = Math.max(0, (p._sprite[l][0] + p._sprite[l][1]) / 1e3 - v), D = _ * 1e3 / Math.abs(b._rate), S = p._sprite[l][0] / 1e3, M = (p._sprite[l][0] + p._sprite[l][1]) / 1e3;
          b._sprite = l, b._ended = !1;
          var O = function() {
            b._paused = !1, b._seek = v, b._start = S, b._stop = M, b._loop = !!(b._loop || p._sprite[l][2]);
          };
          if (v >= M) {
            p._ended(b);
            return;
          }
          var T = b._node;
          if (p._webAudio) {
            var N = function() {
              p._playLock = !1, O(), p._refreshBuffer(b);
              var U = b._muted || p._muted ? 0 : b._volume;
              T.gain.setValueAtTime(U, n.ctx.currentTime), b._playStart = n.ctx.currentTime, typeof T.bufferSource.start > "u" ? b._loop ? T.bufferSource.noteGrainOn(0, v, 86400) : T.bufferSource.noteGrainOn(0, v, _) : b._loop ? T.bufferSource.start(0, v, 86400) : T.bufferSource.start(0, v, _), D !== 1 / 0 && (p._endTimers[b._id] = setTimeout(p._ended.bind(p, b), D)), f || setTimeout(function() {
                p._emit("play", b._id), p._loadQueue();
              }, 0);
            };
            n.state === "running" && n.ctx.state !== "interrupted" ? N() : (p._playLock = !0, p.once("resume", N), p._clearTimer(b._id));
          } else {
            var H = function() {
              T.currentTime = v, T.muted = b._muted || p._muted || n._muted || T.muted, T.volume = b._volume * n.volume(), T.playbackRate = b._rate;
              try {
                var U = T.play();
                if (U && typeof Promise < "u" && (U instanceof Promise || typeof U.then == "function") ? (p._playLock = !0, O(), U.then(function() {
                  p._playLock = !1, T._unlocked = !0, f ? p._loadQueue() : p._emit("play", b._id);
                }).catch(function() {
                  p._playLock = !1, p._emit("playerror", b._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), b._ended = !0, b._paused = !0;
                })) : f || (p._playLock = !1, O(), p._emit("play", b._id)), T.playbackRate = b._rate, T.paused) {
                  p._emit("playerror", b._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  return;
                }
                l !== "__default" || b._loop ? p._endTimers[b._id] = setTimeout(p._ended.bind(p, b), D) : (p._endTimers[b._id] = function() {
                  p._ended(b), T.removeEventListener("ended", p._endTimers[b._id], !1);
                }, T.addEventListener("ended", p._endTimers[b._id], !1));
              } catch (V) {
                p._emit("playerror", b._id, V);
              }
            };
            T.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (T.src = p._src, T.load());
            var $ = window && window.ejecta || !T.readyState && n._navigator.isCocoonJS;
            if (T.readyState >= 3 || $)
              H();
            else {
              p._playLock = !0, p._state = "loading";
              var j = function() {
                p._state = "loaded", H(), T.removeEventListener(n._canPlayEvent, j, !1);
              };
              T.addEventListener(n._canPlayEvent, j, !1), p._clearTimer(b._id);
            }
          }
          return b._id;
        },
        /**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */
        pause: function(l) {
          var f = this;
          if (f._state !== "loaded" || f._playLock)
            return f._queue.push({
              event: "pause",
              action: function() {
                f.pause(l);
              }
            }), f;
          for (var p = f._getSoundIds(l), m = 0; m < p.length; m++) {
            f._clearTimer(p[m]);
            var g = f._soundById(p[m]);
            if (g && !g._paused && (g._seek = f.seek(p[m]), g._rateSeek = 0, g._paused = !0, f._stopFade(p[m]), g._node))
              if (f._webAudio) {
                if (!g._node.bufferSource)
                  continue;
                typeof g._node.bufferSource.stop > "u" ? g._node.bufferSource.noteOff(0) : g._node.bufferSource.stop(0), f._cleanBuffer(g._node);
              } else (!isNaN(g._node.duration) || g._node.duration === 1 / 0) && g._node.pause();
            arguments[1] || f._emit("pause", g ? g._id : null);
          }
          return f;
        },
        /**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */
        stop: function(l, f) {
          var p = this;
          if (p._state !== "loaded" || p._playLock)
            return p._queue.push({
              event: "stop",
              action: function() {
                p.stop(l);
              }
            }), p;
          for (var m = p._getSoundIds(l), g = 0; g < m.length; g++) {
            p._clearTimer(m[g]);
            var y = p._soundById(m[g]);
            y && (y._seek = y._start || 0, y._rateSeek = 0, y._paused = !0, y._ended = !0, p._stopFade(m[g]), y._node && (p._webAudio ? y._node.bufferSource && (typeof y._node.bufferSource.stop > "u" ? y._node.bufferSource.noteOff(0) : y._node.bufferSource.stop(0), p._cleanBuffer(y._node)) : (!isNaN(y._node.duration) || y._node.duration === 1 / 0) && (y._node.currentTime = y._start || 0, y._node.pause(), y._node.duration === 1 / 0 && p._clearSound(y._node))), f || p._emit("stop", y._id));
          }
          return p;
        },
        /**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */
        mute: function(l, f) {
          var p = this;
          if (p._state !== "loaded" || p._playLock)
            return p._queue.push({
              event: "mute",
              action: function() {
                p.mute(l, f);
              }
            }), p;
          if (typeof f > "u")
            if (typeof l == "boolean")
              p._muted = l;
            else
              return p._muted;
          for (var m = p._getSoundIds(f), g = 0; g < m.length; g++) {
            var y = p._soundById(m[g]);
            y && (y._muted = l, y._interval && p._stopFade(y._id), p._webAudio && y._node ? y._node.gain.setValueAtTime(l ? 0 : y._volume, n.ctx.currentTime) : y._node && (y._node.muted = n._muted ? !0 : l), p._emit("mute", y._id));
          }
          return p;
        },
        /**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */
        volume: function() {
          var l = this, f = arguments, p, m;
          if (f.length === 0)
            return l._volume;
          if (f.length === 1 || f.length === 2 && typeof f[1] > "u") {
            var g = l._getSoundIds(), y = g.indexOf(f[0]);
            y >= 0 ? m = parseInt(f[0], 10) : p = parseFloat(f[0]);
          } else f.length >= 2 && (p = parseFloat(f[0]), m = parseInt(f[1], 10));
          var b;
          if (typeof p < "u" && p >= 0 && p <= 1) {
            if (l._state !== "loaded" || l._playLock)
              return l._queue.push({
                event: "volume",
                action: function() {
                  l.volume.apply(l, f);
                }
              }), l;
            typeof m > "u" && (l._volume = p), m = l._getSoundIds(m);
            for (var E = 0; E < m.length; E++)
              b = l._soundById(m[E]), b && (b._volume = p, f[2] || l._stopFade(m[E]), l._webAudio && b._node && !b._muted ? b._node.gain.setValueAtTime(p, n.ctx.currentTime) : b._node && !b._muted && (b._node.volume = p * n.volume()), l._emit("volume", b._id));
          } else
            return b = m ? l._soundById(m) : l._sounds[0], b ? b._volume : 0;
          return l;
        },
        /**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */
        fade: function(l, f, p, m) {
          var g = this;
          if (g._state !== "loaded" || g._playLock)
            return g._queue.push({
              event: "fade",
              action: function() {
                g.fade(l, f, p, m);
              }
            }), g;
          l = Math.min(Math.max(0, parseFloat(l)), 1), f = Math.min(Math.max(0, parseFloat(f)), 1), p = parseFloat(p), g.volume(l, m);
          for (var y = g._getSoundIds(m), b = 0; b < y.length; b++) {
            var E = g._soundById(y[b]);
            if (E) {
              if (m || g._stopFade(y[b]), g._webAudio && !E._muted) {
                var v = n.ctx.currentTime, _ = v + p / 1e3;
                E._volume = l, E._node.gain.setValueAtTime(l, v), E._node.gain.linearRampToValueAtTime(f, _);
              }
              g._startFadeInterval(E, l, f, p, y[b], typeof m > "u");
            }
          }
          return g;
        },
        /**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */
        _startFadeInterval: function(l, f, p, m, g, y) {
          var b = this, E = f, v = p - f, _ = Math.abs(v / 0.01), D = Math.max(4, _ > 0 ? m / _ : m), S = Date.now();
          l._fadeTo = p, l._interval = setInterval(function() {
            var M = (Date.now() - S) / m;
            S = Date.now(), E += v * M, E = Math.round(E * 100) / 100, v < 0 ? E = Math.max(p, E) : E = Math.min(p, E), b._webAudio ? l._volume = E : b.volume(E, l._id, !0), y && (b._volume = E), (p < f && E <= p || p > f && E >= p) && (clearInterval(l._interval), l._interval = null, l._fadeTo = null, b.volume(p, l._id), b._emit("fade", l._id));
          }, D);
        },
        /**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */
        _stopFade: function(l) {
          var f = this, p = f._soundById(l);
          return p && p._interval && (f._webAudio && p._node.gain.cancelScheduledValues(n.ctx.currentTime), clearInterval(p._interval), p._interval = null, f.volume(p._fadeTo, l), p._fadeTo = null, f._emit("fade", l)), f;
        },
        /**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */
        loop: function() {
          var l = this, f = arguments, p, m, g;
          if (f.length === 0)
            return l._loop;
          if (f.length === 1)
            if (typeof f[0] == "boolean")
              p = f[0], l._loop = p;
            else
              return g = l._soundById(parseInt(f[0], 10)), g ? g._loop : !1;
          else f.length === 2 && (p = f[0], m = parseInt(f[1], 10));
          for (var y = l._getSoundIds(m), b = 0; b < y.length; b++)
            g = l._soundById(y[b]), g && (g._loop = p, l._webAudio && g._node && g._node.bufferSource && (g._node.bufferSource.loop = p, p && (g._node.bufferSource.loopStart = g._start || 0, g._node.bufferSource.loopEnd = g._stop, l.playing(y[b]) && (l.pause(y[b], !0), l.play(y[b], !0)))));
          return l;
        },
        /**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */
        rate: function() {
          var l = this, f = arguments, p, m;
          if (f.length === 0)
            m = l._sounds[0]._id;
          else if (f.length === 1) {
            var g = l._getSoundIds(), y = g.indexOf(f[0]);
            y >= 0 ? m = parseInt(f[0], 10) : p = parseFloat(f[0]);
          } else f.length === 2 && (p = parseFloat(f[0]), m = parseInt(f[1], 10));
          var b;
          if (typeof p == "number") {
            if (l._state !== "loaded" || l._playLock)
              return l._queue.push({
                event: "rate",
                action: function() {
                  l.rate.apply(l, f);
                }
              }), l;
            typeof m > "u" && (l._rate = p), m = l._getSoundIds(m);
            for (var E = 0; E < m.length; E++)
              if (b = l._soundById(m[E]), b) {
                l.playing(m[E]) && (b._rateSeek = l.seek(m[E]), b._playStart = l._webAudio ? n.ctx.currentTime : b._playStart), b._rate = p, l._webAudio && b._node && b._node.bufferSource ? b._node.bufferSource.playbackRate.setValueAtTime(p, n.ctx.currentTime) : b._node && (b._node.playbackRate = p);
                var v = l.seek(m[E]), _ = (l._sprite[b._sprite][0] + l._sprite[b._sprite][1]) / 1e3 - v, D = _ * 1e3 / Math.abs(b._rate);
                (l._endTimers[m[E]] || !b._paused) && (l._clearTimer(m[E]), l._endTimers[m[E]] = setTimeout(l._ended.bind(l, b), D)), l._emit("rate", b._id);
              }
          } else
            return b = l._soundById(m), b ? b._rate : l._rate;
          return l;
        },
        /**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */
        seek: function() {
          var l = this, f = arguments, p, m;
          if (f.length === 0)
            l._sounds.length && (m = l._sounds[0]._id);
          else if (f.length === 1) {
            var g = l._getSoundIds(), y = g.indexOf(f[0]);
            y >= 0 ? m = parseInt(f[0], 10) : l._sounds.length && (m = l._sounds[0]._id, p = parseFloat(f[0]));
          } else f.length === 2 && (p = parseFloat(f[0]), m = parseInt(f[1], 10));
          if (typeof m > "u")
            return 0;
          if (typeof p == "number" && (l._state !== "loaded" || l._playLock))
            return l._queue.push({
              event: "seek",
              action: function() {
                l.seek.apply(l, f);
              }
            }), l;
          var b = l._soundById(m);
          if (b)
            if (typeof p == "number" && p >= 0) {
              var E = l.playing(m);
              E && l.pause(m, !0), b._seek = p, b._ended = !1, l._clearTimer(m), !l._webAudio && b._node && !isNaN(b._node.duration) && (b._node.currentTime = p);
              var v = function() {
                E && l.play(m, !0), l._emit("seek", m);
              };
              if (E && !l._webAudio) {
                var _ = function() {
                  l._playLock ? setTimeout(_, 0) : v();
                };
                setTimeout(_, 0);
              } else
                v();
            } else if (l._webAudio) {
              var D = l.playing(m) ? n.ctx.currentTime - b._playStart : 0, S = b._rateSeek ? b._rateSeek - b._seek : 0;
              return b._seek + (S + D * Math.abs(b._rate));
            } else
              return b._node.currentTime;
          return l;
        },
        /**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */
        playing: function(l) {
          var f = this;
          if (typeof l == "number") {
            var p = f._soundById(l);
            return p ? !p._paused : !1;
          }
          for (var m = 0; m < f._sounds.length; m++)
            if (!f._sounds[m]._paused)
              return !0;
          return !1;
        },
        /**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */
        duration: function(l) {
          var f = this, p = f._duration, m = f._soundById(l);
          return m && (p = f._sprite[m._sprite][1] / 1e3), p;
        },
        /**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */
        state: function() {
          return this._state;
        },
        /**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */
        unload: function() {
          for (var l = this, f = l._sounds, p = 0; p < f.length; p++)
            f[p]._paused || l.stop(f[p]._id), l._webAudio || (l._clearSound(f[p]._node), f[p]._node.removeEventListener("error", f[p]._errorFn, !1), f[p]._node.removeEventListener(n._canPlayEvent, f[p]._loadFn, !1), f[p]._node.removeEventListener("ended", f[p]._endFn, !1), n._releaseHtml5Audio(f[p]._node)), delete f[p]._node, l._clearTimer(f[p]._id);
          var m = n._howls.indexOf(l);
          m >= 0 && n._howls.splice(m, 1);
          var g = !0;
          for (p = 0; p < n._howls.length; p++)
            if (n._howls[p]._src === l._src || l._src.indexOf(n._howls[p]._src) >= 0) {
              g = !1;
              break;
            }
          return s && g && delete s[l._src], n.noAudio = !1, l._state = "unloaded", l._sounds = [], l = null, null;
        },
        /**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */
        on: function(l, f, p, m) {
          var g = this, y = g["_on" + l];
          return typeof f == "function" && y.push(m ? { id: p, fn: f, once: m } : { id: p, fn: f }), g;
        },
        /**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */
        off: function(l, f, p) {
          var m = this, g = m["_on" + l], y = 0;
          if (typeof f == "number" && (p = f, f = null), f || p)
            for (y = 0; y < g.length; y++) {
              var b = p === g[y].id;
              if (f === g[y].fn && b || !f && b) {
                g.splice(y, 1);
                break;
              }
            }
          else if (l)
            m["_on" + l] = [];
          else {
            var E = Object.keys(m);
            for (y = 0; y < E.length; y++)
              E[y].indexOf("_on") === 0 && Array.isArray(m[E[y]]) && (m[E[y]] = []);
          }
          return m;
        },
        /**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */
        once: function(l, f, p) {
          var m = this;
          return m.on(l, f, p, 1), m;
        },
        /**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */
        _emit: function(l, f, p) {
          for (var m = this, g = m["_on" + l], y = g.length - 1; y >= 0; y--)
            (!g[y].id || g[y].id === f || l === "load") && (setTimeout((function(b) {
              b.call(this, f, p);
            }).bind(m, g[y].fn), 0), g[y].once && m.off(l, g[y].fn, g[y].id));
          return m._loadQueue(l), m;
        },
        /**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */
        _loadQueue: function(l) {
          var f = this;
          if (f._queue.length > 0) {
            var p = f._queue[0];
            p.event === l && (f._queue.shift(), f._loadQueue()), l || p.action();
          }
          return f;
        },
        /**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _ended: function(l) {
          var f = this, p = l._sprite;
          if (!f._webAudio && l._node && !l._node.paused && !l._node.ended && l._node.currentTime < l._stop)
            return setTimeout(f._ended.bind(f, l), 100), f;
          var m = !!(l._loop || f._sprite[p][2]);
          if (f._emit("end", l._id), !f._webAudio && m && f.stop(l._id, !0).play(l._id), f._webAudio && m) {
            f._emit("play", l._id), l._seek = l._start || 0, l._rateSeek = 0, l._playStart = n.ctx.currentTime;
            var g = (l._stop - l._start) * 1e3 / Math.abs(l._rate);
            f._endTimers[l._id] = setTimeout(f._ended.bind(f, l), g);
          }
          return f._webAudio && !m && (l._paused = !0, l._ended = !0, l._seek = l._start || 0, l._rateSeek = 0, f._clearTimer(l._id), f._cleanBuffer(l._node), n._autoSuspend()), !f._webAudio && !m && f.stop(l._id, !0), f;
        },
        /**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */
        _clearTimer: function(l) {
          var f = this;
          if (f._endTimers[l]) {
            if (typeof f._endTimers[l] != "function")
              clearTimeout(f._endTimers[l]);
            else {
              var p = f._soundById(l);
              p && p._node && p._node.removeEventListener("ended", f._endTimers[l], !1);
            }
            delete f._endTimers[l];
          }
          return f;
        },
        /**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */
        _soundById: function(l) {
          for (var f = this, p = 0; p < f._sounds.length; p++)
            if (l === f._sounds[p]._id)
              return f._sounds[p];
          return null;
        },
        /**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */
        _inactiveSound: function() {
          var l = this;
          l._drain();
          for (var f = 0; f < l._sounds.length; f++)
            if (l._sounds[f]._ended)
              return l._sounds[f].reset();
          return new i(l);
        },
        /**
         * Drain excess inactive sounds from the pool.
         */
        _drain: function() {
          var l = this, f = l._pool, p = 0, m = 0;
          if (!(l._sounds.length < f)) {
            for (m = 0; m < l._sounds.length; m++)
              l._sounds[m]._ended && p++;
            for (m = l._sounds.length - 1; m >= 0; m--) {
              if (p <= f)
                return;
              l._sounds[m]._ended && (l._webAudio && l._sounds[m]._node && l._sounds[m]._node.disconnect(0), l._sounds.splice(m, 1), p--);
            }
          }
        },
        /**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */
        _getSoundIds: function(l) {
          var f = this;
          if (typeof l > "u") {
            for (var p = [], m = 0; m < f._sounds.length; m++)
              p.push(f._sounds[m]._id);
            return p;
          } else
            return [l];
        },
        /**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _refreshBuffer: function(l) {
          var f = this;
          return l._node.bufferSource = n.ctx.createBufferSource(), l._node.bufferSource.buffer = s[f._src], l._panner ? l._node.bufferSource.connect(l._panner) : l._node.bufferSource.connect(l._node), l._node.bufferSource.loop = l._loop, l._loop && (l._node.bufferSource.loopStart = l._start || 0, l._node.bufferSource.loopEnd = l._stop || 0), l._node.bufferSource.playbackRate.setValueAtTime(l._rate, n.ctx.currentTime), f;
        },
        /**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */
        _cleanBuffer: function(l) {
          var f = this, p = n._navigator && n._navigator.vendor.indexOf("Apple") >= 0;
          if (!l.bufferSource)
            return f;
          if (n._scratchBuffer && l.bufferSource && (l.bufferSource.onended = null, l.bufferSource.disconnect(0), p))
            try {
              l.bufferSource.buffer = n._scratchBuffer;
            } catch {
            }
          return l.bufferSource = null, f;
        },
        /**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */
        _clearSound: function(l) {
          var f = /MSIE |Trident\//.test(n._navigator && n._navigator.userAgent);
          f || (l.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
        }
      };
      var i = function(l) {
        this._parent = l, this.init();
      };
      i.prototype = {
        /**
         * Initialize a new Sound object.
         * @return {Sound}
         */
        init: function() {
          var l = this, f = l._parent;
          return l._muted = f._muted, l._loop = f._loop, l._volume = f._volume, l._rate = f._rate, l._seek = 0, l._paused = !0, l._ended = !0, l._sprite = "__default", l._id = ++n._counter, f._sounds.push(l), l.create(), l;
        },
        /**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */
        create: function() {
          var l = this, f = l._parent, p = n._muted || l._muted || l._parent._muted ? 0 : l._volume;
          return f._webAudio ? (l._node = typeof n.ctx.createGain > "u" ? n.ctx.createGainNode() : n.ctx.createGain(), l._node.gain.setValueAtTime(p, n.ctx.currentTime), l._node.paused = !0, l._node.connect(n.masterGain)) : n.noAudio || (l._node = n._obtainHtml5Audio(), l._errorFn = l._errorListener.bind(l), l._node.addEventListener("error", l._errorFn, !1), l._loadFn = l._loadListener.bind(l), l._node.addEventListener(n._canPlayEvent, l._loadFn, !1), l._endFn = l._endListener.bind(l), l._node.addEventListener("ended", l._endFn, !1), l._node.src = f._src, l._node.preload = f._preload === !0 ? "auto" : f._preload, l._node.volume = p * n.volume(), l._node.load()), l;
        },
        /**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */
        reset: function() {
          var l = this, f = l._parent;
          return l._muted = f._muted, l._loop = f._loop, l._volume = f._volume, l._rate = f._rate, l._seek = 0, l._rateSeek = 0, l._paused = !0, l._ended = !0, l._sprite = "__default", l._id = ++n._counter, l;
        },
        /**
         * HTML5 Audio error listener callback.
         */
        _errorListener: function() {
          var l = this;
          l._parent._emit("loaderror", l._id, l._node.error ? l._node.error.code : 0), l._node.removeEventListener("error", l._errorFn, !1);
        },
        /**
         * HTML5 Audio canplaythrough listener callback.
         */
        _loadListener: function() {
          var l = this, f = l._parent;
          f._duration = Math.ceil(l._node.duration * 10) / 10, Object.keys(f._sprite).length === 0 && (f._sprite = { __default: [0, f._duration * 1e3] }), f._state !== "loaded" && (f._state = "loaded", f._emit("load"), f._loadQueue()), l._node.removeEventListener(n._canPlayEvent, l._loadFn, !1);
        },
        /**
         * HTML5 Audio ended listener callback.
         */
        _endListener: function() {
          var l = this, f = l._parent;
          f._duration === 1 / 0 && (f._duration = Math.ceil(l._node.duration * 10) / 10, f._sprite.__default[1] === 1 / 0 && (f._sprite.__default[1] = f._duration * 1e3), f._ended(l)), l._node.removeEventListener("ended", l._endFn, !1);
        }
      };
      var s = {}, a = function(l) {
        var f = l._src;
        if (s[f]) {
          l._duration = s[f].duration, c(l);
          return;
        }
        if (/^data:[^;]+;base64,/.test(f)) {
          for (var p = atob(f.split(",")[1]), m = new Uint8Array(p.length), g = 0; g < p.length; ++g)
            m[g] = p.charCodeAt(g);
          u(m.buffer, l);
        } else {
          var y = new XMLHttpRequest();
          y.open(l._xhr.method, f, !0), y.withCredentials = l._xhr.withCredentials, y.responseType = "arraybuffer", l._xhr.headers && Object.keys(l._xhr.headers).forEach(function(b) {
            y.setRequestHeader(b, l._xhr.headers[b]);
          }), y.onload = function() {
            var b = (y.status + "")[0];
            if (b !== "0" && b !== "2" && b !== "3") {
              l._emit("loaderror", null, "Failed loading audio file with status: " + y.status + ".");
              return;
            }
            u(y.response, l);
          }, y.onerror = function() {
            l._webAudio && (l._html5 = !0, l._webAudio = !1, l._sounds = [], delete s[f], l.load());
          }, o(y);
        }
      }, o = function(l) {
        try {
          l.send();
        } catch {
          l.onerror();
        }
      }, u = function(l, f) {
        var p = function() {
          f._emit("loaderror", null, "Decoding audio data failed.");
        }, m = function(g) {
          g && f._sounds.length > 0 ? (s[f._src] = g, c(f, g)) : p();
        };
        typeof Promise < "u" && n.ctx.decodeAudioData.length === 1 ? n.ctx.decodeAudioData(l).then(m).catch(p) : n.ctx.decodeAudioData(l, m, p);
      }, c = function(l, f) {
        f && !l._duration && (l._duration = f.duration), Object.keys(l._sprite).length === 0 && (l._sprite = { __default: [0, l._duration * 1e3] }), l._state !== "loaded" && (l._state = "loaded", l._emit("load"), l._loadQueue());
      }, d = function() {
        if (n.usingWebAudio) {
          try {
            typeof AudioContext < "u" ? n.ctx = new AudioContext() : typeof webkitAudioContext < "u" ? n.ctx = new webkitAudioContext() : n.usingWebAudio = !1;
          } catch {
            n.usingWebAudio = !1;
          }
          n.ctx || (n.usingWebAudio = !1);
          var l = /iP(hone|od|ad)/.test(n._navigator && n._navigator.platform), f = n._navigator && n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), p = f ? parseInt(f[1], 10) : null;
          if (l && p && p < 9) {
            var m = /safari/.test(n._navigator && n._navigator.userAgent.toLowerCase());
            n._navigator && !m && (n.usingWebAudio = !1);
          }
          n.usingWebAudio && (n.masterGain = typeof n.ctx.createGain > "u" ? n.ctx.createGainNode() : n.ctx.createGain(), n.masterGain.gain.setValueAtTime(n._muted ? 0 : n._volume, n.ctx.currentTime), n.masterGain.connect(n.ctx.destination)), n._setup();
        }
      };
      t.Howler = n, t.Howl = r, typeof cn < "u" ? (cn.HowlerGlobal = e, cn.Howler = n, cn.Howl = r, cn.Sound = i) : typeof window < "u" && (window.HowlerGlobal = e, window.Howler = n, window.Howl = r, window.Sound = i);
    })();
    /*!
     *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
     *  
     *  howler.js v2.2.4
     *  howlerjs.com
     *
     *  (c) 2013-2020, James Simpson of GoldFire Studios
     *  goldfirestudios.com
     *
     *  MIT License
     */
    (function() {
      HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(n) {
        var r = this;
        if (!r.ctx || !r.ctx.listener)
          return r;
        for (var i = r._howls.length - 1; i >= 0; i--)
          r._howls[i].stereo(n);
        return r;
      }, HowlerGlobal.prototype.pos = function(n, r, i) {
        var s = this;
        if (!s.ctx || !s.ctx.listener)
          return s;
        if (r = typeof r != "number" ? s._pos[1] : r, i = typeof i != "number" ? s._pos[2] : i, typeof n == "number")
          s._pos = [n, r, i], typeof s.ctx.listener.positionX < "u" ? (s.ctx.listener.positionX.setTargetAtTime(s._pos[0], Howler.ctx.currentTime, 0.1), s.ctx.listener.positionY.setTargetAtTime(s._pos[1], Howler.ctx.currentTime, 0.1), s.ctx.listener.positionZ.setTargetAtTime(s._pos[2], Howler.ctx.currentTime, 0.1)) : s.ctx.listener.setPosition(s._pos[0], s._pos[1], s._pos[2]);
        else
          return s._pos;
        return s;
      }, HowlerGlobal.prototype.orientation = function(n, r, i, s, a, o) {
        var u = this;
        if (!u.ctx || !u.ctx.listener)
          return u;
        var c = u._orientation;
        if (r = typeof r != "number" ? c[1] : r, i = typeof i != "number" ? c[2] : i, s = typeof s != "number" ? c[3] : s, a = typeof a != "number" ? c[4] : a, o = typeof o != "number" ? c[5] : o, typeof n == "number")
          u._orientation = [n, r, i, s, a, o], typeof u.ctx.listener.forwardX < "u" ? (u.ctx.listener.forwardX.setTargetAtTime(n, Howler.ctx.currentTime, 0.1), u.ctx.listener.forwardY.setTargetAtTime(r, Howler.ctx.currentTime, 0.1), u.ctx.listener.forwardZ.setTargetAtTime(i, Howler.ctx.currentTime, 0.1), u.ctx.listener.upX.setTargetAtTime(s, Howler.ctx.currentTime, 0.1), u.ctx.listener.upY.setTargetAtTime(a, Howler.ctx.currentTime, 0.1), u.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, 0.1)) : u.ctx.listener.setOrientation(n, r, i, s, a, o);
        else
          return c;
        return u;
      }, Howl.prototype.init = /* @__PURE__ */ function(n) {
        return function(r) {
          var i = this;
          return i._orientation = r.orientation || [1, 0, 0], i._stereo = r.stereo || null, i._pos = r.pos || null, i._pannerAttr = {
            coneInnerAngle: typeof r.coneInnerAngle < "u" ? r.coneInnerAngle : 360,
            coneOuterAngle: typeof r.coneOuterAngle < "u" ? r.coneOuterAngle : 360,
            coneOuterGain: typeof r.coneOuterGain < "u" ? r.coneOuterGain : 0,
            distanceModel: typeof r.distanceModel < "u" ? r.distanceModel : "inverse",
            maxDistance: typeof r.maxDistance < "u" ? r.maxDistance : 1e4,
            panningModel: typeof r.panningModel < "u" ? r.panningModel : "HRTF",
            refDistance: typeof r.refDistance < "u" ? r.refDistance : 1,
            rolloffFactor: typeof r.rolloffFactor < "u" ? r.rolloffFactor : 1
          }, i._onstereo = r.onstereo ? [{ fn: r.onstereo }] : [], i._onpos = r.onpos ? [{ fn: r.onpos }] : [], i._onorientation = r.onorientation ? [{ fn: r.onorientation }] : [], n.call(this, r);
        };
      }(Howl.prototype.init), Howl.prototype.stereo = function(n, r) {
        var i = this;
        if (!i._webAudio)
          return i;
        if (i._state !== "loaded")
          return i._queue.push({
            event: "stereo",
            action: function() {
              i.stereo(n, r);
            }
          }), i;
        var s = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
        if (typeof r > "u")
          if (typeof n == "number")
            i._stereo = n, i._pos = [n, 0, 0];
          else
            return i._stereo;
        for (var a = i._getSoundIds(r), o = 0; o < a.length; o++) {
          var u = i._soundById(a[o]);
          if (u)
            if (typeof n == "number")
              u._stereo = n, u._pos = [n, 0, 0], u._node && (u._pannerAttr.panningModel = "equalpower", (!u._panner || !u._panner.pan) && e(u, s), s === "spatial" ? typeof u._panner.positionX < "u" ? (u._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), u._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), u._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : u._panner.setPosition(n, 0, 0) : u._panner.pan.setValueAtTime(n, Howler.ctx.currentTime)), i._emit("stereo", u._id);
            else
              return u._stereo;
        }
        return i;
      }, Howl.prototype.pos = function(n, r, i, s) {
        var a = this;
        if (!a._webAudio)
          return a;
        if (a._state !== "loaded")
          return a._queue.push({
            event: "pos",
            action: function() {
              a.pos(n, r, i, s);
            }
          }), a;
        if (r = typeof r != "number" ? 0 : r, i = typeof i != "number" ? -0.5 : i, typeof s > "u")
          if (typeof n == "number")
            a._pos = [n, r, i];
          else
            return a._pos;
        for (var o = a._getSoundIds(s), u = 0; u < o.length; u++) {
          var c = a._soundById(o[u]);
          if (c)
            if (typeof n == "number")
              c._pos = [n, r, i], c._node && ((!c._panner || c._panner.pan) && e(c, "spatial"), typeof c._panner.positionX < "u" ? (c._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), c._panner.positionY.setValueAtTime(r, Howler.ctx.currentTime), c._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setPosition(n, r, i)), a._emit("pos", c._id);
            else
              return c._pos;
        }
        return a;
      }, Howl.prototype.orientation = function(n, r, i, s) {
        var a = this;
        if (!a._webAudio)
          return a;
        if (a._state !== "loaded")
          return a._queue.push({
            event: "orientation",
            action: function() {
              a.orientation(n, r, i, s);
            }
          }), a;
        if (r = typeof r != "number" ? a._orientation[1] : r, i = typeof i != "number" ? a._orientation[2] : i, typeof s > "u")
          if (typeof n == "number")
            a._orientation = [n, r, i];
          else
            return a._orientation;
        for (var o = a._getSoundIds(s), u = 0; u < o.length; u++) {
          var c = a._soundById(o[u]);
          if (c)
            if (typeof n == "number")
              c._orientation = [n, r, i], c._node && (c._panner || (c._pos || (c._pos = a._pos || [0, 0, -0.5]), e(c, "spatial")), typeof c._panner.orientationX < "u" ? (c._panner.orientationX.setValueAtTime(n, Howler.ctx.currentTime), c._panner.orientationY.setValueAtTime(r, Howler.ctx.currentTime), c._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : c._panner.setOrientation(n, r, i)), a._emit("orientation", c._id);
            else
              return c._orientation;
        }
        return a;
      }, Howl.prototype.pannerAttr = function() {
        var n = this, r = arguments, i, s, a;
        if (!n._webAudio)
          return n;
        if (r.length === 0)
          return n._pannerAttr;
        if (r.length === 1)
          if (typeof r[0] == "object")
            i = r[0], typeof s > "u" && (i.pannerAttr || (i.pannerAttr = {
              coneInnerAngle: i.coneInnerAngle,
              coneOuterAngle: i.coneOuterAngle,
              coneOuterGain: i.coneOuterGain,
              distanceModel: i.distanceModel,
              maxDistance: i.maxDistance,
              refDistance: i.refDistance,
              rolloffFactor: i.rolloffFactor,
              panningModel: i.panningModel
            }), n._pannerAttr = {
              coneInnerAngle: typeof i.pannerAttr.coneInnerAngle < "u" ? i.pannerAttr.coneInnerAngle : n._coneInnerAngle,
              coneOuterAngle: typeof i.pannerAttr.coneOuterAngle < "u" ? i.pannerAttr.coneOuterAngle : n._coneOuterAngle,
              coneOuterGain: typeof i.pannerAttr.coneOuterGain < "u" ? i.pannerAttr.coneOuterGain : n._coneOuterGain,
              distanceModel: typeof i.pannerAttr.distanceModel < "u" ? i.pannerAttr.distanceModel : n._distanceModel,
              maxDistance: typeof i.pannerAttr.maxDistance < "u" ? i.pannerAttr.maxDistance : n._maxDistance,
              refDistance: typeof i.pannerAttr.refDistance < "u" ? i.pannerAttr.refDistance : n._refDistance,
              rolloffFactor: typeof i.pannerAttr.rolloffFactor < "u" ? i.pannerAttr.rolloffFactor : n._rolloffFactor,
              panningModel: typeof i.pannerAttr.panningModel < "u" ? i.pannerAttr.panningModel : n._panningModel
            });
          else
            return a = n._soundById(parseInt(r[0], 10)), a ? a._pannerAttr : n._pannerAttr;
        else r.length === 2 && (i = r[0], s = parseInt(r[1], 10));
        for (var o = n._getSoundIds(s), u = 0; u < o.length; u++)
          if (a = n._soundById(o[u]), a) {
            var c = a._pannerAttr;
            c = {
              coneInnerAngle: typeof i.coneInnerAngle < "u" ? i.coneInnerAngle : c.coneInnerAngle,
              coneOuterAngle: typeof i.coneOuterAngle < "u" ? i.coneOuterAngle : c.coneOuterAngle,
              coneOuterGain: typeof i.coneOuterGain < "u" ? i.coneOuterGain : c.coneOuterGain,
              distanceModel: typeof i.distanceModel < "u" ? i.distanceModel : c.distanceModel,
              maxDistance: typeof i.maxDistance < "u" ? i.maxDistance : c.maxDistance,
              refDistance: typeof i.refDistance < "u" ? i.refDistance : c.refDistance,
              rolloffFactor: typeof i.rolloffFactor < "u" ? i.rolloffFactor : c.rolloffFactor,
              panningModel: typeof i.panningModel < "u" ? i.panningModel : c.panningModel
            };
            var d = a._panner;
            d || (a._pos || (a._pos = n._pos || [0, 0, -0.5]), e(a, "spatial"), d = a._panner), d.coneInnerAngle = c.coneInnerAngle, d.coneOuterAngle = c.coneOuterAngle, d.coneOuterGain = c.coneOuterGain, d.distanceModel = c.distanceModel, d.maxDistance = c.maxDistance, d.refDistance = c.refDistance, d.rolloffFactor = c.rolloffFactor, d.panningModel = c.panningModel;
          }
        return n;
      }, Sound.prototype.init = /* @__PURE__ */ function(n) {
        return function() {
          var r = this, i = r._parent;
          r._orientation = i._orientation, r._stereo = i._stereo, r._pos = i._pos, r._pannerAttr = i._pannerAttr, n.call(this), r._stereo ? i.stereo(r._stereo) : r._pos && i.pos(r._pos[0], r._pos[1], r._pos[2], r._id);
        };
      }(Sound.prototype.init), Sound.prototype.reset = /* @__PURE__ */ function(n) {
        return function() {
          var r = this, i = r._parent;
          return r._orientation = i._orientation, r._stereo = i._stereo, r._pos = i._pos, r._pannerAttr = i._pannerAttr, r._stereo ? i.stereo(r._stereo) : r._pos ? i.pos(r._pos[0], r._pos[1], r._pos[2], r._id) : r._panner && (r._panner.disconnect(0), r._panner = void 0, i._refreshBuffer(r)), n.call(this);
        };
      }(Sound.prototype.reset);
      var e = function(n, r) {
        r = r || "spatial", r === "spatial" ? (n._panner = Howler.ctx.createPanner(), n._panner.coneInnerAngle = n._pannerAttr.coneInnerAngle, n._panner.coneOuterAngle = n._pannerAttr.coneOuterAngle, n._panner.coneOuterGain = n._pannerAttr.coneOuterGain, n._panner.distanceModel = n._pannerAttr.distanceModel, n._panner.maxDistance = n._pannerAttr.maxDistance, n._panner.refDistance = n._pannerAttr.refDistance, n._panner.rolloffFactor = n._pannerAttr.rolloffFactor, n._panner.panningModel = n._pannerAttr.panningModel, typeof n._panner.positionX < "u" ? (n._panner.positionX.setValueAtTime(n._pos[0], Howler.ctx.currentTime), n._panner.positionY.setValueAtTime(n._pos[1], Howler.ctx.currentTime), n._panner.positionZ.setValueAtTime(n._pos[2], Howler.ctx.currentTime)) : n._panner.setPosition(n._pos[0], n._pos[1], n._pos[2]), typeof n._panner.orientationX < "u" ? (n._panner.orientationX.setValueAtTime(n._orientation[0], Howler.ctx.currentTime), n._panner.orientationY.setValueAtTime(n._orientation[1], Howler.ctx.currentTime), n._panner.orientationZ.setValueAtTime(n._orientation[2], Howler.ctx.currentTime)) : n._panner.setOrientation(n._orientation[0], n._orientation[1], n._orientation[2])) : (n._panner = Howler.ctx.createStereoPanner(), n._panner.pan.setValueAtTime(n._stereo, Howler.ctx.currentTime)), n._panner.connect(n._node), n._paused || n._parent.pause(n._id, !0).play(n._id, !0);
      };
    })();
  }(m2)), m2;
}
var a5e = s5e();
const o5e = {
  key: 0,
  src: n5e,
  width: "24",
  height: "24"
}, u5e = {
  key: 1,
  src: uD,
  width: "24",
  height: "24"
}, l5e = {
  key: 1,
  class: "flex h-5 items-center justify-center"
}, c5e = {
  key: 0,
  src: r5e,
  width: "24",
  height: "24"
}, d5e = {
  key: 1,
  src: i5e,
  width: "24",
  height: "24"
}, f5e = { class: "rounded-full bg-black/30 px-2 py-1 text-xs font-bold text-white" }, h5e = /* @__PURE__ */ Ze({
  __name: "AudioMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = Yt(), r = Se(
      0
      /* Initial */
    ), i = Se(), s = Se(0), a = Se(), o = de(() => e.message.isIncoming), u = () => {
      i.value && (s.value = i.value.seek() / i.value.duration() * 100, i.value.playing() && requestAnimationFrame(u));
    }, c = async () => {
      var l, f;
      switch (r.value) {
        case 0: {
          const p = new a5e.Howl({
            src: e.message.url,
            format: ["m4a", "mp3", "wav", "aac", "webm"],
            onload: () => {
              p.play(), r.value = 3;
            },
            onplay: () => {
              requestAnimationFrame(u);
            },
            onend: () => {
              r.value = 2;
            },
            onloaderror: (m, g) => console.log(2, m, g),
            xhr: {
              headers: {
                "IM-Authorization": n.state.imkit.config.token,
                "IM-Client-Key": n.state.imkit.config.clientKey
              }
            }
          });
          i.value = p, r.value = 1;
          break;
        }
        case 2:
        case 4:
          (l = i.value) == null || l.play(), r.value = 3;
          break;
        case 3:
          (f = i.value) == null || f.pause(), r.value = 4;
          break;
      }
    }, d = async (l) => {
      if (!i.value || !a.value) return;
      const { x: f, width: p } = a.value.getBoundingClientRect();
      s.value = (l.clientX - f) / p * 100, i.value.seek(i.value.duration() * s.value / 100);
    };
    return (l, f) => (X(), se(wt, null, [
      W("div", {
        class: vt(["pointer-events-none absolute top-0 bottom-0 left-0", [o.value ? "bg-gray-300" : "bg-blue-300"]]),
        style: Qt({ width: `${s.value}%` })
      }, null, 6),
      W("div", {
        ref_key: "container",
        ref: a,
        class: "relative flex w-full items-center justify-between p-1",
        onClick: d
      }, [
        W("button", {
          onClick: ar(c, ["stop"])
        }, [
          (/* @__PURE__ */ new Set([
            0,
            2,
            4
            /* Paused */
          ])).has(r.value) ? (X(), se(wt, { key: 0 }, [
            o.value ? (X(), se("img", o5e)) : (X(), se("img", u5e))
          ], 64)) : r.value === 1 ? (X(), se("div", l5e, [
            (X(), se("svg", {
              class: vt(["h-5 w-5 animate-spin", [
                o.value ? "fill-gray-100 text-gray-400" : "fill-blue-400 text-gray-200 dark:fill-sky-700 dark:text-gray-700"
              ]]),
              viewBox: "0 0 100 101",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg"
            }, f[0] || (f[0] = [
              W("path", {
                d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                fill: "currentColor"
              }, null, -1),
              W("path", {
                d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                fill: "currentFill"
              }, null, -1)
            ]), 2))
          ])) : r.value === 3 ? (X(), se(wt, { key: 2 }, [
            o.value ? (X(), se("img", c5e)) : (X(), se("img", d5e))
          ], 64)) : Fe("", !0)
        ]),
        f[1] || (f[1] = W("div", { class: "w-[200px]" }, null, -1)),
        W("div", f5e, _e(Math.floor(l.message.duration / 60)) + ":" + _e(`${Math.floor(l.message.duration % 60)}`.padStart(2, "0")), 1)
      ], 512)
    ], 64));
  }
}), p5e = { class: "flex items-center justify-center" }, m5e = { class: "my-3 rounded-lg bg-gray-100 px-2 py-1.5 text-sm text-gray-700 dark:bg-zinc-700 dark:text-gray-200 dark:text-gray-300" }, g5e = /* @__PURE__ */ Ze({
  __name: "SystemMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = Yt(), r = de(() => n.state.imkit.users), { t: i } = Ri(), s = de(() => {
      var o;
      const a = (o = r.value[e.message.senderId]) == null ? void 0 : o.nickname;
      switch (e.message.type) {
        case ft.Recall:
          return e.message.senderId === n.state.imkit.uid ? i("youUnsentMessage") : i("someoneUnsentMessage", [a]);
        case ft.JoinRoom:
          return i("someoneJoinedTheChat", [a]);
        case ft.LeaveRoom:
          return i("someoneLeftTheChat", [a]);
        case ft.AddMember:
          return i("someoneInvited", [
            a,
            e.message.members.map((u) => u.nickname).join(", ")
          ]);
        case ft.DeleteMember:
          return i("someoneKicked", [
            a,
            e.message.members.map((u) => u.nickname).join(", ")
          ]);
        case ft.AddMembers:
          return i("someoneInvited", [
            a,
            e.message.members.map((u) => u.nickname).join(", ")
          ]);
        case ft.Announcement:
          return e.message.text;
        default:
          return "";
      }
    });
    return (a, o) => (X(), se("div", p5e, [
      W("div", m5e, _e(s.value), 1)
    ]));
  }
}), A5e = {}, b5e = { class: "flex h-4 items-center" };
function y5e(t, e) {
  return X(), se("div", b5e, [
    (X(), se(wt, null, on(3, (n) => W("div", {
      key: n,
      class: vt(["mr-0.5 h-1 w-1 rounded-full bg-gray-400", [`animate-bounce-${n}`]])
    }, null, 2)), 64))
  ]);
}
const v5e = /* @__PURE__ */ mn(A5e, [["render", y5e], ["__scopeId", "data-v-490ce08b"]]), T5e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABJCAYAAACesWDiAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAZgSURBVHgB7ZttbBRFGMf/s7ftvbSFKy+BQqEX0EKMSYsSjWmUQ8BPGNAYKUQE/EJITISgxm9toyYmxgQ/ESIR8IuNkkgQPxXkMCEYUVskKOWlPd56UtvecbS9be9ux5mVa+/6trdz2+zW7C+57N1k2lx/meeZmWemgIODg4N1ENr9cSfMJHEZSP4NYSg+J4+HDsAmyOwbBWAqEgrEDxtR8F/zf8cRpIMjSAdHkA6OIB0cQTrISHbBVOI9wGAU4lDYCRmJP2Eq3feAvhiEUe0lyAkxHRxBOjiCdHAE6eAI0sERpIMjSAcytoF2f3SWPYIQha+rzF18hshjobWwCGcE6eAI0sERpIMjSAdHkA6OIB1kzED2tm72yylPrSS5NoHyYytSy9sHehPoCz/kp3283hJji5i2tErPSWq6rXlPKAwBCL0ebMxpcS/dASIHIErPTaD/HwjjdYcwe/a5kc8UYVIdOsrfvnuxPigR+R1o6zQ67vzsP0HxiX8vQYim1WPNe348CgMQeiNoboXqVsEFsyaypacxu4mLIcTVQHQWsFMKGoGEqZpuyleUrUOMh1KxWtLARtFemAYNEEk6svXQhgaqJtfqhZ5tk/R7v2yrLU6XtJorJxsuSm6tP/jizql62VKQFlKSxPeEAUwvfj6atn2xvmGyDrYTdLls4RqJuM5OlISnC6qicTJJthIUlT04Pu+JIAwyu2guqrzVCJRUY9mcFagoWwKjcElbD6/bMbbdNrOYIsk4sPg5JskLo7wwdyN7vQxFUTAwMICOvqs4/OunECBG1dSq7MQtQ/LAVGQ3UFwEo7SULROSYzJ+4pKPsOdI/YmwApm5I0igYBZVXfgkvhAi8NB6af4WLPBUjowgJTWIrvgdRPpvs9HUjr+6W2GQfV/vPq3dcrNFDmpRZkEEHlbbl+zX5GTjkX1aLqpbuoG91kOAhs1HgtokYbkgPnp+G/bBKFwOzz16RPrvQAC/d1jeyd9YLkhk9PBZKx85nFiiB0IQbOIPy7caHSk3jLKitGZc20+936P13s9IRFJYVLoEft88VLAnz0FCUAR5mFkqKJIu0kLMKFXeFTmfL8UvMEGnWIJmm9W+ODpFpYyBh5mlIXYvbXw5MBFKehDTASW0xlJBEUFBD5K9OZ9XltZqeclsJEpqWYiRXTmtSjsrL6QCEKW7A4j35tU1WuITyoLt/W14pnzdyGcu583K/Qj7ruOWJ4wIWwP93nUehUJB/ONPVm8ECztZNbDVOFSxGh2eORBhOxNS5avOacssFDlRNnudam8WWSTmMGOL9ifvHx0XatmUe+dhe+3beGpRHQphxgricr66+5kWblOxcWU9/B7x/GTpNF+eVNi+AMJwSd92HdS2Gnzqdw+VYk6qAovKlo704duOpxfX4czNkzAOCVsqyKsmYQb3lbvaK1O0f+3Jt3JCi78XEkRp2NIQqxh+iOngyv3CEvMo5JKlgpYrhVw4n5yKWbkVRSWVgAiUpttkGvkwmNM69IefrYMgjIeNitLhvLqW8xcdRpQUwygeyYfn2YZ1SB1EjOUiJZ1AVOnFquWLUVeVW+KIKoIbVqghGS5yNqfNV4OCqGRVwWRZ3t1Xs7VLi2Jc0AJ3JZ7NWixylLmj66Bszt9qgWEoQrz0avk0X+cegAgeV341pPO3W4Q2r5Sqx/jTckFeomKZPASjuF369Wu+3fjhajOMQ8OZo2lbHD2/7osarknznHONLRLdLBf52V4se7PKtxnHr3wpXPagKm3KvLeFoHIpjQ2euKHqIpdz7dEqOnPsk4EL6hQvlIWyLzbYZquxns1+FS5zFo7i0DClqZzqhi2OfTLw6uKh/vmGq4x8yvewnDQQVdB3+4HWFkvkV3LJJg36yje7z5zIbrPVZpWH2qu+KP+Cho5mlUdrodhQjyZGRA5j31g5HBlpau4tdvZlC/mvymo6FGZJ0k8k8h2m/3aHBlXVXZNdqCKwKR9cqA+oRS5DV2Dyu2GWDcs5KmFyTocm62FbQRnev/hGI8uUDfn0NSSIzVY8IevdMLO9II42mlyuRpYxd0zVLy9Bmhg0TTVqspkRgjJkiVqDCUJvMkEENKZSnGDnOMfyFTP6szMUfoeREhIkRLsnXcP+ED8T5O/rfMgGCQ3z/EJUcokStCmeVNuJXaECrt46ODg4WMO/G9ahtHi84EEAAAAASUVORK5CYII=", YT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEUAAAAUCAYAAADbX/B7AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAXjSURBVHgBzVhpbFRVFP5m35hO2WlZigVpIQjKQBRkVeISAwTihpqYSAwYEzGKC/pHCSAmGKOkivqLREUpEheWgKJBSjDBgBRrJS2bZbHbdErbmfdmec9z7nsz8zqdVxpam37N15l737nbuWd7Y8EAhPvwyi/htC1QE2oH+hEWr92vVNTtsGCgYV5Rgbd82VWlukmlbfbv/lRVhc9psWKgIRKLQ06i3xUCsaQFkTjsWd2sJCWrz0ZMGtoOYtw4lf6p6t/VrPksWeNzIde6adD9IaHGaCJrehm71YHOS/UdWCmvEQuJ3xMP55DhA60njiT+rMvNIT4GTUEv6jJJfZcTiS8RE8RXiTJxkz5X9sEDxJ3E4zABW7TVasUM7y2QlaS4TIX6qsJVpEoHPM58JFVTfd4UjDf7B/GOHDIuoqR//504i7iX+JDeV0mcDk3BrIj3oCmFUUq8RmyFOX4h3pNuBQuGefesaFTOh0VTTkSxfORsfHPbuk6DWFn3n96MH+uPweMaSofoO6sxxpRmExleLZEl06h/8hVNIz5nkGkxjI0hYx1m1ymhG7BlSEltalZEQ6wV7UlZ9B+6/U0UekaQ5STFJqVoPaS2S5DkEOR4h2jHSJbHSdEGSFIzrHoYtfK8UhOxUVieMYD1NtDyeN7xR8ShPZDdo8uN0zmB+DB6uI9wMoKR+xbC/8Ns1Eb+FX3rix+HTIe3xduxO7gRNfeWY1PJs3i0YAG+Dm7AnPwpGGbzoJy+b5u6FlEpBBspJhq7ju3T1mHXjLcQsHvIBTOWZkfvoCLjNn8SC6AFZjNEie3IWA3LsqX0KNMIIYWWstppwWS605qU0PLgQTgt2nHeGL88PeZsx1VsuHwAS4fPFM93NxzHr40nsHTUIqwuXExWJ6Gx7QJc3lHpMb21FC6urujz8KwctCtNZFkRT0ILvC06m4jluHF2EsijGz3zwH6EllSg1Dta9L1b/Ql2zHpHHLieXKvk2Bo8UfVhZoOKJG7s/X/2ifbWiU9DDZ3G5ltXivaWS9/R1bhIt5l76a1S3MQifR4+7BbiIyayZtbgRw/BFj7VNxaD7T4RWFec2YrL12swn1yEcd+pt3GRXGlnzQ58S9YgxvA/ijtbzn8l2jPzilE8bimmeMeIdtn5crhdnT2/t+7D4z3EZURSuahf+AoS6Do3K+UCka8spYghxM/QQ0SVGILH1yLgGkIp+S9EKcDCPQIRRRbP7wyUoPLaEbLJGKb4xnRaONxeh4rw35ibX4qzc8pE/5FwNcJSPdyDirocKoWbfc9wQqtdOLUuQibO5MJuaLVLNtjius1CDM4S58j/LbEwbPZBcFEGiVls+KBuPz6m4Ppp6WqymskI+osxyVuQHscWZvcV4vXaz1Exc6MItIxXqO0wyKVgdJ+FxKPEEzqreRxu7O8cK/gyFkNLwd3JryJWGNY4S3we3SiE06nTqunYR77Pi3E1a9HfAtzOALbXfoG9zSdF+6lR8zGZrERWtTQeIFfjLTqsLhyrP4o6uVlstinehhP1FTSXq8uaxhvNI87Nej4bmUMjx2fqeyqf3UXk3aXcJzuOsLvcndXHRWAZTOCye3EgdArTf3sZ1ykl29yDOz1XqJr1+4uwhJ5PHx5EMG8CDjWdRFusHRNJOTVyA1zkbmKDVBFfpLpkLMWQsisHaYfenEUfb5yrTUeO/bBbhPUDR6CZeOqdR9YJQx8r4BRxG3GNPo6fKbqSYiZrXEG3UEVmqI5eFUs4LM4uB4nTYT2kgKr2y6hsrYWd6hILuUhlpI5G2EShptDf+PwSzAuUijHbzu3qEmBhUEo+zDMDr872lYeMRXiJqw0HT7kgH56V+wK096GUhdn0/u7WSNU6prBZbLqwajKJSq5gJw5C5+NpiMkteGbSKrQmIvgpdAbNUgPchmBsxMD7PSXr3aevYCeldpBiVCrt4fAhwHFHieeWxUBDXPlffuNJUPp2OcngmYScCtF//Bh4PzKN9reqmXjVvxABQg39B+myETAgZJSMAAAAAElFTkSuQmCC", XT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAUCAYAAADLP76nAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAPZSURBVHgBvVddchpHEO7uXf8lqQp+dITt5QbkBFndAJ0AXJWAkhcW6QCSDiBYvyQIpUpwguATCJ/A6ATaiiQ7byFVia1IzIy7lx20yKiEDeirWpid6b+Z6b9FWBLWg3fekFTBQfoBjMnv1VdysAS4sxIGwXHmX3DzLgyjZpiLbqNXpHwHsMHGwzJBsxBVNt8efqD7fztEh4ru+fC5QNOHJWGmDfApevCZcLTTQ61XH+mLx3u72e9hSUD5Efd4Tw+riCYPGjKjFd3XGjr7YbZf2Tg75hkvYekaUEf8P2jVs2F542Q7mR8YDT0irJp4rDtIpmAVtepPt8sbZ1uYyEF9saPpYdHq1Kg7+/Vs+7qBn9iGJhJe68auBNsH0ocI2gNjtxSr8EmYAFYnRZoCAolhIiDk8daYg+I5D8FEhuAovcbYRkSfb9OPpdD9EusEq5NYX2XzrPpIXayGYW4gNDfZJrw/196Vfms86ZBxzMHV6c4ND+aBgfx7ejDetGHj0zJ5DwM75hsL14Njj+yJjAgw5OvJie8aMDVAjD5Vol/KutZmbYoJkfDxDezA7YiMVmsiC0a3GYN5A3GbnzZOSynjxW1yrfrKY9GfzGU0uSVXdsU3E/s9+5k/BPfV7+HTHr/2pmnViP39RnbqmtL6RcILiQE3w+hXrfBZV4a/BKdrivCNXfqP7hUIqWhTMB/Ky73E5x2DbYVQHW2WiuzmunMlFPKSKiVobzVgXiB9a4e/cqKAiVvgA53IfLglNsnDG/0jJSVD/5vhdupaLNi38KBSe3sId4UJdzWZiaWRh3ipxyLjtkcRH3DEh5pLPwJWx0TsUj8GJz7cAQy3G3hl8mByEXsG1etpfG55889Ca/dZtxk+ifg9LAXH7QdcdS0BEfhpBhsvi0Sl9hcfmhrL5QTRJ4TXnHY9Oyd1ZBqvi8ZpcIE5YOKeMUpy9/MJCmkDDBTHr7E/nj43nLlb9e9q8OUocYsivs6nrUqp+UgSwXpwwgePxcQGv7x59kYCP7GB4wcLkjTc0UQcNLZApRGRUn0g7JirosQnhYEUKx7PswHxm+v6wKbgJm+iXDvtYLIJ5ATD/pC/Ts+xCtMbLTTcy1ysSsk+18OQfbQDC0S6KNl3qSHNVDvRamSlWu/cYF9fOmN3b3dlTQrHObfKnKI8WXP0ZS/dMieBXuJrbQsNF5/BV6B6sRwuMJbum5RRX+vL7vkNtSTmA+iiph0Nl/GpijzbQqTRZN9n+0Jrn+gmUH1rH8IdQtryVOVv80fOC5gTs7XTy4DR/8ACMPMX2UIgGYdjC7Q50twSwALwEa6d2w/lUFKNAAAAAElFTkSuQmCC", KT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAAAUCAYAAAAeLWrqAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAkwSURBVHgB5Vl7UFTXGf/dvftmd2HBZUEgEPFRwIQiStQYSzRB42PaptKgmamtmTEzTTKJnY5jI1WTaibNP2ljzOjUqRknqabKaCPGmKnWGhVNxBc+EJXwWESXZVlYdpfdvXtvv3svL5e7QBw7+cNvZt17zzl855zf+X3f9zsrg1g26XfvIuJXgxGEgUYVwNI//nYXVJFzaKg4Qo2c3AEeD7Exiq1p82cgo/QUgu0KnYQroyHo1IA2EfBeW4+aTW/3+hLwkJpKsZVNLEKok2CJKHyIeHyQeOgD/E089BlvYdzyX+AhN2UgTSlPgQ9FNTJKHxXCbgGWqX/BQ8xG0dSKrVpb/r240HM4cC/sYjdDYKp0DDTKGSLKRgr9/0dqeJC5m6VPJJZvZQSKtvYg1KGTh2vAdDZSKPcoD+fJ94TciJATyMaWckfUZIONQXrpPFgmloIP++WlsQx67nDgQofR+OkhyAfL4UHam/t+Dat9OnguLL3r9CrcqgnA17Eff//9CWqhhI/wqHxt+HI1TPGPwu/9DutK3hvcpYCMzYTp73lpg/IrS0C234oFOeVJP4SF88JYWcZiuliBhmFV4fsNlF8z5RfxQEXM1SKrAUOyAyfKMvCgmXnA74PTaZSeWSIVR+ekofks1KTyVeOnaVO/h68A2tr06HRWYdW0mYO7hubIpOwMCIMOiKc9CTFIIoa2h4pSyVw1mr0qvLD2CQxnrNEOUU0xtBGf4yBgvAAVbS7SLSBwNx2ZLy7DAw3vQg1YnVGKGq0hjMZrBxEfVytN4abcLiQUonRt0ahcjX9OB1avB0sH76itjO4eCqTePg2cf+BdLDqCwt5EENtcEH5VxhPYMl95TjnnSmaPI8mklx6F8DnUfbAI518vQI9zFxgKcSEkAt3HSPR+awY99xkb5ZiN2Tc7Nx0RIoW4+dt1e7G+ZBFKk3PI21kItIEwARzsThnkn/AoVivMycCWlAGO1IrRDLTWnohag0KxMWXMluRNn0VCMmh9JoIapsU52yCULeGx4DkVXC7SnklA/YVbiGVJOTLTGdqrr/nUwAosqZJPNYVa2Cu352/8Eoaxc0lu0YUA3ei8UgbTxAoCJIxb+2YjuagcuoSnoBujQ+sf7Who4CUQUlN1yNzkRMjdg0B3FbK1G+EjUhApcfPb4wOwCGaJlXravs9fi8KVBqwq/w+sqYUk71gEu9pw/uRv8fiMnYgzAJ++Mxnq+MckX/EW4PzZG9HbG8pInW2apBVFE0/SI4pyFY8Iz0vtFrMgzCzihW2bBSycJ4PIU58oPKsPtyKWxaVOBReQgYxQYrUvnoPc1ZuhMRaLVIaGFti8+2s8uZvQVj1N7ghEFUe+TdClVlLxY2nvJuCuF13V24jdNoRcFnCFSyCzJ4JH3r4Kf4uGoioJ1w48jzHjnkePXy6I1rFqlK5+Fh9e3EM5eRIiXARapgtH/laHLdt88PryEfDTvY3hwOhtyJ6yB51eLVSE5Ff72pCZV4we0s4CI+Da4TvR2xvKSN2YLIS75GePF1heJghPFjAIheX1ChTG/gCDAIHS7RPZKiBxjArHK1/CcHLDkDiLqrWYb3nE56yGNX81IqQEOD8HY7oaLSdmIn9DJbrrBeisWnhqy1D318+QWJyO8cuaCDS1dAhtPU1AZT0ylkTgv62CbdobcFR8gpw1a8F5M6Gj25brzAKgOozM3OmkCIjpPRwmF29GYQkxkPbk6+KRN57FqkWT8I+bl3HpRhjp2Toc3DYLW187iaUbHsfSNy/C6WDp70NwXffCnjUDEToQn6cNCnk8ipG5WrAGS/9rmBaRbhdw+y4Dl5s+xM52NyQQRVc8UTTZzoDxf4x3X6jAcIVCP/YJ6WZEcUW50Evs9kAd5yIw/4uGLx5B47bTMGYtpOLDUuhXSCCKJ+c+5oDnymei9qd8TShcDUmH5Ws6Ih2sdkyBVAjiczaSrxC4yDHUfXhImjN57EQpbYg+LUYPsdCDOKOTwDiI8hVWBOlQE7PyoDVqcO7oOglE0emuDZfgbKyWfHS2O6TvlLRx0vddxw2l7d3LyHh1mrzZvl7qTjCp4Av0AhsMIy1bI2kIASG4W69g7/uvYmf5NxhJA+qsWdK1U2/ncXqFJaqXgWmmrRdohph1AQPXJwEJOc9SaFNhcDX2j/dUvwXbMyUI3BFgXRxAoDEIE7Hq5ItPQy46POLik9FF0WU2t+JnlrQhc06Z/xg4QdSWQO3pmt75ZF1mH1cIJ5H/dvNlqd1oTYKX0kRr/amRgTRl5iESGHi3xAnQapl+INPHa/DOsiRU7enAAPv6NjyckCYxqk2QnoLuBoV+Ad2nOsCsFEM/gvi8P2HCy2fgqmnFuNLdCHmsEiODnm/6xzf+6xRSf04M9GqoX2S8Di37C9B3A5k81y6BIhbKlu+uKs5pSWmClp68Hh6/XLMHau0sOBvCeGNzJZpucTCYSdZdPo78OWPFNA5DHEmfm8eVNnhvaBtTfoJIb8UW64fNiv7CIxrn6yYQ3RhyfxxB+1lmZ8mpkzYVctfGGBWmH0E+gNrMItTOwZLzFSb+poZuVhOkNagk7Xlm0HgGHWe3S9KJbl/E1h1o2CMyWQ6pgmfyxMsC6Ueg4cppxRmPfeyB++4hYq5KYt/iV07jtY+q0dmTRMWM0gEB19pQhYL5csU2U/VvuaZ0KFFAmn80B3qSMfpkWgB90lIZBIMDIHV4mnE/xvqCCNKVTOD3o/3rNTFGqXBx3evovL6CQKujwlSL9gvr4dhBp8l+QZHyOboO/7N3rKgvKaQLXpIYrE3swoU1KzBYR3rueCn1VCDkr8SNb7fHmFONsvQFuHxyLXTaenQ5r+LsgZex5ZUskmqfo615L/ZuqoKjppv8VcBV/wmO7KhXchQtdInu6Ql0Gjw8wRD+vGs7bI8uleSDijB3XN+JdfOW4/vbaK99fesRYvztQH/RlioK9SlU8bW49FEKfGfEasrfx/xKSmPw+Oh+RWUyOEfKIdHlcPe35OeXICxfU2Em35eO/xv3Z6O99gkjtMnPueV/gMY6nUQy5bfaVwlEJ4afY7g+foTx/CjGY7jfv9T4cbEJ5kSD9KZJVuHo1hb88L+EM0jIioc6yQCBclv7UXFNP/h/dfwPO3KtjligtFoAAAAASUVORK5CYII=", _5e = ["width", "height"], E5e = ["fill"], Jf = {
  __name: "AlertSvg",
  props: {
    width: {
      type: [Number, String],
      default: 50
    },
    height: {
      type: [Number, String],
      default: 50
    },
    color: {
      type: [String],
      default: "#FF4D4F"
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      viewBox: "0 0 50 50",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      W("g", {
        "clip-path": "url(#ovlhak8zza)",
        fill: e.color
      }, r[0] || (r[0] = [
        W("path", { d: "M25 0C11.215 0 0 11.215 0 25s11.215 25 25 25 25-11.215 25-25S38.785 0 25 0zm0 45.161C13.883 45.161 4.839 36.117 4.839 25S13.883 4.839 25 4.839 45.161 13.883 45.161 25 36.117 45.161 25 45.161z" }, null, -1),
        W("path", { d: "M25 12.299a2.419 2.419 0 0 0-2.42 2.42v13.219a2.42 2.42 0 0 0 4.839 0v-13.22a2.419 2.419 0 0 0-2.42-2.42zM25 37.12a2.42 2.42 0 1 0 0-4.84 2.42 2.42 0 0 0 0 4.84z" }, null, -1)
      ]), 8, E5e),
      r[1] || (r[1] = W("defs", null, [
        W("clipPath", { id: "ovlhak8zza" }, [
          W("path", {
            fill: "#fff",
            d: "M0 0h50v50H0z"
          })
        ])
      ], -1))
    ], 8, _5e));
  }
}, x5e = { class: "relative flex flex-col items-center justify-between" }, w5e = { class: "mt-5 text-xl font-medium text-gray-700 dark:text-gray-300" }, C5e = { class: "mt-5 text-sm font-medium text-gray-700 dark:text-gray-300" }, S5e = { class: "mt-5 flex items-center justify-center" }, sO = /* @__PURE__ */ Ze({
  __name: "PaymentErrorModal",
  setup(t) {
    const e = $n();
    return (n, r) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[360px] max-w-full rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", x5e, [
          W("button", {
            class: "absolute right-0 top-0 flex items-center justify-center",
            onClick: r[0] || (r[0] = (i) => ke(e).closeAll())
          }, [
            et(Br, { class: "h-6 w-6" })
          ]),
          et(Jf, {
            width: "50",
            height: "50"
          }),
          W("h1", w5e, _e(n.$t("paymentFailed")), 1),
          W("p", C5e, _e(n.$t("paymentFailedDescription")), 1)
        ]),
        W("div", S5e, [
          W("button", {
            class: "h-10 grow rounded-lg bg-[#02B13F] text-base text-white",
            onClick: r[1] || (r[1] = (i) => ke(e).closeAll())
          }, _e(n.$t("confirm")), 1)
        ])
      ]),
      _: 1
    }));
  }
}), I5e = { class: "relative flex flex-col items-center justify-between" }, k5e = { class: "text-base font-medium text-gray-700 dark:text-gray-300" }, D5e = { class: "mt-5 flex w-full items-baseline" }, M5e = { class: "mr-2 text-[18px] font-medium text-gray-700 dark:text-gray-300" }, O5e = { class: "h-full min-h-[39px] text-[40px] font-medium dark:bg-zinc-800" }, N5e = { class: "mt-5 flex w-full flex-col" }, L5e = { class: "text-sm font-normal text-[#6B7280] dark:text-gray-300" }, P5e = { class: "text-sm font-normal text-gray-700 dark:text-gray-300" }, R5e = { class: "mt-4 flex w-full flex-col" }, B5e = { class: "text-sm font-normal text-[#6B7280] dark:text-gray-300" }, F5e = { class: "text-sm font-normal text-gray-700 dark:text-gray-300" }, U5e = {
  key: 0,
  class: "mt-2 flex w-full flex-col"
}, $5e = { class: "mr-2 text-sm font-normal text-[#939393] dark:text-gray-300" }, H5e = { class: "mt-1 flex" }, j5e = {
  key: 0,
  class: "mr-4",
  src: YT,
  alt: "LINE Pay Logo"
}, z5e = {
  key: 1,
  class: "mr-4",
  src: XT,
  alt: "Stripe Logo"
}, q5e = {
  key: 2,
  class: "mr-4",
  src: KT,
  alt: "Paypal Logo"
}, V5e = { class: "mt-4 flex w-full flex-col" }, W5e = { class: "text-sm font-normal text-[#6B7280] dark:text-gray-300" }, Q5e = { class: "text-sm font-normal text-gray-700 dark:text-gray-300" }, G5e = { class: "mt-5 flex items-center justify-center" }, Y5e = /* @__PURE__ */ Ze({
  __name: "PaymentRequestDetailModal",
  props: {
    uid: {},
    paymentId: {},
    paymentType: {},
    payer: {},
    payee: {}
  },
  setup(t) {
    const e = t, n = Yt(), r = $n(), { t: i } = Ri(), s = (p) => {
      switch (p) {
        case 0:
          return i("paymentFlowUnpaid");
        case 1:
          return i("paymentFlowPaid");
        case 2:
          return i("paymentFlowRefund");
        case 3:
          return i("paymentFlowAuthorizationError");
        default:
          return i("paymentFlowUnpaid");
      }
    }, a = Se(), o = de(() => {
      var p;
      return ((p = a.value) == null ? void 0 : p.data.method) !== -1;
    }), u = de(() => {
      var p;
      return ((p = a.value) == null ? void 0 : p.data.method) === 0;
    }), c = de(() => {
      var p;
      return ((p = a == null ? void 0 : a.value) == null ? void 0 : p.data.method) === 1;
    }), d = de(() => {
      var p;
      return ((p = a == null ? void 0 : a.value) == null ? void 0 : p.data.method) === 2;
    }), { open: l } = Jn({ component: sO }), f = async () => {
      try {
        a.value = await n.state.imkit.config.callbacks.onPaymentDetailFetched(
          e.paymentId
        );
      } catch (p) {
        console.error(p), l();
      }
    };
    return Tr(() => {
      f();
    }), (p, m) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[400px] max-w-full rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => {
        var g, y, b, E, v, _, D, S;
        return [
          W("div", I5e, [
            W("button", {
              class: "absolute right-0 top-0 flex items-center justify-center",
              onClick: m[0] || (m[0] = (M) => ke(r).closeAll())
            }, [
              et(Br, { class: "h-6 w-6" })
            ]),
            W("h1", k5e, _e(p.$t("paymentRequestDetail")), 1),
            W("div", D5e, [
              W("p", M5e, _e((g = a.value) == null ? void 0 : g.data.currency), 1),
              W("p", O5e, _e((y = a.value) == null ? void 0 : y.data.amount), 1)
            ]),
            W("div", N5e, [
              W("p", L5e, _e(p.$t("paymentRequestTime")), 1),
              W("p", P5e, _e(((b = a.value) == null ? void 0 : b.data.request_at) && new Date((E = a.value) == null ? void 0 : E.data.request_at).toLocaleString()), 1)
            ]),
            W("div", R5e, [
              W("p", B5e, _e(p.$t("status")), 1),
              W("p", F5e, _e(((v = a.value) == null ? void 0 : v.data.payment_at) && new Date((_ = a.value) == null ? void 0 : _.data.payment_at).toLocaleString()) + " " + _e(s(((D = a.value) == null ? void 0 : D.data.status) || 0)), 1)
            ]),
            o.value ? (X(), se("div", U5e, [
              W("p", $5e, _e(p.$t("paymentMethods")), 1),
              W("div", H5e, [
                u.value ? (X(), se("img", j5e)) : Fe("", !0),
                c.value ? (X(), se("img", z5e)) : Fe("", !0),
                d.value ? (X(), se("img", q5e)) : Fe("", !0)
              ])
            ])) : Fe("", !0),
            W("div", V5e, [
              W("p", W5e, _e(p.$t("paymentRequestMessage")), 1),
              W("p", Q5e, _e(((S = a.value) == null ? void 0 : S.data.note) ?? ke(i)("paymentSendPaymentRequestMessageEmpty")), 1)
            ])
          ]),
          W("div", G5e, [
            W("button", {
              class: "h-10 grow rounded-lg bg-[#02B13F] text-base text-white",
              onClick: m[1] || (m[1] = (M) => ke(r).closeAll())
            }, _e(p.$t("confirm")), 1)
          ])
        ];
      }),
      _: 1
    }));
  }
}), X5e = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, aO = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, cr = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, ui = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, fo = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Ge {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(e, n) {
    const r = n.match(e);
    return r && r.length > 0 && r[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(e, n) {
    const r = n.match(e);
    return r && r.length > 1 && r[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(e, n, r) {
    if (e.test(n))
      return r;
  }
  static getWindowsVersionName(e) {
    switch (e) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(e) {
    const n = e.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), n[0] === 10)
      switch (n[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(e) {
    const n = e.split(".").splice(0, 2).map((r) => parseInt(r, 10) || 0);
    if (n.push(0), !(n[0] === 1 && n[1] < 5)) {
      if (n[0] === 1 && n[1] < 6) return "Cupcake";
      if (n[0] === 1 && n[1] >= 6) return "Donut";
      if (n[0] === 2 && n[1] < 2) return "Eclair";
      if (n[0] === 2 && n[1] === 2) return "Froyo";
      if (n[0] === 2 && n[1] > 2) return "Gingerbread";
      if (n[0] === 3) return "Honeycomb";
      if (n[0] === 4 && n[1] < 1) return "Ice Cream Sandwich";
      if (n[0] === 4 && n[1] < 4) return "Jelly Bean";
      if (n[0] === 4 && n[1] >= 4) return "KitKat";
      if (n[0] === 5) return "Lollipop";
      if (n[0] === 6) return "Marshmallow";
      if (n[0] === 7) return "Nougat";
      if (n[0] === 8) return "Oreo";
      if (n[0] === 9) return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(e) {
    return e.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(e, n, r = !1) {
    const i = Ge.getVersionPrecision(e), s = Ge.getVersionPrecision(n);
    let a = Math.max(i, s), o = 0;
    const u = Ge.map([e, n], (c) => {
      const d = a - Ge.getVersionPrecision(c), l = c + new Array(d + 1).join(".0");
      return Ge.map(l.split("."), (f) => new Array(20 - f.length).join("0") + f).reverse();
    });
    for (r && (o = a - Math.min(i, s)), a -= 1; a >= o; ) {
      if (u[0][a] > u[1][a])
        return 1;
      if (u[0][a] === u[1][a]) {
        if (a === o)
          return 0;
        a -= 1;
      } else if (u[0][a] < u[1][a])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(e, n) {
    const r = [];
    let i;
    if (Array.prototype.map)
      return Array.prototype.map.call(e, n);
    for (i = 0; i < e.length; i += 1)
      r.push(n(e[i]));
    return r;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(e, n) {
    let r, i;
    if (Array.prototype.find)
      return Array.prototype.find.call(e, n);
    for (r = 0, i = e.length; r < i; r += 1) {
      const s = e[r];
      if (n(s, r))
        return s;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(e, ...n) {
    const r = e;
    let i, s;
    if (Object.assign)
      return Object.assign(e, ...n);
    for (i = 0, s = n.length; i < s; i += 1) {
      const a = n[i];
      typeof a == "object" && a !== null && Object.keys(a).forEach((u) => {
        r[u] = a[u];
      });
    }
    return e;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(e) {
    return X5e[e];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(e) {
    return aO[e] || "";
  }
}
const Ln = /version\/(\d+(\.?_?\d+)+)/i, K5e = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(t) {
      const e = {
        name: "Googlebot"
      }, n = Ge.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, n = Ge.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(t) {
      const e = {
        name: "Samsung Internet for Android"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/Whale/i],
    describe(t) {
      const e = {
        name: "NAVER Whale Browser"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(t) {
      const e = {
        name: "MZ Browser"
      }, n = Ge.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/focus/i],
    describe(t) {
      const e = {
        name: "Focus"
      }, n = Ge.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/swing/i],
    describe(t) {
      const e = {
        name: "Swing"
      }, n = Ge.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/coast/i],
    describe(t) {
      const e = {
        name: "Opera Coast"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(t) {
      const e = {
        name: "Opera Touch"
      }, n = Ge.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/yabrowser/i],
    describe(t) {
      const e = {
        name: "Yandex Browser"
      }, n = Ge.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(t) {
      const e = {
        name: "UC Browser"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(t) {
      const e = {
        name: "Maxthon"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/epiphany/i],
    describe(t) {
      const e = {
        name: "Epiphany"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/puffin/i],
    describe(t) {
      const e = {
        name: "Puffin"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/sleipnir/i],
    describe(t) {
      const e = {
        name: "Sleipnir"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/k-meleon/i],
    describe(t) {
      const e = {
        name: "K-Meleon"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/micromessenger/i],
    describe(t) {
      const e = {
        name: "WeChat"
      }, n = Ge.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(t) {
      const e = {
        name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser"
      }, n = Ge.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/msie|trident/i],
    describe(t) {
      const e = {
        name: "Internet Explorer"
      }, n = Ge.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/\sedg\//i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, n = Ge.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, n = Ge.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/vivaldi/i],
    describe(t) {
      const e = {
        name: "Vivaldi"
      }, n = Ge.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/seamonkey/i],
    describe(t) {
      const e = {
        name: "SeaMonkey"
      }, n = Ge.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/sailfish/i],
    describe(t) {
      const e = {
        name: "Sailfish"
      }, n = Ge.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/silk/i],
    describe(t) {
      const e = {
        name: "Amazon Silk"
      }, n = Ge.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/phantom/i],
    describe(t) {
      const e = {
        name: "PhantomJS"
      }, n = Ge.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/slimerjs/i],
    describe(t) {
      const e = {
        name: "SlimerJS"
      }, n = Ge.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = {
        name: "BlackBerry"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = {
        name: "WebOS Browser"
      }, n = Ge.getFirstMatch(Ln, t) || Ge.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/bada/i],
    describe(t) {
      const e = {
        name: "Bada"
      }, n = Ge.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/tizen/i],
    describe(t) {
      const e = {
        name: "Tizen"
      }, n = Ge.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/qupzilla/i],
    describe(t) {
      const e = {
        name: "QupZilla"
      }, n = Ge.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(t) {
      const e = {
        name: "Firefox"
      }, n = Ge.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/electron/i],
    describe(t) {
      const e = {
        name: "Electron"
      }, n = Ge.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(t) {
      const e = {
        name: "Miui"
      }, n = Ge.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/chromium/i],
    describe(t) {
      const e = {
        name: "Chromium"
      }, n = Ge.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) || Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(t) {
      const e = {
        name: "Chrome"
      }, n = Ge.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  {
    test: [/GSA/i],
    describe(t) {
      const e = {
        name: "Google Search"
      }, n = Ge.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Android Browser */
  {
    test(t) {
      const e = !t.test(/like android/i), n = t.test(/android/i);
      return e && n;
    },
    describe(t) {
      const e = {
        name: "Android Browser"
      }, n = Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(t) {
      const e = {
        name: "PlayStation 4"
      }, n = Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(t) {
      const e = {
        name: "Safari"
      }, n = Ge.getFirstMatch(Ln, t);
      return n && (e.version = n), e;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(t) {
      const e = /^(.*)\/(.*) /, n = /^(.*)\/(.*)[ \t]\((.*)/, i = t.search("\\(") !== -1 ? n : e;
      return {
        name: Ge.getFirstMatch(i, t),
        version: Ge.getSecondMatch(i, t)
      };
    }
  }
], Z5e = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(t) {
      const e = Ge.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
      return {
        name: ui.Roku,
        version: e
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(t) {
      const e = Ge.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
      return {
        name: ui.WindowsPhone,
        version: e
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(t) {
      const e = Ge.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t), n = Ge.getWindowsVersionName(e);
      return {
        name: ui.Windows,
        version: e,
        versionName: n
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(t) {
      const e = {
        name: ui.iOS
      }, n = Ge.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
      return n && (e.version = n), e;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(t) {
      const e = Ge.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(/[_\s]/g, "."), n = Ge.getMacOSVersionName(e), r = {
        name: ui.MacOS,
        version: e
      };
      return n && (r.versionName = n), r;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(t) {
      const e = Ge.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t).replace(/[_\s]/g, ".");
      return {
        name: ui.iOS,
        version: e
      };
    }
  },
  /* Android */
  {
    test(t) {
      const e = !t.test(/like android/i), n = t.test(/android/i);
      return e && n;
    },
    describe(t) {
      const e = Ge.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t), n = Ge.getAndroidVersionName(e), r = {
        name: ui.Android,
        version: e
      };
      return n && (r.versionName = n), r;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = Ge.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t), n = {
        name: ui.WebOS
      };
      return e && e.length && (n.version = e), n;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = Ge.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) || Ge.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) || Ge.getFirstMatch(/\bbb(\d+)/i, t);
      return {
        name: ui.BlackBerry,
        version: e
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(t) {
      const e = Ge.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
      return {
        name: ui.Bada,
        version: e
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(t) {
      const e = Ge.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: ui.Tizen,
        version: e
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: ui.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: ui.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(t) {
      const e = Ge.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: ui.PlayStation4,
        version: e
      };
    }
  }
], J5e = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(t) {
      const e = Ge.getFirstMatch(/(can-l01)/i, t) && "Nova", n = {
        type: cr.mobile,
        vendor: "Huawei"
      };
      return e && (n.model = e), n;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: cr.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: cr.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: cr.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: cr.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: cr.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: cr.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(t) {
      const e = t.test(/ipod|iphone/i), n = t.test(/like (ipod|iphone)/i);
      return e && !n;
    },
    describe(t) {
      const e = Ge.getFirstMatch(/(ipod|iphone)/i, t);
      return {
        type: cr.mobile,
        vendor: "Apple",
        model: e
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: cr.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: cr.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(t) {
      return t.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: cr.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(t) {
      return t.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: cr.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(t) {
      return t.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: cr.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(t) {
      const e = Number(String(t.getOSVersion()).split(".")[0]);
      return t.getOSName(!0) === "android" && e >= 3;
    },
    describe() {
      return {
        type: cr.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(t) {
      return t.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: cr.mobile
      };
    }
  },
  /* desktop */
  {
    test(t) {
      return t.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: cr.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(t) {
      return t.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: cr.desktop
      };
    }
  },
  /* Linux */
  {
    test(t) {
      return t.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: cr.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(t) {
      return t.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: cr.tv
      };
    }
  },
  /* Roku */
  {
    test(t) {
      return t.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: cr.tv
      };
    }
  }
], eDe = [
  /* EdgeHTML */
  {
    test(t) {
      return t.getBrowserName(!0) === "microsoft edge";
    },
    describe(t) {
      if (/\sedg\//i.test(t))
        return {
          name: fo.Blink
        };
      const n = Ge.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
      return {
        name: fo.EdgeHTML,
        version: n
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(t) {
      const e = {
        name: fo.Trident
      }, n = Ge.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Presto */
  {
    test(t) {
      return t.test(/presto/i);
    },
    describe(t) {
      const e = {
        name: fo.Presto
      }, n = Ge.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Gecko */
  {
    test(t) {
      const e = t.test(/gecko/i), n = t.test(/like gecko/i);
      return e && !n;
    },
    describe(t) {
      const e = {
        name: fo.Gecko
      }, n = Ge.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: fo.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(t) {
      const e = {
        name: fo.WebKit
      }, n = Ge.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
      return n && (e.version = n), e;
    }
  }
];
class Yw {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(e, n = !1) {
    if (e == null || e === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e, this.parsedResult = {}, n !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(e) {
    return e.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const e = Ge.find(K5e, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(e) {
    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const e = Ge.find(Z5e, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS — macOS, Windows, Linux, etc.
   */
  getOSName(e) {
    const { name: n } = this.getOS();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(e = !1) {
    const { type: n } = this.getPlatform();
    return e ? String(n).toLowerCase() || "" : n || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const e = Ge.find(J5e, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(e) {
    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const e = Ge.find(eDe, (n) => {
      if (typeof n.test == "function")
        return n.test(this);
      if (n.test instanceof Array)
        return n.test.some((r) => this.test(r));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Ge.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(e) {
    const n = {};
    let r = 0;
    const i = {};
    let s = 0;
    if (Object.keys(e).forEach((o) => {
      const u = e[o];
      typeof u == "string" ? (i[o] = u, s += 1) : typeof u == "object" && (n[o] = u, r += 1);
    }), r > 0) {
      const o = Object.keys(n), u = Ge.find(o, (d) => this.isOS(d));
      if (u) {
        const d = this.satisfies(n[u]);
        if (d !== void 0)
          return d;
      }
      const c = Ge.find(
        o,
        (d) => this.isPlatform(d)
      );
      if (c) {
        const d = this.satisfies(n[c]);
        if (d !== void 0)
          return d;
      }
    }
    if (s > 0) {
      const o = Object.keys(i), u = Ge.find(o, (c) => this.isBrowser(c, !0));
      if (u !== void 0)
        return this.compareVersion(i[u]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(e, n = !1) {
    const r = this.getBrowserName().toLowerCase();
    let i = e.toLowerCase();
    const s = Ge.getBrowserTypeByAlias(i);
    return n && s && (i = s.toLowerCase()), i === r;
  }
  compareVersion(e) {
    let n = [0], r = e, i = !1;
    const s = this.getBrowserVersion();
    if (typeof s == "string")
      return e[0] === ">" || e[0] === "<" ? (r = e.substr(1), e[1] === "=" ? (i = !0, r = e.substr(2)) : n = [], e[0] === ">" ? n.push(1) : n.push(-1)) : e[0] === "=" ? r = e.substr(1) : e[0] === "~" && (i = !0, r = e.substr(1)), n.indexOf(
        Ge.compareVersions(s, r, i)
      ) > -1;
  }
  isOS(e) {
    return this.getOSName(!0) === String(e).toLowerCase();
  }
  isPlatform(e) {
    return this.getPlatformType(!0) === String(e).toLowerCase();
  }
  isEngine(e) {
    return this.getEngineName(!0) === String(e).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(e, n = !1) {
    return this.isBrowser(e, n) || this.isOS(e) || this.isPlatform(e);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(e = []) {
    return e.some((n) => this.is(n));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class tDe {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(e, n = !1) {
    if (typeof e != "string")
      throw new Error("UserAgent should be a string");
    return new Yw(e, n);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(e) {
    return new Yw(e).getResult();
  }
  static get BROWSER_MAP() {
    return aO;
  }
  static get ENGINE_MAP() {
    return fo;
  }
  static get OS_MAP() {
    return ui;
  }
  static get PLATFORMS_MAP() {
    return cr;
  }
}
const nDe = { class: "relative flex flex-col items-center justify-between" }, rDe = { class: "text-base font-medium text-gray-700 dark:text-gray-300" }, iDe = { class: "mt-5 flex w-full items-baseline" }, sDe = { class: "mr-2 text-[18px] font-medium text-gray-700 dark:text-gray-300" }, aDe = { class: "h-full min-h-[39px] text-[40px] font-medium dark:bg-zinc-800" }, oDe = { class: "mt-5 flex w-full flex-col" }, uDe = { class: "text-sm font-normal text-[#6B7280] dark:text-gray-300" }, lDe = { class: "text-sm font-normal text-gray-700 dark:text-gray-300" }, cDe = { class: "mt-4 flex w-full flex-col" }, dDe = { class: "text-sm font-normal text-[#6B7280] dark:text-gray-300" }, fDe = { class: "text-sm font-normal text-gray-700 dark:text-gray-300" }, hDe = { class: "mt-2 flex w-full flex-col" }, pDe = { class: "mr-2 text-sm font-normal text-[#939393] dark:text-gray-300" }, mDe = { class: "mt-1 flex" }, gDe = {
  key: 0,
  class: "mr-4 flex items-center"
}, ADe = {
  key: 1,
  class: "mr-4 flex items-center"
}, bDe = {
  key: 2,
  class: "mr-4 flex items-center"
}, yDe = { class: "mt-4 flex w-full flex-col" }, vDe = { class: "text-sm font-normal text-[#6B7280] dark:text-gray-300" }, TDe = { class: "text-sm font-normal text-gray-700 dark:text-gray-300" }, _De = { class: "mt-5 flex items-center justify-center" }, EDe = ["disabled"], xDe = /* @__PURE__ */ Ze({
  __name: "PaymentDetailModal",
  props: {
    uid: {},
    paymentId: {},
    paymentType: {},
    payer: {},
    payee: {}
  },
  setup(t) {
    const e = t, n = Yt(), { t: r } = Ri(), i = $n(), s = Se(!1), a = Se(), o = Se(""), u = de(() => n.state.imkit.config.settings), c = de(() => u.value.linePayEnabled), d = de(() => u.value.stripeEnabled), l = de(() => u.value.paypalEnabled), f = de(() => o.value !== ""), { open: p } = Jn({ component: sO }), g = tDe.getParser(window.navigator.userAgent).getBrowserName() === "Safari", y = async () => {
      try {
        s.value = !0, a.value = await n.state.imkit.config.callbacks.onPaymentDetailFetched(
          e.paymentId
        );
      } catch (v) {
        console.error(v), p();
      } finally {
        s.value = !1;
      }
    }, b = async () => {
      const v = o.value === "linepay" ? "line" : o.value, _ = await n.state.imkit.config.callbacks.onPaymentDetailUrlGenerated(
        e.paymentId,
        v
      );
      let D = null;
      g && (D = window.open("", "_blank")), _.url ? g ? setTimeout(() => D.location = _.url, 1e3) : window.open(_.url) : p(), i.closeAll();
    }, E = (v) => {
      switch (v) {
        case 0:
          return r("paymentFlowUnpaid");
        case 1:
          return r("paymentFlowPaid");
        case 2:
          return r("paymentFlowRefund");
        case 3:
          return r("paymentFlowAuthorizationError");
        default:
          return r("paymentFlowUnpaid");
      }
    };
    return Tr(() => {
      y();
    }), (v, _) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[400px] max-w-full rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => {
        var D, S, M, O, T, N;
        return [
          W("div", nDe, [
            W("button", {
              class: "absolute top-0 right-0 flex items-center justify-center",
              onClick: _[0] || (_[0] = (H) => ke(i).closeAll())
            }, [
              et(Br, { class: "h-6 w-6" })
            ]),
            W("h1", rDe, _e(v.$t("paymentDetail")), 1),
            W("div", iDe, [
              W("p", sDe, _e((D = a.value) == null ? void 0 : D.data.currency), 1),
              W("p", aDe, _e((S = a.value) == null ? void 0 : S.data.amount), 1)
            ]),
            W("div", oDe, [
              W("p", uDe, _e(v.$t("paymentRequestTime")), 1),
              W("p", lDe, _e(((M = a.value) == null ? void 0 : M.data.request_at) && new Date((O = a.value) == null ? void 0 : O.data.request_at).toLocaleString()), 1)
            ]),
            W("div", cDe, [
              W("p", dDe, _e(v.$t("status")), 1),
              W("p", fDe, _e(E(((T = a.value) == null ? void 0 : T.data.status) || 0)), 1)
            ]),
            W("div", hDe, [
              W("p", pDe, _e(v.$t("paymentSupportedMethods")), 1),
              W("div", mDe, [
                c.value ? (X(), se("label", gDe, [
                  Gt(W("input", {
                    "onUpdate:modelValue": _[1] || (_[1] = (H) => o.value = H),
                    type: "radio",
                    name: "paymentMethod",
                    value: "linepay",
                    class: "mr-2"
                  }, null, 512), [
                    [j1, o.value]
                  ]),
                  _[4] || (_[4] = W("img", {
                    src: YT,
                    alt: "LINE Pay Logo"
                  }, null, -1))
                ])) : Fe("", !0),
                d.value ? (X(), se("label", ADe, [
                  Gt(W("input", {
                    "onUpdate:modelValue": _[2] || (_[2] = (H) => o.value = H),
                    type: "radio",
                    name: "paymentMethod",
                    value: "stripe",
                    class: "mr-2"
                  }, null, 512), [
                    [j1, o.value]
                  ]),
                  _[5] || (_[5] = W("img", {
                    src: XT,
                    alt: "Stripe Logo"
                  }, null, -1))
                ])) : Fe("", !0),
                l.value ? (X(), se("label", bDe, [
                  Gt(W("input", {
                    "onUpdate:modelValue": _[3] || (_[3] = (H) => o.value = H),
                    type: "radio",
                    name: "paymentMethod",
                    value: "paypal",
                    class: "mr-2"
                  }, null, 512), [
                    [j1, o.value]
                  ]),
                  _[6] || (_[6] = W("img", {
                    src: KT,
                    alt: "Paypal Logo"
                  }, null, -1))
                ])) : Fe("", !0)
              ])
            ]),
            W("div", yDe, [
              W("p", vDe, _e(v.$t("paymentRequestMessage")), 1),
              W("p", TDe, _e(((N = a.value) == null ? void 0 : N.data.note) ?? ke(r)("paymentSendPaymentRequestMessageEmpty")), 1)
            ])
          ]),
          W("div", _De, [
            W("button", {
              disabled: !f.value || s.value,
              class: "h-10 grow rounded-lg bg-[#02B13F] text-base text-white disabled:cursor-not-allowed disabled:opacity-50",
              onClick: b
            }, _e(v.$t("paymentGoToPay")), 9, EDe)
          ])
        ];
      }),
      _: 1
    }));
  }
}), wDe = { class: "flex min-w-[268px] flex-col justify-center" }, CDe = { class: "m-[14px]" }, SDe = { class: "text-sm font-medium" }, IDe = { class: "flex items-baseline" }, kDe = { class: "mr-1 text-[18px] font-medium" }, DDe = { class: "text-[34px] font-medium" }, MDe = { class: "text-xs font-normal text-[#6B7280]" }, ODe = /* @__PURE__ */ Ze({
  __name: "PaymentMessageContent",
  props: {
    message: {}
  },
  setup(t) {
    const e = t, n = Yt(), { t: r } = Ri(), i = de(() => n.state.imkit.uid), s = de(() => e.message.paymentType === "request"), a = de(() => i.value === e.message.payer.id), o = de(() => s.value ? a.value ? r("paymentRequestedFromYou", [e.message.payee.nickname]) : r("paymentRequestedFrom", [e.message.payer.nickname]) : a.value ? r("paymentPaidTo", [e.message.payee.nickname]) : r("paymentCompleted", [e.message.payer.nickname])), { open: u } = Jn({
      component: a.value ? xDe : Y5e,
      attrs: {
        uid: i.value,
        paymentId: e.message.paymentId,
        paymentType: e.message.paymentType,
        payer: e.message.payer,
        payee: e.message.payee
      }
    }), c = () => {
      s.value && u();
    };
    return (d, l) => (X(), se("div", wDe, [
      l[0] || (l[0] = W("img", {
        class: "mx-auto my-6 h-[72px] w-[72px] object-contain",
        src: T5e,
        alt: "Money Icon"
      }, null, -1)),
      l[1] || (l[1] = W("hr", { class: "w-full border-b-[2px] border-[#e5e5e5]" }, null, -1)),
      W("div", CDe, [
        W("p", SDe, _e(o.value), 1),
        W("p", IDe, [
          W("span", kDe, _e(e.message.currency), 1),
          W("span", DDe, _e(e.message.value), 1)
        ]),
        W("p", MDe, _e(new Date(e.message.timestamp).toLocaleString()), 1),
        W("button", {
          class: "mt-6 w-full text-sm font-medium text-[#02b13f]",
          onClick: c
        }, _e(d.$t("paymentViewDetails")), 1)
      ])
    ]));
  }
});
class el extends Error {
}
class NDe extends el {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class LDe extends el {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class PDe extends el {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class $l extends el {
}
class oO extends el {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class qr extends el {
}
class ao extends el {
  constructor() {
    super("Zone is an abstract class");
  }
}
const pt = "numeric", Ls = "short", Wi = "long", x0 = {
  year: pt,
  month: pt,
  day: pt
}, uO = {
  year: pt,
  month: Ls,
  day: pt
}, RDe = {
  year: pt,
  month: Ls,
  day: pt,
  weekday: Ls
}, lO = {
  year: pt,
  month: Wi,
  day: pt
}, cO = {
  year: pt,
  month: Wi,
  day: pt,
  weekday: Wi
}, dO = {
  hour: pt,
  minute: pt
}, fO = {
  hour: pt,
  minute: pt,
  second: pt
}, hO = {
  hour: pt,
  minute: pt,
  second: pt,
  timeZoneName: Ls
}, pO = {
  hour: pt,
  minute: pt,
  second: pt,
  timeZoneName: Wi
}, mO = {
  hour: pt,
  minute: pt,
  hourCycle: "h23"
}, gO = {
  hour: pt,
  minute: pt,
  second: pt,
  hourCycle: "h23"
}, AO = {
  hour: pt,
  minute: pt,
  second: pt,
  hourCycle: "h23",
  timeZoneName: Ls
}, bO = {
  hour: pt,
  minute: pt,
  second: pt,
  hourCycle: "h23",
  timeZoneName: Wi
}, yO = {
  year: pt,
  month: pt,
  day: pt,
  hour: pt,
  minute: pt
}, vO = {
  year: pt,
  month: pt,
  day: pt,
  hour: pt,
  minute: pt,
  second: pt
}, TO = {
  year: pt,
  month: Ls,
  day: pt,
  hour: pt,
  minute: pt
}, _O = {
  year: pt,
  month: Ls,
  day: pt,
  hour: pt,
  minute: pt,
  second: pt
}, BDe = {
  year: pt,
  month: Ls,
  day: pt,
  weekday: Ls,
  hour: pt,
  minute: pt
}, EO = {
  year: pt,
  month: Wi,
  day: pt,
  hour: pt,
  minute: pt,
  timeZoneName: Ls
}, xO = {
  year: pt,
  month: Wi,
  day: pt,
  hour: pt,
  minute: pt,
  second: pt,
  timeZoneName: Ls
}, wO = {
  year: pt,
  month: Wi,
  day: pt,
  weekday: Wi,
  hour: pt,
  minute: pt,
  timeZoneName: Wi
}, CO = {
  year: pt,
  month: Wi,
  day: pt,
  weekday: Wi,
  hour: pt,
  minute: pt,
  second: pt,
  timeZoneName: Wi
};
class wh {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ao();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ao();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ao();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, n) {
    throw new ao();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, n) {
    throw new ao();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    throw new ao();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    throw new ao();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ao();
  }
}
let g2 = null;
class zg extends wh {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return g2 === null && (g2 = new zg()), g2;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: n, locale: r }) {
    return BO(e, n, r);
  }
  /** @override **/
  formatOffset(e, n) {
    return Tf(this.offset(e), n);
  }
  /** @override **/
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  /** @override **/
  equals(e) {
    return e.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
const Ay = /* @__PURE__ */ new Map();
function FDe(t) {
  let e = Ay.get(t);
  return e === void 0 && (e = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  }), Ay.set(t, e)), e;
}
const UDe = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function $De(t, e) {
  const n = t.format(e).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n), [, i, s, a, o, u, c, d] = r;
  return [a, i, s, o, u, c, d];
}
function HDe(t, e) {
  const n = t.formatToParts(e), r = [];
  for (let i = 0; i < n.length; i++) {
    const { type: s, value: a } = n[i], o = UDe[s];
    s === "era" ? r[o] = a : Ut(o) || (r[o] = parseInt(a, 10));
  }
  return r;
}
const A2 = /* @__PURE__ */ new Map();
class Wa extends wh {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(e) {
    let n = A2.get(e);
    return n === void 0 && A2.set(e, n = new Wa(e)), n;
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    A2.clear(), Ay.clear();
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = Wa.isValidZone(e);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !1;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, { format: n, locale: r }) {
    return BO(e, n, r, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, n) {
    return Tf(this.offset(e), n);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    if (!this.valid) return NaN;
    const n = new Date(e);
    if (isNaN(n)) return NaN;
    const r = FDe(this.name);
    let [i, s, a, o, u, c, d] = r.formatToParts ? HDe(r, n) : $De(r, n);
    o === "BC" && (i = -Math.abs(i) + 1);
    const f = Vg({
      year: i,
      month: s,
      day: a,
      hour: u === 24 ? 0 : u,
      minute: c,
      second: d,
      millisecond: 0
    });
    let p = +n;
    const m = p % 1e3;
    return p -= m >= 0 ? m : 1e3 + m, (f - p) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
}
let Xw = {};
function jDe(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let r = Xw[n];
  return r || (r = new Intl.ListFormat(t, e), Xw[n] = r), r;
}
const by = /* @__PURE__ */ new Map();
function yy(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let r = by.get(n);
  return r === void 0 && (r = new Intl.DateTimeFormat(t, e), by.set(n, r)), r;
}
const vy = /* @__PURE__ */ new Map();
function zDe(t, e = {}) {
  const n = JSON.stringify([t, e]);
  let r = vy.get(n);
  return r === void 0 && (r = new Intl.NumberFormat(t, e), vy.set(n, r)), r;
}
const Ty = /* @__PURE__ */ new Map();
function qDe(t, e = {}) {
  const { base: n, ...r } = e, i = JSON.stringify([t, r]);
  let s = Ty.get(i);
  return s === void 0 && (s = new Intl.RelativeTimeFormat(t, e), Ty.set(i, s)), s;
}
let Zd = null;
function VDe() {
  return Zd || (Zd = new Intl.DateTimeFormat().resolvedOptions().locale, Zd);
}
const _y = /* @__PURE__ */ new Map();
function SO(t) {
  let e = _y.get(t);
  return e === void 0 && (e = new Intl.DateTimeFormat(t).resolvedOptions(), _y.set(t, e)), e;
}
const Ey = /* @__PURE__ */ new Map();
function WDe(t) {
  let e = Ey.get(t);
  if (!e) {
    const n = new Intl.Locale(t);
    e = "getWeekInfo" in n ? n.getWeekInfo() : n.weekInfo, "minimalDays" in e || (e = { ...IO, ...e }), Ey.set(t, e);
  }
  return e;
}
function QDe(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const n = t.indexOf("-u-");
  if (n === -1)
    return [t];
  {
    let r, i;
    try {
      r = yy(t).resolvedOptions(), i = t;
    } catch {
      const u = t.substring(0, n);
      r = yy(u).resolvedOptions(), i = u;
    }
    const { numberingSystem: s, calendar: a } = r;
    return [i, s, a];
  }
}
function GDe(t, e, n) {
  return (n || e) && (t.includes("-u-") || (t += "-u"), n && (t += `-ca-${n}`), e && (t += `-nu-${e}`)), t;
}
function YDe(t) {
  const e = [];
  for (let n = 1; n <= 12; n++) {
    const r = Ft.utc(2009, n, 1);
    e.push(t(r));
  }
  return e;
}
function XDe(t) {
  const e = [];
  for (let n = 1; n <= 7; n++) {
    const r = Ft.utc(2016, 11, 13 + n);
    e.push(t(r));
  }
  return e;
}
function Fp(t, e, n, r) {
  const i = t.listingMode();
  return i === "error" ? null : i === "en" ? n(e) : r(e);
}
function KDe(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || SO(t.locale).numberingSystem === "latn";
}
class ZDe {
  constructor(e, n, r) {
    this.padTo = r.padTo || 0, this.floor = r.floor || !1;
    const { padTo: i, floor: s, ...a } = r;
    if (!n || Object.keys(a).length > 0) {
      const o = { useGrouping: !1, ...r };
      r.padTo > 0 && (o.minimumIntegerDigits = r.padTo), this.inf = zDe(e, o);
    }
  }
  format(e) {
    if (this.inf) {
      const n = this.floor ? Math.floor(e) : e;
      return this.inf.format(n);
    } else {
      const n = this.floor ? Math.floor(e) : n_(e, 3);
      return Ar(n, this.padTo);
    }
  }
}
class JDe {
  constructor(e, n, r) {
    this.opts = r, this.originalZone = void 0;
    let i;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const a = -1 * (e.offset / 60), o = a >= 0 ? `Etc/GMT+${a}` : `Etc/GMT${a}`;
      e.offset !== 0 && Wa.create(o).valid ? (i = o, this.dt = e) : (i = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, i = e.zone.name) : (i = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const s = { ...this.opts };
    s.timeZone = s.timeZone || i, this.dtf = yy(n, s);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((n) => {
      if (n.type === "timeZoneName") {
        const r = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...n,
          value: r
        };
      } else
        return n;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class e8e {
  constructor(e, n, r) {
    this.opts = { style: "long", ...r }, !n && PO() && (this.rtf = qDe(e, r));
  }
  format(e, n) {
    return this.rtf ? this.rtf.format(e, n) : _8e(n, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, n) {
    return this.rtf ? this.rtf.formatToParts(e, n) : [];
  }
}
const IO = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class _n {
  static fromOpts(e) {
    return _n.create(
      e.locale,
      e.numberingSystem,
      e.outputCalendar,
      e.weekSettings,
      e.defaultToEN
    );
  }
  static create(e, n, r, i, s = !1) {
    const a = e || sr.defaultLocale, o = a || (s ? "en-US" : VDe()), u = n || sr.defaultNumberingSystem, c = r || sr.defaultOutputCalendar, d = wy(i) || sr.defaultWeekSettings;
    return new _n(o, u, c, d, a);
  }
  static resetCache() {
    Zd = null, by.clear(), vy.clear(), Ty.clear(), _y.clear(), Ey.clear();
  }
  static fromObject({ locale: e, numberingSystem: n, outputCalendar: r, weekSettings: i } = {}) {
    return _n.create(e, n, r, i);
  }
  constructor(e, n, r, i, s) {
    const [a, o, u] = QDe(e);
    this.locale = a, this.numberingSystem = n || o || null, this.outputCalendar = r || u || null, this.weekSettings = i, this.intl = GDe(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = s, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = KDe(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), n = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && n ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : _n.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      wy(e.weekSettings) || this.weekSettings,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, n = !1) {
    return Fp(this, e, $O, () => {
      const r = n ? { month: e, day: "numeric" } : { month: e }, i = n ? "format" : "standalone";
      return this.monthsCache[i][e] || (this.monthsCache[i][e] = YDe((s) => this.extract(s, r, "month"))), this.monthsCache[i][e];
    });
  }
  weekdays(e, n = !1) {
    return Fp(this, e, zO, () => {
      const r = n ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, i = n ? "format" : "standalone";
      return this.weekdaysCache[i][e] || (this.weekdaysCache[i][e] = XDe(
        (s) => this.extract(s, r, "weekday")
      )), this.weekdaysCache[i][e];
    });
  }
  meridiems() {
    return Fp(
      this,
      void 0,
      () => qO,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [Ft.utc(2016, 11, 13, 9), Ft.utc(2016, 11, 13, 19)].map(
            (n) => this.extract(n, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return Fp(this, e, VO, () => {
      const n = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [Ft.utc(-40, 1, 1), Ft.utc(2017, 1, 1)].map(
        (r) => this.extract(r, n, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, n, r) {
    const i = this.dtFormatter(e, n), s = i.formatToParts(), a = s.find((o) => o.type.toLowerCase() === r);
    return a ? a.value : null;
  }
  numberFormatter(e = {}) {
    return new ZDe(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, n = {}) {
    return new JDe(e, this.intl, n);
  }
  relFormatter(e = {}) {
    return new e8e(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return jDe(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || SO(this.intl).locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : RO() ? WDe(this.locale) : IO;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
}
let b2 = null;
class fi extends wh {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return b2 === null && (b2 = new fi(0)), b2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(e) {
    return e === 0 ? fi.utcInstance : new fi(e);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(e) {
    if (e) {
      const n = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (n)
        return new fi(Wg(n[1], n[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Tf(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Tf(-this.fixed, "narrow")}`;
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, n) {
    return Tf(this.fixed, n);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !0;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return !0;
  }
}
class t8e extends wh {
  constructor(e) {
    super(), this.zoneName = e;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function yo(t, e) {
  if (Ut(t) || t === null)
    return e;
  if (t instanceof wh)
    return t;
  if (o8e(t)) {
    const n = t.toLowerCase();
    return n === "default" ? e : n === "local" || n === "system" ? zg.instance : n === "utc" || n === "gmt" ? fi.utcInstance : fi.parseSpecifier(n) || Wa.create(t);
  } else return Io(t) ? fi.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new t8e(t);
}
const ZT = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, Kw = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, n8e = ZT.hanidec.replace(/[\[|\]]/g, "").split("");
function r8e(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let n = 0; n < t.length; n++) {
      const r = t.charCodeAt(n);
      if (t[n].search(ZT.hanidec) !== -1)
        e += n8e.indexOf(t[n]);
      else
        for (const i in Kw) {
          const [s, a] = Kw[i];
          r >= s && r <= a && (e += r - s);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
const xy = /* @__PURE__ */ new Map();
function i8e() {
  xy.clear();
}
function Ts({ numberingSystem: t }, e = "") {
  const n = t || "latn";
  let r = xy.get(n);
  r === void 0 && (r = /* @__PURE__ */ new Map(), xy.set(n, r));
  let i = r.get(e);
  return i === void 0 && (i = new RegExp(`${ZT[n]}${e}`), r.set(e, i)), i;
}
let Zw = () => Date.now(), Jw = "system", eC = null, tC = null, nC = null, rC = 60, iC, sC = null;
class sr {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return Zw;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(e) {
    Zw = e;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(e) {
    Jw = e;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return yo(Jw, zg.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return eC;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(e) {
    eC = e;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return tC;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(e) {
    tC = e;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return nC;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(e) {
    nC = e;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return sC;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(e) {
    sC = wy(e);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return rC;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(e) {
    rC = e % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return iC;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(e) {
    iC = e;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    _n.resetCache(), Wa.resetCache(), Ft.resetCache(), i8e();
  }
}
class ks {
  constructor(e, n) {
    this.reason = e, this.explanation = n;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const kO = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], DO = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function rs(t, e) {
  return new ks(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function JT(t, e, n) {
  const r = new Date(Date.UTC(t, e - 1, n));
  t < 100 && t >= 0 && r.setUTCFullYear(r.getUTCFullYear() - 1900);
  const i = r.getUTCDay();
  return i === 0 ? 7 : i;
}
function MO(t, e, n) {
  return n + (Ch(t) ? DO : kO)[e - 1];
}
function OO(t, e) {
  const n = Ch(t) ? DO : kO, r = n.findIndex((s) => s < e), i = e - n[r];
  return { month: r + 1, day: i };
}
function e_(t, e) {
  return (t - e + 7) % 7 + 1;
}
function w0(t, e = 4, n = 1) {
  const { year: r, month: i, day: s } = t, a = MO(r, i, s), o = e_(JT(r, i, s), n);
  let u = Math.floor((a - o + 14 - e) / 7), c;
  return u < 1 ? (c = r - 1, u = eh(c, e, n)) : u > eh(r, e, n) ? (c = r + 1, u = 1) : c = r, { weekYear: c, weekNumber: u, weekday: o, ...Qg(t) };
}
function aC(t, e = 4, n = 1) {
  const { weekYear: r, weekNumber: i, weekday: s } = t, a = e_(JT(r, 1, e), n), o = tc(r);
  let u = i * 7 + s - a - 7 + e, c;
  u < 1 ? (c = r - 1, u += tc(c)) : u > o ? (c = r + 1, u -= tc(r)) : c = r;
  const { month: d, day: l } = OO(c, u);
  return { year: c, month: d, day: l, ...Qg(t) };
}
function y2(t) {
  const { year: e, month: n, day: r } = t, i = MO(e, n, r);
  return { year: e, ordinal: i, ...Qg(t) };
}
function oC(t) {
  const { year: e, ordinal: n } = t, { month: r, day: i } = OO(e, n);
  return { year: e, month: r, day: i, ...Qg(t) };
}
function uC(t, e) {
  if (!Ut(t.localWeekday) || !Ut(t.localWeekNumber) || !Ut(t.localWeekYear)) {
    if (!Ut(t.weekday) || !Ut(t.weekNumber) || !Ut(t.weekYear))
      throw new $l(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return Ut(t.localWeekday) || (t.weekday = t.localWeekday), Ut(t.localWeekNumber) || (t.weekNumber = t.localWeekNumber), Ut(t.localWeekYear) || (t.weekYear = t.localWeekYear), delete t.localWeekday, delete t.localWeekNumber, delete t.localWeekYear, {
      minDaysInFirstWeek: e.getMinDaysInFirstWeek(),
      startOfWeek: e.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function s8e(t, e = 4, n = 1) {
  const r = qg(t.weekYear), i = is(
    t.weekNumber,
    1,
    eh(t.weekYear, e, n)
  ), s = is(t.weekday, 1, 7);
  return r ? i ? s ? !1 : rs("weekday", t.weekday) : rs("week", t.weekNumber) : rs("weekYear", t.weekYear);
}
function a8e(t) {
  const e = qg(t.year), n = is(t.ordinal, 1, tc(t.year));
  return e ? n ? !1 : rs("ordinal", t.ordinal) : rs("year", t.year);
}
function NO(t) {
  const e = qg(t.year), n = is(t.month, 1, 12), r = is(t.day, 1, C0(t.year, t.month));
  return e ? n ? r ? !1 : rs("day", t.day) : rs("month", t.month) : rs("year", t.year);
}
function LO(t) {
  const { hour: e, minute: n, second: r, millisecond: i } = t, s = is(e, 0, 23) || e === 24 && n === 0 && r === 0 && i === 0, a = is(n, 0, 59), o = is(r, 0, 59), u = is(i, 0, 999);
  return s ? a ? o ? u ? !1 : rs("millisecond", i) : rs("second", r) : rs("minute", n) : rs("hour", e);
}
function Ut(t) {
  return typeof t > "u";
}
function Io(t) {
  return typeof t == "number";
}
function qg(t) {
  return typeof t == "number" && t % 1 === 0;
}
function o8e(t) {
  return typeof t == "string";
}
function u8e(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function PO() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function RO() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function l8e(t) {
  return Array.isArray(t) ? t : [t];
}
function lC(t, e, n) {
  if (t.length !== 0)
    return t.reduce((r, i) => {
      const s = [e(i), i];
      return r && n(r[0], s[0]) === r[0] ? r : s;
    }, null)[1];
}
function c8e(t, e) {
  return e.reduce((n, r) => (n[r] = t[r], n), {});
}
function bc(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function wy(t) {
  if (t == null)
    return null;
  if (typeof t != "object")
    throw new qr("Week settings must be an object");
  if (!is(t.firstDay, 1, 7) || !is(t.minimalDays, 1, 7) || !Array.isArray(t.weekend) || t.weekend.some((e) => !is(e, 1, 7)))
    throw new qr("Invalid week settings");
  return {
    firstDay: t.firstDay,
    minimalDays: t.minimalDays,
    weekend: Array.from(t.weekend)
  };
}
function is(t, e, n) {
  return qg(t) && t >= e && t <= n;
}
function d8e(t, e) {
  return t - e * Math.floor(t / e);
}
function Ar(t, e = 2) {
  const n = t < 0;
  let r;
  return n ? r = "-" + ("" + -t).padStart(e, "0") : r = ("" + t).padStart(e, "0"), r;
}
function bo(t) {
  if (!(Ut(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function tu(t) {
  if (!(Ut(t) || t === null || t === ""))
    return parseFloat(t);
}
function t_(t) {
  if (!(Ut(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function n_(t, e, n = !1) {
  const r = 10 ** e;
  return (n ? Math.trunc : Math.round)(t * r) / r;
}
function Ch(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function tc(t) {
  return Ch(t) ? 366 : 365;
}
function C0(t, e) {
  const n = d8e(e - 1, 12) + 1, r = t + (e - n) / 12;
  return n === 2 ? Ch(r) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];
}
function Vg(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function cC(t, e, n) {
  return -e_(JT(t, 1, e), n) + e - 1;
}
function eh(t, e = 4, n = 1) {
  const r = cC(t, e, n), i = cC(t + 1, e, n);
  return (tc(t) - r + i) / 7;
}
function Cy(t) {
  return t > 99 ? t : t > sr.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function BO(t, e, n, r = null) {
  const i = new Date(t), s = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  r && (s.timeZone = r);
  const a = { timeZoneName: e, ...s }, o = new Intl.DateTimeFormat(n, a).formatToParts(i).find((u) => u.type.toLowerCase() === "timezonename");
  return o ? o.value : null;
}
function Wg(t, e) {
  let n = parseInt(t, 10);
  Number.isNaN(n) && (n = 0);
  const r = parseInt(e, 10) || 0, i = n < 0 || Object.is(n, -0) ? -r : r;
  return n * 60 + i;
}
function FO(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e))
    throw new qr(`Invalid unit value ${t}`);
  return e;
}
function S0(t, e) {
  const n = {};
  for (const r in t)
    if (bc(t, r)) {
      const i = t[r];
      if (i == null) continue;
      n[e(r)] = FO(i);
    }
  return n;
}
function Tf(t, e) {
  const n = Math.trunc(Math.abs(t / 60)), r = Math.trunc(Math.abs(t % 60)), i = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${i}${Ar(n, 2)}:${Ar(r, 2)}`;
    case "narrow":
      return `${i}${n}${r > 0 ? `:${r}` : ""}`;
    case "techie":
      return `${i}${Ar(n, 2)}${Ar(r, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function Qg(t) {
  return c8e(t, ["hour", "minute", "second", "millisecond"]);
}
const f8e = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], UO = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], h8e = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function $O(t) {
  switch (t) {
    case "narrow":
      return [...h8e];
    case "short":
      return [...UO];
    case "long":
      return [...f8e];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const HO = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], jO = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], p8e = ["M", "T", "W", "T", "F", "S", "S"];
function zO(t) {
  switch (t) {
    case "narrow":
      return [...p8e];
    case "short":
      return [...jO];
    case "long":
      return [...HO];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const qO = ["AM", "PM"], m8e = ["Before Christ", "Anno Domini"], g8e = ["BC", "AD"], A8e = ["B", "A"];
function VO(t) {
  switch (t) {
    case "narrow":
      return [...A8e];
    case "short":
      return [...g8e];
    case "long":
      return [...m8e];
    default:
      return null;
  }
}
function b8e(t) {
  return qO[t.hour < 12 ? 0 : 1];
}
function y8e(t, e) {
  return zO(e)[t.weekday - 1];
}
function v8e(t, e) {
  return $O(e)[t.month - 1];
}
function T8e(t, e) {
  return VO(e)[t.year < 0 ? 0 : 1];
}
function _8e(t, e, n = "always", r = !1) {
  const i = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, s = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (n === "auto" && s) {
    const l = t === "days";
    switch (e) {
      case 1:
        return l ? "tomorrow" : `next ${i[t][0]}`;
      case -1:
        return l ? "yesterday" : `last ${i[t][0]}`;
      case 0:
        return l ? "today" : `this ${i[t][0]}`;
    }
  }
  const a = Object.is(e, -0) || e < 0, o = Math.abs(e), u = o === 1, c = i[t], d = r ? u ? c[1] : c[2] || c[1] : u ? i[t][0] : t;
  return a ? `${o} ${d} ago` : `in ${o} ${d}`;
}
function dC(t, e) {
  let n = "";
  for (const r of t)
    r.literal ? n += r.val : n += e(r.val);
  return n;
}
const E8e = {
  D: x0,
  DD: uO,
  DDD: lO,
  DDDD: cO,
  t: dO,
  tt: fO,
  ttt: hO,
  tttt: pO,
  T: mO,
  TT: gO,
  TTT: AO,
  TTTT: bO,
  f: yO,
  ff: TO,
  fff: EO,
  ffff: wO,
  F: vO,
  FF: _O,
  FFF: xO,
  FFFF: CO
};
class Xr {
  static create(e, n = {}) {
    return new Xr(e, n);
  }
  static parseFormat(e) {
    let n = null, r = "", i = !1;
    const s = [];
    for (let a = 0; a < e.length; a++) {
      const o = e.charAt(a);
      o === "'" ? (r.length > 0 && s.push({ literal: i || /^\s+$/.test(r), val: r }), n = null, r = "", i = !i) : i || o === n ? r += o : (r.length > 0 && s.push({ literal: /^\s+$/.test(r), val: r }), r = o, n = o);
    }
    return r.length > 0 && s.push({ literal: i || /^\s+$/.test(r), val: r }), s;
  }
  static macroTokenToFormatOpts(e) {
    return E8e[e];
  }
  constructor(e, n) {
    this.opts = n, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, n) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...n }).format();
  }
  dtFormatter(e, n = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...n });
  }
  formatDateTime(e, n) {
    return this.dtFormatter(e, n).format();
  }
  formatDateTimeParts(e, n) {
    return this.dtFormatter(e, n).formatToParts();
  }
  formatInterval(e, n) {
    return this.dtFormatter(e.start, n).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, n) {
    return this.dtFormatter(e, n).resolvedOptions();
  }
  num(e, n = 0) {
    if (this.opts.forceSimple)
      return Ar(e, n);
    const r = { ...this.opts };
    return n > 0 && (r.padTo = n), this.loc.numberFormatter(r).format(e);
  }
  formatDateTimeFromString(e, n) {
    const r = this.loc.listingMode() === "en", i = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", s = (p, m) => this.loc.extract(e, p, m), a = (p) => e.isOffsetFixed && e.offset === 0 && p.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, p.format) : "", o = () => r ? b8e(e) : s({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), u = (p, m) => r ? v8e(e, p) : s(m ? { month: p } : { month: p, day: "numeric" }, "month"), c = (p, m) => r ? y8e(e, p) : s(
      m ? { weekday: p } : { weekday: p, month: "long", day: "numeric" },
      "weekday"
    ), d = (p) => {
      const m = Xr.macroTokenToFormatOpts(p);
      return m ? this.formatWithSystemDefault(e, m) : p;
    }, l = (p) => r ? T8e(e, p) : s({ era: p }, "era"), f = (p) => {
      switch (p) {
        // ms
        case "S":
          return this.num(e.millisecond);
        case "u":
        // falls through
        case "SSS":
          return this.num(e.millisecond, 3);
        // seconds
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        // fractional seconds
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        // minutes
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        // hours
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        // offset
        case "Z":
          return a({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return a({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return a({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        // zone
        case "z":
          return e.zoneName;
        // meridiems
        case "a":
          return o();
        // dates
        case "d":
          return i ? s({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return i ? s({ day: "2-digit" }, "day") : this.num(e.day, 2);
        // weekdays - standalone
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return c("short", !0);
        case "cccc":
          return c("long", !0);
        case "ccccc":
          return c("narrow", !0);
        // weekdays - format
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return c("short", !1);
        case "EEEE":
          return c("long", !1);
        case "EEEEE":
          return c("narrow", !1);
        // months - standalone
        case "L":
          return i ? s({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return i ? s({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return u("short", !0);
        case "LLLL":
          return u("long", !0);
        case "LLLLL":
          return u("narrow", !0);
        // months - format
        case "M":
          return i ? s({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return i ? s({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return u("short", !1);
        case "MMMM":
          return u("long", !1);
        case "MMMMM":
          return u("narrow", !1);
        // years
        case "y":
          return i ? s({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return i ? s({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return i ? s({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return i ? s({ year: "numeric" }, "year") : this.num(e.year, 6);
        // eras
        case "G":
          return l("short");
        case "GG":
          return l("long");
        case "GGGGG":
          return l("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "n":
          return this.num(e.localWeekNumber);
        case "nn":
          return this.num(e.localWeekNumber, 2);
        case "ii":
          return this.num(e.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(e.localWeekYear, 4);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return d(p);
      }
    };
    return dC(Xr.parseFormat(n), f);
  }
  formatDurationFromString(e, n) {
    const r = (u) => {
      switch (u[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, i = (u) => (c) => {
      const d = r(c);
      return d ? this.num(u.get(d), c.length) : c;
    }, s = Xr.parseFormat(n), a = s.reduce(
      (u, { literal: c, val: d }) => c ? u : u.concat(d),
      []
    ), o = e.shiftTo(...a.map(r).filter((u) => u));
    return dC(s, i(o));
  }
}
const WO = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Gc(...t) {
  const e = t.reduce((n, r) => n + r.source, "");
  return RegExp(`^${e}$`);
}
function Yc(...t) {
  return (e) => t.reduce(
    ([n, r, i], s) => {
      const [a, o, u] = s(e, i);
      return [{ ...n, ...a }, o || r, u];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function Xc(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [n, r] of e) {
    const i = n.exec(t);
    if (i)
      return r(i);
  }
  return [null, null];
}
function QO(...t) {
  return (e, n) => {
    const r = {};
    let i;
    for (i = 0; i < t.length; i++)
      r[t[i]] = bo(e[n + i]);
    return [r, null, n + i];
  };
}
const GO = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, x8e = `(?:${GO.source}?(?:\\[(${WO.source})\\])?)?`, r_ = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, YO = RegExp(`${r_.source}${x8e}`), i_ = RegExp(`(?:T${YO.source})?`), w8e = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, C8e = /(\d{4})-?W(\d\d)(?:-?(\d))?/, S8e = /(\d{4})-?(\d{3})/, I8e = QO("weekYear", "weekNumber", "weekDay"), k8e = QO("year", "ordinal"), D8e = /(\d{4})-(\d\d)-(\d\d)/, XO = RegExp(
  `${r_.source} ?(?:${GO.source}|(${WO.source}))?`
), M8e = RegExp(`(?: ${XO.source})?`);
function nc(t, e, n) {
  const r = t[e];
  return Ut(r) ? n : bo(r);
}
function O8e(t, e) {
  return [{
    year: nc(t, e),
    month: nc(t, e + 1, 1),
    day: nc(t, e + 2, 1)
  }, null, e + 3];
}
function Kc(t, e) {
  return [{
    hours: nc(t, e, 0),
    minutes: nc(t, e + 1, 0),
    seconds: nc(t, e + 2, 0),
    milliseconds: t_(t[e + 3])
  }, null, e + 4];
}
function Sh(t, e) {
  const n = !t[e] && !t[e + 1], r = Wg(t[e + 1], t[e + 2]), i = n ? null : fi.instance(r);
  return [{}, i, e + 3];
}
function Ih(t, e) {
  const n = t[e] ? Wa.create(t[e]) : null;
  return [{}, n, e + 1];
}
const N8e = RegExp(`^T?${r_.source}$`), L8e = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function P8e(t) {
  const [e, n, r, i, s, a, o, u, c] = t, d = e[0] === "-", l = u && u[0] === "-", f = (p, m = !1) => p !== void 0 && (m || p && d) ? -p : p;
  return [
    {
      years: f(tu(n)),
      months: f(tu(r)),
      weeks: f(tu(i)),
      days: f(tu(s)),
      hours: f(tu(a)),
      minutes: f(tu(o)),
      seconds: f(tu(u), u === "-0"),
      milliseconds: f(t_(c), l)
    }
  ];
}
const R8e = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function s_(t, e, n, r, i, s, a) {
  const o = {
    year: e.length === 2 ? Cy(bo(e)) : bo(e),
    month: UO.indexOf(n) + 1,
    day: bo(r),
    hour: bo(i),
    minute: bo(s)
  };
  return a && (o.second = bo(a)), t && (o.weekday = t.length > 3 ? HO.indexOf(t) + 1 : jO.indexOf(t) + 1), o;
}
const B8e = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function F8e(t) {
  const [
    ,
    e,
    n,
    r,
    i,
    s,
    a,
    o,
    u,
    c,
    d,
    l
  ] = t, f = s_(e, i, r, n, s, a, o);
  let p;
  return u ? p = R8e[u] : c ? p = 0 : p = Wg(d, l), [f, new fi(p)];
}
function U8e(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const $8e = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, H8e = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, j8e = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function fC(t) {
  const [, e, n, r, i, s, a, o] = t;
  return [s_(e, i, r, n, s, a, o), fi.utcInstance];
}
function z8e(t) {
  const [, e, n, r, i, s, a, o] = t;
  return [s_(e, o, n, r, i, s, a), fi.utcInstance];
}
const q8e = Gc(w8e, i_), V8e = Gc(C8e, i_), W8e = Gc(S8e, i_), Q8e = Gc(YO), KO = Yc(
  O8e,
  Kc,
  Sh,
  Ih
), G8e = Yc(
  I8e,
  Kc,
  Sh,
  Ih
), Y8e = Yc(
  k8e,
  Kc,
  Sh,
  Ih
), X8e = Yc(
  Kc,
  Sh,
  Ih
);
function K8e(t) {
  return Xc(
    t,
    [q8e, KO],
    [V8e, G8e],
    [W8e, Y8e],
    [Q8e, X8e]
  );
}
function Z8e(t) {
  return Xc(U8e(t), [B8e, F8e]);
}
function J8e(t) {
  return Xc(
    t,
    [$8e, fC],
    [H8e, fC],
    [j8e, z8e]
  );
}
function eMe(t) {
  return Xc(t, [L8e, P8e]);
}
const tMe = Yc(Kc);
function nMe(t) {
  return Xc(t, [N8e, tMe]);
}
const rMe = Gc(D8e, M8e), iMe = Gc(XO), sMe = Yc(
  Kc,
  Sh,
  Ih
);
function aMe(t) {
  return Xc(
    t,
    [rMe, KO],
    [iMe, sMe]
  );
}
const hC = "Invalid Duration", ZO = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, oMe = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...ZO
}, Zi = 146097 / 400, Il = 146097 / 4800, uMe = {
  years: {
    quarters: 4,
    months: 12,
    weeks: Zi / 7,
    days: Zi,
    hours: Zi * 24,
    minutes: Zi * 24 * 60,
    seconds: Zi * 24 * 60 * 60,
    milliseconds: Zi * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: Zi / 28,
    days: Zi / 4,
    hours: Zi * 24 / 4,
    minutes: Zi * 24 * 60 / 4,
    seconds: Zi * 24 * 60 * 60 / 4,
    milliseconds: Zi * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: Il / 7,
    days: Il,
    hours: Il * 24,
    minutes: Il * 24 * 60,
    seconds: Il * 24 * 60 * 60,
    milliseconds: Il * 24 * 60 * 60 * 1e3
  },
  ...ZO
}, bu = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], lMe = bu.slice(0).reverse();
function oo(t, e, n = !1) {
  const r = {
    values: n ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new dn(r);
}
function JO(t, e) {
  let n = e.milliseconds ?? 0;
  for (const r of lMe.slice(1))
    e[r] && (n += e[r] * t[r].milliseconds);
  return n;
}
function pC(t, e) {
  const n = JO(t, e) < 0 ? -1 : 1;
  bu.reduceRight((r, i) => {
    if (Ut(e[i]))
      return r;
    if (r) {
      const s = e[r] * n, a = t[i][r], o = Math.floor(s / a);
      e[i] += o * n, e[r] -= o * a * n;
    }
    return i;
  }, null), bu.reduce((r, i) => {
    if (Ut(e[i]))
      return r;
    if (r) {
      const s = e[r] % 1;
      e[r] -= s, e[i] += s * t[r][i];
    }
    return i;
  }, null);
}
function cMe(t) {
  const e = {};
  for (const [n, r] of Object.entries(t))
    r !== 0 && (e[n] = r);
  return e;
}
class dn {
  /**
   * @private
   */
  constructor(e) {
    const n = e.conversionAccuracy === "longterm" || !1;
    let r = n ? uMe : oMe;
    e.matrix && (r = e.matrix), this.values = e.values, this.loc = e.loc || _n.create(), this.conversionAccuracy = n ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(e, n) {
    return dn.fromObject({ milliseconds: e }, n);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(e, n = {}) {
    if (e == null || typeof e != "object")
      throw new qr(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new dn({
      values: S0(e, dn.normalizeUnit),
      loc: _n.fromObject(n),
      conversionAccuracy: n.conversionAccuracy,
      matrix: n.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(e) {
    if (Io(e))
      return dn.fromMillis(e);
    if (dn.isDuration(e))
      return e;
    if (typeof e == "object")
      return dn.fromObject(e);
    throw new qr(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(e, n) {
    const [r] = eMe(e);
    return r ? dn.fromObject(r, n) : dn.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(e, n) {
    const [r] = nMe(e);
    return r ? dn.fromObject(r, n) : dn.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(e, n = null) {
    if (!e)
      throw new qr("need to specify a reason the Duration is invalid");
    const r = e instanceof ks ? e : new ks(e, n);
    if (sr.throwOnInvalid)
      throw new PDe(r);
    return new dn({ invalid: r });
  }
  /**
   * @private
   */
  static normalizeUnit(e) {
    const n = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!n) throw new oO(e);
    return n;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(e, n = {}) {
    const r = {
      ...n,
      floor: n.round !== !1 && n.floor !== !1
    };
    return this.isValid ? Xr.create(this.loc, r).formatDurationFromString(this, e) : hC;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(e = {}) {
    if (!this.isValid) return hC;
    const n = bu.map((r) => {
      const i = this.values[r];
      return Ut(i) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: r.slice(0, -1) }).format(i);
    }).filter((r) => r);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(n);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += n_(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(e = {}) {
    if (!this.isValid) return null;
    const n = this.toMillis();
    return n < 0 || n >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, Ft.fromMillis(n, { zone: "UTC" }).toISOTime(e));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? JO(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(e) {
    if (!this.isValid) return this;
    const n = dn.fromDurationLike(e), r = {};
    for (const i of bu)
      (bc(n.values, i) || bc(this.values, i)) && (r[i] = n.get(i) + this.get(i));
    return oo(this, { values: r }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(e) {
    if (!this.isValid) return this;
    const n = dn.fromDurationLike(e);
    return this.plus(n.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(e) {
    if (!this.isValid) return this;
    const n = {};
    for (const r of Object.keys(this.values))
      n[r] = FO(e(this.values[r], r));
    return oo(this, { values: n }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(e) {
    return this[dn.normalizeUnit(e)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(e) {
    if (!this.isValid) return this;
    const n = { ...this.values, ...S0(e, dn.normalizeUnit) };
    return oo(this, { values: n });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: e, numberingSystem: n, conversionAccuracy: r, matrix: i } = {}) {
    const a = { loc: this.loc.clone({ locale: e, numberingSystem: n }), matrix: i, conversionAccuracy: r };
    return oo(this, a);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const e = this.toObject();
    return pC(this.matrix, e), oo(this, { values: e }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const e = cMe(this.normalize().shiftToAll().toObject());
    return oo(this, { values: e }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...e) {
    if (!this.isValid) return this;
    if (e.length === 0)
      return this;
    e = e.map((a) => dn.normalizeUnit(a));
    const n = {}, r = {}, i = this.toObject();
    let s;
    for (const a of bu)
      if (e.indexOf(a) >= 0) {
        s = a;
        let o = 0;
        for (const c in r)
          o += this.matrix[c][a] * r[c], r[c] = 0;
        Io(i[a]) && (o += i[a]);
        const u = Math.trunc(o);
        n[a] = u, r[a] = (o * 1e3 - u * 1e3) / 1e3;
      } else Io(i[a]) && (r[a] = i[a]);
    for (const a in r)
      r[a] !== 0 && (n[s] += a === s ? r[a] : r[a] / this.matrix[s][a]);
    return pC(this.matrix, n), oo(this, { values: n }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const e = {};
    for (const n of Object.keys(this.values))
      e[n] = this.values[n] === 0 ? 0 : -this.values[n];
    return oo(this, { values: e }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function n(r, i) {
      return r === void 0 || r === 0 ? i === void 0 || i === 0 : r === i;
    }
    for (const r of bu)
      if (!n(this.values[r], e.values[r]))
        return !1;
    return !0;
  }
}
const kl = "Invalid Interval";
function dMe(t, e) {
  return !t || !t.isValid ? ir.invalid("missing or invalid start") : !e || !e.isValid ? ir.invalid("missing or invalid end") : e < t ? ir.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class ir {
  /**
   * @private
   */
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(e, n = null) {
    if (!e)
      throw new qr("need to specify a reason the Interval is invalid");
    const r = e instanceof ks ? e : new ks(e, n);
    if (sr.throwOnInvalid)
      throw new LDe(r);
    return new ir({ invalid: r });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(e, n) {
    const r = Fd(e), i = Fd(n), s = dMe(r, i);
    return s ?? new ir({
      start: r,
      end: i
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(e, n) {
    const r = dn.fromDurationLike(n), i = Fd(e);
    return ir.fromDateTimes(i, i.plus(r));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(e, n) {
    const r = dn.fromDurationLike(n), i = Fd(e);
    return ir.fromDateTimes(i.minus(r), i);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(e, n) {
    const [r, i] = (e || "").split("/", 2);
    if (r && i) {
      let s, a;
      try {
        s = Ft.fromISO(r, n), a = s.isValid;
      } catch {
        a = !1;
      }
      let o, u;
      try {
        o = Ft.fromISO(i, n), u = o.isValid;
      } catch {
        u = !1;
      }
      if (a && u)
        return ir.fromDateTimes(s, o);
      if (a) {
        const c = dn.fromISO(i, n);
        if (c.isValid)
          return ir.after(s, c);
      } else if (u) {
        const c = dn.fromISO(r, n);
        if (c.isValid)
          return ir.before(o, c);
      }
    }
    return ir.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns the last DateTime included in the interval (since end is not part of the interval)
   * @type {DateTime}
   */
  get lastDateTime() {
    return this.isValid && this.e ? this.e.minus(1) : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(e = "milliseconds", n) {
    if (!this.isValid) return NaN;
    const r = this.start.startOf(e, n);
    let i;
    return n != null && n.useLocaleWeeks ? i = this.end.reconfigure({ locale: r.locale }) : i = this.end, i = i.startOf(e, n), Math.floor(i.diff(r, e).get(e)) + (i.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: e, end: n } = {}) {
    return this.isValid ? ir.fromDateTimes(e || this.s, n || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...e) {
    if (!this.isValid) return [];
    const n = e.map(Fd).filter((a) => this.contains(a)).sort((a, o) => a.toMillis() - o.toMillis()), r = [];
    let { s: i } = this, s = 0;
    for (; i < this.e; ) {
      const a = n[s] || this.e, o = +a > +this.e ? this.e : a;
      r.push(ir.fromDateTimes(i, o)), i = o, s += 1;
    }
    return r;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(e) {
    const n = dn.fromDurationLike(e);
    if (!this.isValid || !n.isValid || n.as("milliseconds") === 0)
      return [];
    let { s: r } = this, i = 1, s;
    const a = [];
    for (; r < this.e; ) {
      const o = this.start.plus(n.mapUnits((u) => u * i));
      s = +o > +this.e ? this.e : o, a.push(ir.fromDateTimes(r, s)), r = s, i += 1;
    }
    return a;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(e) {
    if (!this.isValid) return this;
    const n = this.s > e.s ? this.s : e.s, r = this.e < e.e ? this.e : e.e;
    return n >= r ? null : ir.fromDateTimes(n, r);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(e) {
    if (!this.isValid) return this;
    const n = this.s < e.s ? this.s : e.s, r = this.e > e.e ? this.e : e.e;
    return ir.fromDateTimes(n, r);
  }
  /**
   * Merge an array of Intervals into an equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
   * and ending with the latest.
   *
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(e) {
    const [n, r] = e.sort((i, s) => i.s - s.s).reduce(
      ([i, s], a) => s ? s.overlaps(a) || s.abutsStart(a) ? [i, s.union(a)] : [i.concat([s]), a] : [i, a],
      [[], null]
    );
    return r && n.push(r), n;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(e) {
    let n = null, r = 0;
    const i = [], s = e.map((u) => [
      { time: u.s, type: "s" },
      { time: u.e, type: "e" }
    ]), a = Array.prototype.concat(...s), o = a.sort((u, c) => u.time - c.time);
    for (const u of o)
      r += u.type === "s" ? 1 : -1, r === 1 ? n = u.time : (n && +n != +u.time && i.push(ir.fromDateTimes(n, u.time)), n = null);
    return ir.merge(i);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...e) {
    return ir.xor([this].concat(e)).map((n) => this.intersection(n)).filter((n) => n && !n.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : kl;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(e = x0, n = {}) {
    return this.isValid ? Xr.create(this.s.loc.clone(n), e).formatInterval(this) : kl;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : kl;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : kl;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : kl;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(e, { separator: n = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${n}${this.e.toFormat(e)}` : kl;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(e, n) {
    return this.isValid ? this.e.diff(this.s, e, n) : dn.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(e) {
    return ir.fromDateTimes(e(this.s), e(this.e));
  }
}
class Up {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(e = sr.defaultZone) {
    const n = Ft.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && n.offset !== n.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(e) {
    return Wa.isValidZone(e);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(e) {
    return yo(e, sr.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: e = null, locObj: n = null } = {}) {
    return (n || _n.create(e)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: e = null, locObj: n = null } = {}) {
    return (n || _n.create(e)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: e = null, locObj: n = null } = {}) {
    return (n || _n.create(e)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(e = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null, outputCalendar: s = "gregory" } = {}) {
    return (i || _n.create(n, r, s)).months(e);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(e = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null, outputCalendar: s = "gregory" } = {}) {
    return (i || _n.create(n, r, s)).months(e, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(e = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null } = {}) {
    return (i || _n.create(n, r, null)).weekdays(e);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(e = "long", { locale: n = null, numberingSystem: r = null, locObj: i = null } = {}) {
    return (i || _n.create(n, r, null)).weekdays(e, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: e = null } = {}) {
    return _n.create(e).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(e = "short", { locale: n = null } = {}) {
    return _n.create(n, null, "gregory").eras(e);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: PO(), localeWeek: RO() };
  }
}
function mC(t, e) {
  const n = (i) => i.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), r = n(e) - n(t);
  return Math.floor(dn.fromMillis(r).as("days"));
}
function fMe(t, e, n) {
  const r = [
    ["years", (u, c) => c.year - u.year],
    ["quarters", (u, c) => c.quarter - u.quarter + (c.year - u.year) * 4],
    ["months", (u, c) => c.month - u.month + (c.year - u.year) * 12],
    [
      "weeks",
      (u, c) => {
        const d = mC(u, c);
        return (d - d % 7) / 7;
      }
    ],
    ["days", mC]
  ], i = {}, s = t;
  let a, o;
  for (const [u, c] of r)
    n.indexOf(u) >= 0 && (a = u, i[u] = c(t, e), o = s.plus(i), o > e ? (i[u]--, t = s.plus(i), t > e && (o = t, i[u]--, t = s.plus(i))) : t = o);
  return [t, i, o, a];
}
function hMe(t, e, n, r) {
  let [i, s, a, o] = fMe(t, e, n);
  const u = e - i, c = n.filter(
    (l) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(l) >= 0
  );
  c.length === 0 && (a < e && (a = i.plus({ [o]: 1 })), a !== i && (s[o] = (s[o] || 0) + u / (a - i)));
  const d = dn.fromObject(s, r);
  return c.length > 0 ? dn.fromMillis(u, r).shiftTo(...c).plus(d) : d;
}
const pMe = "missing Intl.DateTimeFormat.formatToParts support";
function yn(t, e = (n) => n) {
  return { regex: t, deser: ([n]) => e(r8e(n)) };
}
const mMe = " ", eN = `[ ${mMe}]`, tN = new RegExp(eN, "g");
function gMe(t) {
  return t.replace(/\./g, "\\.?").replace(tN, eN);
}
function gC(t) {
  return t.replace(/\./g, "").replace(tN, " ").toLowerCase();
}
function _s(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(gMe).join("|")),
    deser: ([n]) => t.findIndex((r) => gC(n) === gC(r)) + e
  };
}
function AC(t, e) {
  return { regex: t, deser: ([, n, r]) => Wg(n, r), groups: e };
}
function $p(t) {
  return { regex: t, deser: ([e]) => e };
}
function AMe(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function bMe(t, e) {
  const n = Ts(e), r = Ts(e, "{2}"), i = Ts(e, "{3}"), s = Ts(e, "{4}"), a = Ts(e, "{6}"), o = Ts(e, "{1,2}"), u = Ts(e, "{1,3}"), c = Ts(e, "{1,6}"), d = Ts(e, "{1,9}"), l = Ts(e, "{2,4}"), f = Ts(e, "{4,6}"), p = (y) => ({ regex: RegExp(AMe(y.val)), deser: ([b]) => b, literal: !0 }), g = ((y) => {
    if (t.literal)
      return p(y);
    switch (y.val) {
      // era
      case "G":
        return _s(e.eras("short"), 0);
      case "GG":
        return _s(e.eras("long"), 0);
      // years
      case "y":
        return yn(c);
      case "yy":
        return yn(l, Cy);
      case "yyyy":
        return yn(s);
      case "yyyyy":
        return yn(f);
      case "yyyyyy":
        return yn(a);
      // months
      case "M":
        return yn(o);
      case "MM":
        return yn(r);
      case "MMM":
        return _s(e.months("short", !0), 1);
      case "MMMM":
        return _s(e.months("long", !0), 1);
      case "L":
        return yn(o);
      case "LL":
        return yn(r);
      case "LLL":
        return _s(e.months("short", !1), 1);
      case "LLLL":
        return _s(e.months("long", !1), 1);
      // dates
      case "d":
        return yn(o);
      case "dd":
        return yn(r);
      // ordinals
      case "o":
        return yn(u);
      case "ooo":
        return yn(i);
      // time
      case "HH":
        return yn(r);
      case "H":
        return yn(o);
      case "hh":
        return yn(r);
      case "h":
        return yn(o);
      case "mm":
        return yn(r);
      case "m":
        return yn(o);
      case "q":
        return yn(o);
      case "qq":
        return yn(r);
      case "s":
        return yn(o);
      case "ss":
        return yn(r);
      case "S":
        return yn(u);
      case "SSS":
        return yn(i);
      case "u":
        return $p(d);
      case "uu":
        return $p(o);
      case "uuu":
        return yn(n);
      // meridiem
      case "a":
        return _s(e.meridiems(), 0);
      // weekYear (k)
      case "kkkk":
        return yn(s);
      case "kk":
        return yn(l, Cy);
      // weekNumber (W)
      case "W":
        return yn(o);
      case "WW":
        return yn(r);
      // weekdays
      case "E":
      case "c":
        return yn(n);
      case "EEE":
        return _s(e.weekdays("short", !1), 1);
      case "EEEE":
        return _s(e.weekdays("long", !1), 1);
      case "ccc":
        return _s(e.weekdays("short", !0), 1);
      case "cccc":
        return _s(e.weekdays("long", !0), 1);
      // offset/zone
      case "Z":
      case "ZZ":
        return AC(new RegExp(`([+-]${o.source})(?::(${r.source}))?`), 2);
      case "ZZZ":
        return AC(new RegExp(`([+-]${o.source})(${r.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are
      case "z":
        return $p(/[a-z_+-/]{1,256}?/i);
      // this special-case "token" represents a place where a macro-token expanded into a white-space literal
      // in this case we accept any non-newline white-space
      case " ":
        return $p(/[^\S\n\r]/);
      default:
        return p(y);
    }
  })(t) || {
    invalidReason: pMe
  };
  return g.token = t, g;
}
const yMe = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function vMe(t, e, n) {
  const { type: r, value: i } = t;
  if (r === "literal") {
    const u = /^\s+$/.test(i);
    return {
      literal: !u,
      val: u ? " " : i
    };
  }
  const s = e[r];
  let a = r;
  r === "hour" && (e.hour12 != null ? a = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? a = "hour12" : a = "hour24" : a = n.hour12 ? "hour12" : "hour24");
  let o = yMe[a];
  if (typeof o == "object" && (o = o[s]), o)
    return {
      literal: !1,
      val: o
    };
}
function TMe(t) {
  return [`^${t.map((n) => n.regex).reduce((n, r) => `${n}(${r.source})`, "")}$`, t];
}
function _Me(t, e, n) {
  const r = t.match(e);
  if (r) {
    const i = {};
    let s = 1;
    for (const a in n)
      if (bc(n, a)) {
        const o = n[a], u = o.groups ? o.groups + 1 : 1;
        !o.literal && o.token && (i[o.token.val[0]] = o.deser(r.slice(s, s + u))), s += u;
      }
    return [r, i];
  } else
    return [r, {}];
}
function EMe(t) {
  const e = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let n = null, r;
  return Ut(t.z) || (n = Wa.create(t.z)), Ut(t.Z) || (n || (n = new fi(t.Z)), r = t.Z), Ut(t.q) || (t.M = (t.q - 1) * 3 + 1), Ut(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), Ut(t.u) || (t.S = t_(t.u)), [Object.keys(t).reduce((s, a) => {
    const o = e(a);
    return o && (s[o] = t[a]), s;
  }, {}), n, r];
}
let v2 = null;
function xMe() {
  return v2 || (v2 = Ft.fromMillis(1555555555555)), v2;
}
function wMe(t, e) {
  if (t.literal)
    return t;
  const n = Xr.macroTokenToFormatOpts(t.val), r = sN(n, e);
  return r == null || r.includes(void 0) ? t : r;
}
function nN(t, e) {
  return Array.prototype.concat(...t.map((n) => wMe(n, e)));
}
class rN {
  constructor(e, n) {
    if (this.locale = e, this.format = n, this.tokens = nN(Xr.parseFormat(n), e), this.units = this.tokens.map((r) => bMe(r, e)), this.disqualifyingUnit = this.units.find((r) => r.invalidReason), !this.disqualifyingUnit) {
      const [r, i] = TMe(this.units);
      this.regex = RegExp(r, "i"), this.handlers = i;
    }
  }
  explainFromTokens(e) {
    if (this.isValid) {
      const [n, r] = _Me(e, this.regex, this.handlers), [i, s, a] = r ? EMe(r) : [null, null, void 0];
      if (bc(r, "a") && bc(r, "H"))
        throw new $l(
          "Can't include meridiem when specifying 24-hour format"
        );
      return {
        input: e,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches: n,
        matches: r,
        result: i,
        zone: s,
        specificOffset: a
      };
    } else
      return { input: e, tokens: this.tokens, invalidReason: this.invalidReason };
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
}
function iN(t, e, n) {
  return new rN(t, n).explainFromTokens(e);
}
function CMe(t, e, n) {
  const { result: r, zone: i, specificOffset: s, invalidReason: a } = iN(t, e, n);
  return [r, i, s, a];
}
function sN(t, e) {
  if (!t)
    return null;
  const r = Xr.create(e, t).dtFormatter(xMe()), i = r.formatToParts(), s = r.resolvedOptions();
  return i.map((a) => vMe(a, t, s));
}
const T2 = "Invalid DateTime", bC = 864e13;
function Jd(t) {
  return new ks("unsupported zone", `the zone "${t.name}" is not supported`);
}
function _2(t) {
  return t.weekData === null && (t.weekData = w0(t.c)), t.weekData;
}
function E2(t) {
  return t.localWeekData === null && (t.localWeekData = w0(
    t.c,
    t.loc.getMinDaysInFirstWeek(),
    t.loc.getStartOfWeek()
  )), t.localWeekData;
}
function nu(t, e) {
  const n = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new Ft({ ...n, ...e, old: n });
}
function aN(t, e, n) {
  let r = t - e * 60 * 1e3;
  const i = n.offset(r);
  if (e === i)
    return [r, e];
  r -= (i - e) * 60 * 1e3;
  const s = n.offset(r);
  return i === s ? [r, i] : [t - Math.min(i, s) * 60 * 1e3, Math.max(i, s)];
}
function Hp(t, e) {
  t += e * 60 * 1e3;
  const n = new Date(t);
  return {
    year: n.getUTCFullYear(),
    month: n.getUTCMonth() + 1,
    day: n.getUTCDate(),
    hour: n.getUTCHours(),
    minute: n.getUTCMinutes(),
    second: n.getUTCSeconds(),
    millisecond: n.getUTCMilliseconds()
  };
}
function Tm(t, e, n) {
  return aN(Vg(t), e, n);
}
function yC(t, e) {
  const n = t.o, r = t.c.year + Math.trunc(e.years), i = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, s = {
    ...t.c,
    year: r,
    month: i,
    day: Math.min(t.c.day, C0(r, i)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, a = dn.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), o = Vg(s);
  let [u, c] = aN(o, n, t.zone);
  return a !== 0 && (u += a, c = t.zone.offset(u)), { ts: u, o: c };
}
function Dl(t, e, n, r, i, s) {
  const { setZone: a, zone: o } = n;
  if (t && Object.keys(t).length !== 0 || e) {
    const u = e || o, c = Ft.fromObject(t, {
      ...n,
      zone: u,
      specificOffset: s
    });
    return a ? c : c.setZone(o);
  } else
    return Ft.invalid(
      new ks("unparsable", `the input "${i}" can't be parsed as ${r}`)
    );
}
function jp(t, e, n = !0) {
  return t.isValid ? Xr.create(_n.create("en-US"), {
    allowZ: n,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function x2(t, e) {
  const n = t.c.year > 9999 || t.c.year < 0;
  let r = "";
  return n && t.c.year >= 0 && (r += "+"), r += Ar(t.c.year, n ? 6 : 4), e ? (r += "-", r += Ar(t.c.month), r += "-", r += Ar(t.c.day)) : (r += Ar(t.c.month), r += Ar(t.c.day)), r;
}
function vC(t, e, n, r, i, s) {
  let a = Ar(t.c.hour);
  return e ? (a += ":", a += Ar(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (a += ":")) : a += Ar(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !n) && (a += Ar(t.c.second), (t.c.millisecond !== 0 || !r) && (a += ".", a += Ar(t.c.millisecond, 3))), i && (t.isOffsetFixed && t.offset === 0 && !s ? a += "Z" : t.o < 0 ? (a += "-", a += Ar(Math.trunc(-t.o / 60)), a += ":", a += Ar(Math.trunc(-t.o % 60))) : (a += "+", a += Ar(Math.trunc(t.o / 60)), a += ":", a += Ar(Math.trunc(t.o % 60)))), s && (a += "[" + t.zone.ianaName + "]"), a;
}
const oN = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, SMe = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, IMe = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, uN = ["year", "month", "day", "hour", "minute", "second", "millisecond"], kMe = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], DMe = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function MMe(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e) throw new oO(t);
  return e;
}
function TC(t) {
  switch (t.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return MMe(t);
  }
}
function OMe(t) {
  if (ef === void 0 && (ef = sr.now()), t.type !== "iana")
    return t.offset(ef);
  const e = t.name;
  let n = Sy.get(e);
  return n === void 0 && (n = t.offset(ef), Sy.set(e, n)), n;
}
function _C(t, e) {
  const n = yo(e.zone, sr.defaultZone);
  if (!n.isValid)
    return Ft.invalid(Jd(n));
  const r = _n.fromObject(e);
  let i, s;
  if (Ut(t.year))
    i = sr.now();
  else {
    for (const u of uN)
      Ut(t[u]) && (t[u] = oN[u]);
    const a = NO(t) || LO(t);
    if (a)
      return Ft.invalid(a);
    const o = OMe(n);
    [i, s] = Tm(t, o, n);
  }
  return new Ft({ ts: i, zone: n, loc: r, o: s });
}
function EC(t, e, n) {
  const r = Ut(n.round) ? !0 : n.round, i = (a, o) => (a = n_(a, r || n.calendary ? 0 : 2, !0), e.loc.clone(n).relFormatter(n).format(a, o)), s = (a) => n.calendary ? e.hasSame(t, a) ? 0 : e.startOf(a).diff(t.startOf(a), a).get(a) : e.diff(t, a).get(a);
  if (n.unit)
    return i(s(n.unit), n.unit);
  for (const a of n.units) {
    const o = s(a);
    if (Math.abs(o) >= 1)
      return i(o, a);
  }
  return i(t > e ? -0 : 0, n.units[n.units.length - 1]);
}
function xC(t) {
  let e = {}, n;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], n = Array.from(t).slice(0, t.length - 1)) : n = Array.from(t), [e, n];
}
let ef;
const Sy = /* @__PURE__ */ new Map();
class Ft {
  /**
   * @access private
   */
  constructor(e) {
    const n = e.zone || sr.defaultZone;
    let r = e.invalid || (Number.isNaN(e.ts) ? new ks("invalid input") : null) || (n.isValid ? null : Jd(n));
    this.ts = Ut(e.ts) ? sr.now() : e.ts;
    let i = null, s = null;
    if (!r)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(n))
        [i, s] = [e.old.c, e.old.o];
      else {
        const o = Io(e.o) && !e.old ? e.o : n.offset(this.ts);
        i = Hp(this.ts, o), r = Number.isNaN(i.year) ? new ks("invalid input") : null, i = r ? null : i, s = r ? null : o;
      }
    this._zone = n, this.loc = e.loc || _n.create(), this.invalid = r, this.weekData = null, this.localWeekData = null, this.c = i, this.o = s, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new Ft({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [e, n] = xC(arguments), [r, i, s, a, o, u, c] = n;
    return _C({ year: r, month: i, day: s, hour: a, minute: o, second: u, millisecond: c }, e);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [e, n] = xC(arguments), [r, i, s, a, o, u, c] = n;
    return e.zone = fi.utcInstance, _C({ year: r, month: i, day: s, hour: a, minute: o, second: u, millisecond: c }, e);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(e, n = {}) {
    const r = u8e(e) ? e.valueOf() : NaN;
    if (Number.isNaN(r))
      return Ft.invalid("invalid input");
    const i = yo(n.zone, sr.defaultZone);
    return i.isValid ? new Ft({
      ts: r,
      zone: i,
      loc: _n.fromObject(n)
    }) : Ft.invalid(Jd(i));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(e, n = {}) {
    if (Io(e))
      return e < -bC || e > bC ? Ft.invalid("Timestamp out of range") : new Ft({
        ts: e,
        zone: yo(n.zone, sr.defaultZone),
        loc: _n.fromObject(n)
      });
    throw new qr(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(e, n = {}) {
    if (Io(e))
      return new Ft({
        ts: e * 1e3,
        zone: yo(n.zone, sr.defaultZone),
        loc: _n.fromObject(n)
      });
    throw new qr("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(e, n = {}) {
    e = e || {};
    const r = yo(n.zone, sr.defaultZone);
    if (!r.isValid)
      return Ft.invalid(Jd(r));
    const i = _n.fromObject(n), s = S0(e, TC), { minDaysInFirstWeek: a, startOfWeek: o } = uC(s, i), u = sr.now(), c = Ut(n.specificOffset) ? r.offset(u) : n.specificOffset, d = !Ut(s.ordinal), l = !Ut(s.year), f = !Ut(s.month) || !Ut(s.day), p = l || f, m = s.weekYear || s.weekNumber;
    if ((p || d) && m)
      throw new $l(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (f && d)
      throw new $l("Can't mix ordinal dates with month/day");
    const g = m || s.weekday && !p;
    let y, b, E = Hp(u, c);
    g ? (y = kMe, b = SMe, E = w0(E, a, o)) : d ? (y = DMe, b = IMe, E = y2(E)) : (y = uN, b = oN);
    let v = !1;
    for (const N of y) {
      const H = s[N];
      Ut(H) ? v ? s[N] = b[N] : s[N] = E[N] : v = !0;
    }
    const _ = g ? s8e(s, a, o) : d ? a8e(s) : NO(s), D = _ || LO(s);
    if (D)
      return Ft.invalid(D);
    const S = g ? aC(s, a, o) : d ? oC(s) : s, [M, O] = Tm(S, c, r), T = new Ft({
      ts: M,
      zone: r,
      o: O,
      loc: i
    });
    return s.weekday && p && e.weekday !== T.weekday ? Ft.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${s.weekday} and a date of ${T.toISO()}`
    ) : T.isValid ? T : Ft.invalid(T.invalid);
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(e, n = {}) {
    const [r, i] = K8e(e);
    return Dl(r, i, n, "ISO 8601", e);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(e, n = {}) {
    const [r, i] = Z8e(e);
    return Dl(r, i, n, "RFC 2822", e);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(e, n = {}) {
    const [r, i] = J8e(e);
    return Dl(r, i, n, "HTTP", n);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(e, n, r = {}) {
    if (Ut(e) || Ut(n))
      throw new qr("fromFormat requires an input string and a format");
    const { locale: i = null, numberingSystem: s = null } = r, a = _n.fromOpts({
      locale: i,
      numberingSystem: s,
      defaultToEN: !0
    }), [o, u, c, d] = CMe(a, e, n);
    return d ? Ft.invalid(d) : Dl(o, u, r, `format ${n}`, e, c);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(e, n, r = {}) {
    return Ft.fromFormat(e, n, r);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(e, n = {}) {
    const [r, i] = aMe(e);
    return Dl(r, i, n, "SQL", e);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(e, n = null) {
    if (!e)
      throw new qr("need to specify a reason the DateTime is invalid");
    const r = e instanceof ks ? e : new ks(e, n);
    if (sr.throwOnInvalid)
      throw new NDe(r);
    return new Ft({ invalid: r });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(e, n = {}) {
    const r = sN(e, _n.fromObject(n));
    return r ? r.map((i) => i ? i.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(e, n = {}) {
    return nN(Xr.parseFormat(e), _n.fromObject(n)).map((i) => i.val).join("");
  }
  static resetCache() {
    ef = void 0, Sy.clear();
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(e) {
    return this[e];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? _2(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? _2(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? _2(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? E2(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? E2(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? E2(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? y2(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Up.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Up.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Up.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Up.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, n = 6e4, r = Vg(this.c), i = this.zone.offset(r - e), s = this.zone.offset(r + e), a = this.zone.offset(r - i * n), o = this.zone.offset(r - s * n);
    if (a === o)
      return [this];
    const u = r - a * n, c = r - o * n, d = Hp(u, a), l = Hp(c, o);
    return d.hour === l.hour && d.minute === l.minute && d.second === l.second && d.millisecond === l.millisecond ? [nu(this, { ts: u }), nu(this, { ts: c })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return Ch(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return C0(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? tc(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? eh(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? eh(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(e = {}) {
    const { locale: n, numberingSystem: r, calendar: i } = Xr.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: n, numberingSystem: r, outputCalendar: i };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(e = 0, n = {}) {
    return this.setZone(fi.instance(e), n);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(sr.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(e, { keepLocalTime: n = !1, keepCalendarTime: r = !1 } = {}) {
    if (e = yo(e, sr.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let i = this.ts;
      if (n || r) {
        const s = e.offset(this.ts), a = this.toObject();
        [i] = Tm(a, s, e);
      }
      return nu(this, { ts: i, zone: e });
    } else
      return Ft.invalid(Jd(e));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: e, numberingSystem: n, outputCalendar: r } = {}) {
    const i = this.loc.clone({ locale: e, numberingSystem: n, outputCalendar: r });
    return nu(this, { loc: i });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(e) {
    if (!this.isValid) return this;
    const n = S0(e, TC), { minDaysInFirstWeek: r, startOfWeek: i } = uC(n, this.loc), s = !Ut(n.weekYear) || !Ut(n.weekNumber) || !Ut(n.weekday), a = !Ut(n.ordinal), o = !Ut(n.year), u = !Ut(n.month) || !Ut(n.day), c = o || u, d = n.weekYear || n.weekNumber;
    if ((c || a) && d)
      throw new $l(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (u && a)
      throw new $l("Can't mix ordinal dates with month/day");
    let l;
    s ? l = aC(
      { ...w0(this.c, r, i), ...n },
      r,
      i
    ) : Ut(n.ordinal) ? (l = { ...this.toObject(), ...n }, Ut(n.day) && (l.day = Math.min(C0(l.year, l.month), l.day))) : l = oC({ ...y2(this.c), ...n });
    const [f, p] = Tm(l, this.o, this.zone);
    return nu(this, { ts: f, o: p });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(e) {
    if (!this.isValid) return this;
    const n = dn.fromDurationLike(e);
    return nu(this, yC(this, n));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(e) {
    if (!this.isValid) return this;
    const n = dn.fromDurationLike(e).negate();
    return nu(this, yC(this, n));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(e, { useLocaleWeeks: n = !1 } = {}) {
    if (!this.isValid) return this;
    const r = {}, i = dn.normalizeUnit(e);
    switch (i) {
      case "years":
        r.month = 1;
      // falls through
      case "quarters":
      case "months":
        r.day = 1;
      // falls through
      case "weeks":
      case "days":
        r.hour = 0;
      // falls through
      case "hours":
        r.minute = 0;
      // falls through
      case "minutes":
        r.second = 0;
      // falls through
      case "seconds":
        r.millisecond = 0;
        break;
    }
    if (i === "weeks")
      if (n) {
        const s = this.loc.getStartOfWeek(), { weekday: a } = this;
        a < s && (r.weekNumber = this.weekNumber - 1), r.weekday = s;
      } else
        r.weekday = 1;
    if (i === "quarters") {
      const s = Math.ceil(this.month / 3);
      r.month = (s - 1) * 3 + 1;
    }
    return this.set(r);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(e, n) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e, n).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(e, n = {}) {
    return this.isValid ? Xr.create(this.loc.redefaultToEN(n)).formatDateTimeFromString(this, e) : T2;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(e = x0, n = {}) {
    return this.isValid ? Xr.create(this.loc.clone(n), e).formatDateTime(this) : T2;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(e = {}) {
    return this.isValid ? Xr.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string|null}
   */
  toISO({
    format: e = "extended",
    suppressSeconds: n = !1,
    suppressMilliseconds: r = !1,
    includeOffset: i = !0,
    extendedZone: s = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const a = e === "extended";
    let o = x2(this, a);
    return o += "T", o += vC(this, a, n, r, i, s), o;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string|null}
   */
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? x2(this, e === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return jp(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: n = !1,
    includeOffset: r = !0,
    includePrefix: i = !1,
    extendedZone: s = !1,
    format: a = "extended"
  } = {}) {
    return this.isValid ? (i ? "T" : "") + vC(
      this,
      a === "extended",
      n,
      e,
      r,
      s
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return jp(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return jp(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string|null}
   */
  toSQLDate() {
    return this.isValid ? x2(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: e = !0, includeZone: n = !1, includeOffsetSpace: r = !0 } = {}) {
    let i = "HH:mm:ss.SSS";
    return (n || e) && (r && (i += " "), n ? i += "z" : e && (i += "ZZ")), jp(this, i, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : T2;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(e = {}) {
    if (!this.isValid) return {};
    const n = { ...this.c };
    return e.includeConfig && (n.outputCalendar = this.outputCalendar, n.numberingSystem = this.loc.numberingSystem, n.locale = this.loc.locale), n;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(e, n = "milliseconds", r = {}) {
    if (!this.isValid || !e.isValid)
      return dn.invalid("created by diffing an invalid DateTime");
    const i = { locale: this.locale, numberingSystem: this.numberingSystem, ...r }, s = l8e(n).map(dn.normalizeUnit), a = e.valueOf() > this.valueOf(), o = a ? this : e, u = a ? e : this, c = hMe(o, u, s, i);
    return a ? c.negate() : c;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(e = "milliseconds", n = {}) {
    return this.diff(Ft.now(), e, n);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval|DateTime}
   */
  until(e) {
    return this.isValid ? ir.fromDateTimes(this, e) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(e, n, r) {
    if (!this.isValid) return !1;
    const i = e.valueOf(), s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(n, r) <= i && i <= s.endOf(n, r);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(e = {}) {
    if (!this.isValid) return null;
    const n = e.base || Ft.fromObject({}, { zone: this.zone }), r = e.padding ? this < n ? -e.padding : e.padding : 0;
    let i = ["years", "months", "days", "hours", "minutes", "seconds"], s = e.unit;
    return Array.isArray(e.unit) && (i = e.unit, s = void 0), EC(n, this.plus(r), {
      ...e,
      numeric: "always",
      units: i,
      unit: s
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(e = {}) {
    return this.isValid ? EC(e.base || Ft.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...e) {
    if (!e.every(Ft.isDateTime))
      throw new qr("min requires all arguments be DateTimes");
    return lC(e, (n) => n.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...e) {
    if (!e.every(Ft.isDateTime))
      throw new qr("max requires all arguments be DateTimes");
    return lC(e, (n) => n.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(e, n, r = {}) {
    const { locale: i = null, numberingSystem: s = null } = r, a = _n.fromOpts({
      locale: i,
      numberingSystem: s,
      defaultToEN: !0
    });
    return iN(a, e, n);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(e, n, r = {}) {
    return Ft.fromFormatExplain(e, n, r);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(e, n = {}) {
    const { locale: r = null, numberingSystem: i = null } = n, s = _n.fromOpts({
      locale: r,
      numberingSystem: i,
      defaultToEN: !0
    });
    return new rN(s, e);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(e, n, r = {}) {
    if (Ut(e) || Ut(n))
      throw new qr(
        "fromFormatParser requires an input string and a format parser"
      );
    const { locale: i = null, numberingSystem: s = null } = r, a = _n.fromOpts({
      locale: i,
      numberingSystem: s,
      defaultToEN: !0
    });
    if (!a.equals(n.locale))
      throw new qr(
        `fromFormatParser called with a locale of ${a}, but the format parser was created for ${n.locale}`
      );
    const { result: o, zone: u, specificOffset: c, invalidReason: d } = n.explainFromTokens(e);
    return d ? Ft.invalid(d) : Dl(
      o,
      u,
      r,
      `format ${n.format}`,
      e,
      c
    );
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return x0;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return uO;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return RDe;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return lO;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return cO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return dO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return fO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return hO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return pO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return mO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return gO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return AO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return bO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return yO;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return vO;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return TO;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return _O;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return BDe;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return EO;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return xO;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return wO;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return CO;
  }
}
function Fd(t) {
  if (Ft.isDateTime(t))
    return t;
  if (t && t.valueOf && Io(t.valueOf()))
    return Ft.fromJSDate(t);
  if (t && typeof t == "object")
    return Ft.fromObject(t);
  throw new qr(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
const NMe = (t, e, n = Wn()) => {
  const r = Wn(t);
  if (r.isSame(n, "day"))
    return e("today");
  if (r.isSame(n.subtract(1, "day"), "day"))
    return e("yesterday");
  const i = Ft.fromMillis(t);
  return r.isSame(n, "week") ? i.toLocaleString({
    month: "numeric",
    day: "numeric",
    weekday: "short"
  }) : r.isSame(n, "year") ? i.toLocaleString({
    month: "numeric",
    day: "numeric"
  }) : i.toLocaleString({
    month: "numeric",
    day: "numeric",
    year: "numeric"
  });
}, LMe = ["width", "height"], PMe = {
  __name: "TranslateSvg",
  props: {
    width: {
      type: [Number, String],
      default: 19
    },
    height: {
      type: [Number, String],
      default: 19
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      "stroke-linejoin": "round",
      "stroke-miterlimit": "2",
      viewBox: "0 0 24 24",
      xmlns: "http://www.w3.org/2000/svg"
    }, r[0] || (r[0] = [
      $0('<g id="Icon"><path d="m23.25 3.75v7c0 .729-.29 1.429-.805 1.945-.516.515-1.216.805-1.945.805h-.773l-2.811 1.874c-.23.153-.526.168-.77.037-.244-.13-.396-.384-.396-.661v-1.25h-2.25c-.729 0-1.429-.29-1.945-.805-.515-.516-.805-1.216-.805-1.945v-7c0-.729.29-1.429.805-1.945.516-.515 1.216-.805 1.945-.805h7c.729 0 1.429.29 1.945.805.515.516.805 1.216.805 1.945zm-1.5 0c0-.332-.132-.649-.366-.884-.235-.234-.552-.366-.884-.366h-7c-.332 0-.649.132-.884.366-.234.235-.366.552-.366.884v7c0 .332.132.649.366.884.235.234.552.366.884.366h3c.414 0 .75.336.75.75v.599l1.834-1.223c.123-.082.268-.126.416-.126h1c.332 0 .649-.132.884-.366.234-.235.366-.552.366-.884z"></path><path d="m11.75 12.482c0-.414.336-.75.75-.75s.75.336.75.75v5.768c0 .729-.29 1.429-.805 1.945-.516.515-1.216.805-1.945.805h-2.25v1.25c0 .277-.152.531-.396.661-.244.131-.54.116-.77-.037l-2.811-1.874h-.773c-.729 0-1.429-.29-1.945-.805-.515-.516-.805-1.216-.805-1.945v-7c0-.729.29-1.429.805-1.945.516-.515 1.216-.805 1.945-.805h8c.414 0 .75.336.75.75s-.336.75-.75.75h-8c-.332 0-.649.132-.884.366-.234.235-.366.552-.366.884v7c0 .332.132.649.366.884.235.234.552.366.884.366h1c.148 0 .293.044.416.126 0 0 1.834 1.223 1.834 1.223v-.599c0-.414.336-.75.75-.75h3c.332 0 .649-.132.884-.366.234-.235.366-.552.366-.884z"></path><path d="m17.75 5.75c0 .414-.336.75-.75.75s-.75-.336-.75-.75v-1.5c0-.414.336-.75.75-.75s.75.336.75.75z"></path><path d="m14.5 6.5c-.414 0-.75-.336-.75-.75s.336-.75.75-.75h5c.414 0 .75.336.75.75s-.336.75-.75.75z"></path><path d="m17.75 5.75c0-.414.336-.75.75-.75s.75.336.75.75c0 2.623-2.127 4.75-4.75 4.75-.414 0-.75-.336-.75-.75s.336-.75.75-.75c1.795 0 3.25-1.455 3.25-3.25z"></path><path d="m14.75 5.75c0-.414.336-.75.75-.75s.75.336.75.75c0 1.795 1.455 3.25 3.25 3.25.414 0 .75.336.75.75s-.336.75-.75.75c-2.623 0-4.75-2.127-4.75-4.75z"></path><path d="m5.696 17.529c-.153.384-.59.571-.975.417-.384-.153-.571-.59-.417-.975l2-5c.114-.284.389-.471.696-.471s.582.187.696.471l2 5c.154.385-.033.822-.417.975-.385.154-.822-.033-.975-.417l-1.304-3.26z"></path><path d="m6 17c-.414 0-.75-.336-.75-.75s.336-.75.75-.75h2c.414 0 .75.336.75.75s-.336.75-.75.75z"></path></g>', 1)
    ]), 8, LMe));
  }
};
function Iy(t, e, n) {
  var r, i, s, a, o;
  e == null && (e = 100);
  function u() {
    var d = Date.now() - a;
    d < e && d >= 0 ? r = setTimeout(u, e - d) : (r = null, n || (o = t.apply(s, i), s = i = null));
  }
  var c = function() {
    s = this, i = arguments, a = Date.now();
    var d = n && !r;
    return r || (r = setTimeout(u, e)), d && (o = t.apply(s, i), s = i = null), o;
  };
  return c.clear = function() {
    r && (clearTimeout(r), r = null);
  }, c.flush = function() {
    r && (o = t.apply(s, i), s = i = null, clearTimeout(r), r = null);
  }, c;
}
Iy.debounce = Iy;
var w2 = Iy;
function RMe(t, e, n) {
  F0(t) ? Ct(t, (r, i) => {
    i == null || i.removeEventListener(e, n), r == null || r.addEventListener(e, n);
  }) : Tr(() => {
    t.addEventListener(e, n);
  }), mi(() => {
    var r;
    (r = ke(t)) === null || r === void 0 || r.removeEventListener(e, n);
  });
}
function BMe(t, e) {
  const n = "pointerdown";
  return typeof window > "u" || !window ? void 0 : RMe(window, n, (i) => {
    const s = ke(t);
    s && (s === i.target || i.composedPath().includes(s) || e(i));
  });
}
function FMe(t, e, n) {
  let r = null;
  const i = Se(!1);
  Tr(() => {
    (t.content !== void 0 || n.value) && (i.value = !0), r = new MutationObserver(s), r.observe(e.value, {
      childList: !0,
      subtree: !0
    });
  }), mi(() => r.disconnect()), Ct(n, (a) => {
    a ? i.value = !0 : i.value = !1;
  });
  const s = () => {
    t.content ? i.value = !0 : i.value = !1;
  };
  return {
    hasContent: i
  };
}
function yc(t, e) {
  var n = t.getBoundingClientRect(), r = 1, i = 1;
  return {
    width: n.width / r,
    height: n.height / i,
    top: n.top / i,
    right: n.right / r,
    bottom: n.bottom / i,
    left: n.left / r,
    x: n.left / r,
    y: n.top / i
  };
}
function Hs(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function a_(t) {
  var e = Hs(t), n = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function th(t) {
  var e = Hs(t).Element;
  return t instanceof e || t instanceof Element;
}
function os(t) {
  var e = Hs(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function lN(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = Hs(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function UMe(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function $Me(t) {
  return t === Hs(t) || !os(t) ? a_(t) : UMe(t);
}
function ma(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function $o(t) {
  return ((th(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function o_(t) {
  return yc($o(t)).left + a_(t).scrollLeft;
}
function Qa(t) {
  return Hs(t).getComputedStyle(t);
}
function u_(t) {
  var e = Qa(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function HMe(t) {
  var e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function jMe(t, e, n) {
  n === void 0 && (n = !1);
  var r = os(e);
  os(e) && HMe(e);
  var i = $o(e), s = yc(t), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, o = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((ma(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  u_(i)) && (a = $Me(e)), os(e) ? (o = yc(e), o.x += e.clientLeft, o.y += e.clientTop) : i && (o.x = o_(i))), {
    x: s.left + a.scrollLeft - o.x,
    y: s.top + a.scrollTop - o.y,
    width: s.width,
    height: s.height
  };
}
function l_(t) {
  var e = yc(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}
function Gg(t) {
  return ma(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (lN(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    $o(t)
  );
}
function cN(t) {
  return ["html", "body", "#document"].indexOf(ma(t)) >= 0 ? t.ownerDocument.body : os(t) && u_(t) ? t : cN(Gg(t));
}
function _f(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = cN(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Hs(r), a = i ? [s].concat(s.visualViewport || [], u_(r) ? r : []) : r, o = e.concat(a);
  return i ? o : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    o.concat(_f(Gg(a)))
  );
}
function zMe(t) {
  return ["table", "td", "th"].indexOf(ma(t)) >= 0;
}
function wC(t) {
  return !os(t) || // https://github.com/popperjs/popper-core/issues/837
  Qa(t).position === "fixed" ? null : t.offsetParent;
}
function qMe(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && os(t)) {
    var r = Qa(t);
    if (r.position === "fixed")
      return null;
  }
  for (var i = Gg(t); os(i) && ["html", "body"].indexOf(ma(i)) < 0; ) {
    var s = Qa(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function kh(t) {
  for (var e = Hs(t), n = wC(t); n && zMe(n) && Qa(n).position === "static"; )
    n = wC(n);
  return n && (ma(n) === "html" || ma(n) === "body" && Qa(n).position === "static") ? e : n || qMe(t) || e;
}
var us = "top", Ps = "bottom", Rs = "right", ls = "left", c_ = "auto", Dh = [us, Ps, Rs, ls], vc = "start", nh = "end", VMe = "clippingParents", dN = "viewport", Ud = "popper", WMe = "reference", CC = /* @__PURE__ */ Dh.reduce(function(t, e) {
  return t.concat([e + "-" + vc, e + "-" + nh]);
}, []), fN = /* @__PURE__ */ [].concat(Dh, [c_]).reduce(function(t, e) {
  return t.concat([e, e + "-" + vc, e + "-" + nh]);
}, []), QMe = "beforeRead", GMe = "read", YMe = "afterRead", XMe = "beforeMain", KMe = "main", ZMe = "afterMain", JMe = "beforeWrite", eOe = "write", tOe = "afterWrite", nOe = [QMe, GMe, YMe, XMe, KMe, ZMe, JMe, eOe, tOe];
function rOe(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var a = [].concat(s.requires || [], s.requiresIfExists || []);
    a.forEach(function(o) {
      if (!n.has(o)) {
        var u = e.get(o);
        u && i(u);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function iOe(t) {
  var e = rOe(t);
  return nOe.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function sOe(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function oa(t) {
  return t.split("-")[0];
}
function aOe(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
function oOe(t) {
  var e = Hs(t), n = $o(t), r = e.visualViewport, i = n.clientWidth, s = n.clientHeight, a = 0, o = 0;
  return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, o = r.offsetTop)), {
    width: i,
    height: s,
    x: a + o_(t),
    y: o
  };
}
var ko = Math.max, rh = Math.min, zp = Math.round;
function uOe(t) {
  var e, n = $o(t), r = a_(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = ko(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = ko(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), o = -r.scrollLeft + o_(t), u = -r.scrollTop;
  return Qa(i || n).direction === "rtl" && (o += ko(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: a,
    x: o,
    y: u
  };
}
function hN(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && lN(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function ky(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function lOe(t) {
  var e = yc(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function SC(t, e) {
  return e === dN ? ky(oOe(t)) : os(e) ? lOe(e) : ky(uOe($o(t)));
}
function cOe(t) {
  var e = _f(Gg(t)), n = ["absolute", "fixed"].indexOf(Qa(t).position) >= 0, r = n && os(t) ? kh(t) : t;
  return th(r) ? e.filter(function(i) {
    return th(i) && hN(i, r) && ma(i) !== "body";
  }) : [];
}
function dOe(t, e, n) {
  var r = e === "clippingParents" ? cOe(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], a = i.reduce(function(o, u) {
    var c = SC(t, u);
    return o.top = ko(c.top, o.top), o.right = rh(c.right, o.right), o.bottom = rh(c.bottom, o.bottom), o.left = ko(c.left, o.left), o;
  }, SC(t, s));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function Tc(t) {
  return t.split("-")[1];
}
function d_(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function pN(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? oa(r) : null, s = r ? Tc(r) : null, a = e.x + e.width / 2 - n.width / 2, o = e.y + e.height / 2 - n.height / 2, u;
  switch (i) {
    case us:
      u = {
        x: a,
        y: e.y - n.height
      };
      break;
    case Ps:
      u = {
        x: a,
        y: e.y + e.height
      };
      break;
    case Rs:
      u = {
        x: e.x + e.width,
        y: o
      };
      break;
    case ls:
      u = {
        x: e.x - n.width,
        y: o
      };
      break;
    default:
      u = {
        x: e.x,
        y: e.y
      };
  }
  var c = i ? d_(i) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (s) {
      case vc:
        u[c] = u[c] - (e[d] / 2 - n[d] / 2);
        break;
      case nh:
        u[c] = u[c] + (e[d] / 2 - n[d] / 2);
        break;
    }
  }
  return u;
}
function mN() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function gN(t) {
  return Object.assign({}, mN(), t);
}
function AN(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
function f_(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.boundary, a = s === void 0 ? VMe : s, o = n.rootBoundary, u = o === void 0 ? dN : o, c = n.elementContext, d = c === void 0 ? Ud : c, l = n.altBoundary, f = l === void 0 ? !1 : l, p = n.padding, m = p === void 0 ? 0 : p, g = gN(typeof m != "number" ? m : AN(m, Dh)), y = d === Ud ? WMe : Ud, b = t.rects.popper, E = t.elements[f ? y : d], v = dOe(th(E) ? E : E.contextElement || $o(t.elements.popper), a, u), _ = yc(t.elements.reference), D = pN({
    reference: _,
    element: b,
    placement: i
  }), S = ky(Object.assign({}, b, D)), M = d === Ud ? S : _, O = {
    top: v.top - M.top + g.top,
    bottom: M.bottom - v.bottom + g.bottom,
    left: v.left - M.left + g.left,
    right: M.right - v.right + g.right
  }, T = t.modifiersData.offset;
  if (d === Ud && T) {
    var N = T[i];
    Object.keys(O).forEach(function(H) {
      var $ = [Rs, Ps].indexOf(H) >= 0 ? 1 : -1, j = [us, Ps].indexOf(H) >= 0 ? "y" : "x";
      O[H] += N[j] * $;
    });
  }
  return O;
}
var IC = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function kC() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function fOe(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? IC : i;
  return function(o, u, c) {
    c === void 0 && (c = s);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, IC, s),
      modifiersData: {},
      elements: {
        reference: o,
        popper: u
      },
      attributes: {},
      styles: {}
    }, l = [], f = !1, p = {
      state: d,
      setOptions: function(b) {
        var E = typeof b == "function" ? b(d.options) : b;
        g(), d.options = Object.assign({}, s, d.options, E), d.scrollParents = {
          reference: th(o) ? _f(o) : o.contextElement ? _f(o.contextElement) : [],
          popper: _f(u)
        };
        var v = iOe(aOe([].concat(r, d.options.modifiers)));
        return d.orderedModifiers = v.filter(function(_) {
          return _.enabled;
        }), m(), p.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var b = d.elements, E = b.reference, v = b.popper;
          if (kC(E, v)) {
            d.rects = {
              reference: jMe(E, kh(v), d.options.strategy === "fixed"),
              popper: l_(v)
            }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(N) {
              return d.modifiersData[N.name] = Object.assign({}, N.data);
            });
            for (var _ = 0; _ < d.orderedModifiers.length; _++) {
              if (d.reset === !0) {
                d.reset = !1, _ = -1;
                continue;
              }
              var D = d.orderedModifiers[_], S = D.fn, M = D.options, O = M === void 0 ? {} : M, T = D.name;
              typeof S == "function" && (d = S({
                state: d,
                options: O,
                name: T,
                instance: p
              }) || d);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: sOe(function() {
        return new Promise(function(y) {
          p.forceUpdate(), y(d);
        });
      }),
      destroy: function() {
        g(), f = !0;
      }
    };
    if (!kC(o, u))
      return p;
    p.setOptions(c).then(function(y) {
      !f && c.onFirstUpdate && c.onFirstUpdate(y);
    });
    function m() {
      d.orderedModifiers.forEach(function(y) {
        var b = y.name, E = y.options, v = E === void 0 ? {} : E, _ = y.effect;
        if (typeof _ == "function") {
          var D = _({
            state: d,
            name: b,
            instance: p,
            options: v
          }), S = function() {
          };
          l.push(D || S);
        }
      });
    }
    function g() {
      l.forEach(function(y) {
        return y();
      }), l = [];
    }
    return p;
  };
}
var qp = {
  passive: !0
};
function hOe(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, a = r.resize, o = a === void 0 ? !0 : a, u = Hs(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && c.forEach(function(d) {
    d.addEventListener("scroll", n.update, qp);
  }), o && u.addEventListener("resize", n.update, qp), function() {
    s && c.forEach(function(d) {
      d.removeEventListener("scroll", n.update, qp);
    }), o && u.removeEventListener("resize", n.update, qp);
  };
}
var pOe = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: hOe,
  data: {}
};
function mOe(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = pN({
    reference: e.rects.reference,
    element: e.rects.popper,
    placement: e.placement
  });
}
var gOe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: mOe,
  data: {}
}, AOe = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function bOe(t) {
  var e = t.x, n = t.y, r = window, i = r.devicePixelRatio || 1;
  return {
    x: zp(zp(e * i) / i) || 0,
    y: zp(zp(n * i) / i) || 0
  };
}
function DC(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, a = t.offsets, o = t.position, u = t.gpuAcceleration, c = t.adaptive, d = t.roundOffsets, l = d === !0 ? bOe(a) : typeof d == "function" ? d(a) : a, f = l.x, p = f === void 0 ? 0 : f, m = l.y, g = m === void 0 ? 0 : m, y = a.hasOwnProperty("x"), b = a.hasOwnProperty("y"), E = ls, v = us, _ = window;
  if (c) {
    var D = kh(n), S = "clientHeight", M = "clientWidth";
    D === Hs(n) && (D = $o(n), Qa(D).position !== "static" && o === "absolute" && (S = "scrollHeight", M = "scrollWidth")), D = D, (i === us || (i === ls || i === Rs) && s === nh) && (v = Ps, g -= D[S] - r.height, g *= u ? 1 : -1), (i === ls || (i === us || i === Ps) && s === nh) && (E = Rs, p -= D[M] - r.width, p *= u ? 1 : -1);
  }
  var O = Object.assign({
    position: o
  }, c && AOe);
  if (u) {
    var T;
    return Object.assign({}, O, (T = {}, T[v] = b ? "0" : "", T[E] = y ? "0" : "", T.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + g + "px)" : "translate3d(" + p + "px, " + g + "px, 0)", T));
  }
  return Object.assign({}, O, (e = {}, e[v] = b ? g + "px" : "", e[E] = y ? p + "px" : "", e.transform = "", e));
}
function yOe(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, a = s === void 0 ? !0 : s, o = n.roundOffsets, u = o === void 0 ? !0 : o, c = {
    placement: oa(e.placement),
    variation: Tc(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, DC(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: a,
    roundOffsets: u
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, DC(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: u
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
var vOe = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: yOe,
  data: {}
};
function TOe(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !os(s) || !ma(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(a) {
      var o = i[a];
      o === !1 ? s.removeAttribute(a) : s.setAttribute(a, o === !0 ? "" : o);
    }));
  });
}
function _Oe(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), o = a.reduce(function(u, c) {
        return u[c] = "", u;
      }, {});
      !os(i) || !ma(i) || (Object.assign(i.style, o), Object.keys(s).forEach(function(u) {
        i.removeAttribute(u);
      }));
    });
  };
}
var EOe = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: TOe,
  effect: _Oe,
  requires: ["computeStyles"]
}, xOe = [pOe, gOe, vOe, EOe], wOe = /* @__PURE__ */ fOe({
  defaultModifiers: xOe
});
function COe(t) {
  return t === "x" ? "y" : "x";
}
function _m(t, e, n) {
  return ko(t, rh(e, n));
}
function SOe(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, o = a === void 0 ? !1 : a, u = n.boundary, c = n.rootBoundary, d = n.altBoundary, l = n.padding, f = n.tether, p = f === void 0 ? !0 : f, m = n.tetherOffset, g = m === void 0 ? 0 : m, y = f_(e, {
    boundary: u,
    rootBoundary: c,
    padding: l,
    altBoundary: d
  }), b = oa(e.placement), E = Tc(e.placement), v = !E, _ = d_(b), D = COe(_), S = e.modifiersData.popperOffsets, M = e.rects.reference, O = e.rects.popper, T = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, N = {
    x: 0,
    y: 0
  };
  if (S) {
    if (s || o) {
      var H = _ === "y" ? us : ls, $ = _ === "y" ? Ps : Rs, j = _ === "y" ? "height" : "width", U = S[_], V = S[_] + y[H], B = S[_] - y[$], R = p ? -O[j] / 2 : 0, K = E === vc ? M[j] : O[j], Q = E === vc ? -O[j] : -M[j], P = e.elements.arrow, I = p && P ? l_(P) : {
        width: 0,
        height: 0
      }, G = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : mN(), te = G[H], ee = G[$], Z = _m(0, M[j], I[j]), ye = v ? M[j] / 2 - R - Z - te - T : K - Z - te - T, he = v ? -M[j] / 2 + R + Z + ee + T : Q + Z + ee + T, Ee = e.elements.arrow && kh(e.elements.arrow), be = Ee ? _ === "y" ? Ee.clientTop || 0 : Ee.clientLeft || 0 : 0, ve = e.modifiersData.offset ? e.modifiersData.offset[e.placement][_] : 0, Ce = S[_] + ye - ve - be, Ne = S[_] + he - ve;
      if (s) {
        var qe = _m(p ? rh(V, Ce) : V, U, p ? ko(B, Ne) : B);
        S[_] = qe, N[_] = qe - U;
      }
      if (o) {
        var $e = _ === "x" ? us : ls, Xe = _ === "x" ? Ps : Rs, at = S[D], Ie = at + y[$e], ne = at - y[Xe], ue = _m(p ? rh(Ie, Ce) : Ie, at, p ? ko(ne, Ne) : ne);
        S[D] = ue, N[D] = ue - at;
      }
    }
    e.modifiersData[r] = N;
  }
}
var IOe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: SOe,
  requiresIfExists: ["offset"]
}, kOe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Em(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return kOe[e];
  });
}
var DOe = {
  start: "end",
  end: "start"
};
function MC(t) {
  return t.replace(/start|end/g, function(e) {
    return DOe[e];
  });
}
function MOe(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, a = n.padding, o = n.flipVariations, u = n.allowedAutoPlacements, c = u === void 0 ? fN : u, d = Tc(r), l = d ? o ? CC : CC.filter(function(m) {
    return Tc(m) === d;
  }) : Dh, f = l.filter(function(m) {
    return c.indexOf(m) >= 0;
  });
  f.length === 0 && (f = l);
  var p = f.reduce(function(m, g) {
    return m[g] = f_(t, {
      placement: g,
      boundary: i,
      rootBoundary: s,
      padding: a
    })[oa(g)], m;
  }, {});
  return Object.keys(p).sort(function(m, g) {
    return p[m] - p[g];
  });
}
function OOe(t) {
  if (oa(t) === c_)
    return [];
  var e = Em(t);
  return [MC(t), e, MC(e)];
}
function NOe(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, o = a === void 0 ? !0 : a, u = n.fallbackPlacements, c = n.padding, d = n.boundary, l = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, m = p === void 0 ? !0 : p, g = n.allowedAutoPlacements, y = e.options.placement, b = oa(y), E = b === y, v = u || (E || !m ? [Em(y)] : OOe(y)), _ = [y].concat(v).reduce(function(ee, Z) {
      return ee.concat(oa(Z) === c_ ? MOe(e, {
        placement: Z,
        boundary: d,
        rootBoundary: l,
        padding: c,
        flipVariations: m,
        allowedAutoPlacements: g
      }) : Z);
    }, []), D = e.rects.reference, S = e.rects.popper, M = /* @__PURE__ */ new Map(), O = !0, T = _[0], N = 0; N < _.length; N++) {
      var H = _[N], $ = oa(H), j = Tc(H) === vc, U = [us, Ps].indexOf($) >= 0, V = U ? "width" : "height", B = f_(e, {
        placement: H,
        boundary: d,
        rootBoundary: l,
        altBoundary: f,
        padding: c
      }), R = U ? j ? Rs : ls : j ? Ps : us;
      D[V] > S[V] && (R = Em(R));
      var K = Em(R), Q = [];
      if (s && Q.push(B[$] <= 0), o && Q.push(B[R] <= 0, B[K] <= 0), Q.every(function(ee) {
        return ee;
      })) {
        T = H, O = !1;
        break;
      }
      M.set(H, Q);
    }
    if (O)
      for (var P = m ? 3 : 1, I = function(Z) {
        var ye = _.find(function(he) {
          var Ee = M.get(he);
          if (Ee)
            return Ee.slice(0, Z).every(function(be) {
              return be;
            });
        });
        if (ye)
          return T = ye, "break";
      }, G = P; G > 0; G--) {
        var te = I(G);
        if (te === "break") break;
      }
    e.placement !== T && (e.modifiersData[r]._skip = !0, e.placement = T, e.reset = !0);
  }
}
var LOe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: NOe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function POe(t, e, n) {
  var r = oa(t), i = [ls, us].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, a = s[0], o = s[1];
  return a = a || 0, o = (o || 0) * i, [ls, Rs].indexOf(r) >= 0 ? {
    x: o,
    y: a
  } : {
    x: a,
    y: o
  };
}
function ROe(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, a = fN.reduce(function(d, l) {
    return d[l] = POe(l, e.rects, s), d;
  }, {}), o = a[e.placement], u = o.x, c = o.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += u, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
}
var BOe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: ROe
}, FOe = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, gN(typeof e != "number" ? e : AN(e, Dh));
};
function UOe(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, a = n.modifiersData.popperOffsets, o = oa(n.placement), u = d_(o), c = [ls, Rs].indexOf(o) >= 0, d = c ? "height" : "width";
  if (!(!s || !a)) {
    var l = FOe(i.padding, n), f = l_(s), p = u === "y" ? us : ls, m = u === "y" ? Ps : Rs, g = n.rects.reference[d] + n.rects.reference[u] - a[u] - n.rects.popper[d], y = a[u] - n.rects.reference[u], b = kh(s), E = b ? u === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, v = g / 2 - y / 2, _ = l[p], D = E - f[d] - l[m], S = E / 2 - f[d] / 2 + v, M = _m(_, S, D), O = u;
    n.modifiersData[r] = (e = {}, e[O] = M, e.centerOffset = M - S, e);
  }
}
function $Oe(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || hN(e.elements.popper, i) && (e.elements.arrow = i));
}
var HOe = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: UOe,
  effect: $Oe,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
const C2 = (t) => parseInt(t, 10);
function jOe({
  arrowPadding: t,
  emit: e,
  locked: n,
  offsetDistance: r,
  offsetSkid: i,
  placement: s,
  popperNode: a,
  triggerNode: o
}) {
  const u = ja({
    isOpen: !1,
    popperInstance: null
  }), c = (g) => {
    var y;
    (y = u.popperInstance) === null || y === void 0 || y.setOptions((b) => ({
      ...b,
      modifiers: [...b.modifiers, {
        name: "eventListeners",
        enabled: g
      }]
    }));
  }, d = () => c(!0), l = () => c(!1), f = () => {
    u.isOpen && (u.isOpen = !1, e("close:popper"));
  }, p = () => {
    u.isOpen || (u.isOpen = !0, e("open:popper"));
  };
  Ct([() => u.isOpen, s], async ([g]) => {
    g ? (await m(), d()) : l();
  });
  const m = async () => {
    await ca(), u.popperInstance = wOe(o.value, a.value, {
      placement: s.value,
      modifiers: [IOe, LOe, {
        name: "flip",
        enabled: !n.value
      }, HOe, {
        name: "arrow",
        options: {
          padding: C2(t.value)
        }
      }, BOe, {
        name: "offset",
        options: {
          offset: [C2(i.value), C2(r.value)]
        }
      }]
    }), u.popperInstance.update();
  };
  return mi(() => {
    var g;
    (g = u.popperInstance) === null || g === void 0 || g.destroy();
  }), {
    ...Nl(u),
    open: p,
    close: f
  };
}
const zOe = {
  id: "arrow",
  "data-popper-arrow": ""
};
function qOe(t, e) {
  return X(), se("div", zOe);
}
function bN(t, e) {
  e === void 0 && (e = {});
  var n = e.insertAt;
  if (!(!t || typeof document > "u")) {
    var r = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style");
    i.type = "text/css", n === "top" && r.firstChild ? r.insertBefore(i, r.firstChild) : r.appendChild(i), i.styleSheet ? i.styleSheet.cssText = t : i.appendChild(document.createTextNode(t));
  }
}
var VOe = `
#arrow[data-v-20b7fd4a],
  #arrow[data-v-20b7fd4a]::before {
    transition: background 250ms ease-in-out;
    position: absolute;
    width: calc(10px - var(--popper-theme-border-width, 0px));
    height: calc(10px - var(--popper-theme-border-width, 0px));
    box-sizing: border-box;
    background: var(--popper-theme-background-color);
}
#arrow[data-v-20b7fd4a] {
    visibility: hidden;
}
#arrow[data-v-20b7fd4a]::before {
    visibility: visible;
    content: "";
    transform: rotate(45deg);
}

  /* Top arrow */
.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a] {
    bottom: -5px;
}
.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a]::before {
    border-right: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
    border-bottom: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
}

  /* Bottom arrow */
.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a] {
    top: -5px;
}
.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a]::before {
    border-left: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
    border-top: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
}

  /* Left arrow */
.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a] {
    right: -5px;
}
.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a]::before {
    border-right: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
    border-top: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
}

  /* Right arrow */
.popper[data-popper-placement^="right"] > #arrow[data-v-20b7fd4a] {
    left: -5px;
}
`;
bN(VOe);
const h_ = {};
h_.render = qOe;
h_.__scopeId = "data-v-20b7fd4a";
var WOe = h_;
const QOe = ["onKeyup"];
var yN = {
  props: {
    /**
     * Preferred placement (the "auto" placements will choose the side with most space.)
     */
    placement: {
      type: String,
      default: "bottom",
      validator: function(t) {
        return ["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end"].includes(t);
      }
    },
    /**
     * Disables automatically closing the popover when the user clicks away from it
     */
    disableClickAway: {
      type: Boolean,
      default: !1
    },
    /**
     * Offset in pixels along the trigger element
     */
    offsetSkid: {
      type: String,
      default: "0"
    },
    /**
     * Offset in pixels away from the trigger element
     */
    offsetDistance: {
      type: String,
      default: "12"
    },
    /**
     * Trigger the popper on hover
     */
    hover: {
      type: Boolean,
      default: !1
    },
    /**
     * Manually open/close the Popper, other events are ignored if this prop is set
     */
    show: {
      type: Boolean,
      default: null
    },
    /**
     * Disables the Popper. If it was already open, it will be closed.
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Open the Popper after a delay (ms).
     */
    openDelay: {
      type: [Number, String],
      default: 0
    },
    /**
     * Close the Popper after a delay (ms).
     */
    closeDelay: {
      type: [Number, String],
      default: 0
    },
    /**
     * The z-index of the Popper.
     */
    zIndex: {
      type: [Number, String],
      default: 9999
    },
    /**
     * Display an arrow on the popper
     */
    arrow: {
      type: Boolean,
      default: !1
    },
    /**
     * Stop arrow from reaching the edge of the popper
     */
    arrowPadding: {
      type: String,
      default: "0"
    },
    /**
     * If the Popper should be interactive, it will close when clicked/hovered if false
     */
    interactive: {
      type: Boolean,
      default: !0
    },
    /**
     * Lock the Popper into place, it will not flip dynamically when it runs out of space if true
     */
    locked: {
      type: Boolean,
      default: !1
    },
    /**
     * If the content is just a simple string, it can be passed in as a prop
     */
    content: {
      type: String,
      default: null
    }
  },
  emits: ["open:popper", "close:popper"],
  setup(t, {
    emit: e
  }) {
    const n = t;
    h7((K) => ({
      c81fc0a4: t.zIndex
    }));
    const r = p7(), i = Se(null), s = Se(null), a = Se(null), o = Se(!1);
    Tr(() => {
      const K = r.default();
      if (K && K.length > 1)
        return console.error(`[Popper]: The <Popper> component expects only one child element at its root. You passed ${K.length} child nodes.`);
    });
    const {
      arrowPadding: u,
      closeDelay: c,
      content: d,
      disableClickAway: l,
      disabled: f,
      interactive: p,
      locked: m,
      offsetDistance: g,
      offsetSkid: y,
      openDelay: b,
      placement: E,
      show: v
    } = Nl(n), {
      isOpen: _,
      open: D,
      close: S
    } = jOe({
      arrowPadding: u,
      emit: e,
      locked: m,
      offsetDistance: g,
      offsetSkid: y,
      placement: E,
      popperNode: s,
      triggerNode: a
    }), {
      hasContent: M
    } = FMe(r, s, d), O = de(() => v.value !== null), T = de(() => f.value || !M.value), N = de(() => _.value && !T.value), H = de(() => !l.value && !O.value), $ = de(() => p.value ? `border: ${g.value}px solid transparent; margin: -${g.value}px;` : null), j = w2.debounce(D, b.value), U = w2.debounce(S, c.value), V = async () => {
      T.value || O.value || (U.clear(), j());
    }, B = async () => {
      O.value || (j.clear(), U());
    }, R = () => {
      _.value ? B() : V();
    };
    return Ct([M, f], ([K, Q]) => {
      _.value && (!K || Q) && S();
    }), Ct(_, (K) => {
      K ? o.value = !0 : w2.debounce(() => {
        o.value = !1;
      }, 200);
    }), If(() => {
      O.value && (v.value ? j() : U());
    }), If(() => {
      H.value && BMe(i, B);
    }), (K, Q) => (X(), se("div", {
      class: "inline-block",
      style: Qt(ke($)),
      onMouseleave: Q[2] || (Q[2] = (P) => t.hover && B()),
      ref: (P, I) => {
        I.popperContainerNode = P, i.value = P;
      }
    }, [W("div", {
      ref: (P, I) => {
        I.triggerNode = P, a.value = P;
      },
      onMouseover: Q[0] || (Q[0] = (P) => t.hover && V()),
      onClick: R,
      onFocus: V,
      onKeyup: lh(B, ["esc"])
    }, [Jr(K.$slots, "default")], 40, QOe), et(Lu, {
      name: "fade"
    }, {
      default: Zt(() => [Gt(W("div", {
        onClick: Q[1] || (Q[1] = (P) => !ke(p) && B()),
        class: "popper",
        ref: (P, I) => {
          I.popperNode = P, s.value = P;
        }
      }, [Jr(K.$slots, "content", {
        close: ke(S),
        isOpen: o.value
      }, () => [An(_e(ke(d)), 1)]), t.arrow ? (X(), gt(WOe, {
        key: 0
      })) : Fe("", !0)], 512), [[Ra, ke(N)]])]),
      _: 3
    })], 36));
  }
}, GOe = `
.inline-block[data-v-5784ed69] {
    display: inline-block;
}
.popper[data-v-5784ed69] {
    transition: background 250ms ease-in-out;
    background: var(--popper-theme-background-color);
    padding: var(--popper-theme-padding);
    color: var(--popper-theme-text-color);
    border-radius: var(--popper-theme-border-radius);
    border-width: var(--popper-theme-border-width);
    border-style: var(--popper-theme-border-style);
    border-color: var(--popper-theme-border-color);
    box-shadow: var(--popper-theme-box-shadow);
    z-index: var(--c81fc0a4);
}
.popper[data-v-5784ed69]:hover,
  .popper:hover > #arrow[data-v-5784ed69]::before {
    background: var(--popper-theme-background-color-hover);
}
.inline-block[data-v-5784ed69] {
    display: inline-block;
}
.fade-enter-active[data-v-5784ed69],
  .fade-leave-active[data-v-5784ed69] {
    transition: opacity 0.2s ease;
}
.fade-enter-from[data-v-5784ed69],
  .fade-leave-to[data-v-5784ed69] {
    opacity: 0;
}
`;
bN(GOe);
yN.__scopeId = "data-v-5784ed69";
var YOe = /* @__PURE__ */ (() => {
  const t = yN;
  return t.install = (e) => {
    e.component("Popper", t);
  }, t;
})();
const XOe = ["width", "height"], vN = {
  __name: "EmojiSvg",
  props: {
    width: {
      type: [Number, String],
      default: 22
    },
    height: {
      type: [Number, String],
      default: 22
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      viewBox: "0 0 512 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, r[0] || (r[0] = [
      W("path", { d: "M256 32C211.697 32 168.389 45.1374 131.552 69.7508C94.7158 94.3642 66.0051 129.348 49.0511 170.279C32.0971 211.21 27.6611 256.248 36.3042 299.7C44.9473 343.152 66.2812 383.065 97.6082 414.392C128.935 445.719 168.848 467.053 212.3 475.696C255.752 484.339 300.791 479.903 341.721 462.949C382.652 445.995 417.636 417.284 442.249 380.448C466.863 343.611 480 300.303 480 256C479.933 196.612 456.312 139.676 414.318 97.682C372.324 55.6883 315.388 32.0669 256 32ZM256 448C218.026 448 180.905 436.739 149.331 415.642C117.756 394.545 93.1473 364.559 78.6152 329.475C64.0832 294.392 60.281 255.787 67.6893 218.543C75.0977 181.298 93.3839 147.087 120.236 120.235C147.087 93.3838 181.298 75.0976 218.543 67.6892C255.787 60.2809 294.392 64.0831 329.475 78.6151C364.559 93.1472 394.545 117.756 415.642 149.331C436.739 180.905 448 218.026 448 256C447.942 306.904 427.695 355.706 391.701 391.7C355.706 427.695 306.904 447.942 256 448Z" }, null, -1),
      W("path", { d: "M352 268.531C347.757 268.531 343.687 270.217 340.686 273.218C337.686 276.218 336 280.288 336 284.531C336 314.821 302.984 339.469 262.4 339.469H249.6C209.014 339.469 176 314.829 176 284.531C176 280.288 174.314 276.218 171.314 273.218C168.313 270.217 164.243 268.531 160 268.531C155.757 268.531 151.687 270.217 148.686 273.218C145.686 276.218 144 280.288 144 284.531C144 332.469 191.374 371.469 249.6 371.469H262.4C320.627 371.469 368 332.469 368 284.531C368 280.288 366.314 276.218 363.314 273.218C360.313 270.217 356.243 268.531 352 268.531Z" }, null, -1),
      W("path", { d: "M176 224C180.243 224 184.313 222.314 187.314 219.314C190.314 216.313 192 212.243 192 208V200C192 197.878 192.843 195.843 194.343 194.343C195.843 192.843 197.878 192 200 192C202.122 192 204.157 192.843 205.657 194.343C207.157 195.843 208 197.878 208 200V208C208 212.243 209.686 216.313 212.686 219.314C215.687 222.314 219.757 224 224 224C228.243 224 232.313 222.314 235.314 219.314C238.314 216.313 240 212.243 240 208V200C240 189.391 235.786 179.217 228.284 171.716C220.783 164.214 210.609 160 200 160C189.391 160 179.217 164.214 171.716 171.716C164.214 179.217 160 189.391 160 200V208C160 212.243 161.686 216.313 164.686 219.314C167.687 222.314 171.757 224 176 224Z" }, null, -1),
      W("path", { d: "M288 224C292.243 224 296.313 222.314 299.314 219.314C302.314 216.313 304 212.243 304 208V200C304 197.878 304.843 195.843 306.343 194.343C307.843 192.843 309.878 192 312 192C314.122 192 316.157 192.843 317.657 194.343C319.157 195.843 320 197.878 320 200V208C320 212.243 321.686 216.313 324.686 219.314C327.687 222.314 331.757 224 336 224C340.243 224 344.313 222.314 347.314 219.314C350.314 216.313 352 212.243 352 208V200C352 189.391 347.786 179.217 340.284 171.716C332.783 164.214 322.609 160 312 160C301.391 160 291.217 164.214 283.716 171.716C276.214 179.217 272 189.391 272 200V208C272 212.243 273.686 216.313 276.686 219.314C279.687 222.314 283.757 224 288 224Z" }, null, -1)
    ]), 8, XOe));
  }
}, KOe = { class: "cursor-pointer transition-all hover:opacity-80" }, ZOe = {
  class: /* @__PURE__ */ vt([
    "flex items-center gap-2 rounded-xl bg-white px-4 py-2 text-2xl shadow-lg",
    "dark:border dark:border-zinc-700 dark:bg-zinc-800"
  ])
}, JOe = ["onClick"], OC = /* @__PURE__ */ Ze({
  __name: "MessageEmojiPicker",
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = e, r = [
      // :heart::laughing::open_mouth::disappointed_relieved::+1:
      "💖",
      "🤣",
      "😮",
      "😔",
      "👍"
    ], i = (s) => {
      n("select", s);
    };
    return (s, a) => (X(), gt(ke(YOe), { placement: "top" }, {
      content: Zt(() => [
        W("div", ZOe, [
          (X(), se(wt, null, on(r, (o) => W("div", {
            key: o,
            class: "cursor-pointer transition-all hover:translate-y-[-2px]",
            onClick: (u) => i(o)
          }, _e(o), 9, JOe)), 64))
        ])
      ]),
      default: Zt(() => [
        W("div", KOe, [
          Jr(s.$slots, "default", {}, () => [
            et(vN, { class: "cursor-pointer fill-[#6c727f]" })
          ])
        ])
      ]),
      _: 3
    }));
  }
}), eNe = { class: "reactions flex items-center gap-1" }, tNe = ["onClick"], nNe = { class: "text-xs" }, rNe = /* @__PURE__ */ Ze({
  name: "ReactionList",
  __name: "ReactionList",
  props: {
    reactions: {}
  },
  emits: ["selectEmoji"],
  setup(t, { emit: e }) {
    const n = t, r = e, i = Yt(), s = de(() => i.state.imkit.uid), a = de(() => {
      const c = /* @__PURE__ */ new Map();
      return n.reactions.forEach((d) => {
        const l = c.get(d.reaction);
        l ? (l.count += 1, l.clients.includes(d.client) || l.clients.push(d.client)) : c.set(d.reaction, {
          reaction: d.reaction,
          count: 1,
          clients: [d.client]
        });
      }), Array.from(c.values());
    }), o = (c) => {
      r("selectEmoji", c);
    }, u = (c) => [c.clients.includes(s.value) ? "bg-[#dff7fe] border-[#447faf] border text-[#447faf]" : "bg-white dark:bg-zinc-500", "flex items-center gap-1 rounded-full px-2 py-1 cursor-pointer"];
    return (c, d) => (X(), se("div", eNe, [
      (X(!0), se(wt, null, on(a.value, (l) => (X(), se("div", {
        key: l.reaction,
        class: vt(u(l)),
        onClick: (f) => o(l.reaction)
      }, [
        W("span", null, _e(l.reaction), 1),
        W("span", nNe, _e(l.count), 1)
      ], 10, tNe))), 128))
    ]));
  }
}), iNe = {}, sNe = {
  "aria-hidden": "true",
  class: "animate-spin fill-blue-400 text-gray-200 dark:fill-sky-700 dark:text-gray-700",
  viewBox: "0 0 100 101",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function aNe(t, e) {
  return X(), se("svg", sNe, e[0] || (e[0] = [
    W("path", {
      d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
      fill: "currentColor"
    }, null, -1),
    W("path", {
      d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
      fill: "currentFill"
    }, null, -1)
  ]));
}
const _c = /* @__PURE__ */ mn(iNe, [["render", aNe]]), oNe = { class: "mb-1 flex items-center justify-between text-xl font-medium text-gray-700 dark:text-gray-300" }, uNe = { class: "text-gray-500 dark:text-gray-400" }, lNe = { class: "flex items-center justify-center gap-2" }, TN = /* @__PURE__ */ Ze({
  __name: "DeleteMessageConfirmModal",
  props: {
    messageId: {},
    deleteType: {}
  },
  setup(t) {
    const e = $n(), n = Yt(), r = Se(!1), i = t, s = de(
      () => {
        var o;
        return (o = n.state.imkit.messageMultiList.main) == null ? void 0 : o.map.get(i.messageId);
      }
    ), a = async () => {
      r.value = !0;
      try {
        i.deleteType === "everyone" ? await n.dispatch("imkit/deleteMessage", {
          roomId: s.value.roomId,
          messageId: i.messageId
        }) : await n.dispatch("imkit/hideMessage", {
          roomId: s.value.roomId,
          messageIds: [i.messageId]
        }), e.closeAll();
      } catch (o) {
        console.error("Error deleting message:", o);
      } finally {
        r.value = !1;
      }
    };
    return (o, u) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[200px] max-w-full rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", oNe, [
          W("span", null, _e(o.$t("confirmDeleteMessage")), 1),
          W("button", {
            class: "flex items-center justify-center",
            onClick: u[0] || (u[0] = (c) => ke(e).closeAll())
          }, [
            et(Br, { class: "h-6 w-6" })
          ])
        ]),
        W("div", uNe, [
          i.deleteType === "everyone" ? (X(), se(wt, { key: 0 }, [
            An(_e(o.$t("deleteForEveryoneWarning")), 1)
          ], 64)) : (X(), se(wt, { key: 1 }, [
            An(_e(o.$t("deleteForMeWarning")), 1)
          ], 64))
        ]),
        W("div", lNe, [
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 w-[100px] grow rounded-lg border border-gray-200 text-base dark:border-stone-400 dark:text-stone-400",
            onClick: u[1] || (u[1] = (c) => ke(e).closeAll())
          }, _e(o.$t("cancel")), 1),
          W("button", {
            class: vt(["flex h-10 w-[100px] grow items-center justify-center gap-2 rounded-lg text-base text-white", r.value ? "cursor-not-allowed bg-red-300" : "bg-red-500"]),
            onClick: u[2] || (u[2] = (c) => a())
          }, [
            r.value ? (X(), gt(_c, {
              key: 0,
              class: vt(["h-4 w-4", r.value ? "fill-red-300! text-white!" : "fill-red-500"])
            }, null, 8, ["class"])) : Fe("", !0),
            An(" " + _e(o.$t("delete")), 1)
          ], 2)
        ])
      ]),
      _: 1
    }));
  }
}), cNe = { class: "mb-3 flex items-center justify-between text-xl font-semibold text-gray-700 dark:text-gray-300" }, dNe = /* @__PURE__ */ Ze({
  __name: "DeleteMessageModal",
  props: {
    messageId: {},
    roomId: {}
  },
  setup(t) {
    const e = $n(), n = Yt(), r = t, i = de(() => n.state.imkit.rooms[r.roomId]), s = (a) => {
      const { open: o } = Jn({
        component: TN,
        attrs: {
          messageId: r.messageId,
          deleteType: a
        }
      });
      o();
    };
    return (a, o) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => {
        var u;
        return [
          W("div", cNe, [
            o[3] || (o[3] = W("div", null, " ", -1)),
            An(" " + _e(a.$t("deleteMessageConfirmation")) + " ", 1),
            W("button", {
              class: "flex items-center justify-center",
              onClick: o[0] || (o[0] = (c) => ke(e).closeAll())
            }, [
              et(Br, { class: "h-7 w-7" })
            ])
          ]),
          W("button", {
            class: "flex h-10 w-full items-center justify-center rounded-lg border border-gray-300 text-base text-gray-700 dark:border-zinc-600 dark:text-gray-300",
            onClick: o[1] || (o[1] = (c) => s("me"))
          }, _e(a.$t("deleteForMe")), 1),
          (u = i.value) != null && u.isSuperuser && i.value.type === ke($a).Group ? (X(), se("button", {
            key: 0,
            class: "flex h-10 w-full items-center justify-center rounded-lg bg-red-500 text-base text-white",
            onClick: o[2] || (o[2] = (c) => s("everyone"))
          }, _e(a.$t("deleteForEveryone")), 1)) : Fe("", !0)
        ];
      }),
      _: 1
    }));
  }
}), fNe = {}, hNe = {
  width: "20",
  height: "20",
  viewBox: "0 0 20 20",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function pNe(t, e) {
  return X(), se("svg", hNe, e[0] || (e[0] = [
    W("path", {
      d: "M10 1.875C8.39303 1.875 6.82214 2.35152 5.486 3.24431C4.14985 4.1371 3.10844 5.40605 2.49348 6.8907C1.87852 8.37535 1.71762 10.009 2.03112 11.5851C2.34463 13.1612 3.11846 14.6089 4.25476 15.7452C5.39106 16.8815 6.8388 17.6554 8.41489 17.9689C9.99099 18.2824 11.6247 18.1215 13.1093 17.5065C14.594 16.8916 15.8629 15.8502 16.7557 14.514C17.6485 13.1779 18.125 11.607 18.125 10C18.1227 7.84581 17.266 5.78051 15.7427 4.25727C14.2195 2.73403 12.1542 1.87727 10 1.875ZM9.375 6.25C9.375 6.08424 9.44085 5.92527 9.55806 5.80806C9.67527 5.69085 9.83424 5.625 10 5.625C10.1658 5.625 10.3247 5.69085 10.4419 5.80806C10.5592 5.92527 10.625 6.08424 10.625 6.25V10.625C10.625 10.7908 10.5592 10.9497 10.4419 11.0669C10.3247 11.1842 10.1658 11.25 10 11.25C9.83424 11.25 9.67527 11.1842 9.55806 11.0669C9.44085 10.9497 9.375 10.7908 9.375 10.625V6.25ZM10 14.375C9.81458 14.375 9.63333 14.32 9.47916 14.217C9.32498 14.114 9.20482 13.9676 9.13387 13.7963C9.06291 13.625 9.04434 13.4365 9.08052 13.2546C9.11669 13.0727 9.20598 12.9057 9.33709 12.7746C9.4682 12.6435 9.63525 12.5542 9.81711 12.518C9.99896 12.4818 10.1875 12.5004 10.3588 12.5714C10.5301 12.6423 10.6765 12.7625 10.7795 12.9167C10.8825 13.0708 10.9375 13.2521 10.9375 13.4375C10.9375 13.6861 10.8387 13.9246 10.6629 14.1004C10.4871 14.2762 10.2486 14.375 10 14.375Z",
      fill: "#C23B33"
    }, null, -1)
  ]));
}
const NC = /* @__PURE__ */ mn(fNe, [["render", pNe]]), mNe = {}, gNe = {
  xmlns: "http://www.w3.org/2000/svg",
  x: "0px",
  y: "0px",
  width: "50",
  height: "50",
  viewBox: "0 0 50 50"
};
function ANe(t, e) {
  return X(), se("svg", gNe, e[0] || (e[0] = [
    W("path", { d: "M 25 2 A 2.0002 2.0002 0 1 0 25 6 C 35.517124 6 44 14.482876 44 25 C 44 35.517124 35.517124 44 25 44 C 14.482876 44 6 35.517124 6 25 C 6 19.524201 8.3080175 14.608106 12 11.144531 L 12 15 A 2.0002 2.0002 0 1 0 16 15 L 16 4 L 5 4 A 2.0002 2.0002 0 1 0 5 8 L 9.5253906 8 C 4.9067015 12.20948 2 18.272325 2 25 C 2 37.678876 12.321124 48 25 48 C 37.678876 48 48 37.678876 48 25 C 48 12.321124 37.678876 2 25 2 z" }, null, -1)
  ]));
}
const bNe = /* @__PURE__ */ mn(mNe, [["render", ANe]]), yNe = {}, vNe = {
  xmlns: "http://www.w3.org/2000/svg",
  x: "0px",
  y: "0px",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32"
};
function TNe(t, e) {
  return X(), se("svg", vNe, e[0] || (e[0] = [
    W("path", { d: "M 15 4 C 14.476563 4 13.941406 4.183594 13.5625 4.5625 C 13.183594 4.941406 13 5.476563 13 6 L 13 7 L 7 7 L 7 9 L 8 9 L 8 25 C 8 26.644531 9.355469 28 11 28 L 23 28 C 24.644531 28 26 26.644531 26 25 L 26 9 L 27 9 L 27 7 L 21 7 L 21 6 C 21 5.476563 20.816406 4.941406 20.4375 4.5625 C 20.058594 4.183594 19.523438 4 19 4 Z M 15 6 L 19 6 L 19 7 L 15 7 Z M 10 9 L 24 9 L 24 25 C 24 25.554688 23.554688 26 23 26 L 11 26 C 10.445313 26 10 25.554688 10 25 Z M 12 12 L 12 23 L 14 23 L 14 12 Z M 16 12 L 16 23 L 18 23 L 18 12 Z M 20 12 L 20 23 L 22 23 L 22 12 Z" }, null, -1)
  ]));
}
const _Ne = /* @__PURE__ */ mn(yNe, [["render", TNe]]), ENe = {
  key: 0,
  class: "mt-4 mb-2 flex items-center justify-center"
}, xNe = { class: "rounded-full bg-gray-100 px-2 py-1 text-xs text-gray-600 dark:bg-zinc-700 dark:text-gray-400" }, wNe = {
  key: 1,
  class: "col-span-2 text-xs font-medium text-gray-500 dark:text-gray-300"
}, CNe = {
  key: 0,
  class: "flex items-center justify-end gap-2"
}, SNe = { class: "relative flex items-center justify-center" }, INe = {
  key: 1,
  class: "flex flex-col items-end self-end-safe"
}, kNe = {
  key: 2,
  class: "flex flex-col items-end self-end-safe text-xs text-gray-500 dark:text-gray-300"
}, DNe = { key: 0 }, MNe = {
  key: 3,
  class: "self-end text-xs text-gray-500 dark:text-gray-300"
}, ONe = {
  key: 4,
  class: "flex shrink-0 items-center justify-start gap-2"
}, NNe = /* @__PURE__ */ Ze({
  inheritAttrs: !1,
  __name: "MessageCell",
  props: {
    source: {}
  },
  setup(t) {
    const e = t;
    Ba("messageId", e.source.id);
    const n = Ri(), r = de(() => e.source), i = de(() => a.state.imkit.config.settings), s = {
      [ft.Text]: xa,
      [ft.Image]: l4e,
      [ft.Sticker]: oD,
      [ft.Video]: TIe,
      [ft.File]: CIe,
      [ft.Template]: WIe,
      [ft.Flex]: _ke,
      [ft.Location]: t5e,
      [ft.Audio]: h5e,
      [ft.Recall]: xa,
      [ft.JoinRoom]: xa,
      [ft.LeaveRoom]: xa,
      [ft.AddMember]: xa,
      [ft.DeleteMember]: xa,
      [ft.AddMembers]: xa,
      [ft.Announcement]: xa,
      [ft.Typing]: v5e,
      [ft.PaymentSelect]: ODe,
      [ft.Line]: xa
    }, a = Yt(), o = de(() => {
      if (a.state.imkit.uid !== e.source.senderId) return 0;
      const { rooms: be, uid: ve, messageMultiList: Ce } = a.state.imkit, Ne = be[e.source.roomId];
      return Ne ? Object.keys(Ne.lastReadMessageId).filter((qe) => qe !== ve).map((qe) => {
        var Xe;
        const $e = Ne.lastReadMessageId[qe];
        return (Xe = Ce.main) == null ? void 0 : Xe.finds($e);
      }).reduce((qe, $e) => $e && $e.createdAt >= e.source.createdAt ? qe + 1 : qe, 0) : 0;
    }), u = de(() => e.source.isIncoming), c = de(() => !u.value), d = de(() => {
      var Ce, Ne;
      if (r.value.type === ft.Typing)
        return !0;
      const ve = (((Ce = a.state.imkit.messageMultiList.main) == null ? void 0 : Ce.messageGroups) ?? /* @__PURE__ */ new Map()).get(r.value.groupId);
      return ve ? ve[0].id === r.value.id || ((Ne = r.value.prev) == null ? void 0 : Ne.senderId) !== r.value.senderId : !1;
    }), l = de(() => {
      var Ce, Ne;
      if (r.value.type === ft.Typing)
        return !0;
      const ve = (((Ce = a.state.imkit.messageMultiList.main) == null ? void 0 : Ce.messageGroups) ?? /* @__PURE__ */ new Map()).get(r.value.groupId);
      return ve ? ve[ve.length - 1].id === r.value.id || ((Ne = r.value.next) == null ? void 0 : Ne.senderId) !== r.value.senderId : !1;
    }), f = de(() => r.value.reactions), p = de(() => f.value.length > 0), m = de(() => !(/* @__PURE__ */ new Set([
      ft.Sticker,
      ft.Audio,
      ft.File,
      ft.Image,
      ft.Video,
      ft.Flex,
      ft.Template
    ])).has(e.source.type)), g = de(() => (/* @__PURE__ */ new Set([
      ft.Text,
      ft.Image,
      ft.Video,
      ft.Sticker
    ])).has(e.source.type)), y = de(() => e.source.type === ft.Text), b = de(() => {
      var be, ve;
      return ((ve = (be = e.source.template) == null ? void 0 : be.quickReply) == null ? void 0 : ve.items) || [];
    }), E = Se(!1), v = (be) => {
      u.value && e.source.type === ft.Flex || (E.value = !0, be.preventDefault());
    }, _ = () => {
      E.value = !1, a.commit("imkit/setState", { replyId: e.source.id });
    }, D = () => {
      E.value = !1;
      let be = "";
      switch (e.source.type) {
        case ft.Text:
          be = e.source.text;
          break;
        case ft.Location:
          be = e.source.address;
          break;
      }
      navigator.clipboard.writeText(be);
    }, S = de(() => a.state.imkit.rooms[e.source.roomId]), M = () => {
      a.commit("imkit/deleteMessages", [e.source.id]);
    }, O = () => {
      var be;
      if ((be = S.value) != null && be.isSuperuser && S.value.type === $a.Group) {
        const { open: ve } = Jn({
          component: dNe,
          attrs: {
            messageId: e.source.id,
            roomId: e.source.roomId
          }
        });
        ve();
      } else {
        const { open: ve } = Jn({
          component: TN,
          attrs: {
            messageId: e.source.id,
            deleteType: "me"
          }
        });
        ve();
      }
    }, T = () => {
      E.value = !1, a.dispatch("imkit/recallMessage", {
        roomId: e.source.roomId,
        _id: e.source.id,
        messageType: "recall"
      });
    }, N = () => {
      a.dispatch("imkit/retryMessage", e.source);
    }, H = de(() => {
      const be = /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g;
      if (e.source.type === ft.Text) {
        const ve = e.source.text;
        for (let Ce = 0; Ce < ve.length; Ce++)
          if (!be.test(ve[Ce]))
            return !1;
        return !0;
      }
      return !1;
    }), $ = de(() => e.source), j = de(() => e.source.isSystem), U = de(() => a.state.imkit.config.styles), V = de(
      () => a.state.imkit.config.translationApiKey
    ), B = de(
      () => a.state.imkit.users[e.source.senderId]
    ), R = de(() => a.state.imkit.uid), K = de(() => {
      var ve, Ce;
      return ((Ce = (((ve = a.state.imkit.messageMultiList.main) == null ? void 0 : ve.firstMessageOfDate) ?? /* @__PURE__ */ new Map()).get(e.source.dateId)) == null ? void 0 : Ce.id) === e.source.id;
    }), Q = de(() => [
      u.value ? "rounded-r-xl" : "rounded-l-xl",
      c.value && d.value ? "rounded-tr-xl" : "",
      c.value && l.value ? "rounded-br-xl" : "",
      u.value && d.value ? "rounded-tl-xl" : "",
      u.value && l.value ? "rounded-bl-xl" : ""
    ]), P = de(() => {
      const be = [...Q.value], ve = e.source.type, Ce = $.value.templateType;
      return ((/* @__PURE__ */ new Set([
        ft.Sticker,
        ft.Image,
        ft.Template,
        ft.Flex
      ])).has(ve) || (/* @__PURE__ */ new Set([
        Pa.ImageCarousel,
        Pa.Carousel
      ])).has(Ce) || H.value) && be.push("bg-white! dark:bg-zinc-800!"), H.value && be.push("text-3xl!"), [ft.PaymentSelect].includes(e.source.type) && be.push("flex-[0_0_268px] px-0"), !(/* @__PURE__ */ new Set([ft.Template, ft.Flex])).has(ve) && !(/* @__PURE__ */ new Set([
        Pa.ImageCarousel,
        Pa.Carousel
      ])).has(Ce) && be.push("px-3", "py-2"), ve === ft.Audio && be.push("w-full", "max-w-[250px]!"), be;
    }), I = () => {
      E.value = !1, a.dispatch("imkit/translateMessage", e.source);
    }, G = async (be) => (E.value = !1, f.value.some(
      (Ce) => Ce.reaction === be && Ce.client === R.value
    ) ? a.dispatch("imkit/deleteReaction", {
      messageId: e.source.id,
      reaction: be
    }) : a.dispatch("imkit/sendReaction", {
      messageId: e.source.id,
      reaction: be
    })), te = Se(null);
    n6(te, (be) => {
      be.target instanceof HTMLInputElement || be.target instanceof HTMLTextAreaElement || (E.value = !0);
    }, {
      modifiers: { prevent: !1 }
    });
    const Z = Se(!1);
    let ye = null, he = null, Ee = null;
    return Ct(
      () => r.value.status,
      (be) => {
        if (ye && (clearTimeout(ye), ye = null), he && (clearTimeout(he), he = null), be !== Ss.Sending) {
          if (Z.value && Ee) {
            const ve = Date.now() - Ee, Ce = Math.max(0, 1e3 - ve);
            he = setTimeout(() => {
              Z.value = !1, Ee = null, he = null;
            }, Ce);
          } else
            Z.value = !1, Ee = null;
          return;
        }
        be === Ss.Sending && c.value && (ye = setTimeout(() => {
          Z.value = !0, Ee = Date.now(), ye = null;
        }, 1e3));
      },
      { immediate: !0 }
    ), Dc(() => {
      ye && clearTimeout(ye), he && clearTimeout(he);
    }), (be, ve) => {
      var Ce, Ne, qe, $e, Xe;
      return X(), se(wt, null, [
        K.value ? (X(), se("div", ENe, [
          W("div", xNe, _e(ke(NMe)(be.source.createdAt, ke(n).t)), 1)
        ])) : Fe("", !0),
        j.value ? (X(), gt(g5e, {
          key: 1,
          message: be.source
        }, null, 8, ["message"])) : (X(), se("div", {
          key: 2,
          class: vt(["grid w-full grid-flow-row gap-2", [
            u.value ? d.value ? "grid-cols-[30px_fit-content(75%)_120px] grid-rows-[16px_1fr]" : "grid-cols-[fit-content(75%)_120px] pl-[38px]" : "grid-cols-[minmax(140px,auto)_fit-content(75%)]",
            d.value ? "mt-1" : "mt-0.25",
            l.value ? "mb-1" : "mb-0.25",
            b.value.length > 0 ? "mb-[40px]" : ""
          ]]),
          onMouseleave: ve[1] || (ve[1] = (at) => E.value = !1)
        }, [
          u.value && d.value ? (X(), gt(Zr, {
            key: 0,
            url: ((Ce = B.value) == null ? void 0 : Ce.avatarUrl) ?? "",
            name: ((Ne = B.value) == null ? void 0 : Ne.nickname) ?? "",
            class: "row-span-2 h-[30px]! w-[30px]! rounded-full text-xs"
          }, null, 8, ["url", "name"])) : Fe("", !0),
          u.value && d.value ? (X(), se("div", wNe, _e(((qe = B.value) == null ? void 0 : qe.nickname) ?? ""), 1)) : Fe("", !0),
          c.value ? (X(), se(wt, { key: 2 }, [
            E.value ? Gt((X(), se("div", CNe, [
              r.value.status === ke(Ss).Delivered ? (X(), se(wt, { key: 0 }, [
                W("img", {
                  src: S3,
                  class: "my-auto h-5 w-5 cursor-pointer",
                  onClick: O
                }),
                W("img", {
                  src: SR,
                  class: "my-auto h-5 w-5 cursor-pointer",
                  onClick: T
                }),
                m.value ? (X(), se("img", {
                  key: 0,
                  src: I3,
                  class: "my-auto h-5 w-5 cursor-pointer",
                  onClick: D
                })) : Fe("", !0),
                g.value ? (X(), se("img", {
                  key: 1,
                  src: k3,
                  class: "my-auto h-5 w-5 cursor-pointer",
                  onClick: _
                })) : Fe("", !0),
                W("div", SNe, [
                  et(OC, { onSelect: G })
                ])
              ], 64)) : r.value.status === ke(Ss).Failed ? (X(), se(wt, { key: 1 }, [
                et(_Ne, {
                  class: "h-5.5 w-5.5 cursor-pointer fill-slate-500 dark:fill-slate-400",
                  onClick: M
                }),
                et(bNe, {
                  class: "h-4 w-4 cursor-pointer fill-slate-500 dark:fill-slate-400",
                  onClick: N
                })
              ], 64)) : Fe("", !0)
            ])), [
              [ke(So), () => E.value = !1]
            ]) : l.value ? Fe("", !0) : (X(), se("div", INe, [
              Z.value ? (X(), gt(_c, {
                key: 0,
                class: "h-3 w-3"
              })) : r.value.status === ke(Ss).Failed ? (X(), gt(NC, {
                key: 1,
                class: "h-4 w-4"
              })) : Fe("", !0)
            ])),
            l.value && !E.value ? (X(), se("div", kNe, [
              i.value.enableReadReceipt && o.value > 0 ? (X(), se("div", DNe, [
                An(_e(be.$t("read")) + " ", 1),
                (($e = S.value) == null ? void 0 : $e.type) === ke($a).Group ? (X(), se(wt, { key: 0 }, [
                  An(_e(o.value), 1)
                ], 64)) : Fe("", !0)
              ])) : Fe("", !0),
              W("div", null, [
                Z.value ? (X(), gt(_c, {
                  key: 0,
                  class: "mr-1 mb-0.5 inline h-3 w-3"
                })) : r.value.status === ke(Ss).Failed ? (X(), gt(NC, {
                  key: 1,
                  class: "mr-1 mb-0.5 inline h-4 w-4"
                })) : Fe("", !0),
                An(" " + _e(ke(Wn)(be.source.createdAt).format("H:mm")), 1)
              ])
            ])) : Fe("", !0)
          ], 64)) : Fe("", !0),
          W("div", {
            ref_key: "messageCellRef",
            ref: te,
            class: vt(["relative overflow-hidden rounded bg-gray-100 text-gray-900 dark:bg-zinc-700 dark:text-gray-100", P.value]),
            style: Qt([
              u.value ? U.value.incomingMessageCell : U.value.outgoingMessageCell
            ]),
            onContextmenu: v,
            onMouseenter: ve[0] || (ve[0] = (at) => E.value = !0)
          }, [
            (X(), gt(xu(s[be.source.type]), { message: r.value }, null, 8, ["message"])),
            p.value ? (X(), gt(rNe, {
              key: 0,
              reactions: f.value,
              class: "mt-2",
              onSelectEmoji: G
            }, null, 8, ["reactions"])) : Fe("", !0)
          ], 38),
          u.value && l.value && !E.value && r.value.type !== ke(ft).Typing ? (X(), se("div", MNe, _e(ke(Wn)(be.source.createdAt).format("H:mm")), 1)) : Fe("", !0),
          u.value && E.value ? Gt((X(), se("div", ONe, [
            g.value ? (X(), se("img", {
              key: 0,
              src: k3,
              class: vt(["my-auto h-5 w-5 cursor-pointer", d.value ? "ml-1" : "ml-2"]),
              onClick: _
            }, null, 2)) : Fe("", !0),
            m.value ? (X(), se("img", {
              key: 1,
              src: I3,
              class: "my-auto h-5 w-5 cursor-pointer",
              onClick: D
            })) : Fe("", !0),
            et(OC, {
              class: "relative flex items-center justify-center",
              onSelect: G
            }),
            y.value && V.value ? (X(), gt(PMe, {
              key: 2,
              class: "cursor-pointer fill-gray-600",
              onClick: I
            })) : Fe("", !0),
            (Xe = S.value) != null && Xe.isSuperuser && S.value.type === ke($a).Group ? (X(), se("img", {
              key: 3,
              src: S3,
              class: "my-auto h-5 w-5 cursor-pointer",
              onClick: O
            })) : Fe("", !0)
          ])), [
            [ke(So), () => E.value = !1]
          ]) : Fe("", !0)
        ], 34))
      ], 64);
    };
  }
}), LNe = /* @__PURE__ */ mn(NNe, [["__scopeId", "data-v-09f933c4"]]), PNe = { class: "absolute right-0 bottom-[110%] flex h-80 w-80 max-w-full flex-col divide-y overflow-auto rounded-xl bg-white shadow-lg dark:bg-zinc-800" }, RNe = { class: "grid grow grid-cols-3 items-center justify-center gap-4 overflow-y-auto p-4 sm:grid-cols-4" }, BNe = ["src", "onClick"], FNe = {
  key: 0,
  class: "flex h-14 w-full shrink-0 gap-4 overflow-x-auto p-3"
}, UNe = ["src", "onClick"], $Ne = /* @__PURE__ */ Ze({
  __name: "StickerPanel",
  emits: ["close"],
  setup(t, { emit: e }) {
    const n = Yt(), r = [
      { name: "FunFunFamily", number: 40 }
      // { name: 'animal', number: 16 },
      // { name: 'emoji', number: 40 },
      // { name: 'food', number: 16 },
      // { name: 'money', number: 11 },
      // { name: 'natural', number: 30 },
      // { name: 'people', number: 16 },
      // { name: 'sport', number: 16 },
    ], i = Se(r[0]), s = de(
      () => n.state.imkit.rooms[n.state.imkit.selectedRoomId]
    ), a = e, o = async (u) => {
      const c = {
        roomId: s.value.id,
        messageType: "sticker",
        sticker: u
      };
      await n.dispatch("imkit/sendMessage", c), a("close");
    };
    return (u, c) => (X(), se("div", PNe, [
      W("div", RNe, [
        (X(!0), se(wt, null, on(i.value.number, (d) => (X(), se("img", {
          key: d,
          src: `/sticker/${i.value.name}/${i.value.name}-${d}.png`,
          class: "cursor-pointer border-0 object-contain",
          onClick: (l) => o(`${i.value.name}-${d}`)
        }, null, 8, BNe))), 128))
      ]),
      r.length > 1 ? (X(), se("div", FNe, [
        (X(), se(wt, null, on(r, (d) => W("img", {
          key: d.name,
          src: `/sticker/${d.name}/${d.name}-1.png`,
          class: "h-full cursor-pointer border-0 object-contain",
          onClick: (l) => i.value = d
        }, null, 8, UNe)), 64))
      ])) : Fe("", !0)
    ]));
  }
}), _N = "https://cdn.jsdelivr.net/npm/emoji-datasource-apple@6.0.1/img/apple/64", EN = {
  recent: "Recently used",
  smileys_people: "Smiles & People",
  animals_nature: "Animals & Nature",
  food_drink: "Food & Drink",
  activities: "Activities",
  travel_places: "Travel places",
  objects: "Objects",
  symbols: "Symbols",
  flags: "Flags"
}, xN = "u", Yg = "n", Vp = "v", ih = "r", HNe = {
  [Yg]: ["grinning face", "grinning"],
  [xN]: "1f600",
  [ih]: "1f600"
}, I0 = "neutral", jNe = "1f3fb", zNe = "1f3fc", qNe = "1f3fd", VNe = "1f3fe", WNe = "1f3ff", QNe = [
  I0,
  jNe,
  zNe,
  qNe,
  VNe,
  WNe
], GNe = {
  placeholder: "Search emoji",
  skinTone: "Skin tone"
}, YNe = ["light", "dark", "auto"], XNe = [
  {
    n: [
      "grinning face",
      "grinning"
    ],
    u: "1f600"
  },
  {
    n: [
      "grinning face with smiling eyes",
      "grin"
    ],
    u: "1f601"
  },
  {
    n: [
      "face with tears of joy",
      "joy"
    ],
    u: "1f602"
  },
  {
    n: [
      "rolling on the floor laughing",
      "rolling_on_the_floor_laughing"
    ],
    u: "1f923"
  },
  {
    n: [
      "smiling face with open mouth",
      "smiley"
    ],
    u: "1f603"
  },
  {
    n: [
      "smiling face with open mouth and smiling eyes",
      "smile"
    ],
    u: "1f604"
  },
  {
    n: [
      "smiling face with open mouth and cold sweat",
      "sweat_smile"
    ],
    u: "1f605"
  },
  {
    n: [
      "smiling face with open mouth and tightly-closed eyes",
      "laughing",
      "satisfied"
    ],
    u: "1f606"
  },
  {
    n: [
      "winking face",
      "wink"
    ],
    u: "1f609"
  },
  {
    n: [
      "smiling face with smiling eyes",
      "blush"
    ],
    u: "1f60a"
  },
  {
    n: [
      "face savouring delicious food",
      "yum"
    ],
    u: "1f60b"
  },
  {
    n: [
      "smiling face with sunglasses",
      "sunglasses"
    ],
    u: "1f60e"
  },
  {
    n: [
      "smiling face with heart-shaped eyes",
      "heart_eyes"
    ],
    u: "1f60d"
  },
  {
    n: [
      "face throwing a kiss",
      "kissing_heart"
    ],
    u: "1f618"
  },
  {
    n: [
      "kissing face",
      "kissing"
    ],
    u: "1f617"
  },
  {
    n: [
      "kissing face with smiling eyes",
      "kissing_smiling_eyes"
    ],
    u: "1f619"
  },
  {
    n: [
      "kissing face with closed eyes",
      "kissing_closed_eyes"
    ],
    u: "1f61a"
  },
  {
    n: [
      "white smiling face",
      "relaxed"
    ],
    u: "263a-fe0f"
  },
  {
    n: [
      "slightly smiling face",
      "slightly_smiling_face"
    ],
    u: "1f642"
  },
  {
    n: [
      "hugging face",
      "hugging_face"
    ],
    u: "1f917"
  },
  {
    n: [
      "grinning face with star eyes",
      "star-struck",
      "grinning_face_with_star_eyes"
    ],
    u: "1f929"
  },
  {
    n: [
      "thinking face",
      "thinking_face"
    ],
    u: "1f914"
  },
  {
    n: [
      "face with one eyebrow raised",
      "face_with_raised_eyebrow",
      "face_with_one_eyebrow_raised"
    ],
    u: "1f928"
  },
  {
    n: [
      "neutral face",
      "neutral_face"
    ],
    u: "1f610"
  },
  {
    n: [
      "expressionless face",
      "expressionless"
    ],
    u: "1f611"
  },
  {
    n: [
      "face without mouth",
      "no_mouth"
    ],
    u: "1f636"
  },
  {
    n: [
      "face with rolling eyes",
      "face_with_rolling_eyes"
    ],
    u: "1f644"
  },
  {
    n: [
      "smirking face",
      "smirk"
    ],
    u: "1f60f"
  },
  {
    n: [
      "persevering face",
      "persevere"
    ],
    u: "1f623"
  },
  {
    n: [
      "disappointed but relieved face",
      "disappointed_relieved"
    ],
    u: "1f625"
  },
  {
    n: [
      "face with open mouth",
      "open_mouth"
    ],
    u: "1f62e"
  },
  {
    n: [
      "zipper-mouth face",
      "zipper_mouth_face"
    ],
    u: "1f910"
  },
  {
    n: [
      "hushed face",
      "hushed"
    ],
    u: "1f62f"
  },
  {
    n: [
      "sleepy face",
      "sleepy"
    ],
    u: "1f62a"
  },
  {
    n: [
      "tired face",
      "tired_face"
    ],
    u: "1f62b"
  },
  {
    n: [
      "sleeping face",
      "sleeping"
    ],
    u: "1f634"
  },
  {
    n: [
      "relieved face",
      "relieved"
    ],
    u: "1f60c"
  },
  {
    n: [
      "face with stuck-out tongue",
      "stuck_out_tongue"
    ],
    u: "1f61b"
  },
  {
    n: [
      "face with stuck-out tongue and winking eye",
      "stuck_out_tongue_winking_eye"
    ],
    u: "1f61c"
  },
  {
    n: [
      "face with stuck-out tongue and tightly-closed eyes",
      "stuck_out_tongue_closed_eyes"
    ],
    u: "1f61d"
  },
  {
    n: [
      "drooling face",
      "drooling_face"
    ],
    u: "1f924"
  },
  {
    n: [
      "unamused face",
      "unamused"
    ],
    u: "1f612"
  },
  {
    n: [
      "face with cold sweat",
      "sweat"
    ],
    u: "1f613"
  },
  {
    n: [
      "pensive face",
      "pensive"
    ],
    u: "1f614"
  },
  {
    n: [
      "confused face",
      "confused"
    ],
    u: "1f615"
  },
  {
    n: [
      "upside-down face",
      "upside_down_face"
    ],
    u: "1f643"
  },
  {
    n: [
      "money-mouth face",
      "money_mouth_face"
    ],
    u: "1f911"
  },
  {
    n: [
      "astonished face",
      "astonished"
    ],
    u: "1f632"
  },
  {
    n: [
      "white_frowning_face"
    ],
    u: "2639-fe0f"
  },
  {
    n: [
      "slightly frowning face",
      "slightly_frowning_face"
    ],
    u: "1f641"
  },
  {
    n: [
      "confounded face",
      "confounded"
    ],
    u: "1f616"
  },
  {
    n: [
      "disappointed face",
      "disappointed"
    ],
    u: "1f61e"
  },
  {
    n: [
      "worried face",
      "worried"
    ],
    u: "1f61f"
  },
  {
    n: [
      "face with look of triumph",
      "triumph"
    ],
    u: "1f624"
  },
  {
    n: [
      "crying face",
      "cry"
    ],
    u: "1f622"
  },
  {
    n: [
      "loudly crying face",
      "sob"
    ],
    u: "1f62d"
  },
  {
    n: [
      "frowning face with open mouth",
      "frowning"
    ],
    u: "1f626"
  },
  {
    n: [
      "anguished face",
      "anguished"
    ],
    u: "1f627"
  },
  {
    n: [
      "fearful face",
      "fearful"
    ],
    u: "1f628"
  },
  {
    n: [
      "weary face",
      "weary"
    ],
    u: "1f629"
  },
  {
    n: [
      "shocked face with exploding head",
      "exploding_head",
      "shocked_face_with_exploding_head"
    ],
    u: "1f92f"
  },
  {
    n: [
      "grimacing face",
      "grimacing"
    ],
    u: "1f62c"
  },
  {
    n: [
      "face with open mouth and cold sweat",
      "cold_sweat"
    ],
    u: "1f630"
  },
  {
    n: [
      "face screaming in fear",
      "scream"
    ],
    u: "1f631"
  },
  {
    n: [
      "flushed face",
      "flushed"
    ],
    u: "1f633"
  },
  {
    n: [
      "grinning face with one large and one small eye",
      "zany_face",
      "grinning_face_with_one_large_and_one_small_eye"
    ],
    u: "1f92a"
  },
  {
    n: [
      "dizzy face",
      "dizzy_face"
    ],
    u: "1f635"
  },
  {
    n: [
      "pouting face",
      "rage"
    ],
    u: "1f621"
  },
  {
    n: [
      "angry face",
      "angry"
    ],
    u: "1f620"
  },
  {
    n: [
      "serious face with symbols covering mouth",
      "face_with_symbols_on_mouth",
      "serious_face_with_symbols_covering_mouth"
    ],
    u: "1f92c"
  },
  {
    n: [
      "face with medical mask",
      "mask"
    ],
    u: "1f637"
  },
  {
    n: [
      "face with thermometer",
      "face_with_thermometer"
    ],
    u: "1f912"
  },
  {
    n: [
      "face with head-bandage",
      "face_with_head_bandage"
    ],
    u: "1f915"
  },
  {
    n: [
      "nauseated face",
      "nauseated_face"
    ],
    u: "1f922"
  },
  {
    n: [
      "face with open mouth vomiting",
      "face_vomiting",
      "face_with_open_mouth_vomiting"
    ],
    u: "1f92e"
  },
  {
    n: [
      "sneezing face",
      "sneezing_face"
    ],
    u: "1f927"
  },
  {
    n: [
      "smiling face with halo",
      "innocent"
    ],
    u: "1f607"
  },
  {
    n: [
      "face with cowboy hat",
      "face_with_cowboy_hat"
    ],
    u: "1f920"
  },
  {
    n: [
      "clown face",
      "clown_face"
    ],
    u: "1f921"
  },
  {
    n: [
      "lying face",
      "lying_face"
    ],
    u: "1f925"
  },
  {
    n: [
      "face with finger covering closed lips",
      "shushing_face",
      "face_with_finger_covering_closed_lips"
    ],
    u: "1f92b"
  },
  {
    n: [
      "smiling face with smiling eyes and hand covering mouth",
      "face_with_hand_over_mouth",
      "smiling_face_with_smiling_eyes_and_hand_covering_mouth"
    ],
    u: "1f92d"
  },
  {
    n: [
      "face with monocle",
      "face_with_monocle"
    ],
    u: "1f9d0"
  },
  {
    n: [
      "nerd face",
      "nerd_face"
    ],
    u: "1f913"
  },
  {
    n: [
      "smiling face with horns",
      "smiling_imp"
    ],
    u: "1f608"
  },
  {
    n: [
      "imp"
    ],
    u: "1f47f"
  },
  {
    n: [
      "japanese ogre",
      "japanese_ogre"
    ],
    u: "1f479"
  },
  {
    n: [
      "japanese goblin",
      "japanese_goblin"
    ],
    u: "1f47a"
  },
  {
    n: [
      "skull"
    ],
    u: "1f480"
  },
  {
    n: [
      "skull_and_crossbones"
    ],
    u: "2620-fe0f"
  },
  {
    n: [
      "ghost"
    ],
    u: "1f47b"
  },
  {
    n: [
      "extraterrestrial alien",
      "alien"
    ],
    u: "1f47d"
  },
  {
    n: [
      "alien monster",
      "space_invader"
    ],
    u: "1f47e"
  },
  {
    n: [
      "robot face",
      "robot_face"
    ],
    u: "1f916"
  },
  {
    n: [
      "pile of poo",
      "hankey",
      "poop",
      "shit"
    ],
    u: "1f4a9"
  },
  {
    n: [
      "smiling cat face with open mouth",
      "smiley_cat"
    ],
    u: "1f63a"
  },
  {
    n: [
      "grinning cat face with smiling eyes",
      "smile_cat"
    ],
    u: "1f638"
  },
  {
    n: [
      "cat face with tears of joy",
      "joy_cat"
    ],
    u: "1f639"
  },
  {
    n: [
      "smiling cat face with heart-shaped eyes",
      "heart_eyes_cat"
    ],
    u: "1f63b"
  },
  {
    n: [
      "cat face with wry smile",
      "smirk_cat"
    ],
    u: "1f63c"
  },
  {
    n: [
      "kissing cat face with closed eyes",
      "kissing_cat"
    ],
    u: "1f63d"
  },
  {
    n: [
      "weary cat face",
      "scream_cat"
    ],
    u: "1f640"
  },
  {
    n: [
      "crying cat face",
      "crying_cat_face"
    ],
    u: "1f63f"
  },
  {
    n: [
      "pouting cat face",
      "pouting_cat"
    ],
    u: "1f63e"
  },
  {
    n: [
      "see-no-evil monkey",
      "see_no_evil"
    ],
    u: "1f648"
  },
  {
    n: [
      "hear-no-evil monkey",
      "hear_no_evil"
    ],
    u: "1f649"
  },
  {
    n: [
      "speak-no-evil monkey",
      "speak_no_evil"
    ],
    u: "1f64a"
  },
  {
    n: [
      "baby"
    ],
    u: "1f476",
    v: [
      "1f476-1f3fb",
      "1f476-1f3fc",
      "1f476-1f3fd",
      "1f476-1f3fe",
      "1f476-1f3ff"
    ]
  },
  {
    n: [
      "child"
    ],
    u: "1f9d2",
    v: [
      "1f9d2-1f3fb",
      "1f9d2-1f3fc",
      "1f9d2-1f3fd",
      "1f9d2-1f3fe",
      "1f9d2-1f3ff"
    ]
  },
  {
    n: [
      "boy"
    ],
    u: "1f466",
    v: [
      "1f466-1f3fb",
      "1f466-1f3fc",
      "1f466-1f3fd",
      "1f466-1f3fe",
      "1f466-1f3ff"
    ]
  },
  {
    n: [
      "girl"
    ],
    u: "1f467",
    v: [
      "1f467-1f3fb",
      "1f467-1f3fc",
      "1f467-1f3fd",
      "1f467-1f3fe",
      "1f467-1f3ff"
    ]
  },
  {
    n: [
      "adult"
    ],
    u: "1f9d1",
    v: [
      "1f9d1-1f3fb",
      "1f9d1-1f3fc",
      "1f9d1-1f3fd",
      "1f9d1-1f3fe",
      "1f9d1-1f3ff"
    ]
  },
  {
    n: [
      "man"
    ],
    u: "1f468",
    v: [
      "1f468-1f3fb",
      "1f468-1f3fc",
      "1f468-1f3fd",
      "1f468-1f3fe",
      "1f468-1f3ff"
    ]
  },
  {
    n: [
      "woman"
    ],
    u: "1f469",
    v: [
      "1f469-1f3fb",
      "1f469-1f3fc",
      "1f469-1f3fd",
      "1f469-1f3fe",
      "1f469-1f3ff"
    ]
  },
  {
    n: [
      "older adult",
      "older_adult"
    ],
    u: "1f9d3",
    v: [
      "1f9d3-1f3fb",
      "1f9d3-1f3fc",
      "1f9d3-1f3fd",
      "1f9d3-1f3fe",
      "1f9d3-1f3ff"
    ]
  },
  {
    n: [
      "older man",
      "older_man"
    ],
    u: "1f474",
    v: [
      "1f474-1f3fb",
      "1f474-1f3fc",
      "1f474-1f3fd",
      "1f474-1f3fe",
      "1f474-1f3ff"
    ]
  },
  {
    n: [
      "older woman",
      "older_woman"
    ],
    u: "1f475",
    v: [
      "1f475-1f3fb",
      "1f475-1f3fc",
      "1f475-1f3fd",
      "1f475-1f3fe",
      "1f475-1f3ff"
    ]
  },
  {
    n: [
      "male-doctor"
    ],
    u: "1f468-200d-2695-fe0f",
    v: [
      "1f468-1f3fb-200d-2695-fe0f",
      "1f468-1f3fc-200d-2695-fe0f",
      "1f468-1f3fd-200d-2695-fe0f",
      "1f468-1f3fe-200d-2695-fe0f",
      "1f468-1f3ff-200d-2695-fe0f"
    ]
  },
  {
    n: [
      "female-doctor"
    ],
    u: "1f469-200d-2695-fe0f",
    v: [
      "1f469-1f3fb-200d-2695-fe0f",
      "1f469-1f3fc-200d-2695-fe0f",
      "1f469-1f3fd-200d-2695-fe0f",
      "1f469-1f3fe-200d-2695-fe0f",
      "1f469-1f3ff-200d-2695-fe0f"
    ]
  },
  {
    n: [
      "male-student"
    ],
    u: "1f468-200d-1f393",
    v: [
      "1f468-1f3fb-200d-1f393",
      "1f468-1f3fc-200d-1f393",
      "1f468-1f3fd-200d-1f393",
      "1f468-1f3fe-200d-1f393",
      "1f468-1f3ff-200d-1f393"
    ]
  },
  {
    n: [
      "female-student"
    ],
    u: "1f469-200d-1f393",
    v: [
      "1f469-1f3fb-200d-1f393",
      "1f469-1f3fc-200d-1f393",
      "1f469-1f3fd-200d-1f393",
      "1f469-1f3fe-200d-1f393",
      "1f469-1f3ff-200d-1f393"
    ]
  },
  {
    n: [
      "male-teacher"
    ],
    u: "1f468-200d-1f3eb",
    v: [
      "1f468-1f3fb-200d-1f3eb",
      "1f468-1f3fc-200d-1f3eb",
      "1f468-1f3fd-200d-1f3eb",
      "1f468-1f3fe-200d-1f3eb",
      "1f468-1f3ff-200d-1f3eb"
    ]
  },
  {
    n: [
      "female-teacher"
    ],
    u: "1f469-200d-1f3eb",
    v: [
      "1f469-1f3fb-200d-1f3eb",
      "1f469-1f3fc-200d-1f3eb",
      "1f469-1f3fd-200d-1f3eb",
      "1f469-1f3fe-200d-1f3eb",
      "1f469-1f3ff-200d-1f3eb"
    ]
  },
  {
    n: [
      "male-judge"
    ],
    u: "1f468-200d-2696-fe0f",
    v: [
      "1f468-1f3fb-200d-2696-fe0f",
      "1f468-1f3fc-200d-2696-fe0f",
      "1f468-1f3fd-200d-2696-fe0f",
      "1f468-1f3fe-200d-2696-fe0f",
      "1f468-1f3ff-200d-2696-fe0f"
    ]
  },
  {
    n: [
      "female-judge"
    ],
    u: "1f469-200d-2696-fe0f",
    v: [
      "1f469-1f3fb-200d-2696-fe0f",
      "1f469-1f3fc-200d-2696-fe0f",
      "1f469-1f3fd-200d-2696-fe0f",
      "1f469-1f3fe-200d-2696-fe0f",
      "1f469-1f3ff-200d-2696-fe0f"
    ]
  },
  {
    n: [
      "male-farmer"
    ],
    u: "1f468-200d-1f33e",
    v: [
      "1f468-1f3fb-200d-1f33e",
      "1f468-1f3fc-200d-1f33e",
      "1f468-1f3fd-200d-1f33e",
      "1f468-1f3fe-200d-1f33e",
      "1f468-1f3ff-200d-1f33e"
    ]
  },
  {
    n: [
      "female-farmer"
    ],
    u: "1f469-200d-1f33e",
    v: [
      "1f469-1f3fb-200d-1f33e",
      "1f469-1f3fc-200d-1f33e",
      "1f469-1f3fd-200d-1f33e",
      "1f469-1f3fe-200d-1f33e",
      "1f469-1f3ff-200d-1f33e"
    ]
  },
  {
    n: [
      "male-cook"
    ],
    u: "1f468-200d-1f373",
    v: [
      "1f468-1f3fb-200d-1f373",
      "1f468-1f3fc-200d-1f373",
      "1f468-1f3fd-200d-1f373",
      "1f468-1f3fe-200d-1f373",
      "1f468-1f3ff-200d-1f373"
    ]
  },
  {
    n: [
      "female-cook"
    ],
    u: "1f469-200d-1f373",
    v: [
      "1f469-1f3fb-200d-1f373",
      "1f469-1f3fc-200d-1f373",
      "1f469-1f3fd-200d-1f373",
      "1f469-1f3fe-200d-1f373",
      "1f469-1f3ff-200d-1f373"
    ]
  },
  {
    n: [
      "male-mechanic"
    ],
    u: "1f468-200d-1f527",
    v: [
      "1f468-1f3fb-200d-1f527",
      "1f468-1f3fc-200d-1f527",
      "1f468-1f3fd-200d-1f527",
      "1f468-1f3fe-200d-1f527",
      "1f468-1f3ff-200d-1f527"
    ]
  },
  {
    n: [
      "female-mechanic"
    ],
    u: "1f469-200d-1f527",
    v: [
      "1f469-1f3fb-200d-1f527",
      "1f469-1f3fc-200d-1f527",
      "1f469-1f3fd-200d-1f527",
      "1f469-1f3fe-200d-1f527",
      "1f469-1f3ff-200d-1f527"
    ]
  },
  {
    n: [
      "male-factory-worker"
    ],
    u: "1f468-200d-1f3ed",
    v: [
      "1f468-1f3fb-200d-1f3ed",
      "1f468-1f3fc-200d-1f3ed",
      "1f468-1f3fd-200d-1f3ed",
      "1f468-1f3fe-200d-1f3ed",
      "1f468-1f3ff-200d-1f3ed"
    ]
  },
  {
    n: [
      "female-factory-worker"
    ],
    u: "1f469-200d-1f3ed",
    v: [
      "1f469-1f3fb-200d-1f3ed",
      "1f469-1f3fc-200d-1f3ed",
      "1f469-1f3fd-200d-1f3ed",
      "1f469-1f3fe-200d-1f3ed",
      "1f469-1f3ff-200d-1f3ed"
    ]
  },
  {
    n: [
      "male-office-worker"
    ],
    u: "1f468-200d-1f4bc",
    v: [
      "1f468-1f3fb-200d-1f4bc",
      "1f468-1f3fc-200d-1f4bc",
      "1f468-1f3fd-200d-1f4bc",
      "1f468-1f3fe-200d-1f4bc",
      "1f468-1f3ff-200d-1f4bc"
    ]
  },
  {
    n: [
      "female-office-worker"
    ],
    u: "1f469-200d-1f4bc",
    v: [
      "1f469-1f3fb-200d-1f4bc",
      "1f469-1f3fc-200d-1f4bc",
      "1f469-1f3fd-200d-1f4bc",
      "1f469-1f3fe-200d-1f4bc",
      "1f469-1f3ff-200d-1f4bc"
    ]
  },
  {
    n: [
      "male-scientist"
    ],
    u: "1f468-200d-1f52c",
    v: [
      "1f468-1f3fb-200d-1f52c",
      "1f468-1f3fc-200d-1f52c",
      "1f468-1f3fd-200d-1f52c",
      "1f468-1f3fe-200d-1f52c",
      "1f468-1f3ff-200d-1f52c"
    ]
  },
  {
    n: [
      "female-scientist"
    ],
    u: "1f469-200d-1f52c",
    v: [
      "1f469-1f3fb-200d-1f52c",
      "1f469-1f3fc-200d-1f52c",
      "1f469-1f3fd-200d-1f52c",
      "1f469-1f3fe-200d-1f52c",
      "1f469-1f3ff-200d-1f52c"
    ]
  },
  {
    n: [
      "male-technologist"
    ],
    u: "1f468-200d-1f4bb",
    v: [
      "1f468-1f3fb-200d-1f4bb",
      "1f468-1f3fc-200d-1f4bb",
      "1f468-1f3fd-200d-1f4bb",
      "1f468-1f3fe-200d-1f4bb",
      "1f468-1f3ff-200d-1f4bb"
    ]
  },
  {
    n: [
      "female-technologist"
    ],
    u: "1f469-200d-1f4bb",
    v: [
      "1f469-1f3fb-200d-1f4bb",
      "1f469-1f3fc-200d-1f4bb",
      "1f469-1f3fd-200d-1f4bb",
      "1f469-1f3fe-200d-1f4bb",
      "1f469-1f3ff-200d-1f4bb"
    ]
  },
  {
    n: [
      "male-singer"
    ],
    u: "1f468-200d-1f3a4",
    v: [
      "1f468-1f3fb-200d-1f3a4",
      "1f468-1f3fc-200d-1f3a4",
      "1f468-1f3fd-200d-1f3a4",
      "1f468-1f3fe-200d-1f3a4",
      "1f468-1f3ff-200d-1f3a4"
    ]
  },
  {
    n: [
      "female-singer"
    ],
    u: "1f469-200d-1f3a4",
    v: [
      "1f469-1f3fb-200d-1f3a4",
      "1f469-1f3fc-200d-1f3a4",
      "1f469-1f3fd-200d-1f3a4",
      "1f469-1f3fe-200d-1f3a4",
      "1f469-1f3ff-200d-1f3a4"
    ]
  },
  {
    n: [
      "male-artist"
    ],
    u: "1f468-200d-1f3a8",
    v: [
      "1f468-1f3fb-200d-1f3a8",
      "1f468-1f3fc-200d-1f3a8",
      "1f468-1f3fd-200d-1f3a8",
      "1f468-1f3fe-200d-1f3a8",
      "1f468-1f3ff-200d-1f3a8"
    ]
  },
  {
    n: [
      "female-artist"
    ],
    u: "1f469-200d-1f3a8",
    v: [
      "1f469-1f3fb-200d-1f3a8",
      "1f469-1f3fc-200d-1f3a8",
      "1f469-1f3fd-200d-1f3a8",
      "1f469-1f3fe-200d-1f3a8",
      "1f469-1f3ff-200d-1f3a8"
    ]
  },
  {
    n: [
      "male-pilot"
    ],
    u: "1f468-200d-2708-fe0f",
    v: [
      "1f468-1f3fb-200d-2708-fe0f",
      "1f468-1f3fc-200d-2708-fe0f",
      "1f468-1f3fd-200d-2708-fe0f",
      "1f468-1f3fe-200d-2708-fe0f",
      "1f468-1f3ff-200d-2708-fe0f"
    ]
  },
  {
    n: [
      "female-pilot"
    ],
    u: "1f469-200d-2708-fe0f",
    v: [
      "1f469-1f3fb-200d-2708-fe0f",
      "1f469-1f3fc-200d-2708-fe0f",
      "1f469-1f3fd-200d-2708-fe0f",
      "1f469-1f3fe-200d-2708-fe0f",
      "1f469-1f3ff-200d-2708-fe0f"
    ]
  },
  {
    n: [
      "male-astronaut"
    ],
    u: "1f468-200d-1f680",
    v: [
      "1f468-1f3fb-200d-1f680",
      "1f468-1f3fc-200d-1f680",
      "1f468-1f3fd-200d-1f680",
      "1f468-1f3fe-200d-1f680",
      "1f468-1f3ff-200d-1f680"
    ]
  },
  {
    n: [
      "female-astronaut"
    ],
    u: "1f469-200d-1f680",
    v: [
      "1f469-1f3fb-200d-1f680",
      "1f469-1f3fc-200d-1f680",
      "1f469-1f3fd-200d-1f680",
      "1f469-1f3fe-200d-1f680",
      "1f469-1f3ff-200d-1f680"
    ]
  },
  {
    n: [
      "male-firefighter"
    ],
    u: "1f468-200d-1f692",
    v: [
      "1f468-1f3fb-200d-1f692",
      "1f468-1f3fc-200d-1f692",
      "1f468-1f3fd-200d-1f692",
      "1f468-1f3fe-200d-1f692",
      "1f468-1f3ff-200d-1f692"
    ]
  },
  {
    n: [
      "female-firefighter"
    ],
    u: "1f469-200d-1f692",
    v: [
      "1f469-1f3fb-200d-1f692",
      "1f469-1f3fc-200d-1f692",
      "1f469-1f3fd-200d-1f692",
      "1f469-1f3fe-200d-1f692",
      "1f469-1f3ff-200d-1f692"
    ]
  },
  {
    n: [
      "police officer",
      "cop"
    ],
    u: "1f46e",
    v: [
      "1f46e-1f3fb",
      "1f46e-1f3fc",
      "1f46e-1f3fd",
      "1f46e-1f3fe",
      "1f46e-1f3ff"
    ]
  },
  {
    n: [
      "male-police-officer"
    ],
    u: "1f46e-200d-2642-fe0f",
    v: [
      "1f46e-1f3fb-200d-2642-fe0f",
      "1f46e-1f3fc-200d-2642-fe0f",
      "1f46e-1f3fd-200d-2642-fe0f",
      "1f46e-1f3fe-200d-2642-fe0f",
      "1f46e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-police-officer"
    ],
    u: "1f46e-200d-2640-fe0f",
    v: [
      "1f46e-1f3fb-200d-2640-fe0f",
      "1f46e-1f3fc-200d-2640-fe0f",
      "1f46e-1f3fd-200d-2640-fe0f",
      "1f46e-1f3fe-200d-2640-fe0f",
      "1f46e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "sleuth_or_spy"
    ],
    u: "1f575-fe0f",
    v: [
      "1f575-1f3fb",
      "1f575-1f3fc",
      "1f575-1f3fd",
      "1f575-1f3fe",
      "1f575-1f3ff"
    ]
  },
  {
    n: [
      "male-detective"
    ],
    u: "1f575-fe0f-200d-2642-fe0f",
    v: [
      "1f575-1f3fb-200d-2642-fe0f",
      "1f575-1f3fc-200d-2642-fe0f",
      "1f575-1f3fd-200d-2642-fe0f",
      "1f575-1f3fe-200d-2642-fe0f",
      "1f575-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-detective"
    ],
    u: "1f575-fe0f-200d-2640-fe0f",
    v: [
      "1f575-1f3fb-200d-2640-fe0f",
      "1f575-1f3fc-200d-2640-fe0f",
      "1f575-1f3fd-200d-2640-fe0f",
      "1f575-1f3fe-200d-2640-fe0f",
      "1f575-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "guardsman"
    ],
    u: "1f482",
    v: [
      "1f482-1f3fb",
      "1f482-1f3fc",
      "1f482-1f3fd",
      "1f482-1f3fe",
      "1f482-1f3ff"
    ]
  },
  {
    n: [
      "male-guard"
    ],
    u: "1f482-200d-2642-fe0f",
    v: [
      "1f482-1f3fb-200d-2642-fe0f",
      "1f482-1f3fc-200d-2642-fe0f",
      "1f482-1f3fd-200d-2642-fe0f",
      "1f482-1f3fe-200d-2642-fe0f",
      "1f482-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-guard"
    ],
    u: "1f482-200d-2640-fe0f",
    v: [
      "1f482-1f3fb-200d-2640-fe0f",
      "1f482-1f3fc-200d-2640-fe0f",
      "1f482-1f3fd-200d-2640-fe0f",
      "1f482-1f3fe-200d-2640-fe0f",
      "1f482-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "construction worker",
      "construction_worker"
    ],
    u: "1f477",
    v: [
      "1f477-1f3fb",
      "1f477-1f3fc",
      "1f477-1f3fd",
      "1f477-1f3fe",
      "1f477-1f3ff"
    ]
  },
  {
    n: [
      "male-construction-worker"
    ],
    u: "1f477-200d-2642-fe0f",
    v: [
      "1f477-1f3fb-200d-2642-fe0f",
      "1f477-1f3fc-200d-2642-fe0f",
      "1f477-1f3fd-200d-2642-fe0f",
      "1f477-1f3fe-200d-2642-fe0f",
      "1f477-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "female-construction-worker"
    ],
    u: "1f477-200d-2640-fe0f",
    v: [
      "1f477-1f3fb-200d-2640-fe0f",
      "1f477-1f3fc-200d-2640-fe0f",
      "1f477-1f3fd-200d-2640-fe0f",
      "1f477-1f3fe-200d-2640-fe0f",
      "1f477-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "prince"
    ],
    u: "1f934",
    v: [
      "1f934-1f3fb",
      "1f934-1f3fc",
      "1f934-1f3fd",
      "1f934-1f3fe",
      "1f934-1f3ff"
    ]
  },
  {
    n: [
      "princess"
    ],
    u: "1f478",
    v: [
      "1f478-1f3fb",
      "1f478-1f3fc",
      "1f478-1f3fd",
      "1f478-1f3fe",
      "1f478-1f3ff"
    ]
  },
  {
    n: [
      "man with turban",
      "man_with_turban"
    ],
    u: "1f473",
    v: [
      "1f473-1f3fb",
      "1f473-1f3fc",
      "1f473-1f3fd",
      "1f473-1f3fe",
      "1f473-1f3ff"
    ]
  },
  {
    n: [
      "man-wearing-turban"
    ],
    u: "1f473-200d-2642-fe0f",
    v: [
      "1f473-1f3fb-200d-2642-fe0f",
      "1f473-1f3fc-200d-2642-fe0f",
      "1f473-1f3fd-200d-2642-fe0f",
      "1f473-1f3fe-200d-2642-fe0f",
      "1f473-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-wearing-turban"
    ],
    u: "1f473-200d-2640-fe0f",
    v: [
      "1f473-1f3fb-200d-2640-fe0f",
      "1f473-1f3fc-200d-2640-fe0f",
      "1f473-1f3fd-200d-2640-fe0f",
      "1f473-1f3fe-200d-2640-fe0f",
      "1f473-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man with gua pi mao",
      "man_with_gua_pi_mao"
    ],
    u: "1f472",
    v: [
      "1f472-1f3fb",
      "1f472-1f3fc",
      "1f472-1f3fd",
      "1f472-1f3fe",
      "1f472-1f3ff"
    ]
  },
  {
    n: [
      "person with headscarf",
      "person_with_headscarf"
    ],
    u: "1f9d5",
    v: [
      "1f9d5-1f3fb",
      "1f9d5-1f3fc",
      "1f9d5-1f3fd",
      "1f9d5-1f3fe",
      "1f9d5-1f3ff"
    ]
  },
  {
    n: [
      "bearded person",
      "bearded_person"
    ],
    u: "1f9d4",
    v: [
      "1f9d4-1f3fb",
      "1f9d4-1f3fc",
      "1f9d4-1f3fd",
      "1f9d4-1f3fe",
      "1f9d4-1f3ff"
    ]
  },
  {
    n: [
      "person with blond hair",
      "person_with_blond_hair"
    ],
    u: "1f471",
    v: [
      "1f471-1f3fb",
      "1f471-1f3fc",
      "1f471-1f3fd",
      "1f471-1f3fe",
      "1f471-1f3ff"
    ]
  },
  {
    n: [
      "blond-haired-man"
    ],
    u: "1f471-200d-2642-fe0f",
    v: [
      "1f471-1f3fb-200d-2642-fe0f",
      "1f471-1f3fc-200d-2642-fe0f",
      "1f471-1f3fd-200d-2642-fe0f",
      "1f471-1f3fe-200d-2642-fe0f",
      "1f471-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "blond-haired-woman"
    ],
    u: "1f471-200d-2640-fe0f",
    v: [
      "1f471-1f3fb-200d-2640-fe0f",
      "1f471-1f3fc-200d-2640-fe0f",
      "1f471-1f3fd-200d-2640-fe0f",
      "1f471-1f3fe-200d-2640-fe0f",
      "1f471-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man in tuxedo",
      "man_in_tuxedo"
    ],
    u: "1f935",
    v: [
      "1f935-1f3fb",
      "1f935-1f3fc",
      "1f935-1f3fd",
      "1f935-1f3fe",
      "1f935-1f3ff"
    ]
  },
  {
    n: [
      "bride with veil",
      "bride_with_veil"
    ],
    u: "1f470",
    v: [
      "1f470-1f3fb",
      "1f470-1f3fc",
      "1f470-1f3fd",
      "1f470-1f3fe",
      "1f470-1f3ff"
    ]
  },
  {
    n: [
      "pregnant woman",
      "pregnant_woman"
    ],
    u: "1f930",
    v: [
      "1f930-1f3fb",
      "1f930-1f3fc",
      "1f930-1f3fd",
      "1f930-1f3fe",
      "1f930-1f3ff"
    ]
  },
  {
    n: [
      "breast-feeding"
    ],
    u: "1f931",
    v: [
      "1f931-1f3fb",
      "1f931-1f3fc",
      "1f931-1f3fd",
      "1f931-1f3fe",
      "1f931-1f3ff"
    ]
  },
  {
    n: [
      "baby angel",
      "angel"
    ],
    u: "1f47c",
    v: [
      "1f47c-1f3fb",
      "1f47c-1f3fc",
      "1f47c-1f3fd",
      "1f47c-1f3fe",
      "1f47c-1f3ff"
    ]
  },
  {
    n: [
      "father christmas",
      "santa"
    ],
    u: "1f385",
    v: [
      "1f385-1f3fb",
      "1f385-1f3fc",
      "1f385-1f3fd",
      "1f385-1f3fe",
      "1f385-1f3ff"
    ]
  },
  {
    n: [
      "mother christmas",
      "mrs_claus",
      "mother_christmas"
    ],
    u: "1f936",
    v: [
      "1f936-1f3fb",
      "1f936-1f3fc",
      "1f936-1f3fd",
      "1f936-1f3fe",
      "1f936-1f3ff"
    ]
  },
  {
    n: [
      "mage"
    ],
    u: "1f9d9",
    v: [
      "1f9d9-1f3fb",
      "1f9d9-1f3fc",
      "1f9d9-1f3fd",
      "1f9d9-1f3fe",
      "1f9d9-1f3ff"
    ]
  },
  {
    n: [
      "female_mage"
    ],
    u: "1f9d9-200d-2640-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2640-fe0f",
      "1f9d9-1f3fc-200d-2640-fe0f",
      "1f9d9-1f3fd-200d-2640-fe0f",
      "1f9d9-1f3fe-200d-2640-fe0f",
      "1f9d9-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_mage"
    ],
    u: "1f9d9-200d-2642-fe0f",
    v: [
      "1f9d9-1f3fb-200d-2642-fe0f",
      "1f9d9-1f3fc-200d-2642-fe0f",
      "1f9d9-1f3fd-200d-2642-fe0f",
      "1f9d9-1f3fe-200d-2642-fe0f",
      "1f9d9-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "fairy"
    ],
    u: "1f9da",
    v: [
      "1f9da-1f3fb",
      "1f9da-1f3fc",
      "1f9da-1f3fd",
      "1f9da-1f3fe",
      "1f9da-1f3ff"
    ]
  },
  {
    n: [
      "female_fairy"
    ],
    u: "1f9da-200d-2640-fe0f",
    v: [
      "1f9da-1f3fb-200d-2640-fe0f",
      "1f9da-1f3fc-200d-2640-fe0f",
      "1f9da-1f3fd-200d-2640-fe0f",
      "1f9da-1f3fe-200d-2640-fe0f",
      "1f9da-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_fairy"
    ],
    u: "1f9da-200d-2642-fe0f",
    v: [
      "1f9da-1f3fb-200d-2642-fe0f",
      "1f9da-1f3fc-200d-2642-fe0f",
      "1f9da-1f3fd-200d-2642-fe0f",
      "1f9da-1f3fe-200d-2642-fe0f",
      "1f9da-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "vampire"
    ],
    u: "1f9db",
    v: [
      "1f9db-1f3fb",
      "1f9db-1f3fc",
      "1f9db-1f3fd",
      "1f9db-1f3fe",
      "1f9db-1f3ff"
    ]
  },
  {
    n: [
      "female_vampire"
    ],
    u: "1f9db-200d-2640-fe0f",
    v: [
      "1f9db-1f3fb-200d-2640-fe0f",
      "1f9db-1f3fc-200d-2640-fe0f",
      "1f9db-1f3fd-200d-2640-fe0f",
      "1f9db-1f3fe-200d-2640-fe0f",
      "1f9db-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_vampire"
    ],
    u: "1f9db-200d-2642-fe0f",
    v: [
      "1f9db-1f3fb-200d-2642-fe0f",
      "1f9db-1f3fc-200d-2642-fe0f",
      "1f9db-1f3fd-200d-2642-fe0f",
      "1f9db-1f3fe-200d-2642-fe0f",
      "1f9db-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "merperson"
    ],
    u: "1f9dc",
    v: [
      "1f9dc-1f3fb",
      "1f9dc-1f3fc",
      "1f9dc-1f3fd",
      "1f9dc-1f3fe",
      "1f9dc-1f3ff"
    ]
  },
  {
    n: [
      "mermaid"
    ],
    u: "1f9dc-200d-2640-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2640-fe0f",
      "1f9dc-1f3fc-200d-2640-fe0f",
      "1f9dc-1f3fd-200d-2640-fe0f",
      "1f9dc-1f3fe-200d-2640-fe0f",
      "1f9dc-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "merman"
    ],
    u: "1f9dc-200d-2642-fe0f",
    v: [
      "1f9dc-1f3fb-200d-2642-fe0f",
      "1f9dc-1f3fc-200d-2642-fe0f",
      "1f9dc-1f3fd-200d-2642-fe0f",
      "1f9dc-1f3fe-200d-2642-fe0f",
      "1f9dc-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "elf"
    ],
    u: "1f9dd",
    v: [
      "1f9dd-1f3fb",
      "1f9dd-1f3fc",
      "1f9dd-1f3fd",
      "1f9dd-1f3fe",
      "1f9dd-1f3ff"
    ]
  },
  {
    n: [
      "female_elf"
    ],
    u: "1f9dd-200d-2640-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2640-fe0f",
      "1f9dd-1f3fc-200d-2640-fe0f",
      "1f9dd-1f3fd-200d-2640-fe0f",
      "1f9dd-1f3fe-200d-2640-fe0f",
      "1f9dd-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "male_elf"
    ],
    u: "1f9dd-200d-2642-fe0f",
    v: [
      "1f9dd-1f3fb-200d-2642-fe0f",
      "1f9dd-1f3fc-200d-2642-fe0f",
      "1f9dd-1f3fd-200d-2642-fe0f",
      "1f9dd-1f3fe-200d-2642-fe0f",
      "1f9dd-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "genie"
    ],
    u: "1f9de"
  },
  {
    n: [
      "female_genie"
    ],
    u: "1f9de-200d-2640-fe0f"
  },
  {
    n: [
      "male_genie"
    ],
    u: "1f9de-200d-2642-fe0f"
  },
  {
    n: [
      "zombie"
    ],
    u: "1f9df"
  },
  {
    n: [
      "female_zombie"
    ],
    u: "1f9df-200d-2640-fe0f"
  },
  {
    n: [
      "male_zombie"
    ],
    u: "1f9df-200d-2642-fe0f"
  },
  {
    n: [
      "person frowning",
      "person_frowning"
    ],
    u: "1f64d",
    v: [
      "1f64d-1f3fb",
      "1f64d-1f3fc",
      "1f64d-1f3fd",
      "1f64d-1f3fe",
      "1f64d-1f3ff"
    ]
  },
  {
    n: [
      "man-frowning"
    ],
    u: "1f64d-200d-2642-fe0f",
    v: [
      "1f64d-1f3fb-200d-2642-fe0f",
      "1f64d-1f3fc-200d-2642-fe0f",
      "1f64d-1f3fd-200d-2642-fe0f",
      "1f64d-1f3fe-200d-2642-fe0f",
      "1f64d-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-frowning"
    ],
    u: "1f64d-200d-2640-fe0f",
    v: [
      "1f64d-1f3fb-200d-2640-fe0f",
      "1f64d-1f3fc-200d-2640-fe0f",
      "1f64d-1f3fd-200d-2640-fe0f",
      "1f64d-1f3fe-200d-2640-fe0f",
      "1f64d-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person with pouting face",
      "person_with_pouting_face"
    ],
    u: "1f64e",
    v: [
      "1f64e-1f3fb",
      "1f64e-1f3fc",
      "1f64e-1f3fd",
      "1f64e-1f3fe",
      "1f64e-1f3ff"
    ]
  },
  {
    n: [
      "man-pouting"
    ],
    u: "1f64e-200d-2642-fe0f",
    v: [
      "1f64e-1f3fb-200d-2642-fe0f",
      "1f64e-1f3fc-200d-2642-fe0f",
      "1f64e-1f3fd-200d-2642-fe0f",
      "1f64e-1f3fe-200d-2642-fe0f",
      "1f64e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-pouting"
    ],
    u: "1f64e-200d-2640-fe0f",
    v: [
      "1f64e-1f3fb-200d-2640-fe0f",
      "1f64e-1f3fc-200d-2640-fe0f",
      "1f64e-1f3fd-200d-2640-fe0f",
      "1f64e-1f3fe-200d-2640-fe0f",
      "1f64e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face with no good gesture",
      "no_good"
    ],
    u: "1f645",
    v: [
      "1f645-1f3fb",
      "1f645-1f3fc",
      "1f645-1f3fd",
      "1f645-1f3fe",
      "1f645-1f3ff"
    ]
  },
  {
    n: [
      "man-gesturing-no"
    ],
    u: "1f645-200d-2642-fe0f",
    v: [
      "1f645-1f3fb-200d-2642-fe0f",
      "1f645-1f3fc-200d-2642-fe0f",
      "1f645-1f3fd-200d-2642-fe0f",
      "1f645-1f3fe-200d-2642-fe0f",
      "1f645-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-gesturing-no"
    ],
    u: "1f645-200d-2640-fe0f",
    v: [
      "1f645-1f3fb-200d-2640-fe0f",
      "1f645-1f3fc-200d-2640-fe0f",
      "1f645-1f3fd-200d-2640-fe0f",
      "1f645-1f3fe-200d-2640-fe0f",
      "1f645-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face with ok gesture",
      "ok_woman"
    ],
    u: "1f646",
    v: [
      "1f646-1f3fb",
      "1f646-1f3fc",
      "1f646-1f3fd",
      "1f646-1f3fe",
      "1f646-1f3ff"
    ]
  },
  {
    n: [
      "man-gesturing-ok"
    ],
    u: "1f646-200d-2642-fe0f",
    v: [
      "1f646-1f3fb-200d-2642-fe0f",
      "1f646-1f3fc-200d-2642-fe0f",
      "1f646-1f3fd-200d-2642-fe0f",
      "1f646-1f3fe-200d-2642-fe0f",
      "1f646-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-gesturing-ok"
    ],
    u: "1f646-200d-2640-fe0f",
    v: [
      "1f646-1f3fb-200d-2640-fe0f",
      "1f646-1f3fc-200d-2640-fe0f",
      "1f646-1f3fd-200d-2640-fe0f",
      "1f646-1f3fe-200d-2640-fe0f",
      "1f646-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "information desk person",
      "information_desk_person"
    ],
    u: "1f481",
    v: [
      "1f481-1f3fb",
      "1f481-1f3fc",
      "1f481-1f3fd",
      "1f481-1f3fe",
      "1f481-1f3ff"
    ]
  },
  {
    n: [
      "man-tipping-hand"
    ],
    u: "1f481-200d-2642-fe0f",
    v: [
      "1f481-1f3fb-200d-2642-fe0f",
      "1f481-1f3fc-200d-2642-fe0f",
      "1f481-1f3fd-200d-2642-fe0f",
      "1f481-1f3fe-200d-2642-fe0f",
      "1f481-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-tipping-hand"
    ],
    u: "1f481-200d-2640-fe0f",
    v: [
      "1f481-1f3fb-200d-2640-fe0f",
      "1f481-1f3fc-200d-2640-fe0f",
      "1f481-1f3fd-200d-2640-fe0f",
      "1f481-1f3fe-200d-2640-fe0f",
      "1f481-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "happy person raising one hand",
      "raising_hand"
    ],
    u: "1f64b",
    v: [
      "1f64b-1f3fb",
      "1f64b-1f3fc",
      "1f64b-1f3fd",
      "1f64b-1f3fe",
      "1f64b-1f3ff"
    ]
  },
  {
    n: [
      "man-raising-hand"
    ],
    u: "1f64b-200d-2642-fe0f",
    v: [
      "1f64b-1f3fb-200d-2642-fe0f",
      "1f64b-1f3fc-200d-2642-fe0f",
      "1f64b-1f3fd-200d-2642-fe0f",
      "1f64b-1f3fe-200d-2642-fe0f",
      "1f64b-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-raising-hand"
    ],
    u: "1f64b-200d-2640-fe0f",
    v: [
      "1f64b-1f3fb-200d-2640-fe0f",
      "1f64b-1f3fc-200d-2640-fe0f",
      "1f64b-1f3fd-200d-2640-fe0f",
      "1f64b-1f3fe-200d-2640-fe0f",
      "1f64b-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person bowing deeply",
      "bow"
    ],
    u: "1f647",
    v: [
      "1f647-1f3fb",
      "1f647-1f3fc",
      "1f647-1f3fd",
      "1f647-1f3fe",
      "1f647-1f3ff"
    ]
  },
  {
    n: [
      "man-bowing"
    ],
    u: "1f647-200d-2642-fe0f",
    v: [
      "1f647-1f3fb-200d-2642-fe0f",
      "1f647-1f3fc-200d-2642-fe0f",
      "1f647-1f3fd-200d-2642-fe0f",
      "1f647-1f3fe-200d-2642-fe0f",
      "1f647-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-bowing"
    ],
    u: "1f647-200d-2640-fe0f",
    v: [
      "1f647-1f3fb-200d-2640-fe0f",
      "1f647-1f3fc-200d-2640-fe0f",
      "1f647-1f3fd-200d-2640-fe0f",
      "1f647-1f3fe-200d-2640-fe0f",
      "1f647-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face palm",
      "face_palm"
    ],
    u: "1f926",
    v: [
      "1f926-1f3fb",
      "1f926-1f3fc",
      "1f926-1f3fd",
      "1f926-1f3fe",
      "1f926-1f3ff"
    ]
  },
  {
    n: [
      "man-facepalming"
    ],
    u: "1f926-200d-2642-fe0f",
    v: [
      "1f926-1f3fb-200d-2642-fe0f",
      "1f926-1f3fc-200d-2642-fe0f",
      "1f926-1f3fd-200d-2642-fe0f",
      "1f926-1f3fe-200d-2642-fe0f",
      "1f926-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-facepalming"
    ],
    u: "1f926-200d-2640-fe0f",
    v: [
      "1f926-1f3fb-200d-2640-fe0f",
      "1f926-1f3fc-200d-2640-fe0f",
      "1f926-1f3fd-200d-2640-fe0f",
      "1f926-1f3fe-200d-2640-fe0f",
      "1f926-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "shrug"
    ],
    u: "1f937",
    v: [
      "1f937-1f3fb",
      "1f937-1f3fc",
      "1f937-1f3fd",
      "1f937-1f3fe",
      "1f937-1f3ff"
    ]
  },
  {
    n: [
      "man-shrugging"
    ],
    u: "1f937-200d-2642-fe0f",
    v: [
      "1f937-1f3fb-200d-2642-fe0f",
      "1f937-1f3fc-200d-2642-fe0f",
      "1f937-1f3fd-200d-2642-fe0f",
      "1f937-1f3fe-200d-2642-fe0f",
      "1f937-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-shrugging"
    ],
    u: "1f937-200d-2640-fe0f",
    v: [
      "1f937-1f3fb-200d-2640-fe0f",
      "1f937-1f3fc-200d-2640-fe0f",
      "1f937-1f3fd-200d-2640-fe0f",
      "1f937-1f3fe-200d-2640-fe0f",
      "1f937-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "face massage",
      "massage"
    ],
    u: "1f486",
    v: [
      "1f486-1f3fb",
      "1f486-1f3fc",
      "1f486-1f3fd",
      "1f486-1f3fe",
      "1f486-1f3ff"
    ]
  },
  {
    n: [
      "man-getting-massage"
    ],
    u: "1f486-200d-2642-fe0f",
    v: [
      "1f486-1f3fb-200d-2642-fe0f",
      "1f486-1f3fc-200d-2642-fe0f",
      "1f486-1f3fd-200d-2642-fe0f",
      "1f486-1f3fe-200d-2642-fe0f",
      "1f486-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-getting-massage"
    ],
    u: "1f486-200d-2640-fe0f",
    v: [
      "1f486-1f3fb-200d-2640-fe0f",
      "1f486-1f3fc-200d-2640-fe0f",
      "1f486-1f3fd-200d-2640-fe0f",
      "1f486-1f3fe-200d-2640-fe0f",
      "1f486-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "haircut"
    ],
    u: "1f487",
    v: [
      "1f487-1f3fb",
      "1f487-1f3fc",
      "1f487-1f3fd",
      "1f487-1f3fe",
      "1f487-1f3ff"
    ]
  },
  {
    n: [
      "man-getting-haircut"
    ],
    u: "1f487-200d-2642-fe0f",
    v: [
      "1f487-1f3fb-200d-2642-fe0f",
      "1f487-1f3fc-200d-2642-fe0f",
      "1f487-1f3fd-200d-2642-fe0f",
      "1f487-1f3fe-200d-2642-fe0f",
      "1f487-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-getting-haircut"
    ],
    u: "1f487-200d-2640-fe0f",
    v: [
      "1f487-1f3fb-200d-2640-fe0f",
      "1f487-1f3fc-200d-2640-fe0f",
      "1f487-1f3fd-200d-2640-fe0f",
      "1f487-1f3fe-200d-2640-fe0f",
      "1f487-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "pedestrian",
      "walking"
    ],
    u: "1f6b6",
    v: [
      "1f6b6-1f3fb",
      "1f6b6-1f3fc",
      "1f6b6-1f3fd",
      "1f6b6-1f3fe",
      "1f6b6-1f3ff"
    ]
  },
  {
    n: [
      "man-walking"
    ],
    u: "1f6b6-200d-2642-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2642-fe0f",
      "1f6b6-1f3fc-200d-2642-fe0f",
      "1f6b6-1f3fd-200d-2642-fe0f",
      "1f6b6-1f3fe-200d-2642-fe0f",
      "1f6b6-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-walking"
    ],
    u: "1f6b6-200d-2640-fe0f",
    v: [
      "1f6b6-1f3fb-200d-2640-fe0f",
      "1f6b6-1f3fc-200d-2640-fe0f",
      "1f6b6-1f3fd-200d-2640-fe0f",
      "1f6b6-1f3fe-200d-2640-fe0f",
      "1f6b6-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "runner",
      "running"
    ],
    u: "1f3c3",
    v: [
      "1f3c3-1f3fb",
      "1f3c3-1f3fc",
      "1f3c3-1f3fd",
      "1f3c3-1f3fe",
      "1f3c3-1f3ff"
    ]
  },
  {
    n: [
      "man-running"
    ],
    u: "1f3c3-200d-2642-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2642-fe0f",
      "1f3c3-1f3fc-200d-2642-fe0f",
      "1f3c3-1f3fd-200d-2642-fe0f",
      "1f3c3-1f3fe-200d-2642-fe0f",
      "1f3c3-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-running"
    ],
    u: "1f3c3-200d-2640-fe0f",
    v: [
      "1f3c3-1f3fb-200d-2640-fe0f",
      "1f3c3-1f3fc-200d-2640-fe0f",
      "1f3c3-1f3fd-200d-2640-fe0f",
      "1f3c3-1f3fe-200d-2640-fe0f",
      "1f3c3-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "dancer"
    ],
    u: "1f483",
    v: [
      "1f483-1f3fb",
      "1f483-1f3fc",
      "1f483-1f3fd",
      "1f483-1f3fe",
      "1f483-1f3ff"
    ]
  },
  {
    n: [
      "man dancing",
      "man_dancing"
    ],
    u: "1f57a",
    v: [
      "1f57a-1f3fb",
      "1f57a-1f3fc",
      "1f57a-1f3fd",
      "1f57a-1f3fe",
      "1f57a-1f3ff"
    ]
  },
  {
    n: [
      "woman with bunny ears",
      "dancers"
    ],
    u: "1f46f"
  },
  {
    n: [
      "man-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2642-fe0f"
  },
  {
    n: [
      "woman-with-bunny-ears-partying"
    ],
    u: "1f46f-200d-2640-fe0f"
  },
  {
    n: [
      "person in steamy room",
      "person_in_steamy_room"
    ],
    u: "1f9d6",
    v: [
      "1f9d6-1f3fb",
      "1f9d6-1f3fc",
      "1f9d6-1f3fd",
      "1f9d6-1f3fe",
      "1f9d6-1f3ff"
    ]
  },
  {
    n: [
      "woman_in_steamy_room"
    ],
    u: "1f9d6-200d-2640-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2640-fe0f",
      "1f9d6-1f3fc-200d-2640-fe0f",
      "1f9d6-1f3fd-200d-2640-fe0f",
      "1f9d6-1f3fe-200d-2640-fe0f",
      "1f9d6-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_in_steamy_room"
    ],
    u: "1f9d6-200d-2642-fe0f",
    v: [
      "1f9d6-1f3fb-200d-2642-fe0f",
      "1f9d6-1f3fc-200d-2642-fe0f",
      "1f9d6-1f3fd-200d-2642-fe0f",
      "1f9d6-1f3fe-200d-2642-fe0f",
      "1f9d6-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "person climbing",
      "person_climbing"
    ],
    u: "1f9d7",
    v: [
      "1f9d7-1f3fb",
      "1f9d7-1f3fc",
      "1f9d7-1f3fd",
      "1f9d7-1f3fe",
      "1f9d7-1f3ff"
    ]
  },
  {
    n: [
      "woman_climbing"
    ],
    u: "1f9d7-200d-2640-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2640-fe0f",
      "1f9d7-1f3fc-200d-2640-fe0f",
      "1f9d7-1f3fd-200d-2640-fe0f",
      "1f9d7-1f3fe-200d-2640-fe0f",
      "1f9d7-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_climbing"
    ],
    u: "1f9d7-200d-2642-fe0f",
    v: [
      "1f9d7-1f3fb-200d-2642-fe0f",
      "1f9d7-1f3fc-200d-2642-fe0f",
      "1f9d7-1f3fd-200d-2642-fe0f",
      "1f9d7-1f3fe-200d-2642-fe0f",
      "1f9d7-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "person in lotus position",
      "person_in_lotus_position"
    ],
    u: "1f9d8",
    v: [
      "1f9d8-1f3fb",
      "1f9d8-1f3fc",
      "1f9d8-1f3fd",
      "1f9d8-1f3fe",
      "1f9d8-1f3ff"
    ]
  },
  {
    n: [
      "woman_in_lotus_position"
    ],
    u: "1f9d8-200d-2640-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2640-fe0f",
      "1f9d8-1f3fc-200d-2640-fe0f",
      "1f9d8-1f3fd-200d-2640-fe0f",
      "1f9d8-1f3fe-200d-2640-fe0f",
      "1f9d8-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man_in_lotus_position"
    ],
    u: "1f9d8-200d-2642-fe0f",
    v: [
      "1f9d8-1f3fb-200d-2642-fe0f",
      "1f9d8-1f3fc-200d-2642-fe0f",
      "1f9d8-1f3fd-200d-2642-fe0f",
      "1f9d8-1f3fe-200d-2642-fe0f",
      "1f9d8-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "bath"
    ],
    u: "1f6c0",
    v: [
      "1f6c0-1f3fb",
      "1f6c0-1f3fc",
      "1f6c0-1f3fd",
      "1f6c0-1f3fe",
      "1f6c0-1f3ff"
    ]
  },
  {
    n: [
      "sleeping accommodation",
      "sleeping_accommodation"
    ],
    u: "1f6cc",
    v: [
      "1f6cc-1f3fb",
      "1f6cc-1f3fc",
      "1f6cc-1f3fd",
      "1f6cc-1f3fe",
      "1f6cc-1f3ff"
    ]
  },
  {
    n: [
      "man_in_business_suit_levitating"
    ],
    u: "1f574-fe0f",
    v: [
      "1f574-1f3fb",
      "1f574-1f3fc",
      "1f574-1f3fd",
      "1f574-1f3fe",
      "1f574-1f3ff"
    ]
  },
  {
    n: [
      "speaking_head_in_silhouette"
    ],
    u: "1f5e3-fe0f"
  },
  {
    n: [
      "bust in silhouette",
      "bust_in_silhouette"
    ],
    u: "1f464"
  },
  {
    n: [
      "busts in silhouette",
      "busts_in_silhouette"
    ],
    u: "1f465"
  },
  {
    n: [
      "fencer"
    ],
    u: "1f93a"
  },
  {
    n: [
      "horse racing",
      "horse_racing"
    ],
    u: "1f3c7",
    v: [
      "1f3c7-1f3fb",
      "1f3c7-1f3fc",
      "1f3c7-1f3fd",
      "1f3c7-1f3fe",
      "1f3c7-1f3ff"
    ]
  },
  {
    n: [
      "skier"
    ],
    u: "26f7-fe0f"
  },
  {
    n: [
      "snowboarder"
    ],
    u: "1f3c2",
    v: [
      "1f3c2-1f3fb",
      "1f3c2-1f3fc",
      "1f3c2-1f3fd",
      "1f3c2-1f3fe",
      "1f3c2-1f3ff"
    ]
  },
  {
    n: [
      "golfer"
    ],
    u: "1f3cc-fe0f",
    v: [
      "1f3cc-1f3fb",
      "1f3cc-1f3fc",
      "1f3cc-1f3fd",
      "1f3cc-1f3fe",
      "1f3cc-1f3ff"
    ]
  },
  {
    n: [
      "man-golfing"
    ],
    u: "1f3cc-fe0f-200d-2642-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2642-fe0f",
      "1f3cc-1f3fc-200d-2642-fe0f",
      "1f3cc-1f3fd-200d-2642-fe0f",
      "1f3cc-1f3fe-200d-2642-fe0f",
      "1f3cc-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-golfing"
    ],
    u: "1f3cc-fe0f-200d-2640-fe0f",
    v: [
      "1f3cc-1f3fb-200d-2640-fe0f",
      "1f3cc-1f3fc-200d-2640-fe0f",
      "1f3cc-1f3fd-200d-2640-fe0f",
      "1f3cc-1f3fe-200d-2640-fe0f",
      "1f3cc-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "surfer"
    ],
    u: "1f3c4",
    v: [
      "1f3c4-1f3fb",
      "1f3c4-1f3fc",
      "1f3c4-1f3fd",
      "1f3c4-1f3fe",
      "1f3c4-1f3ff"
    ]
  },
  {
    n: [
      "man-surfing"
    ],
    u: "1f3c4-200d-2642-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2642-fe0f",
      "1f3c4-1f3fc-200d-2642-fe0f",
      "1f3c4-1f3fd-200d-2642-fe0f",
      "1f3c4-1f3fe-200d-2642-fe0f",
      "1f3c4-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-surfing"
    ],
    u: "1f3c4-200d-2640-fe0f",
    v: [
      "1f3c4-1f3fb-200d-2640-fe0f",
      "1f3c4-1f3fc-200d-2640-fe0f",
      "1f3c4-1f3fd-200d-2640-fe0f",
      "1f3c4-1f3fe-200d-2640-fe0f",
      "1f3c4-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "rowboat"
    ],
    u: "1f6a3",
    v: [
      "1f6a3-1f3fb",
      "1f6a3-1f3fc",
      "1f6a3-1f3fd",
      "1f6a3-1f3fe",
      "1f6a3-1f3ff"
    ]
  },
  {
    n: [
      "man-rowing-boat"
    ],
    u: "1f6a3-200d-2642-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2642-fe0f",
      "1f6a3-1f3fc-200d-2642-fe0f",
      "1f6a3-1f3fd-200d-2642-fe0f",
      "1f6a3-1f3fe-200d-2642-fe0f",
      "1f6a3-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-rowing-boat"
    ],
    u: "1f6a3-200d-2640-fe0f",
    v: [
      "1f6a3-1f3fb-200d-2640-fe0f",
      "1f6a3-1f3fc-200d-2640-fe0f",
      "1f6a3-1f3fd-200d-2640-fe0f",
      "1f6a3-1f3fe-200d-2640-fe0f",
      "1f6a3-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "swimmer"
    ],
    u: "1f3ca",
    v: [
      "1f3ca-1f3fb",
      "1f3ca-1f3fc",
      "1f3ca-1f3fd",
      "1f3ca-1f3fe",
      "1f3ca-1f3ff"
    ]
  },
  {
    n: [
      "man-swimming"
    ],
    u: "1f3ca-200d-2642-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2642-fe0f",
      "1f3ca-1f3fc-200d-2642-fe0f",
      "1f3ca-1f3fd-200d-2642-fe0f",
      "1f3ca-1f3fe-200d-2642-fe0f",
      "1f3ca-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-swimming"
    ],
    u: "1f3ca-200d-2640-fe0f",
    v: [
      "1f3ca-1f3fb-200d-2640-fe0f",
      "1f3ca-1f3fc-200d-2640-fe0f",
      "1f3ca-1f3fd-200d-2640-fe0f",
      "1f3ca-1f3fe-200d-2640-fe0f",
      "1f3ca-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "person_with_ball"
    ],
    u: "26f9-fe0f",
    v: [
      "26f9-1f3fb",
      "26f9-1f3fc",
      "26f9-1f3fd",
      "26f9-1f3fe",
      "26f9-1f3ff"
    ]
  },
  {
    n: [
      "man-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2642-fe0f",
    v: [
      "26f9-1f3fb-200d-2642-fe0f",
      "26f9-1f3fc-200d-2642-fe0f",
      "26f9-1f3fd-200d-2642-fe0f",
      "26f9-1f3fe-200d-2642-fe0f",
      "26f9-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-bouncing-ball"
    ],
    u: "26f9-fe0f-200d-2640-fe0f",
    v: [
      "26f9-1f3fb-200d-2640-fe0f",
      "26f9-1f3fc-200d-2640-fe0f",
      "26f9-1f3fd-200d-2640-fe0f",
      "26f9-1f3fe-200d-2640-fe0f",
      "26f9-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "weight_lifter"
    ],
    u: "1f3cb-fe0f",
    v: [
      "1f3cb-1f3fb",
      "1f3cb-1f3fc",
      "1f3cb-1f3fd",
      "1f3cb-1f3fe",
      "1f3cb-1f3ff"
    ]
  },
  {
    n: [
      "man-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2642-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2642-fe0f",
      "1f3cb-1f3fc-200d-2642-fe0f",
      "1f3cb-1f3fd-200d-2642-fe0f",
      "1f3cb-1f3fe-200d-2642-fe0f",
      "1f3cb-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-lifting-weights"
    ],
    u: "1f3cb-fe0f-200d-2640-fe0f",
    v: [
      "1f3cb-1f3fb-200d-2640-fe0f",
      "1f3cb-1f3fc-200d-2640-fe0f",
      "1f3cb-1f3fd-200d-2640-fe0f",
      "1f3cb-1f3fe-200d-2640-fe0f",
      "1f3cb-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "bicyclist"
    ],
    u: "1f6b4",
    v: [
      "1f6b4-1f3fb",
      "1f6b4-1f3fc",
      "1f6b4-1f3fd",
      "1f6b4-1f3fe",
      "1f6b4-1f3ff"
    ]
  },
  {
    n: [
      "man-biking"
    ],
    u: "1f6b4-200d-2642-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2642-fe0f",
      "1f6b4-1f3fc-200d-2642-fe0f",
      "1f6b4-1f3fd-200d-2642-fe0f",
      "1f6b4-1f3fe-200d-2642-fe0f",
      "1f6b4-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-biking"
    ],
    u: "1f6b4-200d-2640-fe0f",
    v: [
      "1f6b4-1f3fb-200d-2640-fe0f",
      "1f6b4-1f3fc-200d-2640-fe0f",
      "1f6b4-1f3fd-200d-2640-fe0f",
      "1f6b4-1f3fe-200d-2640-fe0f",
      "1f6b4-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "mountain bicyclist",
      "mountain_bicyclist"
    ],
    u: "1f6b5",
    v: [
      "1f6b5-1f3fb",
      "1f6b5-1f3fc",
      "1f6b5-1f3fd",
      "1f6b5-1f3fe",
      "1f6b5-1f3ff"
    ]
  },
  {
    n: [
      "man-mountain-biking"
    ],
    u: "1f6b5-200d-2642-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2642-fe0f",
      "1f6b5-1f3fc-200d-2642-fe0f",
      "1f6b5-1f3fd-200d-2642-fe0f",
      "1f6b5-1f3fe-200d-2642-fe0f",
      "1f6b5-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-mountain-biking"
    ],
    u: "1f6b5-200d-2640-fe0f",
    v: [
      "1f6b5-1f3fb-200d-2640-fe0f",
      "1f6b5-1f3fc-200d-2640-fe0f",
      "1f6b5-1f3fd-200d-2640-fe0f",
      "1f6b5-1f3fe-200d-2640-fe0f",
      "1f6b5-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "racing_car"
    ],
    u: "1f3ce-fe0f"
  },
  {
    n: [
      "racing_motorcycle"
    ],
    u: "1f3cd-fe0f"
  },
  {
    n: [
      "person doing cartwheel",
      "person_doing_cartwheel"
    ],
    u: "1f938",
    v: [
      "1f938-1f3fb",
      "1f938-1f3fc",
      "1f938-1f3fd",
      "1f938-1f3fe",
      "1f938-1f3ff"
    ]
  },
  {
    n: [
      "man-cartwheeling"
    ],
    u: "1f938-200d-2642-fe0f",
    v: [
      "1f938-1f3fb-200d-2642-fe0f",
      "1f938-1f3fc-200d-2642-fe0f",
      "1f938-1f3fd-200d-2642-fe0f",
      "1f938-1f3fe-200d-2642-fe0f",
      "1f938-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-cartwheeling"
    ],
    u: "1f938-200d-2640-fe0f",
    v: [
      "1f938-1f3fb-200d-2640-fe0f",
      "1f938-1f3fc-200d-2640-fe0f",
      "1f938-1f3fd-200d-2640-fe0f",
      "1f938-1f3fe-200d-2640-fe0f",
      "1f938-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "wrestlers"
    ],
    u: "1f93c"
  },
  {
    n: [
      "man-wrestling"
    ],
    u: "1f93c-200d-2642-fe0f"
  },
  {
    n: [
      "woman-wrestling"
    ],
    u: "1f93c-200d-2640-fe0f"
  },
  {
    n: [
      "water polo",
      "water_polo"
    ],
    u: "1f93d",
    v: [
      "1f93d-1f3fb",
      "1f93d-1f3fc",
      "1f93d-1f3fd",
      "1f93d-1f3fe",
      "1f93d-1f3ff"
    ]
  },
  {
    n: [
      "man-playing-water-polo"
    ],
    u: "1f93d-200d-2642-fe0f",
    v: [
      "1f93d-1f3fb-200d-2642-fe0f",
      "1f93d-1f3fc-200d-2642-fe0f",
      "1f93d-1f3fd-200d-2642-fe0f",
      "1f93d-1f3fe-200d-2642-fe0f",
      "1f93d-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-playing-water-polo"
    ],
    u: "1f93d-200d-2640-fe0f",
    v: [
      "1f93d-1f3fb-200d-2640-fe0f",
      "1f93d-1f3fc-200d-2640-fe0f",
      "1f93d-1f3fd-200d-2640-fe0f",
      "1f93d-1f3fe-200d-2640-fe0f",
      "1f93d-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "handball"
    ],
    u: "1f93e",
    v: [
      "1f93e-1f3fb",
      "1f93e-1f3fc",
      "1f93e-1f3fd",
      "1f93e-1f3fe",
      "1f93e-1f3ff"
    ]
  },
  {
    n: [
      "man-playing-handball"
    ],
    u: "1f93e-200d-2642-fe0f",
    v: [
      "1f93e-1f3fb-200d-2642-fe0f",
      "1f93e-1f3fc-200d-2642-fe0f",
      "1f93e-1f3fd-200d-2642-fe0f",
      "1f93e-1f3fe-200d-2642-fe0f",
      "1f93e-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-playing-handball"
    ],
    u: "1f93e-200d-2640-fe0f",
    v: [
      "1f93e-1f3fb-200d-2640-fe0f",
      "1f93e-1f3fc-200d-2640-fe0f",
      "1f93e-1f3fd-200d-2640-fe0f",
      "1f93e-1f3fe-200d-2640-fe0f",
      "1f93e-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "juggling"
    ],
    u: "1f939",
    v: [
      "1f939-1f3fb",
      "1f939-1f3fc",
      "1f939-1f3fd",
      "1f939-1f3fe",
      "1f939-1f3ff"
    ]
  },
  {
    n: [
      "man-juggling"
    ],
    u: "1f939-200d-2642-fe0f",
    v: [
      "1f939-1f3fb-200d-2642-fe0f",
      "1f939-1f3fc-200d-2642-fe0f",
      "1f939-1f3fd-200d-2642-fe0f",
      "1f939-1f3fe-200d-2642-fe0f",
      "1f939-1f3ff-200d-2642-fe0f"
    ]
  },
  {
    n: [
      "woman-juggling"
    ],
    u: "1f939-200d-2640-fe0f",
    v: [
      "1f939-1f3fb-200d-2640-fe0f",
      "1f939-1f3fc-200d-2640-fe0f",
      "1f939-1f3fd-200d-2640-fe0f",
      "1f939-1f3fe-200d-2640-fe0f",
      "1f939-1f3ff-200d-2640-fe0f"
    ]
  },
  {
    n: [
      "man and woman holding hands",
      "couple",
      "man_and_woman_holding_hands"
    ],
    u: "1f46b"
  },
  {
    n: [
      "two men holding hands",
      "two_men_holding_hands"
    ],
    u: "1f46c"
  },
  {
    n: [
      "two women holding hands",
      "two_women_holding_hands"
    ],
    u: "1f46d"
  },
  {
    n: [
      "kiss",
      "couplekiss"
    ],
    u: "1f48f"
  },
  {
    n: [
      "woman-kiss-man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f468"
  },
  {
    n: [
      "man-kiss-man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f48b-200d-1f468"
  },
  {
    n: [
      "woman-kiss-woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f469"
  },
  {
    n: [
      "couple with heart",
      "couple_with_heart"
    ],
    u: "1f491"
  },
  {
    n: [
      "woman-heart-man"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f468"
  },
  {
    n: [
      "man-heart-man"
    ],
    u: "1f468-200d-2764-fe0f-200d-1f468"
  },
  {
    n: [
      "woman-heart-woman"
    ],
    u: "1f469-200d-2764-fe0f-200d-1f469"
  },
  {
    n: [
      "family",
      "man-woman-boy"
    ],
    u: "1f46a"
  },
  {
    n: [
      "man-woman-boy",
      "family"
    ],
    u: "1f468-200d-1f469-200d-1f466"
  },
  {
    n: [
      "man-woman-girl"
    ],
    u: "1f468-200d-1f469-200d-1f467"
  },
  {
    n: [
      "man-woman-girl-boy"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-woman-boy-boy"
    ],
    u: "1f468-200d-1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-woman-girl-girl"
    ],
    u: "1f468-200d-1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "man-man-boy"
    ],
    u: "1f468-200d-1f468-200d-1f466"
  },
  {
    n: [
      "man-man-girl"
    ],
    u: "1f468-200d-1f468-200d-1f467"
  },
  {
    n: [
      "man-man-girl-boy"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-man-boy-boy"
    ],
    u: "1f468-200d-1f468-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-man-girl-girl"
    ],
    u: "1f468-200d-1f468-200d-1f467-200d-1f467"
  },
  {
    n: [
      "woman-woman-boy"
    ],
    u: "1f469-200d-1f469-200d-1f466"
  },
  {
    n: [
      "woman-woman-girl"
    ],
    u: "1f469-200d-1f469-200d-1f467"
  },
  {
    n: [
      "woman-woman-girl-boy"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "woman-woman-boy-boy"
    ],
    u: "1f469-200d-1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "woman-woman-girl-girl"
    ],
    u: "1f469-200d-1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "man-boy"
    ],
    u: "1f468-200d-1f466"
  },
  {
    n: [
      "man-boy-boy"
    ],
    u: "1f468-200d-1f466-200d-1f466"
  },
  {
    n: [
      "man-girl"
    ],
    u: "1f468-200d-1f467"
  },
  {
    n: [
      "man-girl-boy"
    ],
    u: "1f468-200d-1f467-200d-1f466"
  },
  {
    n: [
      "man-girl-girl"
    ],
    u: "1f468-200d-1f467-200d-1f467"
  },
  {
    n: [
      "woman-boy"
    ],
    u: "1f469-200d-1f466"
  },
  {
    n: [
      "woman-boy-boy"
    ],
    u: "1f469-200d-1f466-200d-1f466"
  },
  {
    n: [
      "woman-girl"
    ],
    u: "1f469-200d-1f467"
  },
  {
    n: [
      "woman-girl-boy"
    ],
    u: "1f469-200d-1f467-200d-1f466"
  },
  {
    n: [
      "woman-girl-girl"
    ],
    u: "1f469-200d-1f467-200d-1f467"
  },
  {
    n: [
      "selfie"
    ],
    u: "1f933",
    v: [
      "1f933-1f3fb",
      "1f933-1f3fc",
      "1f933-1f3fd",
      "1f933-1f3fe",
      "1f933-1f3ff"
    ]
  },
  {
    n: [
      "flexed biceps",
      "muscle"
    ],
    u: "1f4aa",
    v: [
      "1f4aa-1f3fb",
      "1f4aa-1f3fc",
      "1f4aa-1f3fd",
      "1f4aa-1f3fe",
      "1f4aa-1f3ff"
    ]
  },
  {
    n: [
      "white left pointing backhand index",
      "point_left"
    ],
    u: "1f448",
    v: [
      "1f448-1f3fb",
      "1f448-1f3fc",
      "1f448-1f3fd",
      "1f448-1f3fe",
      "1f448-1f3ff"
    ]
  },
  {
    n: [
      "white right pointing backhand index",
      "point_right"
    ],
    u: "1f449",
    v: [
      "1f449-1f3fb",
      "1f449-1f3fc",
      "1f449-1f3fd",
      "1f449-1f3fe",
      "1f449-1f3ff"
    ]
  },
  {
    n: [
      "white up pointing index",
      "point_up"
    ],
    u: "261d-fe0f",
    v: [
      "261d-1f3fb",
      "261d-1f3fc",
      "261d-1f3fd",
      "261d-1f3fe",
      "261d-1f3ff"
    ]
  },
  {
    n: [
      "white up pointing backhand index",
      "point_up_2"
    ],
    u: "1f446",
    v: [
      "1f446-1f3fb",
      "1f446-1f3fc",
      "1f446-1f3fd",
      "1f446-1f3fe",
      "1f446-1f3ff"
    ]
  },
  {
    n: [
      "reversed hand with middle finger extended",
      "middle_finger",
      "reversed_hand_with_middle_finger_extended"
    ],
    u: "1f595",
    v: [
      "1f595-1f3fb",
      "1f595-1f3fc",
      "1f595-1f3fd",
      "1f595-1f3fe",
      "1f595-1f3ff"
    ]
  },
  {
    n: [
      "white down pointing backhand index",
      "point_down"
    ],
    u: "1f447",
    v: [
      "1f447-1f3fb",
      "1f447-1f3fc",
      "1f447-1f3fd",
      "1f447-1f3fe",
      "1f447-1f3ff"
    ]
  },
  {
    n: [
      "victory hand",
      "v"
    ],
    u: "270c-fe0f",
    v: [
      "270c-1f3fb",
      "270c-1f3fc",
      "270c-1f3fd",
      "270c-1f3fe",
      "270c-1f3ff"
    ]
  },
  {
    n: [
      "hand with index and middle fingers crossed",
      "crossed_fingers",
      "hand_with_index_and_middle_fingers_crossed"
    ],
    u: "1f91e",
    v: [
      "1f91e-1f3fb",
      "1f91e-1f3fc",
      "1f91e-1f3fd",
      "1f91e-1f3fe",
      "1f91e-1f3ff"
    ]
  },
  {
    n: [
      "raised hand with part between middle and ring fingers",
      "spock-hand"
    ],
    u: "1f596",
    v: [
      "1f596-1f3fb",
      "1f596-1f3fc",
      "1f596-1f3fd",
      "1f596-1f3fe",
      "1f596-1f3ff"
    ]
  },
  {
    n: [
      "sign of the horns",
      "the_horns",
      "sign_of_the_horns"
    ],
    u: "1f918",
    v: [
      "1f918-1f3fb",
      "1f918-1f3fc",
      "1f918-1f3fd",
      "1f918-1f3fe",
      "1f918-1f3ff"
    ]
  },
  {
    n: [
      "call me hand",
      "call_me_hand"
    ],
    u: "1f919",
    v: [
      "1f919-1f3fb",
      "1f919-1f3fc",
      "1f919-1f3fd",
      "1f919-1f3fe",
      "1f919-1f3ff"
    ]
  },
  {
    n: [
      "raised_hand_with_fingers_splayed"
    ],
    u: "1f590-fe0f",
    v: [
      "1f590-1f3fb",
      "1f590-1f3fc",
      "1f590-1f3fd",
      "1f590-1f3fe",
      "1f590-1f3ff"
    ]
  },
  {
    n: [
      "raised hand",
      "hand",
      "raised_hand"
    ],
    u: "270b",
    v: [
      "270b-1f3fb",
      "270b-1f3fc",
      "270b-1f3fd",
      "270b-1f3fe",
      "270b-1f3ff"
    ]
  },
  {
    n: [
      "ok hand sign",
      "ok_hand"
    ],
    u: "1f44c",
    v: [
      "1f44c-1f3fb",
      "1f44c-1f3fc",
      "1f44c-1f3fd",
      "1f44c-1f3fe",
      "1f44c-1f3ff"
    ]
  },
  {
    n: [
      "thumbs up sign",
      "+1",
      "thumbsup"
    ],
    u: "1f44d",
    v: [
      "1f44d-1f3fb",
      "1f44d-1f3fc",
      "1f44d-1f3fd",
      "1f44d-1f3fe",
      "1f44d-1f3ff"
    ]
  },
  {
    n: [
      "thumbs down sign",
      "-1",
      "thumbsdown"
    ],
    u: "1f44e",
    v: [
      "1f44e-1f3fb",
      "1f44e-1f3fc",
      "1f44e-1f3fd",
      "1f44e-1f3fe",
      "1f44e-1f3ff"
    ]
  },
  {
    n: [
      "raised fist",
      "fist"
    ],
    u: "270a",
    v: [
      "270a-1f3fb",
      "270a-1f3fc",
      "270a-1f3fd",
      "270a-1f3fe",
      "270a-1f3ff"
    ]
  },
  {
    n: [
      "fisted hand sign",
      "facepunch",
      "punch"
    ],
    u: "1f44a",
    v: [
      "1f44a-1f3fb",
      "1f44a-1f3fc",
      "1f44a-1f3fd",
      "1f44a-1f3fe",
      "1f44a-1f3ff"
    ]
  },
  {
    n: [
      "left-facing fist",
      "left-facing_fist"
    ],
    u: "1f91b",
    v: [
      "1f91b-1f3fb",
      "1f91b-1f3fc",
      "1f91b-1f3fd",
      "1f91b-1f3fe",
      "1f91b-1f3ff"
    ]
  },
  {
    n: [
      "right-facing fist",
      "right-facing_fist"
    ],
    u: "1f91c",
    v: [
      "1f91c-1f3fb",
      "1f91c-1f3fc",
      "1f91c-1f3fd",
      "1f91c-1f3fe",
      "1f91c-1f3ff"
    ]
  },
  {
    n: [
      "raised back of hand",
      "raised_back_of_hand"
    ],
    u: "1f91a",
    v: [
      "1f91a-1f3fb",
      "1f91a-1f3fc",
      "1f91a-1f3fd",
      "1f91a-1f3fe",
      "1f91a-1f3ff"
    ]
  },
  {
    n: [
      "waving hand sign",
      "wave"
    ],
    u: "1f44b",
    v: [
      "1f44b-1f3fb",
      "1f44b-1f3fc",
      "1f44b-1f3fd",
      "1f44b-1f3fe",
      "1f44b-1f3ff"
    ]
  },
  {
    n: [
      "i love you hand sign",
      "i_love_you_hand_sign"
    ],
    u: "1f91f",
    v: [
      "1f91f-1f3fb",
      "1f91f-1f3fc",
      "1f91f-1f3fd",
      "1f91f-1f3fe",
      "1f91f-1f3ff"
    ]
  },
  {
    n: [
      "writing_hand"
    ],
    u: "270d-fe0f",
    v: [
      "270d-1f3fb",
      "270d-1f3fc",
      "270d-1f3fd",
      "270d-1f3fe",
      "270d-1f3ff"
    ]
  },
  {
    n: [
      "clapping hands sign",
      "clap"
    ],
    u: "1f44f",
    v: [
      "1f44f-1f3fb",
      "1f44f-1f3fc",
      "1f44f-1f3fd",
      "1f44f-1f3fe",
      "1f44f-1f3ff"
    ]
  },
  {
    n: [
      "open hands sign",
      "open_hands"
    ],
    u: "1f450",
    v: [
      "1f450-1f3fb",
      "1f450-1f3fc",
      "1f450-1f3fd",
      "1f450-1f3fe",
      "1f450-1f3ff"
    ]
  },
  {
    n: [
      "person raising both hands in celebration",
      "raised_hands"
    ],
    u: "1f64c",
    v: [
      "1f64c-1f3fb",
      "1f64c-1f3fc",
      "1f64c-1f3fd",
      "1f64c-1f3fe",
      "1f64c-1f3ff"
    ]
  },
  {
    n: [
      "palms up together",
      "palms_up_together"
    ],
    u: "1f932",
    v: [
      "1f932-1f3fb",
      "1f932-1f3fc",
      "1f932-1f3fd",
      "1f932-1f3fe",
      "1f932-1f3ff"
    ]
  },
  {
    n: [
      "person with folded hands",
      "pray"
    ],
    u: "1f64f",
    v: [
      "1f64f-1f3fb",
      "1f64f-1f3fc",
      "1f64f-1f3fd",
      "1f64f-1f3fe",
      "1f64f-1f3ff"
    ]
  },
  {
    n: [
      "handshake"
    ],
    u: "1f91d"
  },
  {
    n: [
      "nail polish",
      "nail_care"
    ],
    u: "1f485",
    v: [
      "1f485-1f3fb",
      "1f485-1f3fc",
      "1f485-1f3fd",
      "1f485-1f3fe",
      "1f485-1f3ff"
    ]
  },
  {
    n: [
      "ear"
    ],
    u: "1f442",
    v: [
      "1f442-1f3fb",
      "1f442-1f3fc",
      "1f442-1f3fd",
      "1f442-1f3fe",
      "1f442-1f3ff"
    ]
  },
  {
    n: [
      "nose"
    ],
    u: "1f443",
    v: [
      "1f443-1f3fb",
      "1f443-1f3fc",
      "1f443-1f3fd",
      "1f443-1f3fe",
      "1f443-1f3ff"
    ]
  },
  {
    n: [
      "footprints"
    ],
    u: "1f463"
  },
  {
    n: [
      "eyes"
    ],
    u: "1f440"
  },
  {
    n: [
      "eye"
    ],
    u: "1f441-fe0f"
  },
  {
    n: [
      "eye-in-speech-bubble"
    ],
    u: "1f441-fe0f-200d-1f5e8-fe0f"
  },
  {
    n: [
      "brain"
    ],
    u: "1f9e0"
  },
  {
    n: [
      "tongue"
    ],
    u: "1f445"
  },
  {
    n: [
      "mouth",
      "lips"
    ],
    u: "1f444"
  },
  {
    n: [
      "kiss mark",
      "kiss"
    ],
    u: "1f48b"
  },
  {
    n: [
      "heart with arrow",
      "cupid"
    ],
    u: "1f498"
  },
  {
    n: [
      "heavy black heart",
      "heart"
    ],
    u: "2764-fe0f"
  },
  {
    n: [
      "beating heart",
      "heartbeat"
    ],
    u: "1f493"
  },
  {
    n: [
      "broken heart",
      "broken_heart"
    ],
    u: "1f494"
  },
  {
    n: [
      "two hearts",
      "two_hearts"
    ],
    u: "1f495"
  },
  {
    n: [
      "sparkling heart",
      "sparkling_heart"
    ],
    u: "1f496"
  },
  {
    n: [
      "growing heart",
      "heartpulse"
    ],
    u: "1f497"
  },
  {
    n: [
      "blue heart",
      "blue_heart"
    ],
    u: "1f499"
  },
  {
    n: [
      "green heart",
      "green_heart"
    ],
    u: "1f49a"
  },
  {
    n: [
      "yellow heart",
      "yellow_heart"
    ],
    u: "1f49b"
  },
  {
    n: [
      "orange heart",
      "orange_heart"
    ],
    u: "1f9e1"
  },
  {
    n: [
      "purple heart",
      "purple_heart"
    ],
    u: "1f49c"
  },
  {
    n: [
      "black heart",
      "black_heart"
    ],
    u: "1f5a4"
  },
  {
    n: [
      "heart with ribbon",
      "gift_heart"
    ],
    u: "1f49d"
  },
  {
    n: [
      "revolving hearts",
      "revolving_hearts"
    ],
    u: "1f49e"
  },
  {
    n: [
      "heart decoration",
      "heart_decoration"
    ],
    u: "1f49f"
  },
  {
    n: [
      "heavy_heart_exclamation_mark_ornament"
    ],
    u: "2763-fe0f"
  },
  {
    n: [
      "love letter",
      "love_letter"
    ],
    u: "1f48c"
  },
  {
    n: [
      "sleeping symbol",
      "zzz"
    ],
    u: "1f4a4"
  },
  {
    n: [
      "anger symbol",
      "anger"
    ],
    u: "1f4a2"
  },
  {
    n: [
      "bomb"
    ],
    u: "1f4a3"
  },
  {
    n: [
      "collision symbol",
      "boom",
      "collision"
    ],
    u: "1f4a5"
  },
  {
    n: [
      "splashing sweat symbol",
      "sweat_drops"
    ],
    u: "1f4a6"
  },
  {
    n: [
      "dash symbol",
      "dash"
    ],
    u: "1f4a8"
  },
  {
    n: [
      "dizzy symbol",
      "dizzy"
    ],
    u: "1f4ab"
  },
  {
    n: [
      "speech balloon",
      "speech_balloon"
    ],
    u: "1f4ac"
  },
  {
    n: [
      "left_speech_bubble"
    ],
    u: "1f5e8-fe0f"
  },
  {
    n: [
      "right_anger_bubble"
    ],
    u: "1f5ef-fe0f"
  },
  {
    n: [
      "thought balloon",
      "thought_balloon"
    ],
    u: "1f4ad"
  },
  {
    n: [
      "hole"
    ],
    u: "1f573-fe0f"
  },
  {
    n: [
      "eyeglasses"
    ],
    u: "1f453"
  },
  {
    n: [
      "dark_sunglasses"
    ],
    u: "1f576-fe0f"
  },
  {
    n: [
      "necktie"
    ],
    u: "1f454"
  },
  {
    n: [
      "t-shirt",
      "shirt",
      "tshirt"
    ],
    u: "1f455"
  },
  {
    n: [
      "jeans"
    ],
    u: "1f456"
  },
  {
    n: [
      "scarf"
    ],
    u: "1f9e3"
  },
  {
    n: [
      "gloves"
    ],
    u: "1f9e4"
  },
  {
    n: [
      "coat"
    ],
    u: "1f9e5"
  },
  {
    n: [
      "socks"
    ],
    u: "1f9e6"
  },
  {
    n: [
      "dress"
    ],
    u: "1f457"
  },
  {
    n: [
      "kimono"
    ],
    u: "1f458"
  },
  {
    n: [
      "bikini"
    ],
    u: "1f459"
  },
  {
    n: [
      "womans clothes",
      "womans_clothes"
    ],
    u: "1f45a"
  },
  {
    n: [
      "purse"
    ],
    u: "1f45b"
  },
  {
    n: [
      "handbag"
    ],
    u: "1f45c"
  },
  {
    n: [
      "pouch"
    ],
    u: "1f45d"
  },
  {
    n: [
      "shopping_bags"
    ],
    u: "1f6cd-fe0f"
  },
  {
    n: [
      "school satchel",
      "school_satchel"
    ],
    u: "1f392"
  },
  {
    n: [
      "mans shoe",
      "mans_shoe",
      "shoe"
    ],
    u: "1f45e"
  },
  {
    n: [
      "athletic shoe",
      "athletic_shoe"
    ],
    u: "1f45f"
  },
  {
    n: [
      "high-heeled shoe",
      "high_heel"
    ],
    u: "1f460"
  },
  {
    n: [
      "womans sandal",
      "sandal"
    ],
    u: "1f461"
  },
  {
    n: [
      "womans boots",
      "boot"
    ],
    u: "1f462"
  },
  {
    n: [
      "crown"
    ],
    u: "1f451"
  },
  {
    n: [
      "womans hat",
      "womans_hat"
    ],
    u: "1f452"
  },
  {
    n: [
      "top hat",
      "tophat"
    ],
    u: "1f3a9"
  },
  {
    n: [
      "graduation cap",
      "mortar_board"
    ],
    u: "1f393"
  },
  {
    n: [
      "billed cap",
      "billed_cap"
    ],
    u: "1f9e2"
  },
  {
    n: [
      "helmet_with_white_cross"
    ],
    u: "26d1-fe0f"
  },
  {
    n: [
      "prayer beads",
      "prayer_beads"
    ],
    u: "1f4ff"
  },
  {
    n: [
      "lipstick"
    ],
    u: "1f484"
  },
  {
    n: [
      "ring"
    ],
    u: "1f48d"
  },
  {
    n: [
      "gem stone",
      "gem"
    ],
    u: "1f48e"
  }
], KNe = [
  {
    n: [
      "monkey face",
      "monkey_face"
    ],
    u: "1f435"
  },
  {
    n: [
      "monkey"
    ],
    u: "1f412"
  },
  {
    n: [
      "gorilla"
    ],
    u: "1f98d"
  },
  {
    n: [
      "dog face",
      "dog"
    ],
    u: "1f436"
  },
  {
    n: [
      "dog",
      "dog2"
    ],
    u: "1f415"
  },
  {
    n: [
      "poodle"
    ],
    u: "1f429"
  },
  {
    n: [
      "wolf face",
      "wolf"
    ],
    u: "1f43a"
  },
  {
    n: [
      "fox face",
      "fox_face"
    ],
    u: "1f98a"
  },
  {
    n: [
      "cat face",
      "cat"
    ],
    u: "1f431"
  },
  {
    n: [
      "cat",
      "cat2"
    ],
    u: "1f408"
  },
  {
    n: [
      "lion face",
      "lion_face"
    ],
    u: "1f981"
  },
  {
    n: [
      "tiger face",
      "tiger"
    ],
    u: "1f42f"
  },
  {
    n: [
      "tiger",
      "tiger2"
    ],
    u: "1f405"
  },
  {
    n: [
      "leopard"
    ],
    u: "1f406"
  },
  {
    n: [
      "horse face",
      "horse"
    ],
    u: "1f434"
  },
  {
    n: [
      "horse",
      "racehorse"
    ],
    u: "1f40e"
  },
  {
    n: [
      "unicorn face",
      "unicorn_face"
    ],
    u: "1f984"
  },
  {
    n: [
      "zebra face",
      "zebra_face"
    ],
    u: "1f993"
  },
  {
    n: [
      "deer"
    ],
    u: "1f98c"
  },
  {
    n: [
      "cow face",
      "cow"
    ],
    u: "1f42e"
  },
  {
    n: [
      "ox"
    ],
    u: "1f402"
  },
  {
    n: [
      "water buffalo",
      "water_buffalo"
    ],
    u: "1f403"
  },
  {
    n: [
      "cow",
      "cow2"
    ],
    u: "1f404"
  },
  {
    n: [
      "pig face",
      "pig"
    ],
    u: "1f437"
  },
  {
    n: [
      "pig",
      "pig2"
    ],
    u: "1f416"
  },
  {
    n: [
      "boar"
    ],
    u: "1f417"
  },
  {
    n: [
      "pig nose",
      "pig_nose"
    ],
    u: "1f43d"
  },
  {
    n: [
      "ram"
    ],
    u: "1f40f"
  },
  {
    n: [
      "sheep"
    ],
    u: "1f411"
  },
  {
    n: [
      "goat"
    ],
    u: "1f410"
  },
  {
    n: [
      "dromedary camel",
      "dromedary_camel"
    ],
    u: "1f42a"
  },
  {
    n: [
      "bactrian camel",
      "camel"
    ],
    u: "1f42b"
  },
  {
    n: [
      "giraffe face",
      "giraffe_face"
    ],
    u: "1f992"
  },
  {
    n: [
      "elephant"
    ],
    u: "1f418"
  },
  {
    n: [
      "rhinoceros"
    ],
    u: "1f98f"
  },
  {
    n: [
      "mouse face",
      "mouse"
    ],
    u: "1f42d"
  },
  {
    n: [
      "mouse",
      "mouse2"
    ],
    u: "1f401"
  },
  {
    n: [
      "rat"
    ],
    u: "1f400"
  },
  {
    n: [
      "hamster face",
      "hamster"
    ],
    u: "1f439"
  },
  {
    n: [
      "rabbit face",
      "rabbit"
    ],
    u: "1f430"
  },
  {
    n: [
      "rabbit",
      "rabbit2"
    ],
    u: "1f407"
  },
  {
    n: [
      "chipmunk"
    ],
    u: "1f43f-fe0f"
  },
  {
    n: [
      "hedgehog"
    ],
    u: "1f994"
  },
  {
    n: [
      "bat"
    ],
    u: "1f987"
  },
  {
    n: [
      "bear face",
      "bear"
    ],
    u: "1f43b"
  },
  {
    n: [
      "koala"
    ],
    u: "1f428"
  },
  {
    n: [
      "panda face",
      "panda_face"
    ],
    u: "1f43c"
  },
  {
    n: [
      "paw prints",
      "feet",
      "paw_prints"
    ],
    u: "1f43e"
  },
  {
    n: [
      "turkey"
    ],
    u: "1f983"
  },
  {
    n: [
      "chicken"
    ],
    u: "1f414"
  },
  {
    n: [
      "rooster"
    ],
    u: "1f413"
  },
  {
    n: [
      "hatching chick",
      "hatching_chick"
    ],
    u: "1f423"
  },
  {
    n: [
      "baby chick",
      "baby_chick"
    ],
    u: "1f424"
  },
  {
    n: [
      "front-facing baby chick",
      "hatched_chick"
    ],
    u: "1f425"
  },
  {
    n: [
      "bird"
    ],
    u: "1f426"
  },
  {
    n: [
      "penguin"
    ],
    u: "1f427"
  },
  {
    n: [
      "dove_of_peace"
    ],
    u: "1f54a-fe0f"
  },
  {
    n: [
      "eagle"
    ],
    u: "1f985"
  },
  {
    n: [
      "duck"
    ],
    u: "1f986"
  },
  {
    n: [
      "owl"
    ],
    u: "1f989"
  },
  {
    n: [
      "frog face",
      "frog"
    ],
    u: "1f438"
  },
  {
    n: [
      "crocodile"
    ],
    u: "1f40a"
  },
  {
    n: [
      "turtle"
    ],
    u: "1f422"
  },
  {
    n: [
      "lizard"
    ],
    u: "1f98e"
  },
  {
    n: [
      "snake"
    ],
    u: "1f40d"
  },
  {
    n: [
      "dragon face",
      "dragon_face"
    ],
    u: "1f432"
  },
  {
    n: [
      "dragon"
    ],
    u: "1f409"
  },
  {
    n: [
      "sauropod"
    ],
    u: "1f995"
  },
  {
    n: [
      "t-rex"
    ],
    u: "1f996"
  },
  {
    n: [
      "spouting whale",
      "whale"
    ],
    u: "1f433"
  },
  {
    n: [
      "whale",
      "whale2"
    ],
    u: "1f40b"
  },
  {
    n: [
      "dolphin",
      "flipper"
    ],
    u: "1f42c"
  },
  {
    n: [
      "fish"
    ],
    u: "1f41f"
  },
  {
    n: [
      "tropical fish",
      "tropical_fish"
    ],
    u: "1f420"
  },
  {
    n: [
      "blowfish"
    ],
    u: "1f421"
  },
  {
    n: [
      "shark"
    ],
    u: "1f988"
  },
  {
    n: [
      "octopus"
    ],
    u: "1f419"
  },
  {
    n: [
      "spiral shell",
      "shell"
    ],
    u: "1f41a"
  },
  {
    n: [
      "crab"
    ],
    u: "1f980"
  },
  {
    n: [
      "shrimp"
    ],
    u: "1f990"
  },
  {
    n: [
      "squid"
    ],
    u: "1f991"
  },
  {
    n: [
      "snail"
    ],
    u: "1f40c"
  },
  {
    n: [
      "butterfly"
    ],
    u: "1f98b"
  },
  {
    n: [
      "bug"
    ],
    u: "1f41b"
  },
  {
    n: [
      "ant"
    ],
    u: "1f41c"
  },
  {
    n: [
      "honeybee",
      "bee"
    ],
    u: "1f41d"
  },
  {
    n: [
      "lady beetle",
      "beetle"
    ],
    u: "1f41e"
  },
  {
    n: [
      "cricket"
    ],
    u: "1f997"
  },
  {
    n: [
      "spider"
    ],
    u: "1f577-fe0f"
  },
  {
    n: [
      "spider_web"
    ],
    u: "1f578-fe0f"
  },
  {
    n: [
      "scorpion"
    ],
    u: "1f982"
  },
  {
    n: [
      "bouquet"
    ],
    u: "1f490"
  },
  {
    n: [
      "cherry blossom",
      "cherry_blossom"
    ],
    u: "1f338"
  },
  {
    n: [
      "white flower",
      "white_flower"
    ],
    u: "1f4ae"
  },
  {
    n: [
      "rosette"
    ],
    u: "1f3f5-fe0f"
  },
  {
    n: [
      "rose"
    ],
    u: "1f339"
  },
  {
    n: [
      "wilted flower",
      "wilted_flower"
    ],
    u: "1f940"
  },
  {
    n: [
      "hibiscus"
    ],
    u: "1f33a"
  },
  {
    n: [
      "sunflower"
    ],
    u: "1f33b"
  },
  {
    n: [
      "blossom"
    ],
    u: "1f33c"
  },
  {
    n: [
      "tulip"
    ],
    u: "1f337"
  },
  {
    n: [
      "seedling"
    ],
    u: "1f331"
  },
  {
    n: [
      "evergreen tree",
      "evergreen_tree"
    ],
    u: "1f332"
  },
  {
    n: [
      "deciduous tree",
      "deciduous_tree"
    ],
    u: "1f333"
  },
  {
    n: [
      "palm tree",
      "palm_tree"
    ],
    u: "1f334"
  },
  {
    n: [
      "cactus"
    ],
    u: "1f335"
  },
  {
    n: [
      "ear of rice",
      "ear_of_rice"
    ],
    u: "1f33e"
  },
  {
    n: [
      "herb"
    ],
    u: "1f33f"
  },
  {
    n: [
      "shamrock"
    ],
    u: "2618-fe0f"
  },
  {
    n: [
      "four leaf clover",
      "four_leaf_clover"
    ],
    u: "1f340"
  },
  {
    n: [
      "maple leaf",
      "maple_leaf"
    ],
    u: "1f341"
  },
  {
    n: [
      "fallen leaf",
      "fallen_leaf"
    ],
    u: "1f342"
  },
  {
    n: [
      "leaf fluttering in wind",
      "leaves"
    ],
    u: "1f343"
  }
], ZNe = [
  {
    n: [
      "grapes"
    ],
    u: "1f347"
  },
  {
    n: [
      "melon"
    ],
    u: "1f348"
  },
  {
    n: [
      "watermelon"
    ],
    u: "1f349"
  },
  {
    n: [
      "tangerine"
    ],
    u: "1f34a"
  },
  {
    n: [
      "lemon"
    ],
    u: "1f34b"
  },
  {
    n: [
      "banana"
    ],
    u: "1f34c"
  },
  {
    n: [
      "pineapple"
    ],
    u: "1f34d"
  },
  {
    n: [
      "red apple",
      "apple"
    ],
    u: "1f34e"
  },
  {
    n: [
      "green apple",
      "green_apple"
    ],
    u: "1f34f"
  },
  {
    n: [
      "pear"
    ],
    u: "1f350"
  },
  {
    n: [
      "peach"
    ],
    u: "1f351"
  },
  {
    n: [
      "cherries"
    ],
    u: "1f352"
  },
  {
    n: [
      "strawberry"
    ],
    u: "1f353"
  },
  {
    n: [
      "kiwifruit"
    ],
    u: "1f95d"
  },
  {
    n: [
      "tomato"
    ],
    u: "1f345"
  },
  {
    n: [
      "coconut"
    ],
    u: "1f965"
  },
  {
    n: [
      "avocado"
    ],
    u: "1f951"
  },
  {
    n: [
      "aubergine",
      "eggplant"
    ],
    u: "1f346"
  },
  {
    n: [
      "potato"
    ],
    u: "1f954"
  },
  {
    n: [
      "carrot"
    ],
    u: "1f955"
  },
  {
    n: [
      "ear of maize",
      "corn"
    ],
    u: "1f33d"
  },
  {
    n: [
      "hot_pepper"
    ],
    u: "1f336-fe0f"
  },
  {
    n: [
      "cucumber"
    ],
    u: "1f952"
  },
  {
    n: [
      "broccoli"
    ],
    u: "1f966"
  },
  {
    n: [
      "mushroom"
    ],
    u: "1f344"
  },
  {
    n: [
      "peanuts"
    ],
    u: "1f95c"
  },
  {
    n: [
      "chestnut"
    ],
    u: "1f330"
  },
  {
    n: [
      "bread"
    ],
    u: "1f35e"
  },
  {
    n: [
      "croissant"
    ],
    u: "1f950"
  },
  {
    n: [
      "baguette bread",
      "baguette_bread"
    ],
    u: "1f956"
  },
  {
    n: [
      "pretzel"
    ],
    u: "1f968"
  },
  {
    n: [
      "pancakes"
    ],
    u: "1f95e"
  },
  {
    n: [
      "cheese wedge",
      "cheese_wedge"
    ],
    u: "1f9c0"
  },
  {
    n: [
      "meat on bone",
      "meat_on_bone"
    ],
    u: "1f356"
  },
  {
    n: [
      "poultry leg",
      "poultry_leg"
    ],
    u: "1f357"
  },
  {
    n: [
      "cut of meat",
      "cut_of_meat"
    ],
    u: "1f969"
  },
  {
    n: [
      "bacon"
    ],
    u: "1f953"
  },
  {
    n: [
      "hamburger"
    ],
    u: "1f354"
  },
  {
    n: [
      "french fries",
      "fries"
    ],
    u: "1f35f"
  },
  {
    n: [
      "slice of pizza",
      "pizza"
    ],
    u: "1f355"
  },
  {
    n: [
      "hot dog",
      "hotdog"
    ],
    u: "1f32d"
  },
  {
    n: [
      "sandwich"
    ],
    u: "1f96a"
  },
  {
    n: [
      "taco"
    ],
    u: "1f32e"
  },
  {
    n: [
      "burrito"
    ],
    u: "1f32f"
  },
  {
    n: [
      "stuffed flatbread",
      "stuffed_flatbread"
    ],
    u: "1f959"
  },
  {
    n: [
      "egg"
    ],
    u: "1f95a"
  },
  {
    n: [
      "cooking",
      "fried_egg"
    ],
    u: "1f373"
  },
  {
    n: [
      "shallow pan of food",
      "shallow_pan_of_food"
    ],
    u: "1f958"
  },
  {
    n: [
      "pot of food",
      "stew"
    ],
    u: "1f372"
  },
  {
    n: [
      "bowl with spoon",
      "bowl_with_spoon"
    ],
    u: "1f963"
  },
  {
    n: [
      "green salad",
      "green_salad"
    ],
    u: "1f957"
  },
  {
    n: [
      "popcorn"
    ],
    u: "1f37f"
  },
  {
    n: [
      "canned food",
      "canned_food"
    ],
    u: "1f96b"
  },
  {
    n: [
      "bento box",
      "bento"
    ],
    u: "1f371"
  },
  {
    n: [
      "rice cracker",
      "rice_cracker"
    ],
    u: "1f358"
  },
  {
    n: [
      "rice ball",
      "rice_ball"
    ],
    u: "1f359"
  },
  {
    n: [
      "cooked rice",
      "rice"
    ],
    u: "1f35a"
  },
  {
    n: [
      "curry and rice",
      "curry"
    ],
    u: "1f35b"
  },
  {
    n: [
      "steaming bowl",
      "ramen"
    ],
    u: "1f35c"
  },
  {
    n: [
      "spaghetti"
    ],
    u: "1f35d"
  },
  {
    n: [
      "roasted sweet potato",
      "sweet_potato"
    ],
    u: "1f360"
  },
  {
    n: [
      "oden"
    ],
    u: "1f362"
  },
  {
    n: [
      "sushi"
    ],
    u: "1f363"
  },
  {
    n: [
      "fried shrimp",
      "fried_shrimp"
    ],
    u: "1f364"
  },
  {
    n: [
      "fish cake with swirl design",
      "fish_cake"
    ],
    u: "1f365"
  },
  {
    n: [
      "dango"
    ],
    u: "1f361"
  },
  {
    n: [
      "dumpling"
    ],
    u: "1f95f"
  },
  {
    n: [
      "fortune cookie",
      "fortune_cookie"
    ],
    u: "1f960"
  },
  {
    n: [
      "takeout box",
      "takeout_box"
    ],
    u: "1f961"
  },
  {
    n: [
      "soft ice cream",
      "icecream"
    ],
    u: "1f366"
  },
  {
    n: [
      "shaved ice",
      "shaved_ice"
    ],
    u: "1f367"
  },
  {
    n: [
      "ice cream",
      "ice_cream"
    ],
    u: "1f368"
  },
  {
    n: [
      "doughnut"
    ],
    u: "1f369"
  },
  {
    n: [
      "cookie"
    ],
    u: "1f36a"
  },
  {
    n: [
      "birthday cake",
      "birthday"
    ],
    u: "1f382"
  },
  {
    n: [
      "shortcake",
      "cake"
    ],
    u: "1f370"
  },
  {
    n: [
      "pie"
    ],
    u: "1f967"
  },
  {
    n: [
      "chocolate bar",
      "chocolate_bar"
    ],
    u: "1f36b"
  },
  {
    n: [
      "candy"
    ],
    u: "1f36c"
  },
  {
    n: [
      "lollipop"
    ],
    u: "1f36d"
  },
  {
    n: [
      "custard"
    ],
    u: "1f36e"
  },
  {
    n: [
      "honey pot",
      "honey_pot"
    ],
    u: "1f36f"
  },
  {
    n: [
      "baby bottle",
      "baby_bottle"
    ],
    u: "1f37c"
  },
  {
    n: [
      "glass of milk",
      "glass_of_milk"
    ],
    u: "1f95b"
  },
  {
    n: [
      "hot beverage",
      "coffee"
    ],
    u: "2615"
  },
  {
    n: [
      "teacup without handle",
      "tea"
    ],
    u: "1f375"
  },
  {
    n: [
      "sake bottle and cup",
      "sake"
    ],
    u: "1f376"
  },
  {
    n: [
      "bottle with popping cork",
      "champagne"
    ],
    u: "1f37e"
  },
  {
    n: [
      "wine glass",
      "wine_glass"
    ],
    u: "1f377"
  },
  {
    n: [
      "cocktail glass",
      "cocktail"
    ],
    u: "1f378"
  },
  {
    n: [
      "tropical drink",
      "tropical_drink"
    ],
    u: "1f379"
  },
  {
    n: [
      "beer mug",
      "beer"
    ],
    u: "1f37a"
  },
  {
    n: [
      "clinking beer mugs",
      "beers"
    ],
    u: "1f37b"
  },
  {
    n: [
      "clinking glasses",
      "clinking_glasses"
    ],
    u: "1f942"
  },
  {
    n: [
      "tumbler glass",
      "tumbler_glass"
    ],
    u: "1f943"
  },
  {
    n: [
      "cup with straw",
      "cup_with_straw"
    ],
    u: "1f964"
  },
  {
    n: [
      "chopsticks"
    ],
    u: "1f962"
  },
  {
    n: [
      "knife_fork_plate"
    ],
    u: "1f37d-fe0f"
  },
  {
    n: [
      "fork and knife",
      "fork_and_knife"
    ],
    u: "1f374"
  },
  {
    n: [
      "spoon"
    ],
    u: "1f944"
  },
  {
    n: [
      "hocho",
      "knife"
    ],
    u: "1f52a"
  },
  {
    n: [
      "amphora"
    ],
    u: "1f3fa"
  }
], JNe = [
  {
    n: [
      "jack-o-lantern",
      "jack_o_lantern"
    ],
    u: "1f383"
  },
  {
    n: [
      "christmas tree",
      "christmas_tree"
    ],
    u: "1f384"
  },
  {
    n: [
      "fireworks"
    ],
    u: "1f386"
  },
  {
    n: [
      "firework sparkler",
      "sparkler"
    ],
    u: "1f387"
  },
  {
    n: [
      "sparkles"
    ],
    u: "2728"
  },
  {
    n: [
      "balloon"
    ],
    u: "1f388"
  },
  {
    n: [
      "party popper",
      "tada"
    ],
    u: "1f389"
  },
  {
    n: [
      "confetti ball",
      "confetti_ball"
    ],
    u: "1f38a"
  },
  {
    n: [
      "tanabata tree",
      "tanabata_tree"
    ],
    u: "1f38b"
  },
  {
    n: [
      "pine decoration",
      "bamboo"
    ],
    u: "1f38d"
  },
  {
    n: [
      "japanese dolls",
      "dolls"
    ],
    u: "1f38e"
  },
  {
    n: [
      "carp streamer",
      "flags"
    ],
    u: "1f38f"
  },
  {
    n: [
      "wind chime",
      "wind_chime"
    ],
    u: "1f390"
  },
  {
    n: [
      "moon viewing ceremony",
      "rice_scene"
    ],
    u: "1f391"
  },
  {
    n: [
      "ribbon"
    ],
    u: "1f380"
  },
  {
    n: [
      "wrapped present",
      "gift"
    ],
    u: "1f381"
  },
  {
    n: [
      "reminder_ribbon"
    ],
    u: "1f397-fe0f"
  },
  {
    n: [
      "admission_tickets"
    ],
    u: "1f39f-fe0f"
  },
  {
    n: [
      "ticket"
    ],
    u: "1f3ab"
  },
  {
    n: [
      "medal"
    ],
    u: "1f396-fe0f"
  },
  {
    n: [
      "trophy"
    ],
    u: "1f3c6"
  },
  {
    n: [
      "sports medal",
      "sports_medal"
    ],
    u: "1f3c5"
  },
  {
    n: [
      "first place medal",
      "first_place_medal"
    ],
    u: "1f947"
  },
  {
    n: [
      "second place medal",
      "second_place_medal"
    ],
    u: "1f948"
  },
  {
    n: [
      "third place medal",
      "third_place_medal"
    ],
    u: "1f949"
  },
  {
    n: [
      "soccer ball",
      "soccer"
    ],
    u: "26bd"
  },
  {
    n: [
      "baseball"
    ],
    u: "26be"
  },
  {
    n: [
      "basketball and hoop",
      "basketball"
    ],
    u: "1f3c0"
  },
  {
    n: [
      "volleyball"
    ],
    u: "1f3d0"
  },
  {
    n: [
      "american football",
      "football"
    ],
    u: "1f3c8"
  },
  {
    n: [
      "rugby football",
      "rugby_football"
    ],
    u: "1f3c9"
  },
  {
    n: [
      "tennis racquet and ball",
      "tennis"
    ],
    u: "1f3be"
  },
  {
    n: [
      "billiards",
      "8ball"
    ],
    u: "1f3b1"
  },
  {
    n: [
      "bowling"
    ],
    u: "1f3b3"
  },
  {
    n: [
      "cricket bat and ball",
      "cricket_bat_and_ball"
    ],
    u: "1f3cf"
  },
  {
    n: [
      "field hockey stick and ball",
      "field_hockey_stick_and_ball"
    ],
    u: "1f3d1"
  },
  {
    n: [
      "ice hockey stick and puck",
      "ice_hockey_stick_and_puck"
    ],
    u: "1f3d2"
  },
  {
    n: [
      "table tennis paddle and ball",
      "table_tennis_paddle_and_ball"
    ],
    u: "1f3d3"
  },
  {
    n: [
      "badminton racquet and shuttlecock",
      "badminton_racquet_and_shuttlecock"
    ],
    u: "1f3f8"
  },
  {
    n: [
      "boxing glove",
      "boxing_glove"
    ],
    u: "1f94a"
  },
  {
    n: [
      "martial arts uniform",
      "martial_arts_uniform"
    ],
    u: "1f94b"
  },
  {
    n: [
      "goal net",
      "goal_net"
    ],
    u: "1f945"
  },
  {
    n: [
      "direct hit",
      "dart"
    ],
    u: "1f3af"
  },
  {
    n: [
      "flag in hole",
      "golf"
    ],
    u: "26f3"
  },
  {
    n: [
      "ice_skate"
    ],
    u: "26f8-fe0f"
  },
  {
    n: [
      "fishing pole and fish",
      "fishing_pole_and_fish"
    ],
    u: "1f3a3"
  },
  {
    n: [
      "running shirt with sash",
      "running_shirt_with_sash"
    ],
    u: "1f3bd"
  },
  {
    n: [
      "ski and ski boot",
      "ski"
    ],
    u: "1f3bf"
  },
  {
    n: [
      "sled"
    ],
    u: "1f6f7"
  },
  {
    n: [
      "curling stone",
      "curling_stone"
    ],
    u: "1f94c"
  },
  {
    n: [
      "video game",
      "video_game"
    ],
    u: "1f3ae"
  },
  {
    n: [
      "joystick"
    ],
    u: "1f579-fe0f"
  },
  {
    n: [
      "game die",
      "game_die"
    ],
    u: "1f3b2"
  },
  {
    n: [
      "black spade suit",
      "spades"
    ],
    u: "2660-fe0f"
  },
  {
    n: [
      "black heart suit",
      "hearts"
    ],
    u: "2665-fe0f"
  },
  {
    n: [
      "black diamond suit",
      "diamonds"
    ],
    u: "2666-fe0f"
  },
  {
    n: [
      "black club suit",
      "clubs"
    ],
    u: "2663-fe0f"
  },
  {
    n: [
      "playing card black joker",
      "black_joker"
    ],
    u: "1f0cf"
  },
  {
    n: [
      "mahjong tile red dragon",
      "mahjong"
    ],
    u: "1f004"
  },
  {
    n: [
      "flower playing cards",
      "flower_playing_cards"
    ],
    u: "1f3b4"
  }
], e9e = [
  {
    n: [
      "earth globe europe-africa",
      "earth_africa"
    ],
    u: "1f30d"
  },
  {
    n: [
      "earth globe americas",
      "earth_americas"
    ],
    u: "1f30e"
  },
  {
    n: [
      "earth globe asia-australia",
      "earth_asia"
    ],
    u: "1f30f"
  },
  {
    n: [
      "globe with meridians",
      "globe_with_meridians"
    ],
    u: "1f310"
  },
  {
    n: [
      "world_map"
    ],
    u: "1f5fa-fe0f"
  },
  {
    n: [
      "silhouette of japan",
      "japan"
    ],
    u: "1f5fe"
  },
  {
    n: [
      "snow_capped_mountain"
    ],
    u: "1f3d4-fe0f"
  },
  {
    n: [
      "mountain"
    ],
    u: "26f0-fe0f"
  },
  {
    n: [
      "volcano"
    ],
    u: "1f30b"
  },
  {
    n: [
      "mount fuji",
      "mount_fuji"
    ],
    u: "1f5fb"
  },
  {
    n: [
      "camping"
    ],
    u: "1f3d5-fe0f"
  },
  {
    n: [
      "beach_with_umbrella"
    ],
    u: "1f3d6-fe0f"
  },
  {
    n: [
      "desert"
    ],
    u: "1f3dc-fe0f"
  },
  {
    n: [
      "desert_island"
    ],
    u: "1f3dd-fe0f"
  },
  {
    n: [
      "national_park"
    ],
    u: "1f3de-fe0f"
  },
  {
    n: [
      "stadium"
    ],
    u: "1f3df-fe0f"
  },
  {
    n: [
      "classical_building"
    ],
    u: "1f3db-fe0f"
  },
  {
    n: [
      "building_construction"
    ],
    u: "1f3d7-fe0f"
  },
  {
    n: [
      "house_buildings"
    ],
    u: "1f3d8-fe0f"
  },
  {
    n: [
      "cityscape"
    ],
    u: "1f3d9-fe0f"
  },
  {
    n: [
      "derelict_house_building"
    ],
    u: "1f3da-fe0f"
  },
  {
    n: [
      "house building",
      "house"
    ],
    u: "1f3e0"
  },
  {
    n: [
      "house with garden",
      "house_with_garden"
    ],
    u: "1f3e1"
  },
  {
    n: [
      "office building",
      "office"
    ],
    u: "1f3e2"
  },
  {
    n: [
      "japanese post office",
      "post_office"
    ],
    u: "1f3e3"
  },
  {
    n: [
      "european post office",
      "european_post_office"
    ],
    u: "1f3e4"
  },
  {
    n: [
      "hospital"
    ],
    u: "1f3e5"
  },
  {
    n: [
      "bank"
    ],
    u: "1f3e6"
  },
  {
    n: [
      "hotel"
    ],
    u: "1f3e8"
  },
  {
    n: [
      "love hotel",
      "love_hotel"
    ],
    u: "1f3e9"
  },
  {
    n: [
      "convenience store",
      "convenience_store"
    ],
    u: "1f3ea"
  },
  {
    n: [
      "school"
    ],
    u: "1f3eb"
  },
  {
    n: [
      "department store",
      "department_store"
    ],
    u: "1f3ec"
  },
  {
    n: [
      "factory"
    ],
    u: "1f3ed"
  },
  {
    n: [
      "japanese castle",
      "japanese_castle"
    ],
    u: "1f3ef"
  },
  {
    n: [
      "european castle",
      "european_castle"
    ],
    u: "1f3f0"
  },
  {
    n: [
      "wedding"
    ],
    u: "1f492"
  },
  {
    n: [
      "tokyo tower",
      "tokyo_tower"
    ],
    u: "1f5fc"
  },
  {
    n: [
      "statue of liberty",
      "statue_of_liberty"
    ],
    u: "1f5fd"
  },
  {
    n: [
      "church"
    ],
    u: "26ea"
  },
  {
    n: [
      "mosque"
    ],
    u: "1f54c"
  },
  {
    n: [
      "synagogue"
    ],
    u: "1f54d"
  },
  {
    n: [
      "shinto_shrine"
    ],
    u: "26e9-fe0f"
  },
  {
    n: [
      "kaaba"
    ],
    u: "1f54b"
  },
  {
    n: [
      "fountain"
    ],
    u: "26f2"
  },
  {
    n: [
      "tent"
    ],
    u: "26fa"
  },
  {
    n: [
      "foggy"
    ],
    u: "1f301"
  },
  {
    n: [
      "night with stars",
      "night_with_stars"
    ],
    u: "1f303"
  },
  {
    n: [
      "sunrise over mountains",
      "sunrise_over_mountains"
    ],
    u: "1f304"
  },
  {
    n: [
      "sunrise"
    ],
    u: "1f305"
  },
  {
    n: [
      "cityscape at dusk",
      "city_sunset"
    ],
    u: "1f306"
  },
  {
    n: [
      "sunset over buildings",
      "city_sunrise"
    ],
    u: "1f307"
  },
  {
    n: [
      "bridge at night",
      "bridge_at_night"
    ],
    u: "1f309"
  },
  {
    n: [
      "hot springs",
      "hotsprings"
    ],
    u: "2668-fe0f"
  },
  {
    n: [
      "milky way",
      "milky_way"
    ],
    u: "1f30c"
  },
  {
    n: [
      "carousel horse",
      "carousel_horse"
    ],
    u: "1f3a0"
  },
  {
    n: [
      "ferris wheel",
      "ferris_wheel"
    ],
    u: "1f3a1"
  },
  {
    n: [
      "roller coaster",
      "roller_coaster"
    ],
    u: "1f3a2"
  },
  {
    n: [
      "barber pole",
      "barber"
    ],
    u: "1f488"
  },
  {
    n: [
      "circus tent",
      "circus_tent"
    ],
    u: "1f3aa"
  },
  {
    n: [
      "performing arts",
      "performing_arts"
    ],
    u: "1f3ad"
  },
  {
    n: [
      "frame_with_picture"
    ],
    u: "1f5bc-fe0f"
  },
  {
    n: [
      "artist palette",
      "art"
    ],
    u: "1f3a8"
  },
  {
    n: [
      "slot machine",
      "slot_machine"
    ],
    u: "1f3b0"
  },
  {
    n: [
      "steam locomotive",
      "steam_locomotive"
    ],
    u: "1f682"
  },
  {
    n: [
      "railway car",
      "railway_car"
    ],
    u: "1f683"
  },
  {
    n: [
      "high-speed train",
      "bullettrain_side"
    ],
    u: "1f684"
  },
  {
    n: [
      "high-speed train with bullet nose",
      "bullettrain_front"
    ],
    u: "1f685"
  },
  {
    n: [
      "train",
      "train2"
    ],
    u: "1f686"
  },
  {
    n: [
      "metro"
    ],
    u: "1f687"
  },
  {
    n: [
      "light rail",
      "light_rail"
    ],
    u: "1f688"
  },
  {
    n: [
      "station"
    ],
    u: "1f689"
  },
  {
    n: [
      "tram"
    ],
    u: "1f68a"
  },
  {
    n: [
      "monorail"
    ],
    u: "1f69d"
  },
  {
    n: [
      "mountain railway",
      "mountain_railway"
    ],
    u: "1f69e"
  },
  {
    n: [
      "tram car",
      "train"
    ],
    u: "1f68b"
  },
  {
    n: [
      "bus"
    ],
    u: "1f68c"
  },
  {
    n: [
      "oncoming bus",
      "oncoming_bus"
    ],
    u: "1f68d"
  },
  {
    n: [
      "trolleybus"
    ],
    u: "1f68e"
  },
  {
    n: [
      "minibus"
    ],
    u: "1f690"
  },
  {
    n: [
      "ambulance"
    ],
    u: "1f691"
  },
  {
    n: [
      "fire engine",
      "fire_engine"
    ],
    u: "1f692"
  },
  {
    n: [
      "police car",
      "police_car"
    ],
    u: "1f693"
  },
  {
    n: [
      "oncoming police car",
      "oncoming_police_car"
    ],
    u: "1f694"
  },
  {
    n: [
      "taxi"
    ],
    u: "1f695"
  },
  {
    n: [
      "oncoming taxi",
      "oncoming_taxi"
    ],
    u: "1f696"
  },
  {
    n: [
      "automobile",
      "car",
      "red_car"
    ],
    u: "1f697"
  },
  {
    n: [
      "oncoming automobile",
      "oncoming_automobile"
    ],
    u: "1f698"
  },
  {
    n: [
      "recreational vehicle",
      "blue_car"
    ],
    u: "1f699"
  },
  {
    n: [
      "delivery truck",
      "truck"
    ],
    u: "1f69a"
  },
  {
    n: [
      "articulated lorry",
      "articulated_lorry"
    ],
    u: "1f69b"
  },
  {
    n: [
      "tractor"
    ],
    u: "1f69c"
  },
  {
    n: [
      "bicycle",
      "bike"
    ],
    u: "1f6b2"
  },
  {
    n: [
      "scooter"
    ],
    u: "1f6f4"
  },
  {
    n: [
      "motor scooter",
      "motor_scooter"
    ],
    u: "1f6f5"
  },
  {
    n: [
      "bus stop",
      "busstop"
    ],
    u: "1f68f"
  },
  {
    n: [
      "motorway"
    ],
    u: "1f6e3-fe0f"
  },
  {
    n: [
      "railway_track"
    ],
    u: "1f6e4-fe0f"
  },
  {
    n: [
      "fuel pump",
      "fuelpump"
    ],
    u: "26fd"
  },
  {
    n: [
      "police cars revolving light",
      "rotating_light"
    ],
    u: "1f6a8"
  },
  {
    n: [
      "horizontal traffic light",
      "traffic_light"
    ],
    u: "1f6a5"
  },
  {
    n: [
      "vertical traffic light",
      "vertical_traffic_light"
    ],
    u: "1f6a6"
  },
  {
    n: [
      "construction sign",
      "construction"
    ],
    u: "1f6a7"
  },
  {
    n: [
      "octagonal sign",
      "octagonal_sign"
    ],
    u: "1f6d1"
  },
  {
    n: [
      "anchor"
    ],
    u: "2693"
  },
  {
    n: [
      "sailboat",
      "boat"
    ],
    u: "26f5"
  },
  {
    n: [
      "canoe"
    ],
    u: "1f6f6"
  },
  {
    n: [
      "speedboat"
    ],
    u: "1f6a4"
  },
  {
    n: [
      "passenger_ship"
    ],
    u: "1f6f3-fe0f"
  },
  {
    n: [
      "ferry"
    ],
    u: "26f4-fe0f"
  },
  {
    n: [
      "motor_boat"
    ],
    u: "1f6e5-fe0f"
  },
  {
    n: [
      "ship"
    ],
    u: "1f6a2"
  },
  {
    n: [
      "airplane"
    ],
    u: "2708-fe0f"
  },
  {
    n: [
      "small_airplane"
    ],
    u: "1f6e9-fe0f"
  },
  {
    n: [
      "airplane departure",
      "airplane_departure"
    ],
    u: "1f6eb"
  },
  {
    n: [
      "airplane arriving",
      "airplane_arriving"
    ],
    u: "1f6ec"
  },
  {
    n: [
      "seat"
    ],
    u: "1f4ba"
  },
  {
    n: [
      "helicopter"
    ],
    u: "1f681"
  },
  {
    n: [
      "suspension railway",
      "suspension_railway"
    ],
    u: "1f69f"
  },
  {
    n: [
      "mountain cableway",
      "mountain_cableway"
    ],
    u: "1f6a0"
  },
  {
    n: [
      "aerial tramway",
      "aerial_tramway"
    ],
    u: "1f6a1"
  },
  {
    n: [
      "satellite"
    ],
    u: "1f6f0-fe0f"
  },
  {
    n: [
      "rocket"
    ],
    u: "1f680"
  },
  {
    n: [
      "flying saucer",
      "flying_saucer"
    ],
    u: "1f6f8"
  },
  {
    n: [
      "bellhop_bell"
    ],
    u: "1f6ce-fe0f"
  },
  {
    n: [
      "door"
    ],
    u: "1f6aa"
  },
  {
    n: [
      "bed"
    ],
    u: "1f6cf-fe0f"
  },
  {
    n: [
      "couch_and_lamp"
    ],
    u: "1f6cb-fe0f"
  },
  {
    n: [
      "toilet"
    ],
    u: "1f6bd"
  },
  {
    n: [
      "shower"
    ],
    u: "1f6bf"
  },
  {
    n: [
      "bathtub"
    ],
    u: "1f6c1"
  },
  {
    n: [
      "hourglass"
    ],
    u: "231b"
  },
  {
    n: [
      "hourglass with flowing sand",
      "hourglass_flowing_sand"
    ],
    u: "23f3"
  },
  {
    n: [
      "watch"
    ],
    u: "231a"
  },
  {
    n: [
      "alarm clock",
      "alarm_clock"
    ],
    u: "23f0"
  },
  {
    n: [
      "stopwatch"
    ],
    u: "23f1-fe0f"
  },
  {
    n: [
      "timer_clock"
    ],
    u: "23f2-fe0f"
  },
  {
    n: [
      "mantelpiece_clock"
    ],
    u: "1f570-fe0f"
  },
  {
    n: [
      "clock face twelve oclock",
      "clock12"
    ],
    u: "1f55b"
  },
  {
    n: [
      "clock face twelve-thirty",
      "clock1230"
    ],
    u: "1f567"
  },
  {
    n: [
      "clock face one oclock",
      "clock1"
    ],
    u: "1f550"
  },
  {
    n: [
      "clock face one-thirty",
      "clock130"
    ],
    u: "1f55c"
  },
  {
    n: [
      "clock face two oclock",
      "clock2"
    ],
    u: "1f551"
  },
  {
    n: [
      "clock face two-thirty",
      "clock230"
    ],
    u: "1f55d"
  },
  {
    n: [
      "clock face three oclock",
      "clock3"
    ],
    u: "1f552"
  },
  {
    n: [
      "clock face three-thirty",
      "clock330"
    ],
    u: "1f55e"
  },
  {
    n: [
      "clock face four oclock",
      "clock4"
    ],
    u: "1f553"
  },
  {
    n: [
      "clock face four-thirty",
      "clock430"
    ],
    u: "1f55f"
  },
  {
    n: [
      "clock face five oclock",
      "clock5"
    ],
    u: "1f554"
  },
  {
    n: [
      "clock face five-thirty",
      "clock530"
    ],
    u: "1f560"
  },
  {
    n: [
      "clock face six oclock",
      "clock6"
    ],
    u: "1f555"
  },
  {
    n: [
      "clock face six-thirty",
      "clock630"
    ],
    u: "1f561"
  },
  {
    n: [
      "clock face seven oclock",
      "clock7"
    ],
    u: "1f556"
  },
  {
    n: [
      "clock face seven-thirty",
      "clock730"
    ],
    u: "1f562"
  },
  {
    n: [
      "clock face eight oclock",
      "clock8"
    ],
    u: "1f557"
  },
  {
    n: [
      "clock face eight-thirty",
      "clock830"
    ],
    u: "1f563"
  },
  {
    n: [
      "clock face nine oclock",
      "clock9"
    ],
    u: "1f558"
  },
  {
    n: [
      "clock face nine-thirty",
      "clock930"
    ],
    u: "1f564"
  },
  {
    n: [
      "clock face ten oclock",
      "clock10"
    ],
    u: "1f559"
  },
  {
    n: [
      "clock face ten-thirty",
      "clock1030"
    ],
    u: "1f565"
  },
  {
    n: [
      "clock face eleven oclock",
      "clock11"
    ],
    u: "1f55a"
  },
  {
    n: [
      "clock face eleven-thirty",
      "clock1130"
    ],
    u: "1f566"
  },
  {
    n: [
      "new moon symbol",
      "new_moon"
    ],
    u: "1f311"
  },
  {
    n: [
      "waxing crescent moon symbol",
      "waxing_crescent_moon"
    ],
    u: "1f312"
  },
  {
    n: [
      "first quarter moon symbol",
      "first_quarter_moon"
    ],
    u: "1f313"
  },
  {
    n: [
      "waxing gibbous moon symbol",
      "moon",
      "waxing_gibbous_moon"
    ],
    u: "1f314"
  },
  {
    n: [
      "full moon symbol",
      "full_moon"
    ],
    u: "1f315"
  },
  {
    n: [
      "waning gibbous moon symbol",
      "waning_gibbous_moon"
    ],
    u: "1f316"
  },
  {
    n: [
      "last quarter moon symbol",
      "last_quarter_moon"
    ],
    u: "1f317"
  },
  {
    n: [
      "waning crescent moon symbol",
      "waning_crescent_moon"
    ],
    u: "1f318"
  },
  {
    n: [
      "crescent moon",
      "crescent_moon"
    ],
    u: "1f319"
  },
  {
    n: [
      "new moon with face",
      "new_moon_with_face"
    ],
    u: "1f31a"
  },
  {
    n: [
      "first quarter moon with face",
      "first_quarter_moon_with_face"
    ],
    u: "1f31b"
  },
  {
    n: [
      "last quarter moon with face",
      "last_quarter_moon_with_face"
    ],
    u: "1f31c"
  },
  {
    n: [
      "thermometer"
    ],
    u: "1f321-fe0f"
  },
  {
    n: [
      "black sun with rays",
      "sunny"
    ],
    u: "2600-fe0f"
  },
  {
    n: [
      "full moon with face",
      "full_moon_with_face"
    ],
    u: "1f31d"
  },
  {
    n: [
      "sun with face",
      "sun_with_face"
    ],
    u: "1f31e"
  },
  {
    n: [
      "white medium star",
      "star"
    ],
    u: "2b50"
  },
  {
    n: [
      "glowing star",
      "star2"
    ],
    u: "1f31f"
  },
  {
    n: [
      "shooting star",
      "stars"
    ],
    u: "1f320"
  },
  {
    n: [
      "cloud"
    ],
    u: "2601-fe0f"
  },
  {
    n: [
      "sun behind cloud",
      "partly_sunny"
    ],
    u: "26c5"
  },
  {
    n: [
      "thunder_cloud_and_rain"
    ],
    u: "26c8-fe0f"
  },
  {
    n: [
      "mostly_sunny",
      "sun_small_cloud"
    ],
    u: "1f324-fe0f"
  },
  {
    n: [
      "barely_sunny",
      "sun_behind_cloud"
    ],
    u: "1f325-fe0f"
  },
  {
    n: [
      "partly_sunny_rain",
      "sun_behind_rain_cloud"
    ],
    u: "1f326-fe0f"
  },
  {
    n: [
      "rain_cloud"
    ],
    u: "1f327-fe0f"
  },
  {
    n: [
      "snow_cloud"
    ],
    u: "1f328-fe0f"
  },
  {
    n: [
      "lightning",
      "lightning_cloud"
    ],
    u: "1f329-fe0f"
  },
  {
    n: [
      "tornado",
      "tornado_cloud"
    ],
    u: "1f32a-fe0f"
  },
  {
    n: [
      "fog"
    ],
    u: "1f32b-fe0f"
  },
  {
    n: [
      "wind_blowing_face"
    ],
    u: "1f32c-fe0f"
  },
  {
    n: [
      "cyclone"
    ],
    u: "1f300"
  },
  {
    n: [
      "rainbow"
    ],
    u: "1f308"
  },
  {
    n: [
      "closed umbrella",
      "closed_umbrella"
    ],
    u: "1f302"
  },
  {
    n: [
      "umbrella"
    ],
    u: "2602-fe0f"
  },
  {
    n: [
      "umbrella with rain drops",
      "umbrella_with_rain_drops"
    ],
    u: "2614"
  },
  {
    n: [
      "umbrella_on_ground"
    ],
    u: "26f1-fe0f"
  },
  {
    n: [
      "high voltage sign",
      "zap"
    ],
    u: "26a1"
  },
  {
    n: [
      "snowflake"
    ],
    u: "2744-fe0f"
  },
  {
    n: [
      "snowman"
    ],
    u: "2603-fe0f"
  },
  {
    n: [
      "snowman without snow",
      "snowman_without_snow"
    ],
    u: "26c4"
  },
  {
    n: [
      "comet"
    ],
    u: "2604-fe0f"
  },
  {
    n: [
      "fire"
    ],
    u: "1f525"
  },
  {
    n: [
      "droplet"
    ],
    u: "1f4a7"
  },
  {
    n: [
      "water wave",
      "ocean"
    ],
    u: "1f30a"
  }
], t9e = [
  {
    n: [
      "speaker with cancellation stroke",
      "mute"
    ],
    u: "1f507"
  },
  {
    n: [
      "speaker"
    ],
    u: "1f508"
  },
  {
    n: [
      "speaker with one sound wave",
      "sound"
    ],
    u: "1f509"
  },
  {
    n: [
      "speaker with three sound waves",
      "loud_sound"
    ],
    u: "1f50a"
  },
  {
    n: [
      "public address loudspeaker",
      "loudspeaker"
    ],
    u: "1f4e2"
  },
  {
    n: [
      "cheering megaphone",
      "mega"
    ],
    u: "1f4e3"
  },
  {
    n: [
      "postal horn",
      "postal_horn"
    ],
    u: "1f4ef"
  },
  {
    n: [
      "bell"
    ],
    u: "1f514"
  },
  {
    n: [
      "bell with cancellation stroke",
      "no_bell"
    ],
    u: "1f515"
  },
  {
    n: [
      "musical score",
      "musical_score"
    ],
    u: "1f3bc"
  },
  {
    n: [
      "musical note",
      "musical_note"
    ],
    u: "1f3b5"
  },
  {
    n: [
      "multiple musical notes",
      "notes"
    ],
    u: "1f3b6"
  },
  {
    n: [
      "studio_microphone"
    ],
    u: "1f399-fe0f"
  },
  {
    n: [
      "level_slider"
    ],
    u: "1f39a-fe0f"
  },
  {
    n: [
      "control_knobs"
    ],
    u: "1f39b-fe0f"
  },
  {
    n: [
      "microphone"
    ],
    u: "1f3a4"
  },
  {
    n: [
      "headphone",
      "headphones"
    ],
    u: "1f3a7"
  },
  {
    n: [
      "radio"
    ],
    u: "1f4fb"
  },
  {
    n: [
      "saxophone"
    ],
    u: "1f3b7"
  },
  {
    n: [
      "guitar"
    ],
    u: "1f3b8"
  },
  {
    n: [
      "musical keyboard",
      "musical_keyboard"
    ],
    u: "1f3b9"
  },
  {
    n: [
      "trumpet"
    ],
    u: "1f3ba"
  },
  {
    n: [
      "violin"
    ],
    u: "1f3bb"
  },
  {
    n: [
      "drum with drumsticks",
      "drum_with_drumsticks"
    ],
    u: "1f941"
  },
  {
    n: [
      "mobile phone",
      "iphone"
    ],
    u: "1f4f1"
  },
  {
    n: [
      "mobile phone with rightwards arrow at left",
      "calling"
    ],
    u: "1f4f2"
  },
  {
    n: [
      "black telephone",
      "phone",
      "telephone"
    ],
    u: "260e-fe0f"
  },
  {
    n: [
      "telephone receiver",
      "telephone_receiver"
    ],
    u: "1f4de"
  },
  {
    n: [
      "pager"
    ],
    u: "1f4df"
  },
  {
    n: [
      "fax machine",
      "fax"
    ],
    u: "1f4e0"
  },
  {
    n: [
      "battery"
    ],
    u: "1f50b"
  },
  {
    n: [
      "electric plug",
      "electric_plug"
    ],
    u: "1f50c"
  },
  {
    n: [
      "personal computer",
      "computer"
    ],
    u: "1f4bb"
  },
  {
    n: [
      "desktop_computer"
    ],
    u: "1f5a5-fe0f"
  },
  {
    n: [
      "printer"
    ],
    u: "1f5a8-fe0f"
  },
  {
    n: [
      "keyboard"
    ],
    u: "2328-fe0f"
  },
  {
    n: [
      "three_button_mouse"
    ],
    u: "1f5b1-fe0f"
  },
  {
    n: [
      "trackball"
    ],
    u: "1f5b2-fe0f"
  },
  {
    n: [
      "minidisc"
    ],
    u: "1f4bd"
  },
  {
    n: [
      "floppy disk",
      "floppy_disk"
    ],
    u: "1f4be"
  },
  {
    n: [
      "optical disc",
      "cd"
    ],
    u: "1f4bf"
  },
  {
    n: [
      "dvd"
    ],
    u: "1f4c0"
  },
  {
    n: [
      "movie camera",
      "movie_camera"
    ],
    u: "1f3a5"
  },
  {
    n: [
      "film_frames"
    ],
    u: "1f39e-fe0f"
  },
  {
    n: [
      "film_projector"
    ],
    u: "1f4fd-fe0f"
  },
  {
    n: [
      "clapper board",
      "clapper"
    ],
    u: "1f3ac"
  },
  {
    n: [
      "television",
      "tv"
    ],
    u: "1f4fa"
  },
  {
    n: [
      "camera"
    ],
    u: "1f4f7"
  },
  {
    n: [
      "camera with flash",
      "camera_with_flash"
    ],
    u: "1f4f8"
  },
  {
    n: [
      "video camera",
      "video_camera"
    ],
    u: "1f4f9"
  },
  {
    n: [
      "videocassette",
      "vhs"
    ],
    u: "1f4fc"
  },
  {
    n: [
      "left-pointing magnifying glass",
      "mag"
    ],
    u: "1f50d"
  },
  {
    n: [
      "right-pointing magnifying glass",
      "mag_right"
    ],
    u: "1f50e"
  },
  {
    n: [
      "microscope"
    ],
    u: "1f52c"
  },
  {
    n: [
      "telescope"
    ],
    u: "1f52d"
  },
  {
    n: [
      "satellite antenna",
      "satellite_antenna"
    ],
    u: "1f4e1"
  },
  {
    n: [
      "candle"
    ],
    u: "1f56f-fe0f"
  },
  {
    n: [
      "electric light bulb",
      "bulb"
    ],
    u: "1f4a1"
  },
  {
    n: [
      "electric torch",
      "flashlight"
    ],
    u: "1f526"
  },
  {
    n: [
      "izakaya lantern",
      "izakaya_lantern",
      "lantern"
    ],
    u: "1f3ee"
  },
  {
    n: [
      "notebook with decorative cover",
      "notebook_with_decorative_cover"
    ],
    u: "1f4d4"
  },
  {
    n: [
      "closed book",
      "closed_book"
    ],
    u: "1f4d5"
  },
  {
    n: [
      "open book",
      "book",
      "open_book"
    ],
    u: "1f4d6"
  },
  {
    n: [
      "green book",
      "green_book"
    ],
    u: "1f4d7"
  },
  {
    n: [
      "blue book",
      "blue_book"
    ],
    u: "1f4d8"
  },
  {
    n: [
      "orange book",
      "orange_book"
    ],
    u: "1f4d9"
  },
  {
    n: [
      "books"
    ],
    u: "1f4da"
  },
  {
    n: [
      "notebook"
    ],
    u: "1f4d3"
  },
  {
    n: [
      "ledger"
    ],
    u: "1f4d2"
  },
  {
    n: [
      "page with curl",
      "page_with_curl"
    ],
    u: "1f4c3"
  },
  {
    n: [
      "scroll"
    ],
    u: "1f4dc"
  },
  {
    n: [
      "page facing up",
      "page_facing_up"
    ],
    u: "1f4c4"
  },
  {
    n: [
      "newspaper"
    ],
    u: "1f4f0"
  },
  {
    n: [
      "rolled_up_newspaper"
    ],
    u: "1f5de-fe0f"
  },
  {
    n: [
      "bookmark tabs",
      "bookmark_tabs"
    ],
    u: "1f4d1"
  },
  {
    n: [
      "bookmark"
    ],
    u: "1f516"
  },
  {
    n: [
      "label"
    ],
    u: "1f3f7-fe0f"
  },
  {
    n: [
      "money bag",
      "moneybag"
    ],
    u: "1f4b0"
  },
  {
    n: [
      "banknote with yen sign",
      "yen"
    ],
    u: "1f4b4"
  },
  {
    n: [
      "banknote with dollar sign",
      "dollar"
    ],
    u: "1f4b5"
  },
  {
    n: [
      "banknote with euro sign",
      "euro"
    ],
    u: "1f4b6"
  },
  {
    n: [
      "banknote with pound sign",
      "pound"
    ],
    u: "1f4b7"
  },
  {
    n: [
      "money with wings",
      "money_with_wings"
    ],
    u: "1f4b8"
  },
  {
    n: [
      "credit card",
      "credit_card"
    ],
    u: "1f4b3"
  },
  {
    n: [
      "chart with upwards trend and yen sign",
      "chart"
    ],
    u: "1f4b9"
  },
  {
    n: [
      "currency exchange",
      "currency_exchange"
    ],
    u: "1f4b1"
  },
  {
    n: [
      "heavy dollar sign",
      "heavy_dollar_sign"
    ],
    u: "1f4b2"
  },
  {
    n: [
      "envelope",
      "email"
    ],
    u: "2709-fe0f"
  },
  {
    n: [
      "e-mail symbol",
      "e-mail"
    ],
    u: "1f4e7"
  },
  {
    n: [
      "incoming envelope",
      "incoming_envelope"
    ],
    u: "1f4e8"
  },
  {
    n: [
      "envelope with downwards arrow above",
      "envelope_with_arrow"
    ],
    u: "1f4e9"
  },
  {
    n: [
      "outbox tray",
      "outbox_tray"
    ],
    u: "1f4e4"
  },
  {
    n: [
      "inbox tray",
      "inbox_tray"
    ],
    u: "1f4e5"
  },
  {
    n: [
      "package"
    ],
    u: "1f4e6"
  },
  {
    n: [
      "closed mailbox with raised flag",
      "mailbox"
    ],
    u: "1f4eb"
  },
  {
    n: [
      "closed mailbox with lowered flag",
      "mailbox_closed"
    ],
    u: "1f4ea"
  },
  {
    n: [
      "open mailbox with raised flag",
      "mailbox_with_mail"
    ],
    u: "1f4ec"
  },
  {
    n: [
      "open mailbox with lowered flag",
      "mailbox_with_no_mail"
    ],
    u: "1f4ed"
  },
  {
    n: [
      "postbox"
    ],
    u: "1f4ee"
  },
  {
    n: [
      "ballot_box_with_ballot"
    ],
    u: "1f5f3-fe0f"
  },
  {
    n: [
      "pencil",
      "pencil2"
    ],
    u: "270f-fe0f"
  },
  {
    n: [
      "black nib",
      "black_nib"
    ],
    u: "2712-fe0f"
  },
  {
    n: [
      "lower_left_fountain_pen"
    ],
    u: "1f58b-fe0f"
  },
  {
    n: [
      "lower_left_ballpoint_pen"
    ],
    u: "1f58a-fe0f"
  },
  {
    n: [
      "lower_left_paintbrush"
    ],
    u: "1f58c-fe0f"
  },
  {
    n: [
      "lower_left_crayon"
    ],
    u: "1f58d-fe0f"
  },
  {
    n: [
      "memo",
      "pencil"
    ],
    u: "1f4dd"
  },
  {
    n: [
      "briefcase"
    ],
    u: "1f4bc"
  },
  {
    n: [
      "file folder",
      "file_folder"
    ],
    u: "1f4c1"
  },
  {
    n: [
      "open file folder",
      "open_file_folder"
    ],
    u: "1f4c2"
  },
  {
    n: [
      "card_index_dividers"
    ],
    u: "1f5c2-fe0f"
  },
  {
    n: [
      "calendar",
      "date"
    ],
    u: "1f4c5"
  },
  {
    n: [
      "tear-off calendar",
      "calendar"
    ],
    u: "1f4c6"
  },
  {
    n: [
      "spiral_note_pad"
    ],
    u: "1f5d2-fe0f"
  },
  {
    n: [
      "spiral_calendar_pad"
    ],
    u: "1f5d3-fe0f"
  },
  {
    n: [
      "card index",
      "card_index"
    ],
    u: "1f4c7"
  },
  {
    n: [
      "chart with upwards trend",
      "chart_with_upwards_trend"
    ],
    u: "1f4c8"
  },
  {
    n: [
      "chart with downwards trend",
      "chart_with_downwards_trend"
    ],
    u: "1f4c9"
  },
  {
    n: [
      "bar chart",
      "bar_chart"
    ],
    u: "1f4ca"
  },
  {
    n: [
      "clipboard"
    ],
    u: "1f4cb"
  },
  {
    n: [
      "pushpin"
    ],
    u: "1f4cc"
  },
  {
    n: [
      "round pushpin",
      "round_pushpin"
    ],
    u: "1f4cd"
  },
  {
    n: [
      "paperclip"
    ],
    u: "1f4ce"
  },
  {
    n: [
      "linked_paperclips"
    ],
    u: "1f587-fe0f"
  },
  {
    n: [
      "straight ruler",
      "straight_ruler"
    ],
    u: "1f4cf"
  },
  {
    n: [
      "triangular ruler",
      "triangular_ruler"
    ],
    u: "1f4d0"
  },
  {
    n: [
      "black scissors",
      "scissors"
    ],
    u: "2702-fe0f"
  },
  {
    n: [
      "card_file_box"
    ],
    u: "1f5c3-fe0f"
  },
  {
    n: [
      "file_cabinet"
    ],
    u: "1f5c4-fe0f"
  },
  {
    n: [
      "wastebasket"
    ],
    u: "1f5d1-fe0f"
  },
  {
    n: [
      "lock"
    ],
    u: "1f512"
  },
  {
    n: [
      "open lock",
      "unlock"
    ],
    u: "1f513"
  },
  {
    n: [
      "lock with ink pen",
      "lock_with_ink_pen"
    ],
    u: "1f50f"
  },
  {
    n: [
      "closed lock with key",
      "closed_lock_with_key"
    ],
    u: "1f510"
  },
  {
    n: [
      "key"
    ],
    u: "1f511"
  },
  {
    n: [
      "old_key"
    ],
    u: "1f5dd-fe0f"
  },
  {
    n: [
      "hammer"
    ],
    u: "1f528"
  },
  {
    n: [
      "pick"
    ],
    u: "26cf-fe0f"
  },
  {
    n: [
      "hammer_and_pick"
    ],
    u: "2692-fe0f"
  },
  {
    n: [
      "hammer_and_wrench"
    ],
    u: "1f6e0-fe0f"
  },
  {
    n: [
      "dagger_knife"
    ],
    u: "1f5e1-fe0f"
  },
  {
    n: [
      "crossed_swords"
    ],
    u: "2694-fe0f"
  },
  {
    n: [
      "pistol",
      "gun"
    ],
    u: "1f52b"
  },
  {
    n: [
      "bow and arrow",
      "bow_and_arrow"
    ],
    u: "1f3f9"
  },
  {
    n: [
      "shield"
    ],
    u: "1f6e1-fe0f"
  },
  {
    n: [
      "wrench"
    ],
    u: "1f527"
  },
  {
    n: [
      "nut and bolt",
      "nut_and_bolt"
    ],
    u: "1f529"
  },
  {
    n: [
      "gear"
    ],
    u: "2699-fe0f"
  },
  {
    n: [
      "compression"
    ],
    u: "1f5dc-fe0f"
  },
  {
    n: [
      "alembic"
    ],
    u: "2697-fe0f"
  },
  {
    n: [
      "scales"
    ],
    u: "2696-fe0f"
  },
  {
    n: [
      "link symbol",
      "link"
    ],
    u: "1f517"
  },
  {
    n: [
      "chains"
    ],
    u: "26d3-fe0f"
  },
  {
    n: [
      "syringe"
    ],
    u: "1f489"
  },
  {
    n: [
      "pill"
    ],
    u: "1f48a"
  },
  {
    n: [
      "smoking symbol",
      "smoking"
    ],
    u: "1f6ac"
  },
  {
    n: [
      "coffin"
    ],
    u: "26b0-fe0f"
  },
  {
    n: [
      "funeral_urn"
    ],
    u: "26b1-fe0f"
  },
  {
    n: [
      "moyai"
    ],
    u: "1f5ff"
  },
  {
    n: [
      "oil_drum"
    ],
    u: "1f6e2-fe0f"
  },
  {
    n: [
      "crystal ball",
      "crystal_ball"
    ],
    u: "1f52e"
  },
  {
    n: [
      "shopping trolley",
      "shopping_trolley"
    ],
    u: "1f6d2"
  }
], n9e = [
  {
    n: [
      "automated teller machine",
      "atm"
    ],
    u: "1f3e7"
  },
  {
    n: [
      "put litter in its place symbol",
      "put_litter_in_its_place"
    ],
    u: "1f6ae"
  },
  {
    n: [
      "potable water symbol",
      "potable_water"
    ],
    u: "1f6b0"
  },
  {
    n: [
      "wheelchair symbol",
      "wheelchair"
    ],
    u: "267f"
  },
  {
    n: [
      "mens symbol",
      "mens"
    ],
    u: "1f6b9"
  },
  {
    n: [
      "womens symbol",
      "womens"
    ],
    u: "1f6ba"
  },
  {
    n: [
      "restroom"
    ],
    u: "1f6bb"
  },
  {
    n: [
      "baby symbol",
      "baby_symbol"
    ],
    u: "1f6bc"
  },
  {
    n: [
      "water closet",
      "wc"
    ],
    u: "1f6be"
  },
  {
    n: [
      "passport control",
      "passport_control"
    ],
    u: "1f6c2"
  },
  {
    n: [
      "customs"
    ],
    u: "1f6c3"
  },
  {
    n: [
      "baggage claim",
      "baggage_claim"
    ],
    u: "1f6c4"
  },
  {
    n: [
      "left luggage",
      "left_luggage"
    ],
    u: "1f6c5"
  },
  {
    n: [
      "warning sign",
      "warning"
    ],
    u: "26a0-fe0f"
  },
  {
    n: [
      "children crossing",
      "children_crossing"
    ],
    u: "1f6b8"
  },
  {
    n: [
      "no entry",
      "no_entry"
    ],
    u: "26d4"
  },
  {
    n: [
      "no entry sign",
      "no_entry_sign"
    ],
    u: "1f6ab"
  },
  {
    n: [
      "no bicycles",
      "no_bicycles"
    ],
    u: "1f6b3"
  },
  {
    n: [
      "no smoking symbol",
      "no_smoking"
    ],
    u: "1f6ad"
  },
  {
    n: [
      "do not litter symbol",
      "do_not_litter"
    ],
    u: "1f6af"
  },
  {
    n: [
      "non-potable water symbol",
      "non-potable_water"
    ],
    u: "1f6b1"
  },
  {
    n: [
      "no pedestrians",
      "no_pedestrians"
    ],
    u: "1f6b7"
  },
  {
    n: [
      "no mobile phones",
      "no_mobile_phones"
    ],
    u: "1f4f5"
  },
  {
    n: [
      "no one under eighteen symbol",
      "underage"
    ],
    u: "1f51e"
  },
  {
    n: [
      "radioactive_sign"
    ],
    u: "2622-fe0f"
  },
  {
    n: [
      "biohazard_sign"
    ],
    u: "2623-fe0f"
  },
  {
    n: [
      "upwards black arrow",
      "arrow_up"
    ],
    u: "2b06-fe0f"
  },
  {
    n: [
      "north east arrow",
      "arrow_upper_right"
    ],
    u: "2197-fe0f"
  },
  {
    n: [
      "black rightwards arrow",
      "arrow_right"
    ],
    u: "27a1-fe0f"
  },
  {
    n: [
      "south east arrow",
      "arrow_lower_right"
    ],
    u: "2198-fe0f"
  },
  {
    n: [
      "downwards black arrow",
      "arrow_down"
    ],
    u: "2b07-fe0f"
  },
  {
    n: [
      "south west arrow",
      "arrow_lower_left"
    ],
    u: "2199-fe0f"
  },
  {
    n: [
      "leftwards black arrow",
      "arrow_left"
    ],
    u: "2b05-fe0f"
  },
  {
    n: [
      "north west arrow",
      "arrow_upper_left"
    ],
    u: "2196-fe0f"
  },
  {
    n: [
      "up down arrow",
      "arrow_up_down"
    ],
    u: "2195-fe0f"
  },
  {
    n: [
      "left right arrow",
      "left_right_arrow"
    ],
    u: "2194-fe0f"
  },
  {
    n: [
      "leftwards arrow with hook",
      "leftwards_arrow_with_hook"
    ],
    u: "21a9-fe0f"
  },
  {
    n: [
      "rightwards arrow with hook",
      "arrow_right_hook"
    ],
    u: "21aa-fe0f"
  },
  {
    n: [
      "arrow pointing rightwards then curving upwards",
      "arrow_heading_up"
    ],
    u: "2934-fe0f"
  },
  {
    n: [
      "arrow pointing rightwards then curving downwards",
      "arrow_heading_down"
    ],
    u: "2935-fe0f"
  },
  {
    n: [
      "clockwise downwards and upwards open circle arrows",
      "arrows_clockwise"
    ],
    u: "1f503"
  },
  {
    n: [
      "anticlockwise downwards and upwards open circle arrows",
      "arrows_counterclockwise"
    ],
    u: "1f504"
  },
  {
    n: [
      "back with leftwards arrow above",
      "back"
    ],
    u: "1f519"
  },
  {
    n: [
      "end with leftwards arrow above",
      "end"
    ],
    u: "1f51a"
  },
  {
    n: [
      "on with exclamation mark with left right arrow above",
      "on"
    ],
    u: "1f51b"
  },
  {
    n: [
      "soon with rightwards arrow above",
      "soon"
    ],
    u: "1f51c"
  },
  {
    n: [
      "top with upwards arrow above",
      "top"
    ],
    u: "1f51d"
  },
  {
    n: [
      "place of worship",
      "place_of_worship"
    ],
    u: "1f6d0"
  },
  {
    n: [
      "atom_symbol"
    ],
    u: "269b-fe0f"
  },
  {
    n: [
      "om_symbol"
    ],
    u: "1f549-fe0f"
  },
  {
    n: [
      "star_of_david"
    ],
    u: "2721-fe0f"
  },
  {
    n: [
      "wheel_of_dharma"
    ],
    u: "2638-fe0f"
  },
  {
    n: [
      "yin_yang"
    ],
    u: "262f-fe0f"
  },
  {
    n: [
      "latin_cross"
    ],
    u: "271d-fe0f"
  },
  {
    n: [
      "orthodox_cross"
    ],
    u: "2626-fe0f"
  },
  {
    n: [
      "star_and_crescent"
    ],
    u: "262a-fe0f"
  },
  {
    n: [
      "peace_symbol"
    ],
    u: "262e-fe0f"
  },
  {
    n: [
      "menorah with nine branches",
      "menorah_with_nine_branches"
    ],
    u: "1f54e"
  },
  {
    n: [
      "six pointed star with middle dot",
      "six_pointed_star"
    ],
    u: "1f52f"
  },
  {
    n: [
      "aries"
    ],
    u: "2648"
  },
  {
    n: [
      "taurus"
    ],
    u: "2649"
  },
  {
    n: [
      "gemini"
    ],
    u: "264a"
  },
  {
    n: [
      "cancer"
    ],
    u: "264b"
  },
  {
    n: [
      "leo"
    ],
    u: "264c"
  },
  {
    n: [
      "virgo"
    ],
    u: "264d"
  },
  {
    n: [
      "libra"
    ],
    u: "264e"
  },
  {
    n: [
      "scorpius"
    ],
    u: "264f"
  },
  {
    n: [
      "sagittarius"
    ],
    u: "2650"
  },
  {
    n: [
      "capricorn"
    ],
    u: "2651"
  },
  {
    n: [
      "aquarius"
    ],
    u: "2652"
  },
  {
    n: [
      "pisces"
    ],
    u: "2653"
  },
  {
    n: [
      "ophiuchus"
    ],
    u: "26ce"
  },
  {
    n: [
      "twisted rightwards arrows",
      "twisted_rightwards_arrows"
    ],
    u: "1f500"
  },
  {
    n: [
      "clockwise rightwards and leftwards open circle arrows",
      "repeat"
    ],
    u: "1f501"
  },
  {
    n: [
      "clockwise rightwards and leftwards open circle arrows with circled one overlay",
      "repeat_one"
    ],
    u: "1f502"
  },
  {
    n: [
      "black right-pointing triangle",
      "arrow_forward"
    ],
    u: "25b6-fe0f"
  },
  {
    n: [
      "black right-pointing double triangle",
      "fast_forward"
    ],
    u: "23e9"
  },
  {
    n: [
      "black_right_pointing_double_triangle_with_vertical_bar"
    ],
    u: "23ed-fe0f"
  },
  {
    n: [
      "black_right_pointing_triangle_with_double_vertical_bar"
    ],
    u: "23ef-fe0f"
  },
  {
    n: [
      "black left-pointing triangle",
      "arrow_backward"
    ],
    u: "25c0-fe0f"
  },
  {
    n: [
      "black left-pointing double triangle",
      "rewind"
    ],
    u: "23ea"
  },
  {
    n: [
      "black_left_pointing_double_triangle_with_vertical_bar"
    ],
    u: "23ee-fe0f"
  },
  {
    n: [
      "up-pointing small red triangle",
      "arrow_up_small"
    ],
    u: "1f53c"
  },
  {
    n: [
      "black up-pointing double triangle",
      "arrow_double_up"
    ],
    u: "23eb"
  },
  {
    n: [
      "down-pointing small red triangle",
      "arrow_down_small"
    ],
    u: "1f53d"
  },
  {
    n: [
      "black down-pointing double triangle",
      "arrow_double_down"
    ],
    u: "23ec"
  },
  {
    n: [
      "double_vertical_bar"
    ],
    u: "23f8-fe0f"
  },
  {
    n: [
      "black_square_for_stop"
    ],
    u: "23f9-fe0f"
  },
  {
    n: [
      "black_circle_for_record"
    ],
    u: "23fa-fe0f"
  },
  {
    n: [
      "eject"
    ],
    u: "23cf-fe0f"
  },
  {
    n: [
      "cinema"
    ],
    u: "1f3a6"
  },
  {
    n: [
      "low brightness symbol",
      "low_brightness"
    ],
    u: "1f505"
  },
  {
    n: [
      "high brightness symbol",
      "high_brightness"
    ],
    u: "1f506"
  },
  {
    n: [
      "antenna with bars",
      "signal_strength"
    ],
    u: "1f4f6"
  },
  {
    n: [
      "vibration mode",
      "vibration_mode"
    ],
    u: "1f4f3"
  },
  {
    n: [
      "mobile phone off",
      "mobile_phone_off"
    ],
    u: "1f4f4"
  },
  {
    n: [
      "female_sign"
    ],
    u: "2640-fe0f"
  },
  {
    n: [
      "male_sign"
    ],
    u: "2642-fe0f"
  },
  {
    n: [
      "medical_symbol",
      "staff_of_aesculapius"
    ],
    u: "2695-fe0f"
  },
  {
    n: [
      "black universal recycling symbol",
      "recycle"
    ],
    u: "267b-fe0f"
  },
  {
    n: [
      "fleur_de_lis"
    ],
    u: "269c-fe0f"
  },
  {
    n: [
      "trident emblem",
      "trident"
    ],
    u: "1f531"
  },
  {
    n: [
      "name badge",
      "name_badge"
    ],
    u: "1f4db"
  },
  {
    n: [
      "japanese symbol for beginner",
      "beginner"
    ],
    u: "1f530"
  },
  {
    n: [
      "heavy large circle",
      "o"
    ],
    u: "2b55"
  },
  {
    n: [
      "white heavy check mark",
      "white_check_mark"
    ],
    u: "2705"
  },
  {
    n: [
      "ballot box with check",
      "ballot_box_with_check"
    ],
    u: "2611-fe0f"
  },
  {
    n: [
      "heavy check mark",
      "heavy_check_mark"
    ],
    u: "2714-fe0f"
  },
  {
    n: [
      "heavy multiplication x",
      "heavy_multiplication_x"
    ],
    u: "2716-fe0f"
  },
  {
    n: [
      "cross mark",
      "x"
    ],
    u: "274c"
  },
  {
    n: [
      "negative squared cross mark",
      "negative_squared_cross_mark"
    ],
    u: "274e"
  },
  {
    n: [
      "heavy plus sign",
      "heavy_plus_sign"
    ],
    u: "2795"
  },
  {
    n: [
      "heavy minus sign",
      "heavy_minus_sign"
    ],
    u: "2796"
  },
  {
    n: [
      "heavy division sign",
      "heavy_division_sign"
    ],
    u: "2797"
  },
  {
    n: [
      "curly loop",
      "curly_loop"
    ],
    u: "27b0"
  },
  {
    n: [
      "double curly loop",
      "loop"
    ],
    u: "27bf"
  },
  {
    n: [
      "part alternation mark",
      "part_alternation_mark"
    ],
    u: "303d-fe0f"
  },
  {
    n: [
      "eight spoked asterisk",
      "eight_spoked_asterisk"
    ],
    u: "2733-fe0f"
  },
  {
    n: [
      "eight pointed black star",
      "eight_pointed_black_star"
    ],
    u: "2734-fe0f"
  },
  {
    n: [
      "sparkle"
    ],
    u: "2747-fe0f"
  },
  {
    n: [
      "double exclamation mark",
      "bangbang"
    ],
    u: "203c-fe0f"
  },
  {
    n: [
      "exclamation question mark",
      "interrobang"
    ],
    u: "2049-fe0f"
  },
  {
    n: [
      "black question mark ornament",
      "question"
    ],
    u: "2753"
  },
  {
    n: [
      "white question mark ornament",
      "grey_question"
    ],
    u: "2754"
  },
  {
    n: [
      "white exclamation mark ornament",
      "grey_exclamation"
    ],
    u: "2755"
  },
  {
    n: [
      "heavy exclamation mark symbol",
      "exclamation",
      "heavy_exclamation_mark"
    ],
    u: "2757"
  },
  {
    n: [
      "wavy dash",
      "wavy_dash"
    ],
    u: "3030-fe0f"
  },
  {
    n: [
      "copyright sign",
      "copyright"
    ],
    u: "00a9-fe0f"
  },
  {
    n: [
      "registered sign",
      "registered"
    ],
    u: "00ae-fe0f"
  },
  {
    n: [
      "trade mark sign",
      "tm"
    ],
    u: "2122-fe0f"
  },
  {
    n: [
      "hash key",
      "hash"
    ],
    u: "0023-fe0f-20e3"
  },
  {
    n: [
      "keycap_star"
    ],
    u: "002a-fe0f-20e3"
  },
  {
    n: [
      "keycap 0",
      "zero"
    ],
    u: "0030-fe0f-20e3"
  },
  {
    n: [
      "keycap 1",
      "one"
    ],
    u: "0031-fe0f-20e3"
  },
  {
    n: [
      "keycap 2",
      "two"
    ],
    u: "0032-fe0f-20e3"
  },
  {
    n: [
      "keycap 3",
      "three"
    ],
    u: "0033-fe0f-20e3"
  },
  {
    n: [
      "keycap 4",
      "four"
    ],
    u: "0034-fe0f-20e3"
  },
  {
    n: [
      "keycap 5",
      "five"
    ],
    u: "0035-fe0f-20e3"
  },
  {
    n: [
      "keycap 6",
      "six"
    ],
    u: "0036-fe0f-20e3"
  },
  {
    n: [
      "keycap 7",
      "seven"
    ],
    u: "0037-fe0f-20e3"
  },
  {
    n: [
      "keycap 8",
      "eight"
    ],
    u: "0038-fe0f-20e3"
  },
  {
    n: [
      "keycap 9",
      "nine"
    ],
    u: "0039-fe0f-20e3"
  },
  {
    n: [
      "keycap ten",
      "keycap_ten"
    ],
    u: "1f51f"
  },
  {
    n: [
      "hundred points symbol",
      "100"
    ],
    u: "1f4af"
  },
  {
    n: [
      "input symbol for latin capital letters",
      "capital_abcd"
    ],
    u: "1f520"
  },
  {
    n: [
      "input symbol for latin small letters",
      "abcd"
    ],
    u: "1f521"
  },
  {
    n: [
      "input symbol for numbers",
      "1234"
    ],
    u: "1f522"
  },
  {
    n: [
      "input symbol for symbols",
      "symbols"
    ],
    u: "1f523"
  },
  {
    n: [
      "input symbol for latin letters",
      "abc"
    ],
    u: "1f524"
  },
  {
    n: [
      "negative squared latin capital letter a",
      "a"
    ],
    u: "1f170-fe0f"
  },
  {
    n: [
      "negative squared ab",
      "ab"
    ],
    u: "1f18e"
  },
  {
    n: [
      "negative squared latin capital letter b",
      "b"
    ],
    u: "1f171-fe0f"
  },
  {
    n: [
      "squared cl",
      "cl"
    ],
    u: "1f191"
  },
  {
    n: [
      "squared cool",
      "cool"
    ],
    u: "1f192"
  },
  {
    n: [
      "squared free",
      "free"
    ],
    u: "1f193"
  },
  {
    n: [
      "information source",
      "information_source"
    ],
    u: "2139-fe0f"
  },
  {
    n: [
      "squared id",
      "id"
    ],
    u: "1f194"
  },
  {
    n: [
      "circled latin capital letter m",
      "m"
    ],
    u: "24c2-fe0f"
  },
  {
    n: [
      "squared new",
      "new"
    ],
    u: "1f195"
  },
  {
    n: [
      "squared ng",
      "ng"
    ],
    u: "1f196"
  },
  {
    n: [
      "negative squared latin capital letter o",
      "o2"
    ],
    u: "1f17e-fe0f"
  },
  {
    n: [
      "squared ok",
      "ok"
    ],
    u: "1f197"
  },
  {
    n: [
      "negative squared latin capital letter p",
      "parking"
    ],
    u: "1f17f-fe0f"
  },
  {
    n: [
      "squared sos",
      "sos"
    ],
    u: "1f198"
  },
  {
    n: [
      "squared up with exclamation mark",
      "up"
    ],
    u: "1f199"
  },
  {
    n: [
      "squared vs",
      "vs"
    ],
    u: "1f19a"
  },
  {
    n: [
      "squared katakana koko",
      "koko"
    ],
    u: "1f201"
  },
  {
    n: [
      "squared katakana sa",
      "sa"
    ],
    u: "1f202-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-6708",
      "u6708"
    ],
    u: "1f237-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-6709",
      "u6709"
    ],
    u: "1f236"
  },
  {
    n: [
      "squared cjk unified ideograph-6307",
      "u6307"
    ],
    u: "1f22f"
  },
  {
    n: [
      "circled ideograph advantage",
      "ideograph_advantage"
    ],
    u: "1f250"
  },
  {
    n: [
      "squared cjk unified ideograph-5272",
      "u5272"
    ],
    u: "1f239"
  },
  {
    n: [
      "squared cjk unified ideograph-7121",
      "u7121"
    ],
    u: "1f21a"
  },
  {
    n: [
      "squared cjk unified ideograph-7981",
      "u7981"
    ],
    u: "1f232"
  },
  {
    n: [
      "circled ideograph accept",
      "accept"
    ],
    u: "1f251"
  },
  {
    n: [
      "squared cjk unified ideograph-7533",
      "u7533"
    ],
    u: "1f238"
  },
  {
    n: [
      "squared cjk unified ideograph-5408",
      "u5408"
    ],
    u: "1f234"
  },
  {
    n: [
      "squared cjk unified ideograph-7a7a",
      "u7a7a"
    ],
    u: "1f233"
  },
  {
    n: [
      "circled ideograph congratulation",
      "congratulations"
    ],
    u: "3297-fe0f"
  },
  {
    n: [
      "circled ideograph secret",
      "secret"
    ],
    u: "3299-fe0f"
  },
  {
    n: [
      "squared cjk unified ideograph-55b6",
      "u55b6"
    ],
    u: "1f23a"
  },
  {
    n: [
      "squared cjk unified ideograph-6e80",
      "u6e80"
    ],
    u: "1f235"
  },
  {
    n: [
      "black small square",
      "black_small_square"
    ],
    u: "25aa-fe0f"
  },
  {
    n: [
      "white small square",
      "white_small_square"
    ],
    u: "25ab-fe0f"
  },
  {
    n: [
      "white medium square",
      "white_medium_square"
    ],
    u: "25fb-fe0f"
  },
  {
    n: [
      "black medium square",
      "black_medium_square"
    ],
    u: "25fc-fe0f"
  },
  {
    n: [
      "white medium small square",
      "white_medium_small_square"
    ],
    u: "25fd"
  },
  {
    n: [
      "black medium small square",
      "black_medium_small_square"
    ],
    u: "25fe"
  },
  {
    n: [
      "black large square",
      "black_large_square"
    ],
    u: "2b1b"
  },
  {
    n: [
      "white large square",
      "white_large_square"
    ],
    u: "2b1c"
  },
  {
    n: [
      "large orange diamond",
      "large_orange_diamond"
    ],
    u: "1f536"
  },
  {
    n: [
      "large blue diamond",
      "large_blue_diamond"
    ],
    u: "1f537"
  },
  {
    n: [
      "small orange diamond",
      "small_orange_diamond"
    ],
    u: "1f538"
  },
  {
    n: [
      "small blue diamond",
      "small_blue_diamond"
    ],
    u: "1f539"
  },
  {
    n: [
      "up-pointing red triangle",
      "small_red_triangle"
    ],
    u: "1f53a"
  },
  {
    n: [
      "down-pointing red triangle",
      "small_red_triangle_down"
    ],
    u: "1f53b"
  },
  {
    n: [
      "diamond shape with a dot inside",
      "diamond_shape_with_a_dot_inside"
    ],
    u: "1f4a0"
  },
  {
    n: [
      "radio button",
      "radio_button"
    ],
    u: "1f518"
  },
  {
    n: [
      "black square button",
      "black_square_button"
    ],
    u: "1f532"
  },
  {
    n: [
      "white square button",
      "white_square_button"
    ],
    u: "1f533"
  },
  {
    n: [
      "medium white circle",
      "white_circle"
    ],
    u: "26aa"
  },
  {
    n: [
      "medium black circle",
      "black_circle"
    ],
    u: "26ab"
  },
  {
    n: [
      "large red circle",
      "red_circle"
    ],
    u: "1f534"
  },
  {
    n: [
      "large blue circle",
      "large_blue_circle"
    ],
    u: "1f535"
  }
], r9e = [
  {
    n: [
      "chequered flag",
      "checkered_flag"
    ],
    u: "1f3c1"
  },
  {
    n: [
      "triangular flag on post",
      "triangular_flag_on_post"
    ],
    u: "1f6a9"
  },
  {
    n: [
      "crossed flags",
      "crossed_flags"
    ],
    u: "1f38c"
  },
  {
    n: [
      "waving black flag",
      "waving_black_flag"
    ],
    u: "1f3f4"
  },
  {
    n: [
      "waving_white_flag"
    ],
    u: "1f3f3-fe0f"
  },
  {
    n: [
      "rainbow-flag"
    ],
    u: "1f3f3-fe0f-200d-1f308"
  },
  {
    n: [
      "ascension island flag",
      "flag-ac"
    ],
    u: "1f1e6-1f1e8"
  },
  {
    n: [
      "andorra flag",
      "flag-ad"
    ],
    u: "1f1e6-1f1e9"
  },
  {
    n: [
      "united arab emirates flag",
      "flag-ae"
    ],
    u: "1f1e6-1f1ea"
  },
  {
    n: [
      "afghanistan flag",
      "flag-af"
    ],
    u: "1f1e6-1f1eb"
  },
  {
    n: [
      "antigua & barbuda flag",
      "flag-ag"
    ],
    u: "1f1e6-1f1ec"
  },
  {
    n: [
      "anguilla flag",
      "flag-ai"
    ],
    u: "1f1e6-1f1ee"
  },
  {
    n: [
      "albania flag",
      "flag-al"
    ],
    u: "1f1e6-1f1f1"
  },
  {
    n: [
      "armenia flag",
      "flag-am"
    ],
    u: "1f1e6-1f1f2"
  },
  {
    n: [
      "angola flag",
      "flag-ao"
    ],
    u: "1f1e6-1f1f4"
  },
  {
    n: [
      "antarctica flag",
      "flag-aq"
    ],
    u: "1f1e6-1f1f6"
  },
  {
    n: [
      "argentina flag",
      "flag-ar"
    ],
    u: "1f1e6-1f1f7"
  },
  {
    n: [
      "american samoa flag",
      "flag-as"
    ],
    u: "1f1e6-1f1f8"
  },
  {
    n: [
      "austria flag",
      "flag-at"
    ],
    u: "1f1e6-1f1f9"
  },
  {
    n: [
      "australia flag",
      "flag-au"
    ],
    u: "1f1e6-1f1fa"
  },
  {
    n: [
      "aruba flag",
      "flag-aw"
    ],
    u: "1f1e6-1f1fc"
  },
  {
    n: [
      "åland islands flag",
      "flag-ax"
    ],
    u: "1f1e6-1f1fd"
  },
  {
    n: [
      "azerbaijan flag",
      "flag-az"
    ],
    u: "1f1e6-1f1ff"
  },
  {
    n: [
      "bosnia & herzegovina flag",
      "flag-ba"
    ],
    u: "1f1e7-1f1e6"
  },
  {
    n: [
      "barbados flag",
      "flag-bb"
    ],
    u: "1f1e7-1f1e7"
  },
  {
    n: [
      "bangladesh flag",
      "flag-bd"
    ],
    u: "1f1e7-1f1e9"
  },
  {
    n: [
      "belgium flag",
      "flag-be"
    ],
    u: "1f1e7-1f1ea"
  },
  {
    n: [
      "burkina faso flag",
      "flag-bf"
    ],
    u: "1f1e7-1f1eb"
  },
  {
    n: [
      "bulgaria flag",
      "flag-bg"
    ],
    u: "1f1e7-1f1ec"
  },
  {
    n: [
      "bahrain flag",
      "flag-bh"
    ],
    u: "1f1e7-1f1ed"
  },
  {
    n: [
      "burundi flag",
      "flag-bi"
    ],
    u: "1f1e7-1f1ee"
  },
  {
    n: [
      "benin flag",
      "flag-bj"
    ],
    u: "1f1e7-1f1ef"
  },
  {
    n: [
      "st. barthélemy flag",
      "flag-bl"
    ],
    u: "1f1e7-1f1f1"
  },
  {
    n: [
      "bermuda flag",
      "flag-bm"
    ],
    u: "1f1e7-1f1f2"
  },
  {
    n: [
      "brunei flag",
      "flag-bn"
    ],
    u: "1f1e7-1f1f3"
  },
  {
    n: [
      "bolivia flag",
      "flag-bo"
    ],
    u: "1f1e7-1f1f4"
  },
  {
    n: [
      "caribbean netherlands flag",
      "flag-bq"
    ],
    u: "1f1e7-1f1f6"
  },
  {
    n: [
      "brazil flag",
      "flag-br"
    ],
    u: "1f1e7-1f1f7"
  },
  {
    n: [
      "bahamas flag",
      "flag-bs"
    ],
    u: "1f1e7-1f1f8"
  },
  {
    n: [
      "bhutan flag",
      "flag-bt"
    ],
    u: "1f1e7-1f1f9"
  },
  {
    n: [
      "bouvet island flag",
      "flag-bv"
    ],
    u: "1f1e7-1f1fb"
  },
  {
    n: [
      "botswana flag",
      "flag-bw"
    ],
    u: "1f1e7-1f1fc"
  },
  {
    n: [
      "belarus flag",
      "flag-by"
    ],
    u: "1f1e7-1f1fe"
  },
  {
    n: [
      "belize flag",
      "flag-bz"
    ],
    u: "1f1e7-1f1ff"
  },
  {
    n: [
      "canada flag",
      "flag-ca"
    ],
    u: "1f1e8-1f1e6"
  },
  {
    n: [
      "cocos (keeling) islands flag",
      "flag-cc"
    ],
    u: "1f1e8-1f1e8"
  },
  {
    n: [
      "congo - kinshasa flag",
      "flag-cd"
    ],
    u: "1f1e8-1f1e9"
  },
  {
    n: [
      "central african republic flag",
      "flag-cf"
    ],
    u: "1f1e8-1f1eb"
  },
  {
    n: [
      "congo - brazzaville flag",
      "flag-cg"
    ],
    u: "1f1e8-1f1ec"
  },
  {
    n: [
      "switzerland flag",
      "flag-ch"
    ],
    u: "1f1e8-1f1ed"
  },
  {
    n: [
      "côte d’ivoire flag",
      "flag-ci"
    ],
    u: "1f1e8-1f1ee"
  },
  {
    n: [
      "cook islands flag",
      "flag-ck"
    ],
    u: "1f1e8-1f1f0"
  },
  {
    n: [
      "chile flag",
      "flag-cl"
    ],
    u: "1f1e8-1f1f1"
  },
  {
    n: [
      "cameroon flag",
      "flag-cm"
    ],
    u: "1f1e8-1f1f2"
  },
  {
    n: [
      "china flag",
      "cn",
      "flag-cn"
    ],
    u: "1f1e8-1f1f3"
  },
  {
    n: [
      "colombia flag",
      "flag-co"
    ],
    u: "1f1e8-1f1f4"
  },
  {
    n: [
      "clipperton island flag",
      "flag-cp"
    ],
    u: "1f1e8-1f1f5"
  },
  {
    n: [
      "costa rica flag",
      "flag-cr"
    ],
    u: "1f1e8-1f1f7"
  },
  {
    n: [
      "cuba flag",
      "flag-cu"
    ],
    u: "1f1e8-1f1fa"
  },
  {
    n: [
      "cape verde flag",
      "flag-cv"
    ],
    u: "1f1e8-1f1fb"
  },
  {
    n: [
      "curaçao flag",
      "flag-cw"
    ],
    u: "1f1e8-1f1fc"
  },
  {
    n: [
      "christmas island flag",
      "flag-cx"
    ],
    u: "1f1e8-1f1fd"
  },
  {
    n: [
      "cyprus flag",
      "flag-cy"
    ],
    u: "1f1e8-1f1fe"
  },
  {
    n: [
      "czechia flag",
      "flag-cz"
    ],
    u: "1f1e8-1f1ff"
  },
  {
    n: [
      "germany flag",
      "de",
      "flag-de"
    ],
    u: "1f1e9-1f1ea"
  },
  {
    n: [
      "diego garcia flag",
      "flag-dg"
    ],
    u: "1f1e9-1f1ec"
  },
  {
    n: [
      "djibouti flag",
      "flag-dj"
    ],
    u: "1f1e9-1f1ef"
  },
  {
    n: [
      "denmark flag",
      "flag-dk"
    ],
    u: "1f1e9-1f1f0"
  },
  {
    n: [
      "dominica flag",
      "flag-dm"
    ],
    u: "1f1e9-1f1f2"
  },
  {
    n: [
      "dominican republic flag",
      "flag-do"
    ],
    u: "1f1e9-1f1f4"
  },
  {
    n: [
      "algeria flag",
      "flag-dz"
    ],
    u: "1f1e9-1f1ff"
  },
  {
    n: [
      "ceuta & melilla flag",
      "flag-ea"
    ],
    u: "1f1ea-1f1e6"
  },
  {
    n: [
      "ecuador flag",
      "flag-ec"
    ],
    u: "1f1ea-1f1e8"
  },
  {
    n: [
      "estonia flag",
      "flag-ee"
    ],
    u: "1f1ea-1f1ea"
  },
  {
    n: [
      "egypt flag",
      "flag-eg"
    ],
    u: "1f1ea-1f1ec"
  },
  {
    n: [
      "western sahara flag",
      "flag-eh"
    ],
    u: "1f1ea-1f1ed"
  },
  {
    n: [
      "eritrea flag",
      "flag-er"
    ],
    u: "1f1ea-1f1f7"
  },
  {
    n: [
      "spain flag",
      "es",
      "flag-es"
    ],
    u: "1f1ea-1f1f8"
  },
  {
    n: [
      "ethiopia flag",
      "flag-et"
    ],
    u: "1f1ea-1f1f9"
  },
  {
    n: [
      "european union flag",
      "flag-eu"
    ],
    u: "1f1ea-1f1fa"
  },
  {
    n: [
      "finland flag",
      "flag-fi"
    ],
    u: "1f1eb-1f1ee"
  },
  {
    n: [
      "fiji flag",
      "flag-fj"
    ],
    u: "1f1eb-1f1ef"
  },
  {
    n: [
      "falkland islands flag",
      "flag-fk"
    ],
    u: "1f1eb-1f1f0"
  },
  {
    n: [
      "micronesia flag",
      "flag-fm"
    ],
    u: "1f1eb-1f1f2"
  },
  {
    n: [
      "faroe islands flag",
      "flag-fo"
    ],
    u: "1f1eb-1f1f4"
  },
  {
    n: [
      "france flag",
      "fr",
      "flag-fr"
    ],
    u: "1f1eb-1f1f7"
  },
  {
    n: [
      "gabon flag",
      "flag-ga"
    ],
    u: "1f1ec-1f1e6"
  },
  {
    n: [
      "united kingdom flag",
      "gb",
      "uk",
      "flag-gb"
    ],
    u: "1f1ec-1f1e7"
  },
  {
    n: [
      "grenada flag",
      "flag-gd"
    ],
    u: "1f1ec-1f1e9"
  },
  {
    n: [
      "georgia flag",
      "flag-ge"
    ],
    u: "1f1ec-1f1ea"
  },
  {
    n: [
      "french guiana flag",
      "flag-gf"
    ],
    u: "1f1ec-1f1eb"
  },
  {
    n: [
      "guernsey flag",
      "flag-gg"
    ],
    u: "1f1ec-1f1ec"
  },
  {
    n: [
      "ghana flag",
      "flag-gh"
    ],
    u: "1f1ec-1f1ed"
  },
  {
    n: [
      "gibraltar flag",
      "flag-gi"
    ],
    u: "1f1ec-1f1ee"
  },
  {
    n: [
      "greenland flag",
      "flag-gl"
    ],
    u: "1f1ec-1f1f1"
  },
  {
    n: [
      "gambia flag",
      "flag-gm"
    ],
    u: "1f1ec-1f1f2"
  },
  {
    n: [
      "guinea flag",
      "flag-gn"
    ],
    u: "1f1ec-1f1f3"
  },
  {
    n: [
      "guadeloupe flag",
      "flag-gp"
    ],
    u: "1f1ec-1f1f5"
  },
  {
    n: [
      "equatorial guinea flag",
      "flag-gq"
    ],
    u: "1f1ec-1f1f6"
  },
  {
    n: [
      "greece flag",
      "flag-gr"
    ],
    u: "1f1ec-1f1f7"
  },
  {
    n: [
      "south georgia & south sandwich islands flag",
      "flag-gs"
    ],
    u: "1f1ec-1f1f8"
  },
  {
    n: [
      "guatemala flag",
      "flag-gt"
    ],
    u: "1f1ec-1f1f9"
  },
  {
    n: [
      "guam flag",
      "flag-gu"
    ],
    u: "1f1ec-1f1fa"
  },
  {
    n: [
      "guinea-bissau flag",
      "flag-gw"
    ],
    u: "1f1ec-1f1fc"
  },
  {
    n: [
      "guyana flag",
      "flag-gy"
    ],
    u: "1f1ec-1f1fe"
  },
  {
    n: [
      "hong kong sar china flag",
      "flag-hk"
    ],
    u: "1f1ed-1f1f0"
  },
  {
    n: [
      "heard & mcdonald islands flag",
      "flag-hm"
    ],
    u: "1f1ed-1f1f2"
  },
  {
    n: [
      "honduras flag",
      "flag-hn"
    ],
    u: "1f1ed-1f1f3"
  },
  {
    n: [
      "croatia flag",
      "flag-hr"
    ],
    u: "1f1ed-1f1f7"
  },
  {
    n: [
      "haiti flag",
      "flag-ht"
    ],
    u: "1f1ed-1f1f9"
  },
  {
    n: [
      "hungary flag",
      "flag-hu"
    ],
    u: "1f1ed-1f1fa"
  },
  {
    n: [
      "canary islands flag",
      "flag-ic"
    ],
    u: "1f1ee-1f1e8"
  },
  {
    n: [
      "indonesia flag",
      "flag-id"
    ],
    u: "1f1ee-1f1e9"
  },
  {
    n: [
      "ireland flag",
      "flag-ie"
    ],
    u: "1f1ee-1f1ea"
  },
  {
    n: [
      "israel flag",
      "flag-il"
    ],
    u: "1f1ee-1f1f1"
  },
  {
    n: [
      "isle of man flag",
      "flag-im"
    ],
    u: "1f1ee-1f1f2"
  },
  {
    n: [
      "india flag",
      "flag-in"
    ],
    u: "1f1ee-1f1f3"
  },
  {
    n: [
      "british indian ocean territory flag",
      "flag-io"
    ],
    u: "1f1ee-1f1f4"
  },
  {
    n: [
      "iraq flag",
      "flag-iq"
    ],
    u: "1f1ee-1f1f6"
  },
  {
    n: [
      "iran flag",
      "flag-ir"
    ],
    u: "1f1ee-1f1f7"
  },
  {
    n: [
      "iceland flag",
      "flag-is"
    ],
    u: "1f1ee-1f1f8"
  },
  {
    n: [
      "italy flag",
      "it",
      "flag-it"
    ],
    u: "1f1ee-1f1f9"
  },
  {
    n: [
      "jersey flag",
      "flag-je"
    ],
    u: "1f1ef-1f1ea"
  },
  {
    n: [
      "jamaica flag",
      "flag-jm"
    ],
    u: "1f1ef-1f1f2"
  },
  {
    n: [
      "jordan flag",
      "flag-jo"
    ],
    u: "1f1ef-1f1f4"
  },
  {
    n: [
      "japan flag",
      "jp",
      "flag-jp"
    ],
    u: "1f1ef-1f1f5"
  },
  {
    n: [
      "kenya flag",
      "flag-ke"
    ],
    u: "1f1f0-1f1ea"
  },
  {
    n: [
      "kyrgyzstan flag",
      "flag-kg"
    ],
    u: "1f1f0-1f1ec"
  },
  {
    n: [
      "cambodia flag",
      "flag-kh"
    ],
    u: "1f1f0-1f1ed"
  },
  {
    n: [
      "kiribati flag",
      "flag-ki"
    ],
    u: "1f1f0-1f1ee"
  },
  {
    n: [
      "comoros flag",
      "flag-km"
    ],
    u: "1f1f0-1f1f2"
  },
  {
    n: [
      "st. kitts & nevis flag",
      "flag-kn"
    ],
    u: "1f1f0-1f1f3"
  },
  {
    n: [
      "north korea flag",
      "flag-kp"
    ],
    u: "1f1f0-1f1f5"
  },
  {
    n: [
      "south korea flag",
      "kr",
      "flag-kr"
    ],
    u: "1f1f0-1f1f7"
  },
  {
    n: [
      "kuwait flag",
      "flag-kw"
    ],
    u: "1f1f0-1f1fc"
  },
  {
    n: [
      "cayman islands flag",
      "flag-ky"
    ],
    u: "1f1f0-1f1fe"
  },
  {
    n: [
      "kazakhstan flag",
      "flag-kz"
    ],
    u: "1f1f0-1f1ff"
  },
  {
    n: [
      "laos flag",
      "flag-la"
    ],
    u: "1f1f1-1f1e6"
  },
  {
    n: [
      "lebanon flag",
      "flag-lb"
    ],
    u: "1f1f1-1f1e7"
  },
  {
    n: [
      "st. lucia flag",
      "flag-lc"
    ],
    u: "1f1f1-1f1e8"
  },
  {
    n: [
      "liechtenstein flag",
      "flag-li"
    ],
    u: "1f1f1-1f1ee"
  },
  {
    n: [
      "sri lanka flag",
      "flag-lk"
    ],
    u: "1f1f1-1f1f0"
  },
  {
    n: [
      "liberia flag",
      "flag-lr"
    ],
    u: "1f1f1-1f1f7"
  },
  {
    n: [
      "lesotho flag",
      "flag-ls"
    ],
    u: "1f1f1-1f1f8"
  },
  {
    n: [
      "lithuania flag",
      "flag-lt"
    ],
    u: "1f1f1-1f1f9"
  },
  {
    n: [
      "luxembourg flag",
      "flag-lu"
    ],
    u: "1f1f1-1f1fa"
  },
  {
    n: [
      "latvia flag",
      "flag-lv"
    ],
    u: "1f1f1-1f1fb"
  },
  {
    n: [
      "libya flag",
      "flag-ly"
    ],
    u: "1f1f1-1f1fe"
  },
  {
    n: [
      "morocco flag",
      "flag-ma"
    ],
    u: "1f1f2-1f1e6"
  },
  {
    n: [
      "monaco flag",
      "flag-mc"
    ],
    u: "1f1f2-1f1e8"
  },
  {
    n: [
      "moldova flag",
      "flag-md"
    ],
    u: "1f1f2-1f1e9"
  },
  {
    n: [
      "montenegro flag",
      "flag-me"
    ],
    u: "1f1f2-1f1ea"
  },
  {
    n: [
      "st. martin flag",
      "flag-mf"
    ],
    u: "1f1f2-1f1eb"
  },
  {
    n: [
      "madagascar flag",
      "flag-mg"
    ],
    u: "1f1f2-1f1ec"
  },
  {
    n: [
      "marshall islands flag",
      "flag-mh"
    ],
    u: "1f1f2-1f1ed"
  },
  {
    n: [
      "macedonia flag",
      "flag-mk"
    ],
    u: "1f1f2-1f1f0"
  },
  {
    n: [
      "mali flag",
      "flag-ml"
    ],
    u: "1f1f2-1f1f1"
  },
  {
    n: [
      "myanmar (burma) flag",
      "flag-mm"
    ],
    u: "1f1f2-1f1f2"
  },
  {
    n: [
      "mongolia flag",
      "flag-mn"
    ],
    u: "1f1f2-1f1f3"
  },
  {
    n: [
      "macau sar china flag",
      "flag-mo"
    ],
    u: "1f1f2-1f1f4"
  },
  {
    n: [
      "northern mariana islands flag",
      "flag-mp"
    ],
    u: "1f1f2-1f1f5"
  },
  {
    n: [
      "martinique flag",
      "flag-mq"
    ],
    u: "1f1f2-1f1f6"
  },
  {
    n: [
      "mauritania flag",
      "flag-mr"
    ],
    u: "1f1f2-1f1f7"
  },
  {
    n: [
      "montserrat flag",
      "flag-ms"
    ],
    u: "1f1f2-1f1f8"
  },
  {
    n: [
      "malta flag",
      "flag-mt"
    ],
    u: "1f1f2-1f1f9"
  },
  {
    n: [
      "mauritius flag",
      "flag-mu"
    ],
    u: "1f1f2-1f1fa"
  },
  {
    n: [
      "maldives flag",
      "flag-mv"
    ],
    u: "1f1f2-1f1fb"
  },
  {
    n: [
      "malawi flag",
      "flag-mw"
    ],
    u: "1f1f2-1f1fc"
  },
  {
    n: [
      "mexico flag",
      "flag-mx"
    ],
    u: "1f1f2-1f1fd"
  },
  {
    n: [
      "malaysia flag",
      "flag-my"
    ],
    u: "1f1f2-1f1fe"
  },
  {
    n: [
      "mozambique flag",
      "flag-mz"
    ],
    u: "1f1f2-1f1ff"
  },
  {
    n: [
      "namibia flag",
      "flag-na"
    ],
    u: "1f1f3-1f1e6"
  },
  {
    n: [
      "new caledonia flag",
      "flag-nc"
    ],
    u: "1f1f3-1f1e8"
  },
  {
    n: [
      "niger flag",
      "flag-ne"
    ],
    u: "1f1f3-1f1ea"
  },
  {
    n: [
      "norfolk island flag",
      "flag-nf"
    ],
    u: "1f1f3-1f1eb"
  },
  {
    n: [
      "nigeria flag",
      "flag-ng"
    ],
    u: "1f1f3-1f1ec"
  },
  {
    n: [
      "nicaragua flag",
      "flag-ni"
    ],
    u: "1f1f3-1f1ee"
  },
  {
    n: [
      "netherlands flag",
      "flag-nl"
    ],
    u: "1f1f3-1f1f1"
  },
  {
    n: [
      "norway flag",
      "flag-no"
    ],
    u: "1f1f3-1f1f4"
  },
  {
    n: [
      "nepal flag",
      "flag-np"
    ],
    u: "1f1f3-1f1f5"
  },
  {
    n: [
      "nauru flag",
      "flag-nr"
    ],
    u: "1f1f3-1f1f7"
  },
  {
    n: [
      "niue flag",
      "flag-nu"
    ],
    u: "1f1f3-1f1fa"
  },
  {
    n: [
      "new zealand flag",
      "flag-nz"
    ],
    u: "1f1f3-1f1ff"
  },
  {
    n: [
      "oman flag",
      "flag-om"
    ],
    u: "1f1f4-1f1f2"
  },
  {
    n: [
      "panama flag",
      "flag-pa"
    ],
    u: "1f1f5-1f1e6"
  },
  {
    n: [
      "peru flag",
      "flag-pe"
    ],
    u: "1f1f5-1f1ea"
  },
  {
    n: [
      "french polynesia flag",
      "flag-pf"
    ],
    u: "1f1f5-1f1eb"
  },
  {
    n: [
      "papua new guinea flag",
      "flag-pg"
    ],
    u: "1f1f5-1f1ec"
  },
  {
    n: [
      "philippines flag",
      "flag-ph"
    ],
    u: "1f1f5-1f1ed"
  },
  {
    n: [
      "pakistan flag",
      "flag-pk"
    ],
    u: "1f1f5-1f1f0"
  },
  {
    n: [
      "poland flag",
      "flag-pl"
    ],
    u: "1f1f5-1f1f1"
  },
  {
    n: [
      "st. pierre & miquelon flag",
      "flag-pm"
    ],
    u: "1f1f5-1f1f2"
  },
  {
    n: [
      "pitcairn islands flag",
      "flag-pn"
    ],
    u: "1f1f5-1f1f3"
  },
  {
    n: [
      "puerto rico flag",
      "flag-pr"
    ],
    u: "1f1f5-1f1f7"
  },
  {
    n: [
      "palestinian territories flag",
      "flag-ps"
    ],
    u: "1f1f5-1f1f8"
  },
  {
    n: [
      "portugal flag",
      "flag-pt"
    ],
    u: "1f1f5-1f1f9"
  },
  {
    n: [
      "palau flag",
      "flag-pw"
    ],
    u: "1f1f5-1f1fc"
  },
  {
    n: [
      "paraguay flag",
      "flag-py"
    ],
    u: "1f1f5-1f1fe"
  },
  {
    n: [
      "qatar flag",
      "flag-qa"
    ],
    u: "1f1f6-1f1e6"
  },
  {
    n: [
      "réunion flag",
      "flag-re"
    ],
    u: "1f1f7-1f1ea"
  },
  {
    n: [
      "romania flag",
      "flag-ro"
    ],
    u: "1f1f7-1f1f4"
  },
  {
    n: [
      "serbia flag",
      "flag-rs"
    ],
    u: "1f1f7-1f1f8"
  },
  {
    n: [
      "russia flag",
      "ru",
      "flag-ru"
    ],
    u: "1f1f7-1f1fa"
  },
  {
    n: [
      "rwanda flag",
      "flag-rw"
    ],
    u: "1f1f7-1f1fc"
  },
  {
    n: [
      "saudi arabia flag",
      "flag-sa"
    ],
    u: "1f1f8-1f1e6"
  },
  {
    n: [
      "solomon islands flag",
      "flag-sb"
    ],
    u: "1f1f8-1f1e7"
  },
  {
    n: [
      "seychelles flag",
      "flag-sc"
    ],
    u: "1f1f8-1f1e8"
  },
  {
    n: [
      "sudan flag",
      "flag-sd"
    ],
    u: "1f1f8-1f1e9"
  },
  {
    n: [
      "sweden flag",
      "flag-se"
    ],
    u: "1f1f8-1f1ea"
  },
  {
    n: [
      "singapore flag",
      "flag-sg"
    ],
    u: "1f1f8-1f1ec"
  },
  {
    n: [
      "st. helena flag",
      "flag-sh"
    ],
    u: "1f1f8-1f1ed"
  },
  {
    n: [
      "slovenia flag",
      "flag-si"
    ],
    u: "1f1f8-1f1ee"
  },
  {
    n: [
      "svalbard & jan mayen flag",
      "flag-sj"
    ],
    u: "1f1f8-1f1ef"
  },
  {
    n: [
      "slovakia flag",
      "flag-sk"
    ],
    u: "1f1f8-1f1f0"
  },
  {
    n: [
      "sierra leone flag",
      "flag-sl"
    ],
    u: "1f1f8-1f1f1"
  },
  {
    n: [
      "san marino flag",
      "flag-sm"
    ],
    u: "1f1f8-1f1f2"
  },
  {
    n: [
      "senegal flag",
      "flag-sn"
    ],
    u: "1f1f8-1f1f3"
  },
  {
    n: [
      "somalia flag",
      "flag-so"
    ],
    u: "1f1f8-1f1f4"
  },
  {
    n: [
      "suriname flag",
      "flag-sr"
    ],
    u: "1f1f8-1f1f7"
  },
  {
    n: [
      "south sudan flag",
      "flag-ss"
    ],
    u: "1f1f8-1f1f8"
  },
  {
    n: [
      "são tomé & príncipe flag",
      "flag-st"
    ],
    u: "1f1f8-1f1f9"
  },
  {
    n: [
      "el salvador flag",
      "flag-sv"
    ],
    u: "1f1f8-1f1fb"
  },
  {
    n: [
      "sint maarten flag",
      "flag-sx"
    ],
    u: "1f1f8-1f1fd"
  },
  {
    n: [
      "syria flag",
      "flag-sy"
    ],
    u: "1f1f8-1f1fe"
  },
  {
    n: [
      "swaziland flag",
      "flag-sz"
    ],
    u: "1f1f8-1f1ff"
  },
  {
    n: [
      "tristan da cunha flag",
      "flag-ta"
    ],
    u: "1f1f9-1f1e6"
  },
  {
    n: [
      "turks & caicos islands flag",
      "flag-tc"
    ],
    u: "1f1f9-1f1e8"
  },
  {
    n: [
      "chad flag",
      "flag-td"
    ],
    u: "1f1f9-1f1e9"
  },
  {
    n: [
      "french southern territories flag",
      "flag-tf"
    ],
    u: "1f1f9-1f1eb"
  },
  {
    n: [
      "togo flag",
      "flag-tg"
    ],
    u: "1f1f9-1f1ec"
  },
  {
    n: [
      "thailand flag",
      "flag-th"
    ],
    u: "1f1f9-1f1ed"
  },
  {
    n: [
      "tajikistan flag",
      "flag-tj"
    ],
    u: "1f1f9-1f1ef"
  },
  {
    n: [
      "tokelau flag",
      "flag-tk"
    ],
    u: "1f1f9-1f1f0"
  },
  {
    n: [
      "timor-leste flag",
      "flag-tl"
    ],
    u: "1f1f9-1f1f1"
  },
  {
    n: [
      "turkmenistan flag",
      "flag-tm"
    ],
    u: "1f1f9-1f1f2"
  },
  {
    n: [
      "tunisia flag",
      "flag-tn"
    ],
    u: "1f1f9-1f1f3"
  },
  {
    n: [
      "tonga flag",
      "flag-to"
    ],
    u: "1f1f9-1f1f4"
  },
  {
    n: [
      "turkey flag",
      "flag-tr"
    ],
    u: "1f1f9-1f1f7"
  },
  {
    n: [
      "trinidad & tobago flag",
      "flag-tt"
    ],
    u: "1f1f9-1f1f9"
  },
  {
    n: [
      "tuvalu flag",
      "flag-tv"
    ],
    u: "1f1f9-1f1fb"
  },
  {
    n: [
      "taiwan flag",
      "flag-tw"
    ],
    u: "1f1f9-1f1fc"
  },
  {
    n: [
      "tanzania flag",
      "flag-tz"
    ],
    u: "1f1f9-1f1ff"
  },
  {
    n: [
      "ukraine flag",
      "flag-ua"
    ],
    u: "1f1fa-1f1e6"
  },
  {
    n: [
      "uganda flag",
      "flag-ug"
    ],
    u: "1f1fa-1f1ec"
  },
  {
    n: [
      "u.s. outlying islands flag",
      "flag-um"
    ],
    u: "1f1fa-1f1f2"
  },
  {
    n: [
      "united nations flag",
      "flag-un"
    ],
    u: "1f1fa-1f1f3"
  },
  {
    n: [
      "united states flag",
      "us",
      "flag-us"
    ],
    u: "1f1fa-1f1f8"
  },
  {
    n: [
      "uruguay flag",
      "flag-uy"
    ],
    u: "1f1fa-1f1fe"
  },
  {
    n: [
      "uzbekistan flag",
      "flag-uz"
    ],
    u: "1f1fa-1f1ff"
  },
  {
    n: [
      "vatican city flag",
      "flag-va"
    ],
    u: "1f1fb-1f1e6"
  },
  {
    n: [
      "st. vincent & grenadines flag",
      "flag-vc"
    ],
    u: "1f1fb-1f1e8"
  },
  {
    n: [
      "venezuela flag",
      "flag-ve"
    ],
    u: "1f1fb-1f1ea"
  },
  {
    n: [
      "british virgin islands flag",
      "flag-vg"
    ],
    u: "1f1fb-1f1ec"
  },
  {
    n: [
      "u.s. virgin islands flag",
      "flag-vi"
    ],
    u: "1f1fb-1f1ee"
  },
  {
    n: [
      "vietnam flag",
      "flag-vn"
    ],
    u: "1f1fb-1f1f3"
  },
  {
    n: [
      "vanuatu flag",
      "flag-vu"
    ],
    u: "1f1fb-1f1fa"
  },
  {
    n: [
      "wallis & futuna flag",
      "flag-wf"
    ],
    u: "1f1fc-1f1eb"
  },
  {
    n: [
      "samoa flag",
      "flag-ws"
    ],
    u: "1f1fc-1f1f8"
  },
  {
    n: [
      "kosovo flag",
      "flag-xk"
    ],
    u: "1f1fd-1f1f0"
  },
  {
    n: [
      "yemen flag",
      "flag-ye"
    ],
    u: "1f1fe-1f1ea"
  },
  {
    n: [
      "mayotte flag",
      "flag-yt"
    ],
    u: "1f1fe-1f1f9"
  },
  {
    n: [
      "south africa flag",
      "flag-za"
    ],
    u: "1f1ff-1f1e6"
  },
  {
    n: [
      "zambia flag",
      "flag-zm"
    ],
    u: "1f1ff-1f1f2"
  },
  {
    n: [
      "zimbabwe flag",
      "flag-zw"
    ],
    u: "1f1ff-1f1fc"
  },
  {
    n: [
      "england flag",
      "flag-england"
    ],
    u: "1f3f4-e0067-e0062-e0065-e006e-e0067-e007f"
  },
  {
    n: [
      "scotland flag",
      "flag-scotland"
    ],
    u: "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f"
  },
  {
    n: [
      "wales flag",
      "flag-wales"
    ],
    u: "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f"
  }
];
var i9e = {
  smileys_people: XNe,
  animals_nature: KNe,
  food_drink: ZNe,
  activities: JNe,
  travel_places: e9e,
  objects: t9e,
  symbols: n9e,
  flags: r9e
}, LC = [
  {
    key: "recent",
    title: "Recently Used",
    u: "1f551"
  },
  {
    key: "smileys_people",
    title: "Smiles & People",
    u: "1f600"
  },
  {
    key: "animals_nature",
    title: "Animals & Nature",
    u: "1F431"
  },
  {
    key: "food_drink",
    title: "Food & Drink",
    u: "2615"
  },
  {
    key: "activities",
    title: "Activities",
    u: "26BD"
  },
  {
    key: "travel_places",
    title: "Travel & Places",
    u: "1F697"
  },
  {
    key: "objects",
    title: "Objects",
    u: "1F4A1"
  },
  {
    key: "symbols",
    title: "Symbols",
    u: "1f4af"
  },
  {
    key: "flags",
    title: "Flags",
    u: "1f3f3-fe0f"
  }
];
const s9e = (t, e) => e.some((n) => t instanceof n);
let PC, RC;
function a9e() {
  return PC || (PC = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function o9e() {
  return RC || (RC = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const wN = /* @__PURE__ */ new WeakMap(), Dy = /* @__PURE__ */ new WeakMap(), CN = /* @__PURE__ */ new WeakMap(), S2 = /* @__PURE__ */ new WeakMap(), p_ = /* @__PURE__ */ new WeakMap();
function u9e(t) {
  const e = new Promise((n, r) => {
    const i = () => {
      t.removeEventListener("success", s), t.removeEventListener("error", a);
    }, s = () => {
      n(Do(t.result)), i();
    }, a = () => {
      r(t.error), i();
    };
    t.addEventListener("success", s), t.addEventListener("error", a);
  });
  return e.then((n) => {
    n instanceof IDBCursor && wN.set(n, t);
  }).catch(() => {
  }), p_.set(e, t), e;
}
function l9e(t) {
  if (Dy.has(t))
    return;
  const e = new Promise((n, r) => {
    const i = () => {
      t.removeEventListener("complete", s), t.removeEventListener("error", a), t.removeEventListener("abort", a);
    }, s = () => {
      n(), i();
    }, a = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), i();
    };
    t.addEventListener("complete", s), t.addEventListener("error", a), t.addEventListener("abort", a);
  });
  Dy.set(t, e);
}
let My = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return Dy.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || CN.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Do(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function c9e(t) {
  My = t(My);
}
function d9e(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(I2(this), e, ...n);
    return CN.set(r, e.sort ? e.sort() : [e]), Do(r);
  } : o9e().includes(t) ? function(...e) {
    return t.apply(I2(this), e), Do(wN.get(this));
  } : function(...e) {
    return Do(t.apply(I2(this), e));
  };
}
function f9e(t) {
  return typeof t == "function" ? d9e(t) : (t instanceof IDBTransaction && l9e(t), s9e(t, a9e()) ? new Proxy(t, My) : t);
}
function Do(t) {
  if (t instanceof IDBRequest)
    return u9e(t);
  if (S2.has(t))
    return S2.get(t);
  const e = f9e(t);
  return e !== t && (S2.set(t, e), p_.set(e, t)), e;
}
const I2 = (t) => p_.get(t);
function m_(t, e, { blocked: n, upgrade: r, blocking: i, terminated: s } = {}) {
  const a = indexedDB.open(t, e), o = Do(a);
  return r && a.addEventListener("upgradeneeded", (u) => {
    r(Do(a.result), u.oldVersion, u.newVersion, Do(a.transaction), u);
  }), n && a.addEventListener("blocked", (u) => n(
    u.oldVersion,
    u.newVersion,
    u
  )), o.then((u) => {
    s && u.addEventListener("close", () => s()), i && u.addEventListener("versionchange", (c) => i(c.oldVersion, c.newVersion, c));
  }).catch(() => {
  }), o;
}
const h9e = ["get", "getKey", "getAll", "getAllKeys", "count"], p9e = ["put", "add", "delete", "clear"], k2 = /* @__PURE__ */ new Map();
function BC(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (k2.get(e))
    return k2.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, i = p9e.includes(n);
  if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || h9e.includes(n)))
    return;
  const s = async function(a, ...o) {
    const u = this.transaction(a, i ? "readwrite" : "readonly");
    let c = u.store;
    return r && (c = c.index(o.shift())), (await Promise.all([
      c[n](...o),
      i && u.done
    ]))[0];
  };
  return k2.set(e, s), s;
}
c9e((t) => ({
  ...t,
  get: (e, n, r) => BC(e, n) || t.get(e, n, r),
  has: (e, n) => !!BC(e, n) || t.has(e, n)
}));
const g_ = "EMJ", Ec = "emojis", A_ = 3;
async function m9e() {
  (await m_(g_, A_, {
    upgrade(e, n) {
      e.objectStoreNames.contains(Ec) || e.createObjectStore(Ec, {
        keyPath: "id",
        autoIncrement: !0
      }).createIndex("id", "id", {
        unique: !0
      });
    }
  })).close();
}
m9e();
const g9e = {
  native: !1,
  hideSearch: !0,
  hideGroupIcons: !1,
  hideGroupNames: !1,
  staticTexts: {},
  disabledGroups: [],
  groupNames: {},
  displayRecent: !1,
  additionalGroups: {},
  groupOrder: [],
  groupIcons: {}
};
async function A9e() {
  return await (await m_(g_, A_)).transaction(Ec, "readonly").objectStore(Ec).getAll();
}
function b9e() {
  const t = ja({
    search: "",
    emoji: HNe,
    activeGroup: "",
    skinTone: I0,
    options: g9e,
    additionalGroups: {},
    recent: [],
    get emojis() {
      return {
        recent: this.recent,
        ...this.options.additionalGroups,
        ...i9e
      };
    },
    get disabled() {
      let l = Array.isArray(this.options.disabledGroups) ? this.options.disabledGroups : [];
      return this.options.displayRecent || (l = ["recent", ...l]), l;
    },
    get groups() {
      return LC.filter(
        (l) => !this.disabled.includes(l.key)
      );
    },
    get orderedGroupKeys() {
      const l = [
        ...this.options.groupOrder,
        ...Object.keys(this.options.additionalGroups),
        ...LC.map((f) => f.key)
      ];
      return [...new Set(l)].filter((f) => !this.disabled.includes(f));
    }
  });
  function e() {
    t.options.displayRecent && r();
  }
  async function n() {
    var l;
    let f = await A9e();
    return Array.isArray(f) && f.length ? f = JSON.parse(((l = f[0]) == null ? void 0 : l.value) || "") : f = [], f;
  }
  function r() {
    n().then((l) => {
      t.recent = l, c();
    });
  }
  const i = (l) => {
    t.search = l;
  }, s = (l) => {
    t.emoji = l;
  }, a = (l) => {
    t.activeGroup = l;
  }, o = (l = I0) => {
    t.skinTone = l;
  }, u = (l) => {
    t.options = Object.assign({}, t.options, l), e();
  };
  async function c() {
    (await m_(g_, A_)).transaction(Ec, "readwrite").objectStore(Ec).put({
      id: 0,
      value: JSON.stringify(t.recent)
    });
  }
  const d = (l) => {
    if (t.options.displayRecent !== !0)
      return;
    const f = t.recent.findIndex((m) => m.u === l.u);
    if (f > 0 && t.recent.splice(f, 1), f === 0)
      return;
    const p = { u: l.u, n: KS(l.n) };
    t.recent = [p, ...t.recent], t.recent.length > 24 && (t.recent.length = 24), c();
  };
  return {
    state: B0(t),
    updateSearch: i,
    updateEmoji: s,
    updateActiveGroup: a,
    updateSkinTone: o,
    updateOptions: u,
    updateSelect: d
  };
}
var Ni = "top", ps = "bottom", ms = "right", Li = "left", b_ = "auto", Mh = [Ni, ps, ms, Li], xc = "start", sh = "end", y9e = "clippingParents", SN = "viewport", $d = "popper", v9e = "reference", FC = /* @__PURE__ */ Mh.reduce(function(t, e) {
  return t.concat([e + "-" + xc, e + "-" + sh]);
}, []), IN = /* @__PURE__ */ [].concat(Mh, [b_]).reduce(function(t, e) {
  return t.concat([e, e + "-" + xc, e + "-" + sh]);
}, []), T9e = "beforeRead", _9e = "read", E9e = "afterRead", x9e = "beforeMain", w9e = "main", C9e = "afterMain", S9e = "beforeWrite", I9e = "write", k9e = "afterWrite", D9e = [T9e, _9e, E9e, x9e, w9e, C9e, S9e, I9e, k9e];
function ga(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function js(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function wc(t) {
  var e = js(t).Element;
  return t instanceof e || t instanceof Element;
}
function cs(t) {
  var e = js(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function kN(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = js(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function M9e(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n];
    !cs(s) || !ga(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(a) {
      var o = i[a];
      o === !1 ? s.removeAttribute(a) : s.setAttribute(a, o === !0 ? "" : o);
    }));
  });
}
function O9e(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var i = e.elements[r], s = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), o = a.reduce(function(u, c) {
        return u[c] = "", u;
      }, {});
      !cs(i) || !ga(i) || (Object.assign(i.style, o), Object.keys(s).forEach(function(u) {
        i.removeAttribute(u);
      }));
    });
  };
}
var N9e = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: M9e,
  effect: O9e,
  requires: ["computeStyles"]
};
function ua(t) {
  return t.split("-")[0];
}
var Ou = Math.max, k0 = Math.min, Cc = Math.round;
function Sc(t, e) {
  e === void 0 && (e = !1);
  var n = t.getBoundingClientRect(), r = 1, i = 1;
  if (cs(t) && e) {
    var s = t.offsetHeight, a = t.offsetWidth;
    a > 0 && (r = Cc(n.width) / a || 1), s > 0 && (i = Cc(n.height) / s || 1);
  }
  return {
    width: n.width / r,
    height: n.height / i,
    top: n.top / i,
    right: n.right / r,
    bottom: n.bottom / i,
    left: n.left / r,
    x: n.left / r,
    y: n.top / i
  };
}
function y_(t) {
  var e = Sc(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: r
  };
}
function DN(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && kN(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Aa(t) {
  return js(t).getComputedStyle(t);
}
function L9e(t) {
  return ["table", "td", "th"].indexOf(ga(t)) >= 0;
}
function Ho(t) {
  return ((wc(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function Xg(t) {
  return ga(t) === "html" ? t : t.assignedSlot || t.parentNode || (kN(t) ? t.host : null) || Ho(t);
}
function UC(t) {
  return !cs(t) || Aa(t).position === "fixed" ? null : t.offsetParent;
}
function P9e(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && cs(t)) {
    var r = Aa(t);
    if (r.position === "fixed")
      return null;
  }
  for (var i = Xg(t); cs(i) && ["html", "body"].indexOf(ga(i)) < 0; ) {
    var s = Aa(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
      return i;
    i = i.parentNode;
  }
  return null;
}
function Oh(t) {
  for (var e = js(t), n = UC(t); n && L9e(n) && Aa(n).position === "static"; )
    n = UC(n);
  return n && (ga(n) === "html" || ga(n) === "body" && Aa(n).position === "static") ? e : n || P9e(t) || e;
}
function v_(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function Ef(t, e, n) {
  return Ou(t, k0(e, n));
}
function R9e(t, e, n) {
  var r = Ef(t, e, n);
  return r > n ? n : r;
}
function MN() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function ON(t) {
  return Object.assign({}, MN(), t);
}
function NN(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var B9e = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, ON(typeof e != "number" ? e : NN(e, Mh));
};
function F9e(t) {
  var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, a = n.modifiersData.popperOffsets, o = ua(n.placement), u = v_(o), c = [Li, ms].indexOf(o) >= 0, d = c ? "height" : "width";
  if (!(!s || !a)) {
    var l = B9e(i.padding, n), f = y_(s), p = u === "y" ? Ni : Li, m = u === "y" ? ps : ms, g = n.rects.reference[d] + n.rects.reference[u] - a[u] - n.rects.popper[d], y = a[u] - n.rects.reference[u], b = Oh(s), E = b ? u === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, v = g / 2 - y / 2, _ = l[p], D = E - f[d] - l[m], S = E / 2 - f[d] / 2 + v, M = Ef(_, S, D), O = u;
    n.modifiersData[r] = (e = {}, e[O] = M, e.centerOffset = M - S, e);
  }
}
function U9e(t) {
  var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || DN(e.elements.popper, i) && (e.elements.arrow = i));
}
var $9e = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: F9e,
  effect: U9e,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ic(t) {
  return t.split("-")[1];
}
var H9e = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function j9e(t) {
  var e = t.x, n = t.y, r = window, i = r.devicePixelRatio || 1;
  return {
    x: Cc(e * i) / i || 0,
    y: Cc(n * i) / i || 0
  };
}
function $C(t) {
  var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, a = t.offsets, o = t.position, u = t.gpuAcceleration, c = t.adaptive, d = t.roundOffsets, l = t.isFixed, f = d === !0 ? j9e(a) : typeof d == "function" ? d(a) : a, p = f.x, m = p === void 0 ? 0 : p, g = f.y, y = g === void 0 ? 0 : g, b = a.hasOwnProperty("x"), E = a.hasOwnProperty("y"), v = Li, _ = Ni, D = window;
  if (c) {
    var S = Oh(n), M = "clientHeight", O = "clientWidth";
    if (S === js(n) && (S = Ho(n), Aa(S).position !== "static" && o === "absolute" && (M = "scrollHeight", O = "scrollWidth")), S = S, i === Ni || (i === Li || i === ms) && s === sh) {
      _ = ps;
      var T = l && D.visualViewport ? D.visualViewport.height : S[M];
      y -= T - r.height, y *= u ? 1 : -1;
    }
    if (i === Li || (i === Ni || i === ps) && s === sh) {
      v = ms;
      var N = l && D.visualViewport ? D.visualViewport.width : S[O];
      m -= N - r.width, m *= u ? 1 : -1;
    }
  }
  var H = Object.assign({
    position: o
  }, c && H9e);
  if (u) {
    var $;
    return Object.assign({}, H, ($ = {}, $[_] = E ? "0" : "", $[v] = b ? "0" : "", $.transform = (D.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + y + "px)" : "translate3d(" + m + "px, " + y + "px, 0)", $));
  }
  return Object.assign({}, H, (e = {}, e[_] = E ? y + "px" : "", e[v] = b ? m + "px" : "", e.transform = "", e));
}
function z9e(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, a = s === void 0 ? !0 : s, o = n.roundOffsets, u = o === void 0 ? !0 : o, c = {
    placement: ua(e.placement),
    variation: Ic(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: i,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, $C(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: a,
    roundOffsets: u
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, $C(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: u
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
var q9e = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: z9e,
  data: {}
}, Wp = {
  passive: !0
};
function V9e(t) {
  var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, a = r.resize, o = a === void 0 ? !0 : a, u = js(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return s && c.forEach(function(d) {
    d.addEventListener("scroll", n.update, Wp);
  }), o && u.addEventListener("resize", n.update, Wp), function() {
    s && c.forEach(function(d) {
      d.removeEventListener("scroll", n.update, Wp);
    }), o && u.removeEventListener("resize", n.update, Wp);
  };
}
var W9e = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: V9e,
  data: {}
}, Q9e = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function xm(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return Q9e[e];
  });
}
var G9e = {
  start: "end",
  end: "start"
};
function HC(t) {
  return t.replace(/start|end/g, function(e) {
    return G9e[e];
  });
}
function T_(t) {
  var e = js(t), n = e.pageXOffset, r = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  };
}
function __(t) {
  return Sc(Ho(t)).left + T_(t).scrollLeft;
}
function Y9e(t) {
  var e = js(t), n = Ho(t), r = e.visualViewport, i = n.clientWidth, s = n.clientHeight, a = 0, o = 0;
  return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, o = r.offsetTop)), {
    width: i,
    height: s,
    x: a + __(t),
    y: o
  };
}
function X9e(t) {
  var e, n = Ho(t), r = T_(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = Ou(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = Ou(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), o = -r.scrollLeft + __(t), u = -r.scrollTop;
  return Aa(i || n).direction === "rtl" && (o += Ou(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: a,
    x: o,
    y: u
  };
}
function E_(t) {
  var e = Aa(t), n = e.overflow, r = e.overflowX, i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function LN(t) {
  return ["html", "body", "#document"].indexOf(ga(t)) >= 0 ? t.ownerDocument.body : cs(t) && E_(t) ? t : LN(Xg(t));
}
function xf(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = LN(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = js(r), a = i ? [s].concat(s.visualViewport || [], E_(r) ? r : []) : r, o = e.concat(a);
  return i ? o : o.concat(xf(Xg(a)));
}
function Oy(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function K9e(t) {
  var e = Sc(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function jC(t, e) {
  return e === SN ? Oy(Y9e(t)) : wc(e) ? K9e(e) : Oy(X9e(Ho(t)));
}
function Z9e(t) {
  var e = xf(Xg(t)), n = ["absolute", "fixed"].indexOf(Aa(t).position) >= 0, r = n && cs(t) ? Oh(t) : t;
  return wc(r) ? e.filter(function(i) {
    return wc(i) && DN(i, r) && ga(i) !== "body" && (n ? Aa(i).position !== "static" : !0);
  }) : [];
}
function J9e(t, e, n) {
  var r = e === "clippingParents" ? Z9e(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], a = i.reduce(function(o, u) {
    var c = jC(t, u);
    return o.top = Ou(c.top, o.top), o.right = k0(c.right, o.right), o.bottom = k0(c.bottom, o.bottom), o.left = Ou(c.left, o.left), o;
  }, jC(t, s));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function PN(t) {
  var e = t.reference, n = t.element, r = t.placement, i = r ? ua(r) : null, s = r ? Ic(r) : null, a = e.x + e.width / 2 - n.width / 2, o = e.y + e.height / 2 - n.height / 2, u;
  switch (i) {
    case Ni:
      u = {
        x: a,
        y: e.y - n.height
      };
      break;
    case ps:
      u = {
        x: a,
        y: e.y + e.height
      };
      break;
    case ms:
      u = {
        x: e.x + e.width,
        y: o
      };
      break;
    case Li:
      u = {
        x: e.x - n.width,
        y: o
      };
      break;
    default:
      u = {
        x: e.x,
        y: e.y
      };
  }
  var c = i ? v_(i) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (s) {
      case xc:
        u[c] = u[c] - (e[d] / 2 - n[d] / 2);
        break;
      case sh:
        u[c] = u[c] + (e[d] / 2 - n[d] / 2);
        break;
    }
  }
  return u;
}
function ah(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.boundary, a = s === void 0 ? y9e : s, o = n.rootBoundary, u = o === void 0 ? SN : o, c = n.elementContext, d = c === void 0 ? $d : c, l = n.altBoundary, f = l === void 0 ? !1 : l, p = n.padding, m = p === void 0 ? 0 : p, g = ON(typeof m != "number" ? m : NN(m, Mh)), y = d === $d ? v9e : $d, b = t.rects.popper, E = t.elements[f ? y : d], v = J9e(wc(E) ? E : E.contextElement || Ho(t.elements.popper), a, u), _ = Sc(t.elements.reference), D = PN({
    reference: _,
    element: b,
    placement: i
  }), S = Oy(Object.assign({}, b, D)), M = d === $d ? S : _, O = {
    top: v.top - M.top + g.top,
    bottom: M.bottom - v.bottom + g.bottom,
    left: v.left - M.left + g.left,
    right: M.right - v.right + g.right
  }, T = t.modifiersData.offset;
  if (d === $d && T) {
    var N = T[i];
    Object.keys(O).forEach(function(H) {
      var $ = [ms, ps].indexOf(H) >= 0 ? 1 : -1, j = [Ni, ps].indexOf(H) >= 0 ? "y" : "x";
      O[H] += N[j] * $;
    });
  }
  return O;
}
function eLe(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, a = n.padding, o = n.flipVariations, u = n.allowedAutoPlacements, c = u === void 0 ? IN : u, d = Ic(r), l = d ? o ? FC : FC.filter(function(m) {
    return Ic(m) === d;
  }) : Mh, f = l.filter(function(m) {
    return c.indexOf(m) >= 0;
  });
  f.length === 0 && (f = l);
  var p = f.reduce(function(m, g) {
    return m[g] = ah(t, {
      placement: g,
      boundary: i,
      rootBoundary: s,
      padding: a
    })[ua(g)], m;
  }, {});
  return Object.keys(p).sort(function(m, g) {
    return p[m] - p[g];
  });
}
function tLe(t) {
  if (ua(t) === b_)
    return [];
  var e = xm(t);
  return [HC(t), e, HC(e)];
}
function nLe(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, o = a === void 0 ? !0 : a, u = n.fallbackPlacements, c = n.padding, d = n.boundary, l = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, m = p === void 0 ? !0 : p, g = n.allowedAutoPlacements, y = e.options.placement, b = ua(y), E = b === y, v = u || (E || !m ? [xm(y)] : tLe(y)), _ = [y].concat(v).reduce(function(ee, Z) {
      return ee.concat(ua(Z) === b_ ? eLe(e, {
        placement: Z,
        boundary: d,
        rootBoundary: l,
        padding: c,
        flipVariations: m,
        allowedAutoPlacements: g
      }) : Z);
    }, []), D = e.rects.reference, S = e.rects.popper, M = /* @__PURE__ */ new Map(), O = !0, T = _[0], N = 0; N < _.length; N++) {
      var H = _[N], $ = ua(H), j = Ic(H) === xc, U = [Ni, ps].indexOf($) >= 0, V = U ? "width" : "height", B = ah(e, {
        placement: H,
        boundary: d,
        rootBoundary: l,
        altBoundary: f,
        padding: c
      }), R = U ? j ? ms : Li : j ? ps : Ni;
      D[V] > S[V] && (R = xm(R));
      var K = xm(R), Q = [];
      if (s && Q.push(B[$] <= 0), o && Q.push(B[R] <= 0, B[K] <= 0), Q.every(function(ee) {
        return ee;
      })) {
        T = H, O = !1;
        break;
      }
      M.set(H, Q);
    }
    if (O)
      for (var P = m ? 3 : 1, I = function(Z) {
        var ye = _.find(function(he) {
          var Ee = M.get(he);
          if (Ee)
            return Ee.slice(0, Z).every(function(be) {
              return be;
            });
        });
        if (ye)
          return T = ye, "break";
      }, G = P; G > 0; G--) {
        var te = I(G);
        if (te === "break")
          break;
      }
    e.placement !== T && (e.modifiersData[r]._skip = !0, e.placement = T, e.reset = !0);
  }
}
var rLe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: nLe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function zC(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function qC(t) {
  return [Ni, ms, ps, Li].some(function(e) {
    return t[e] >= 0;
  });
}
function iLe(t) {
  var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, a = ah(e, {
    elementContext: "reference"
  }), o = ah(e, {
    altBoundary: !0
  }), u = zC(a, r), c = zC(o, i, s), d = qC(u), l = qC(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: u,
    popperEscapeOffsets: c,
    isReferenceHidden: d,
    hasPopperEscaped: l
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": l
  });
}
var sLe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: iLe
};
function aLe(t, e, n) {
  var r = ua(t), i = [Li, Ni].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, a = s[0], o = s[1];
  return a = a || 0, o = (o || 0) * i, [Li, ms].indexOf(r) >= 0 ? {
    x: o,
    y: a
  } : {
    x: a,
    y: o
  };
}
function oLe(t) {
  var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, a = IN.reduce(function(d, l) {
    return d[l] = aLe(l, e.rects, s), d;
  }, {}), o = a[e.placement], u = o.x, c = o.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += u, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
}
var uLe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: oLe
};
function lLe(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = PN({
    reference: e.rects.reference,
    element: e.rects.popper,
    placement: e.placement
  });
}
var cLe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: lLe,
  data: {}
};
function dLe(t) {
  return t === "x" ? "y" : "x";
}
function fLe(t) {
  var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, o = a === void 0 ? !1 : a, u = n.boundary, c = n.rootBoundary, d = n.altBoundary, l = n.padding, f = n.tether, p = f === void 0 ? !0 : f, m = n.tetherOffset, g = m === void 0 ? 0 : m, y = ah(e, {
    boundary: u,
    rootBoundary: c,
    padding: l,
    altBoundary: d
  }), b = ua(e.placement), E = Ic(e.placement), v = !E, _ = v_(b), D = dLe(_), S = e.modifiersData.popperOffsets, M = e.rects.reference, O = e.rects.popper, T = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, N = typeof T == "number" ? {
    mainAxis: T,
    altAxis: T
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, T), H = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, $ = {
    x: 0,
    y: 0
  };
  if (S) {
    if (s) {
      var j, U = _ === "y" ? Ni : Li, V = _ === "y" ? ps : ms, B = _ === "y" ? "height" : "width", R = S[_], K = R + y[U], Q = R - y[V], P = p ? -O[B] / 2 : 0, I = E === xc ? M[B] : O[B], G = E === xc ? -O[B] : -M[B], te = e.elements.arrow, ee = p && te ? y_(te) : {
        width: 0,
        height: 0
      }, Z = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : MN(), ye = Z[U], he = Z[V], Ee = Ef(0, M[B], ee[B]), be = v ? M[B] / 2 - P - Ee - ye - N.mainAxis : I - Ee - ye - N.mainAxis, ve = v ? -M[B] / 2 + P + Ee + he + N.mainAxis : G + Ee + he + N.mainAxis, Ce = e.elements.arrow && Oh(e.elements.arrow), Ne = Ce ? _ === "y" ? Ce.clientTop || 0 : Ce.clientLeft || 0 : 0, qe = (j = H == null ? void 0 : H[_]) != null ? j : 0, $e = R + be - qe - Ne, Xe = R + ve - qe, at = Ef(p ? k0(K, $e) : K, R, p ? Ou(Q, Xe) : Q);
      S[_] = at, $[_] = at - R;
    }
    if (o) {
      var Ie, ne = _ === "x" ? Ni : Li, ue = _ === "x" ? ps : ms, ie = S[D], Te = D === "y" ? "height" : "width", je = ie + y[ne], We = ie - y[ue], Qe = [Ni, Li].indexOf(b) !== -1, xe = (Ie = H == null ? void 0 : H[D]) != null ? Ie : 0, Be = Qe ? je : ie - M[Te] - O[Te] - xe + N.altAxis, At = Qe ? ie + M[Te] + O[Te] - xe - N.altAxis : We, xt = p && Qe ? R9e(Be, ie, At) : Ef(p ? Be : je, ie, p ? At : We);
      S[D] = xt, $[D] = xt - ie;
    }
    e.modifiersData[r] = $;
  }
}
var hLe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: fLe,
  requiresIfExists: ["offset"]
};
function pLe(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function mLe(t) {
  return t === js(t) || !cs(t) ? T_(t) : pLe(t);
}
function gLe(t) {
  var e = t.getBoundingClientRect(), n = Cc(e.width) / t.offsetWidth || 1, r = Cc(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function ALe(t, e, n) {
  n === void 0 && (n = !1);
  var r = cs(e), i = cs(e) && gLe(e), s = Ho(e), a = Sc(t, i), o = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && ((ga(e) !== "body" || E_(s)) && (o = mLe(e)), cs(e) ? (u = Sc(e, !0), u.x += e.clientLeft, u.y += e.clientTop) : s && (u.x = __(s))), {
    x: a.left + o.scrollLeft - u.x,
    y: a.top + o.scrollTop - u.y,
    width: a.width,
    height: a.height
  };
}
function bLe(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var a = [].concat(s.requires || [], s.requiresIfExists || []);
    a.forEach(function(o) {
      if (!n.has(o)) {
        var u = e.get(o);
        u && i(u);
      }
    }), r.push(s);
  }
  return t.forEach(function(s) {
    n.has(s.name) || i(s);
  }), r;
}
function yLe(t) {
  var e = bLe(t);
  return D9e.reduce(function(n, r) {
    return n.concat(e.filter(function(i) {
      return i.phase === r;
    }));
  }, []);
}
function vLe(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function TLe(t) {
  var e = t.reduce(function(n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var VC = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function WC() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function _Le(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? VC : i;
  return function(o, u, c) {
    c === void 0 && (c = s);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, VC, s),
      modifiersData: {},
      elements: {
        reference: o,
        popper: u
      },
      attributes: {},
      styles: {}
    }, l = [], f = !1, p = {
      state: d,
      setOptions: function(b) {
        var E = typeof b == "function" ? b(d.options) : b;
        g(), d.options = Object.assign({}, s, d.options, E), d.scrollParents = {
          reference: wc(o) ? xf(o) : o.contextElement ? xf(o.contextElement) : [],
          popper: xf(u)
        };
        var v = yLe(TLe([].concat(r, d.options.modifiers)));
        return d.orderedModifiers = v.filter(function(_) {
          return _.enabled;
        }), m(), p.update();
      },
      forceUpdate: function() {
        if (!f) {
          var b = d.elements, E = b.reference, v = b.popper;
          if (WC(E, v)) {
            d.rects = {
              reference: ALe(E, Oh(v), d.options.strategy === "fixed"),
              popper: y_(v)
            }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(N) {
              return d.modifiersData[N.name] = Object.assign({}, N.data);
            });
            for (var _ = 0; _ < d.orderedModifiers.length; _++) {
              if (d.reset === !0) {
                d.reset = !1, _ = -1;
                continue;
              }
              var D = d.orderedModifiers[_], S = D.fn, M = D.options, O = M === void 0 ? {} : M, T = D.name;
              typeof S == "function" && (d = S({
                state: d,
                options: O,
                name: T,
                instance: p
              }) || d);
            }
          }
        }
      },
      update: vLe(function() {
        return new Promise(function(y) {
          p.forceUpdate(), y(d);
        });
      }),
      destroy: function() {
        g(), f = !0;
      }
    };
    if (!WC(o, u))
      return p;
    p.setOptions(c).then(function(y) {
      !f && c.onFirstUpdate && c.onFirstUpdate(y);
    });
    function m() {
      d.orderedModifiers.forEach(function(y) {
        var b = y.name, E = y.options, v = E === void 0 ? {} : E, _ = y.effect;
        if (typeof _ == "function") {
          var D = _({
            state: d,
            name: b,
            instance: p,
            options: v
          }), S = function() {
          };
          l.push(D || S);
        }
      });
    }
    function g() {
      l.forEach(function(y) {
        return y();
      }), l = [];
    }
    return p;
  };
}
var ELe = [W9e, cLe, q9e, N9e, uLe, rLe, hLe, $9e, sLe], xLe = /* @__PURE__ */ _Le({
  defaultModifiers: ELe
}), RN = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgOS4zODI4MTMgNCA0IDkuMzgyODEzIDQgMTYgQyA0IDIyLjYxNzE4OCA5LjM4MjgxMyAyOCAxNiAyOCBDIDIyLjYxNzE4OCAyOCAyOCAyMi42MTcxODggMjggMTYgQyAyOCA5LjM4MjgxMyAyMi42MTcxODggNCAxNiA0IFogTSAxNiA2IEMgMjEuNTM1MTU2IDYgMjYgMTAuNDY0ODQ0IDI2IDE2IEMgMjYgMjEuNTM1MTU2IDIxLjUzNTE1NiAyNiAxNiAyNiBDIDEwLjQ2NDg0NCAyNiA2IDIxLjUzNTE1NiA2IDE2IEMgNiAxMC40NjQ4NDQgMTAuNDY0ODQ0IDYgMTYgNiBaIE0gMTEuNSAxMiBDIDEwLjY3MTg3NSAxMiAxMCAxMi42NzE4NzUgMTAgMTMuNSBDIDEwIDE0LjMyODEyNSAxMC42NzE4NzUgMTUgMTEuNSAxNSBDIDEyLjMyODEyNSAxNSAxMyAxNC4zMjgxMjUgMTMgMTMuNSBDIDEzIDEyLjY3MTg3NSAxMi4zMjgxMjUgMTIgMTEuNSAxMiBaIE0gMjAuNSAxMiBDIDE5LjY3MTg3NSAxMiAxOSAxMi42NzE4NzUgMTkgMTMuNSBDIDE5IDE0LjMyODEyNSAxOS42NzE4NzUgMTUgMjAuNSAxNSBDIDIxLjMyODEyNSAxNSAyMiAxNC4zMjgxMjUgMjIgMTMuNSBDIDIyIDEyLjY3MTg3NSAyMS4zMjgxMjUgMTIgMjAuNSAxMiBaIE0gMTAuODEyNSAxOSBMIDkuMDkzNzUgMjAgQyAxMC40NzY1NjMgMjIuMzg2NzE5IDEzLjA0Njg3NSAyNCAxNiAyNCBDIDE4Ljk1MzEyNSAyNCAyMS41MjM0MzggMjIuMzg2NzE5IDIyLjkwNjI1IDIwIEwgMjEuMTg3NSAxOSBDIDIwLjE0ODQzOCAyMC43OTI5NjkgMTguMjI2NTYzIDIyIDE2IDIyIEMgMTMuNzczNDM4IDIyIDExLjg1MTU2MyAyMC43OTI5NjkgMTAuODEyNSAxOSBaIi8+PC9zdmc+";
function wm(t) {
  return t.split("-").map((e) => parseInt(e, 16)).map((e) => String.fromCodePoint(e)).join("");
}
function wLe(t, e, n, r = []) {
  const i = {};
  return Object.keys(t).forEach((s) => {
    if (r.includes(s))
      return;
    const a = [];
    t[s].forEach((o) => {
      var u;
      if (o[Yg][0].includes(e.toLocaleLowerCase())) {
        let c = o[xN];
        if (n !== I0 && Array.isArray(o[Vp])) {
          const d = ((u = o[Vp]) == null ? void 0 : u.findIndex(
            (l) => l.includes(n)
          )) || -1;
          d !== -1 && o[Vp] && (c = o[Vp][d]);
        }
        return a.push({
          ...o,
          [ih]: c
        });
      }
    }), a.length && (i[s] = a);
  }), i;
}
function BN() {
  var t;
  return (((t = navigator == null ? void 0 : navigator.userAgentData) == null ? void 0 : t.platform) || (navigator == null ? void 0 : navigator.platform) || "unknown").toUpperCase().indexOf("MAC") !== -1;
}
function FN(t) {
  return t.replace(
    /^_*(.)|_+(.)/g,
    (e, n, r) => n ? n.toUpperCase() : " " + r.toUpperCase()
  );
}
var Nh = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, i] of e)
    n[r] = i;
  return n;
};
const CLe = Ze({
  name: "Body",
  emits: {
    select: (t) => !0
  },
  setup() {
    const { state: t, updateEmoji: e, updateSelect: n } = pn("store"), r = Se(null), i = de(() => wLe(
      t.emojis,
      t.search,
      t.skinTone,
      t.options.disabledGroups
    )), s = la(), a = de(() => !t.options.hideGroupNames), o = de(() => !t.options.disableStickyGroupNames), u = KS(t.options.groupNames), c = t.orderedGroupKeys;
    t.options.additionalGroups && Object.keys(t.options.additionalGroups).map((m) => {
      t.options.groupNames[m] ? u[m] = t.options.groupNames[m] : u[m] = FN(m);
    });
    const d = BN() ? "is-mac" : "";
    function l(m) {
      e(m);
    }
    function f(m) {
      n(m), s == null || s.emit("select", {
        ...m,
        t: t.skinTone,
        i: wm(m.r)
      });
    }
    function p(m, g) {
      var y;
      const b = (y = m == null ? void 0 : m.target) == null ? void 0 : y.closest("button");
      b && (b.innerHTML = `<span>${wm(g)}</span>`);
    }
    return Ct(
      () => t.activeGroup,
      () => {
        var m;
        const g = (m = r.value) == null ? void 0 : m.querySelector("#" + t.activeGroup);
        g && (g.parentNode.scrollTop = g.offsetTop - g.parentNode.offsetTop);
      }
    ), {
      emojis: i,
      bodyInner: r,
      EMOJI_REMOTE_SRC: _N,
      GROUP_NAMES: EN,
      handleClick: f,
      handleError: p,
      handleMouseEnter: l,
      native: t.options.native,
      unicodeToEmoji: wm,
      EMOJI_RESULT_KEY: ih,
      EMOJI_NAME_KEY: Yg,
      hasGroupNames: a,
      isSticky: o,
      platform: d,
      groupNames: u,
      orderedKeys: c
    };
  }
}), SLe = { class: "v3-body" }, ILe = ["id"], kLe = { class: "v3-emojis" }, DLe = ["onMouseenter", "onClick"], MLe = { key: 0 }, OLe = ["src", "alt", "onError"], NLe = {
  key: 1,
  class: "v3-no-result"
};
function LLe(t, e, n, r, i, s) {
  return X(), se("div", SLe, [
    W("div", {
      ref: "bodyInner",
      class: vt([t.platform, "v3-body-inner"])
    }, [
      t.orderedKeys.length ? (X(!0), se(wt, { key: 0 }, on(t.orderedKeys, (a) => (X(), se("div", {
        id: a,
        key: a,
        class: "v3-group"
      }, [
        t.hasGroupNames ? Gt((X(), se("h5", {
          key: 0,
          class: vt(t.isSticky ? "v3-sticky" : "")
        }, _e(t.groupNames[a]), 3)), [
          [Ra, t.emojis[a]]
        ]) : Fe("", !0),
        Gt(W("div", kLe, [
          (X(!0), se(wt, null, on(t.emojis[a], (o) => (X(), se("button", {
            key: o.r,
            type: "button",
            onMouseenter: (u) => t.handleMouseEnter(o),
            onClick: (u) => t.handleClick(o)
          }, [
            t.native ? (X(), se("span", MLe, _e(t.unicodeToEmoji(o.r)), 1)) : (X(), se("img", {
              key: 1,
              src: t.EMOJI_REMOTE_SRC + `/${o.r}.png`,
              alt: o.n[0],
              onError: (u) => t.handleError(u, o.r)
            }, null, 40, OLe))
          ], 40, DLe))), 128))
        ], 512), [
          [Ra, t.emojis[a]]
        ])
      ], 8, ILe))), 128)) : (X(), se("span", NLe, " No emoji has been found! "))
    ], 2)
  ]);
}
var PLe = /* @__PURE__ */ Nh(CLe, [["render", LLe]]), RLe = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMi41IDUgQyAxMS40Mjk2ODggNSAxMC41IDUuNjA5Mzc1IDkuOTA2MjUgNi40Mzc1IEMgOS4zMTI1IDcuMjY1NjI1IDkgOC4zMzk4NDQgOSA5LjUgQyA5IDEwLjY2MDE1NiA5LjMxMjUgMTEuNzM0Mzc1IDkuOTA2MjUgMTIuNTYyNSBDIDEwLjUgMTMuMzkwNjI1IDExLjQyOTY4OCAxNCAxMi41IDE0IEMgMTMuNTcwMzEzIDE0IDE0LjUgMTMuMzkwNjI1IDE1LjA5Mzc1IDEyLjU2MjUgQyAxNS42ODc1IDExLjczNDM3NSAxNiAxMC42NjAxNTYgMTYgOS41IEMgMTYgOC4zMzk4NDQgMTUuNjg3NSA3LjI2NTYyNSAxNS4wOTM3NSA2LjQzNzUgQyAxNC41IDUuNjA5Mzc1IDEzLjU3MDMxMyA1IDEyLjUgNSBaIE0gMTYgOS41IEMgMTYgMTAuNjYwMTU2IDE2LjMxMjUgMTEuNzM0Mzc1IDE2LjkwNjI1IDEyLjU2MjUgQyAxNy41IDEzLjM5MDYyNSAxOC40Mjk2ODggMTQgMTkuNSAxNCBDIDIwLjU3MDMxMyAxNCAyMS41IDEzLjM5MDYyNSAyMi4wOTM3NSAxMi41NjI1IEMgMjIuNjg3NSAxMS43MzQzNzUgMjMgMTAuNjYwMTU2IDIzIDkuNSBDIDIzIDguMzM5ODQ0IDIyLjY4NzUgNy4yNjU2MjUgMjIuMDkzNzUgNi40Mzc1IEMgMjEuNSA1LjYwOTM3NSAyMC41NzAzMTMgNSAxOS41IDUgQyAxOC40Mjk2ODggNSAxNy41IDUuNjA5Mzc1IDE2LjkwNjI1IDYuNDM3NSBDIDE2LjMxMjUgNy4yNjU2MjUgMTYgOC4zMzk4NDQgMTYgOS41IFogTSAxMi41IDcgQyAxMi44MTI1IDcgMTMuMTU2MjUgNy4xNTYyNSAxMy40Njg3NSA3LjU5Mzc1IEMgMTMuNzgxMjUgOC4wMzEyNSAxNCA4LjcyNjU2MyAxNCA5LjUgQyAxNCAxMC4yNzM0MzggMTMuNzgxMjUgMTAuOTY4NzUgMTMuNDY4NzUgMTEuNDA2MjUgQyAxMy4xNTYyNSAxMS44NDM3NSAxMi44MTI1IDEyIDEyLjUgMTIgQyAxMi4xODc1IDEyIDExLjg0Mzc1IDExLjg0Mzc1IDExLjUzMTI1IDExLjQwNjI1IEMgMTEuMjE4NzUgMTAuOTY4NzUgMTEgMTAuMjczNDM4IDExIDkuNSBDIDExIDguNzI2NTYzIDExLjIxODc1IDguMDMxMjUgMTEuNTMxMjUgNy41OTM3NSBDIDExLjg0Mzc1IDcuMTU2MjUgMTIuMTg3NSA3IDEyLjUgNyBaIE0gMTkuNSA3IEMgMTkuODEyNSA3IDIwLjE1NjI1IDcuMTU2MjUgMjAuNDY4NzUgNy41OTM3NSBDIDIwLjc4MTI1IDguMDMxMjUgMjEgOC43MjY1NjMgMjEgOS41IEMgMjEgMTAuMjczNDM4IDIwLjc4MTI1IDEwLjk2ODc1IDIwLjQ2ODc1IDExLjQwNjI1IEMgMjAuMTU2MjUgMTEuODQzNzUgMTkuODEyNSAxMiAxOS41IDEyIEMgMTkuMTg3NSAxMiAxOC44NDM3NSAxMS44NDM3NSAxOC41MzEyNSAxMS40MDYyNSBDIDE4LjIxODc1IDEwLjk2ODc1IDE4IDEwLjI3MzQzOCAxOCA5LjUgQyAxOCA4LjcyNjU2MyAxOC4yMTg3NSA4LjAzMTI1IDE4LjUzMTI1IDcuNTkzNzUgQyAxOC44NDM3NSA3LjE1NjI1IDE5LjE4NzUgNyAxOS41IDcgWiBNIDcuNSAxMiBDIDYuNDI5Njg4IDEyIDUuNSAxMi42MDkzNzUgNC45MDYyNSAxMy40Mzc1IEMgNC4zMTI1IDE0LjI2NTYyNSA0IDE1LjMzOTg0NCA0IDE2LjUgQyA0IDE3LjY2MDE1NiA0LjMxMjUgMTguNzM0Mzc1IDQuOTA2MjUgMTkuNTYyNSBDIDUuNSAyMC4zOTA2MjUgNi40Mjk2ODggMjEgNy41IDIxIEMgOC41NzAzMTMgMjEgOS41IDIwLjM5MDYyNSAxMC4wOTM3NSAxOS41NjI1IEMgMTAuNjg3NSAxOC43MzQzNzUgMTEgMTcuNjYwMTU2IDExIDE2LjUgQyAxMSAxNS4zMzk4NDQgMTAuNjg3NSAxNC4yNjU2MjUgMTAuMDkzNzUgMTMuNDM3NSBDIDkuNSAxMi42MDkzNzUgOC41NzAzMTMgMTIgNy41IDEyIFogTSAyNC41IDEyIEMgMjMuNDI5Njg4IDEyIDIyLjUgMTIuNjA5Mzc1IDIxLjkwNjI1IDEzLjQzNzUgQyAyMS4zMTI1IDE0LjI2NTYyNSAyMSAxNS4zMzk4NDQgMjEgMTYuNSBDIDIxIDE3LjY2MDE1NiAyMS4zMTI1IDE4LjczNDM3NSAyMS45MDYyNSAxOS41NjI1IEMgMjIuNSAyMC4zOTA2MjUgMjMuNDI5Njg4IDIxIDI0LjUgMjEgQyAyNS41NzAzMTMgMjEgMjYuNSAyMC4zOTA2MjUgMjcuMDkzNzUgMTkuNTYyNSBDIDI3LjY4NzUgMTguNzM0Mzc1IDI4IDE3LjY2MDE1NiAyOCAxNi41IEMgMjggMTUuMzM5ODQ0IDI3LjY4NzUgMTQuMjY1NjI1IDI3LjA5Mzc1IDEzLjQzNzUgQyAyNi41IDEyLjYwOTM3NSAyNS41NzAzMTMgMTIgMjQuNSAxMiBaIE0gNy41IDE0IEMgNy44MTI1IDE0IDguMTU2MjUgMTQuMTU2MjUgOC40Njg3NSAxNC41OTM3NSBDIDguNzgxMjUgMTUuMDMxMjUgOSAxNS43MjY1NjMgOSAxNi41IEMgOSAxNy4yNzM0MzggOC43ODEyNSAxNy45Njg3NSA4LjQ2ODc1IDE4LjQwNjI1IEMgOC4xNTYyNSAxOC44NDM3NSA3LjgxMjUgMTkgNy41IDE5IEMgNy4xODc1IDE5IDYuODQzNzUgMTguODQzNzUgNi41MzEyNSAxOC40MDYyNSBDIDYuMjE4NzUgMTcuOTY4NzUgNiAxNy4yNzM0MzggNiAxNi41IEMgNiAxNS43MjY1NjMgNi4yMTg3NSAxNS4wMzEyNSA2LjUzMTI1IDE0LjU5Mzc1IEMgNi44NDM3NSAxNC4xNTYyNSA3LjE4NzUgMTQgNy41IDE0IFogTSAyNC41IDE0IEMgMjQuODEyNSAxNCAyNS4xNTYyNSAxNC4xNTYyNSAyNS40Njg3NSAxNC41OTM3NSBDIDI1Ljc4MTI1IDE1LjAzMTI1IDI2IDE1LjcyNjU2MyAyNiAxNi41IEMgMjYgMTcuMjczNDM4IDI1Ljc4MTI1IDE3Ljk2ODc1IDI1LjQ2ODc1IDE4LjQwNjI1IEMgMjUuMTU2MjUgMTguODQzNzUgMjQuODEyNSAxOSAyNC41IDE5IEMgMjQuMTg3NSAxOSAyMy44NDM3NSAxOC44NDM3NSAyMy41MzEyNSAxOC40MDYyNSBDIDIzLjIxODc1IDE3Ljk2ODc1IDIzIDE3LjI3MzQzOCAyMyAxNi41IEMgMjMgMTUuNzI2NTYzIDIzLjIxODc1IDE1LjAzMTI1IDIzLjUzMTI1IDE0LjU5Mzc1IEMgMjMuODQzNzUgMTQuMTU2MjUgMjQuMTg3NSAxNCAyNC41IDE0IFogTSAxNiAxNiBDIDE0LjY2Nzk2OSAxNiAxMy43MzgyODEgMTYuODY3MTg4IDEzLjI4MTI1IDE3LjYyNSBDIDEyLjgyNDIxOSAxOC4zODI4MTMgMTIuNTQ2ODc1IDE5LjAxNTYyNSAxMi4yODEyNSAxOS4yODEyNSBDIDEyLjEyNSAxOS40Mzc1IDExLjE2MDE1NiAxOS44MDA3ODEgMTAuMTU2MjUgMjAuMzEyNSBDIDkuNjUyMzQ0IDIwLjU3MDMxMyA5LjE0NDUzMSAyMC45MTQwNjMgOC43MTg3NSAyMS40Mzc1IEMgOC4yOTI5NjkgMjEuOTYwOTM4IDggMjIuNjg3NSA4IDIzLjUgQyA4IDI1LjQyMTg3NSA5LjU3ODEyNSAyNyAxMS41IDI3IEMgMTIuMzY3MTg4IDI3IDEzLjI2OTUzMSAyNi43MjI2NTYgMTQuMTU2MjUgMjYuNDY4NzUgQyAxNS4wNDI5NjkgMjYuMjE0ODQ0IDE2IDI2IDE2IDI2IEMgMTYgMjYgMTYuOTU3MDMxIDI2LjIxNDg0NCAxNy44NDM3NSAyNi40Njg3NSBDIDE4LjczMDQ2OSAyNi43MjI2NTYgMTkuNjMyODEzIDI3IDIwLjUgMjcgQyAyMi40MjE4NzUgMjcgMjQgMjUuNDIxODc1IDI0IDIzLjUgQyAyNCAyMi43MDcwMzEgMjMuNzA3MDMxIDIxLjk4MDQ2OSAyMy4yODEyNSAyMS40Njg3NSBDIDIyLjg1NTQ2OSAyMC45NTcwMzEgMjIuMzQzNzUgMjAuNjQwNjI1IDIxLjg0Mzc1IDIwLjM3NSBDIDIwLjg0Mzc1IDE5Ljg0Mzc1IDE5Ljg1OTM3NSAxOS40MjE4NzUgMTkuNzE4NzUgMTkuMjgxMjUgQyAxOS40ODA0NjkgMTkuMDQyOTY5IDE5LjIxMDkzOCAxOC4zOTA2MjUgMTguNzUgMTcuNjI1IEMgMTguMjg5MDYzIDE2Ljg1OTM3NSAxNy4zMzk4NDQgMTYgMTYgMTYgWiBNIDE2IDE4IEMgMTYuNjYwMTU2IDE4IDE2LjczNDM3NSAxOC4xNjAxNTYgMTcuMDMxMjUgMTguNjU2MjUgQyAxNy4zMjgxMjUgMTkuMTUyMzQ0IDE3LjU1NDY4OCAxOS45OTIxODggMTguMjgxMjUgMjAuNzE4NzUgQyAxOS4xMDU0NjkgMjEuNTQyOTY5IDIwLjE0ODQzOCAyMS43MjI2NTYgMjAuOTA2MjUgMjIuMTI1IEMgMjEuMjg1MTU2IDIyLjMyODEyNSAyMS41NzgxMjUgMjIuNTQyOTY5IDIxLjc1IDIyLjc1IEMgMjEuOTIxODc1IDIyLjk1NzAzMSAyMiAyMy4xNDg0MzggMjIgMjMuNSBDIDIyIDI0LjMzOTg0NCAyMS4zMzk4NDQgMjUgMjAuNSAyNSBDIDIwLjIxMDkzOCAyNSAxOS4yNzczNDQgMjQuNzc3MzQ0IDE4LjQwNjI1IDI0LjUzMTI1IEMgMTcuNTM1MTU2IDI0LjI4NTE1NiAxNi44MTY0MDYgMjQgMTYgMjQgQyAxNS4xODM1OTQgMjQgMTQuNDY0ODQ0IDI0LjI4NTE1NiAxMy41OTM3NSAyNC41MzEyNSBDIDEyLjcyMjY1NiAyNC43NzczNDQgMTEuNzg5MDYzIDI1IDExLjUgMjUgQyAxMC42NjAxNTYgMjUgMTAgMjQuMzM5ODQ0IDEwIDIzLjUgQyAxMCAyMy4wOTc2NTYgMTAuMDgyMDMxIDIyLjg5MDYyNSAxMC4yNSAyMi42ODc1IEMgMTAuNDE3OTY5IDIyLjQ4NDM3NSAxMC43MjI2NTYgMjIuMjg1MTU2IDExLjA5Mzc1IDIyLjA5Mzc1IEMgMTEuODM5ODQ0IDIxLjcxNDg0NCAxMi44NzUgMjEuNTYyNSAxMy43MTg3NSAyMC43MTg3NSBDIDE0LjQ1MzEyNSAxOS45ODQzNzUgMTQuNjc1NzgxIDE5LjExNzE4OCAxNC45Njg3NSAxOC42MjUgQyAxNS4yNjE3MTkgMTguMTMyODEzIDE1LjMzMjAzMSAxOCAxNiAxOCBaIi8+PC9zdmc+", BLe = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMSAzIEwgMTEgNyBMIDEzIDcgTCAxMyAzIFogTSAxNSA0IEwgMTUgNyBMIDE3IDcgTCAxNyA0IFogTSA0Ljg3NSA4IEwgNSA5LjA5Mzc1IEwgNi44MTI1IDI2LjMxMjUgQyA2Ljk3MjY1NiAyNy44MzIwMzEgOC4yODUxNTYgMjkgOS44MTI1IDI5IEwgMTkuMTg3NSAyOSBDIDIwLjcxNDg0NCAyOSAyMi4wMjczNDQgMjcuODMyMDMxIDIyLjE4NzUgMjYuMzEyNSBMIDIyLjY1NjI1IDIyIEwgMjUgMjIgQyAyNi42NDQ1MzEgMjIgMjggMjAuNjQ0NTMxIDI4IDE5IEwgMjggMTYgQyAyOCAxNC4zNTU0NjkgMjYuNjQ0NTMxIDEzIDI1IDEzIEwgMjMuNTkzNzUgMTMgTCAyNCA5LjA5Mzc1IEwgMjQuMTI1IDggWiBNIDcuMTI1IDEwIEwgMjEuODc1IDEwIEwgMjAuMTg3NSAyNi4wOTM3NSBDIDIwLjEzMjgxMyAyNi42MTMyODEgMTkuNzA3MDMxIDI3IDE5LjE4NzUgMjcgTCA5LjgxMjUgMjcgQyA5LjI5Mjk2OSAyNyA4Ljg2NzE4OCAyNi42MTMyODEgOC44MTI1IDI2LjA5Mzc1IFogTSAyMy4zNzUgMTUgTCAyNSAxNSBDIDI1LjU2NjQwNiAxNSAyNiAxNS40MzM1OTQgMjYgMTYgTCAyNiAxOSBDIDI2IDE5LjU2NjQwNiAyNS41NjY0MDYgMjAgMjUgMjAgTCAyMi44NDM3NSAyMCBaIi8+PC9zdmc+", FLe = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiAzIEMgOC44MzIwMzEgMyAzIDguODMyMDMxIDMgMTYgQyAzIDIzLjE2Nzk2OSA4LjgzMjAzMSAyOSAxNiAyOSBDIDIzLjE2Nzk2OSAyOSAyOSAyMy4xNjc5NjkgMjkgMTYgQyAyOSA4LjgzMjAzMSAyMy4xNjc5NjkgMyAxNiAzIFogTSAxNiA1IEMgMTYuNjAxNTYzIDUgMTcuMTc1NzgxIDUuMDYyNSAxNy43NSA1LjE1NjI1IEwgMTYgNi40MDYyNSBMIDE0LjI1IDUuMTU2MjUgQyAxNC44MjAzMTMgNS4wNjY0MDYgMTUuNDAyMzQ0IDUgMTYgNSBaIE0gMTEuODEyNSA1Ljg0Mzc1IEwgMTUuNDA2MjUgOC40Njg3NSBMIDE2IDguOTA2MjUgTCAxNi41OTM3NSA4LjQ2ODc1IEwgMjAuMTg3NSA1Ljg0Mzc1IEMgMjEuNzg1MTU2IDYuNTA3ODEzIDIzLjE5NTMxMyA3LjUyMzQzOCAyNC4zMTI1IDguODEyNSBMIDIyLjkzNzUgMTMuMDkzNzUgTCAyMi43MTg3NSAxMy43ODEyNSBMIDIzLjMxMjUgMTQuMTg3NSBMIDI2LjkzNzUgMTYuODQzNzUgQyAyNi44MDQ2ODggMTguNjA1NDY5IDI2LjI2NTYyNSAyMC4yNTc4MTMgMjUuNDA2MjUgMjEuNjg3NSBMIDIwLjEyNSAyMS42ODc1IEwgMTkuOTA2MjUgMjIuMzc1IEwgMTguNSAyNi43MTg3NSBDIDE3LjY5OTIxOSAyNi45MDYyNSAxNi44NTkzNzUgMjcgMTYgMjcgQyAxNS4xMDU0NjkgMjcgMTQuMjM4MjgxIDI2Ljg4NjcxOSAxMy40MDYyNSAyNi42ODc1IEwgMTIuMDMxMjUgMjIuNDA2MjUgTCAxMS44MTI1IDIxLjcxODc1IEwgNi41OTM3NSAyMS43MTg3NSBDIDUuNzE4NzUgMjAuMjgxMjUgNS4xOTkyMTkgMTguNjIxMDk0IDUuMDYyNSAxNi44NDM3NSBMIDguNjU2MjUgMTQuMjE4NzUgTCA5LjI1IDEzLjgxMjUgTCA5LjAzMTI1IDEzLjEyNSBMIDcuNjI1IDguODc1IEMgOC43NSA3LjU1NDY4OCAxMC4xODM1OTQgNi41MTU2MjUgMTEuODEyNSA1Ljg0Mzc1IFogTSAxNiAxMC4wOTM3NSBMIDE1LjQwNjI1IDEwLjUzMTI1IEwgMTAuODQzNzUgMTMuODQzNzUgTCAxMC4yODEyNSAxNC4yODEyNSBMIDEwLjUgMTQuOTY4NzUgTCAxMi4yNSAyMC4zMTI1IEwgMTIuNDY4NzUgMjEgTCAxOS41MzEyNSAyMSBMIDE5Ljc1IDIwLjMxMjUgTCAyMS41IDE0Ljk2ODc1IEwgMjEuNzE4NzUgMTQuMjgxMjUgTCAyMS4xNTYyNSAxMy44NDM3NSBMIDE2LjU5Mzc1IDEwLjUzMTI1IFogTSAyNS43NSAxMC45MDYyNSBDIDI2LjI5Njg3NSAxMS45NTMxMjUgMjYuNjU2MjUgMTMuMTAxNTYzIDI2Ljg0Mzc1IDE0LjMxMjUgTCAyNS4wNjI1IDEzLjAzMTI1IFogTSA2LjIxODc1IDEwLjk2ODc1IEwgNi45MDYyNSAxMy4wMzEyNSBMIDUuMTU2MjUgMTQuMzEyNSBDIDUuMzM5ODQ0IDEzLjEyNSA1LjY4NzUgMTIgNi4yMTg3NSAxMC45Njg3NSBaIE0gMTYgMTIuNTkzNzUgTCAxOS4zNzUgMTUuMDMxMjUgTCAxOC4wOTM3NSAxOSBMIDEzLjkwNjI1IDE5IEwgMTIuNjI1IDE1LjAzMTI1IFogTSAyMS41OTM3NSAyMy42ODc1IEwgMjMuODQzNzUgMjMuNjg3NSBDIDIyLjk5MjE4OCAyNC41NjY0MDYgMjIuMDExNzE5IDI1LjI5Mjk2OSAyMC45MDYyNSAyNS44NDM3NSBaIE0gOC4xNTYyNSAyMy43MTg3NSBMIDEwLjM0Mzc1IDIzLjcxODc1IEwgMTEuMDMxMjUgMjUuODEyNSBDIDkuOTYwOTM4IDI1LjI2OTUzMSA4Ljk4ODI4MSAyNC41NjI1IDguMTU2MjUgMjMuNzE4NzUgWiIvPjwvc3ZnPg==", ULe = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSA5LjUgNiBDIDguMTc5Njg4IDYgNy4wMDM5MDYgNi44NTkzNzUgNi42MjUgOC4xMjUgTCA1LjI1IDEyLjcxODc1IEwgMy4zMTI1IDEyLjA2MjUgTCAyLjY4NzUgMTMuOTM3NSBMIDQuNjU2MjUgMTQuNTkzNzUgTCA0LjAzMTI1IDE2LjcxODc1IEMgNC4wMDc4MTMgMTYuODA4NTk0IDMuOTk2MDk0IDE2LjkwNjI1IDQgMTcgTCA0IDI0IEMgNCAyNC4wMzEyNSA0IDI0LjA2MjUgNCAyNC4wOTM3NSBMIDQgMjUgQyA0IDI1LjU1MDc4MSA0LjQ0OTIxOSAyNiA1IDI2IEwgOCAyNiBMIDguMzQzNzUgMjUgTCAyMy42NTYyNSAyNSBMIDI0IDI2IEwgMjcgMjYgQyAyNy41NTA3ODEgMjYgMjggMjUuNTUwNzgxIDI4IDI1IEwgMjggMjQuMTU2MjUgQyAyOC4wMDM5MDYgMjQuMTA1NDY5IDI4LjAwMzkwNiAyNC4wNTA3ODEgMjggMjQgTCAyOCAxNyBDIDI4LjAwMzkwNiAxNi45MDYyNSAyNy45OTIxODggMTYuODA4NTk0IDI3Ljk2ODc1IDE2LjcxODc1IEwgMjcuMzQzNzUgMTQuNTkzNzUgTCAyOS4zMTI1IDEzLjkzNzUgTCAyOC42ODc1IDEyLjA2MjUgTCAyNi43NSAxMi43MTg3NSBMIDI1LjM3NSA4LjEyNSBDIDI0Ljk5NjA5NCA2Ljg1OTM3NSAyMy44MjAzMTMgNiAyMi41IDYgWiBNIDkuNSA4IEwgMjIuNSA4IEMgMjIuOTQ1MzEzIDggMjMuMzM5ODQ0IDguMjkyOTY5IDIzLjQ2ODc1IDguNzE4NzUgTCAyNC43NSAxMyBMIDcuMjUgMTMgTCA4LjUzMTI1IDguNzE4NzUgQyA4LjY2MDE1NiA4LjI4OTA2MyA5LjA1NDY4OCA4IDkuNSA4IFogTSA2LjY1NjI1IDE1IEwgMjUuMzQzNzUgMTUgTCAyNiAxNy4xODc1IEwgMjYgMjMgTCA2IDIzIEwgNiAxNy4xODc1IFogTSA4LjUgMTYgQyA3LjY3MTg3NSAxNiA3IDE2LjY3MTg3NSA3IDE3LjUgQyA3IDE4LjMyODEyNSA3LjY3MTg3NSAxOSA4LjUgMTkgQyA5LjMyODEyNSAxOSAxMCAxOC4zMjgxMjUgMTAgMTcuNSBDIDEwIDE2LjY3MTg3NSA5LjMyODEyNSAxNiA4LjUgMTYgWiBNIDIzLjUgMTYgQyAyMi42NzE4NzUgMTYgMjIgMTYuNjcxODc1IDIyIDE3LjUgQyAyMiAxOC4zMjgxMjUgMjIuNjcxODc1IDE5IDIzLjUgMTkgQyAyNC4zMjgxMjUgMTkgMjUgMTguMzI4MTI1IDI1IDE3LjUgQyAyNSAxNi42NzE4NzUgMjQuMzI4MTI1IDE2IDIzLjUgMTYgWiBNIDEyIDE5IEwgMTAuNzUgMjIgTCAxMi45MDYyNSAyMiBMIDEzLjM0Mzc1IDIxIEwgMTguNjU2MjUgMjEgTCAxOS4wOTM3NSAyMiBMIDIxLjI1IDIyIEwgMjAgMTkgWiIvPjwvc3ZnPg==", $Le = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgMTEuMDQyOTY5IDQgNyA4LjA0Mjk2OSA3IDEzIEMgNyAxNC45MTc5NjkgNy44NDM3NSAxNi45MDYyNSA5IDE4LjY4NzUgQyA5Ljg1OTM3NSAyMC4wMTE3MTkgMTAuODg2NzE5IDIxLjIzMDQ2OSAxMiAyMi4xNTYyNSBMIDEyIDI1IEMgMTIgMjYuMDkzNzUgMTIuOTA2MjUgMjcgMTQgMjcgTCAxNSAyOCBMIDE3IDI4IEwgMTggMjcgQyAxOS4wOTM3NSAyNyAyMCAyNi4wOTM3NSAyMCAyNSBMIDIwIDIyLjE1NjI1IEMgMjEuMTEzMjgxIDIxLjIzMDQ2OSAyMi4xNDA2MjUgMjAuMDExNzE5IDIzIDE4LjY4NzUgQyAyNC4xNTYyNSAxNi45MDYyNSAyNSAxNC45MTc5NjkgMjUgMTMgQyAyNSA4LjA0Mjk2OSAyMC45NTcwMzEgNCAxNiA0IFogTSAxNiA2IEMgMTkuODc4OTA2IDYgMjMgOS4xMjEwOTQgMjMgMTMgQyAyMyAxNC4zMDg1OTQgMjIuMzU1NDY5IDE2LjAzNTE1NiAyMS4zNDM3NSAxNy41OTM3NSBDIDIwLjQ0MTQwNiAxOC45ODQzNzUgMTkuMjUzOTA2IDIwLjIyMjY1NiAxOC4xNTYyNSAyMSBMIDEzLjg0Mzc1IDIxIEMgMTIuNzQ2MDk0IDIwLjIyMjY1NiAxMS41NTg1OTQgMTguOTg0Mzc1IDEwLjY1NjI1IDE3LjU5Mzc1IEMgOS42NDQ1MzEgMTYuMDM1MTU2IDkgMTQuMzA4NTk0IDkgMTMgQyA5IDkuMTIxMDk0IDEyLjEyMTA5NCA2IDE2IDYgWiBNIDE0LjI1IDIzIEwgMTcuNzUgMjMgQyAxNy44MjgxMjUgMjMuMDU0Njg4IDE3LjkxMDE1NiAyMy4wOTM3NSAxOCAyMy4xMjUgTCAxOCAyNSBMIDE0IDI1IEwgMTQgMjMuMTI1IEMgMTQuMDg5ODQ0IDIzLjA5Mzc1IDE0LjE3MTg3NSAyMy4wNTQ2ODggMTQuMjUgMjMgWiIvPjwvc3ZnPg==", HLe = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxMSA1IEwgMTEgMTEgTCA1IDExIEwgNSAxMyBMIDExIDEzIEwgMTEgMTkgTCA1IDE5IEwgNSAyMSBMIDExIDIxIEwgMTEgMjcgTCAxMyAyNyBMIDEzIDIxIEwgMTkgMjEgTCAxOSAyNyBMIDIxIDI3IEwgMjEgMjEgTCAyNyAyMSBMIDI3IDE5IEwgMjEgMTkgTCAyMSAxMyBMIDI3IDEzIEwgMjcgMTEgTCAyMSAxMSBMIDIxIDUgTCAxOSA1IEwgMTkgMTEgTCAxMyAxMSBMIDEzIDUgWiBNIDEzIDEzIEwgMTkgMTMgTCAxOSAxOSBMIDEzIDE5IFoiLz48L3N2Zz4=", jLe = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSA5IDQgQyA3LjM0NiA0IDYgNS4zNDYgNiA3IEMgNiA4LjMwMTYwOTQgNi44Mzg3NDg2IDkuNDAyMTM5MSA4IDkuODE2NDA2MiBMIDggMTEuMzA0Njg4IEwgOCAyMy4yMDcwMzEgTCA4IDI3LjAyMzQzOCBDIDggMjcuNTYzNDM4IDguNDM2NTYyNSAyOCA4Ljk3NjU2MjUgMjggTCA5LjAyMzQzNzUgMjggQyA5LjU2MzQzNzUgMjggMTAgMjcuNTYzNDM3IDEwIDI3LjAyMzQzOCBMIDEwIDIyLjIyODUxNiBDIDEwLjMzNDcwNyAyMS44Mzk3NTYgMTEuMTM4NDIzIDIxLjA0Njg3NSAxMy40NDUzMTIgMjEuMDQ2ODc1IEMgMTQuNjY5MzEzIDIxLjA0Njg3NSAxNS42NzA0MjIgMjEuNDczNzgxIDE2LjczMjQyMiAyMS45MjU3ODEgQyAxNy43Njk0MjIgMjIuMzY3NzgxIDE4Ljg0MTg5MSAyMi44MjQyMTkgMjAuMDg3ODkxIDIyLjgyNDIxOSBDIDIyLjQ0Njg5MSAyMi44MjQyMTkgMjQuMDQ5Mzc1IDIxLjU4NDY4OCAyNC43MzQzNzUgMjEuMDU0Njg4IEwgMjQuODg2NzE5IDIwLjkzOTQ1MyBDIDI1LjQzNzcxOSAyMC41NDA0NTMgMjYgMTkuOTk2IDI2IDE5IEwgMjYgMTAuNjc1NzgxIEMgMjYgOS43Njc3ODEyIDI1LjIyMTgyOCA5IDI0LjI5ODgyOCA5IEMgMjMuODAzODI4IDkgMjMuNDQwNDA2IDkuMjg2NTkzNyAyMi45NDE0MDYgOS42ODM1OTM4IEMgMjIuMjc5NDA2IDEwLjIwNzU5NCAyMS4yODA4OTEgMTEgMjAuMDg3ODkxIDExIEMgMTkuMjcyODkxIDExIDE4LjQ3NzY4OCAxMC42MTk3MzQgMTcuNTU0Njg4IDEwLjE3NzczNCBDIDE2LjQwMzY4NyA5LjYyNTczNDQgMTUuMDk4MzU5IDkgMTMuNDQzMzU5IDkgQyAxMi4zMDgyNTcgOSAxMS40MjE2ODcgOS4xODgzMzkzIDEwLjcxMjg5MSA5LjQ1NzAzMTIgQyAxMS40ODkwNzEgOC45MTQxODI0IDEyIDguMDE2NzgwMiAxMiA3IEMgMTIgNS4zNDYgMTAuNjU0IDQgOSA0IHogTSA5IDYgQyA5LjU1MiA2IDEwIDYuNDQ5IDEwIDcgQyAxMCA3LjU1MSA5LjU1MiA4IDkgOCBDIDguNDQ4IDggOCA3LjU1MSA4IDcgQyA4IDYuNDQ5IDguNDQ4IDYgOSA2IHogTSAxMy40NDMzNTkgMTEgQyAxNC42NDUzNTkgMTEgMTUuNjM4NDA2IDExLjQ3NjQ2OSAxNi42OTE0MDYgMTEuOTgwNDY5IEMgMTcuNzM2NDA2IDEyLjQ4MjQ2OSAxOC44MTc4OTEgMTMgMjAuMDg3ODkxIDEzIEMgMjEuODQyODkxIDEzIDIzLjE1ODA0NyAxMi4wNTQ0ODQgMjMuOTk4MDQ3IDExLjM5NjQ4NCBMIDIzLjk5ODA0NyAxOS4wNjY0MDYgQyAyMy45OTcwNDcgMTkuMDcwNDA2IDIzLjk1Mjk4NCAxOS4xNDUyNjYgMjMuNzA4OTg0IDE5LjMyMjI2NiBMIDIzLjUwOTc2NiAxOS40NzQ2MDkgQyAyMi45NDI3NjYgMTkuOTEyNjA5IDIxLjc2Mjg5MSAyMC44MjQyMTkgMjAuMDg3ODkxIDIwLjgyNDIxOSBDIDE5LjI0OTg5MSAyMC44MjQyMTkgMTguNDQ2NjI1IDIwLjQ4MjkzNyAxNy41MTU2MjUgMjAuMDg1OTM4IEMgMTYuMzcyNjI1IDE5LjU5NzkzOCAxNS4wNzYzNTkgMTkuMDQ0OTIyIDEzLjQ0MzM1OSAxOS4wNDQ5MjIgQyAxMS44OTEzNTkgMTkuMDQ0OTIyIDEwLjc4NiAxOS4zNTggMTAgMTkuNzUgTCAxMCAxMi4zNjEzMjggQyAxMC4zNDUgMTEuOTA1MzI4IDExLjEzMjM1OSAxMSAxMy40NDMzNTkgMTEgeiIvPjwvc3ZnPg==", zLe = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHBhdGggZD0iTSAxNiA0IEMgMTEuODMyMDMxIDQgOC4xNTIzNDQgNi4xMTMyODEgNiA5LjM0Mzc1IEwgNiA2IEwgNCA2IEwgNCAxMyBMIDExIDEzIEwgMTEgMTEgTCA3LjM3NSAxMSBDIDkuMTAxNTYzIDguMDE5NTMxIDEyLjI5Njg3NSA2IDE2IDYgQyAyMS41MzUxNTYgNiAyNiAxMC40NjQ4NDQgMjYgMTYgQyAyNiAyMS41MzUxNTYgMjEuNTM1MTU2IDI2IDE2IDI2IEMgMTAuNDY0ODQ0IDI2IDYgMjEuNTM1MTU2IDYgMTYgTCA0IDE2IEMgNCAyMi42MTcxODggOS4zODI4MTMgMjggMTYgMjggQyAyMi42MTcxODggMjggMjggMjIuNjE3MTg4IDI4IDE2IEMgMjggOS4zODI4MTMgMjIuNjE3MTg4IDQgMTYgNCBaIE0gMTUgOCBMIDE1IDE3IEwgMjIgMTcgTCAyMiAxNSBMIDE3IDE1IEwgMTcgOCBaIi8+PC9zdmc+Cg==";
const qLe = Ze({
  name: "Header",
  setup(t) {
    const { state: e, updateSearch: n, updateActiveGroup: r } = pn("store"), i = de(() => !e.options.hideSearch), s = de(() => !e.options.hideGroupIcons), a = JSON.parse(JSON.stringify(e.orderedGroupKeys)), o = de(
      () => e.options.staticTexts.placeholder || ""
    ), u = de({
      get: () => e.search,
      set: (l) => n(l)
    }), c = [
      ...e.groups,
      ...Object.keys(e.options.additionalGroups).map((l) => ({
        key: l,
        title: e.options.groupNames[l] ? e.options.groupNames[l] : FN(l)
      }))
    ], d = [];
    return a.forEach((l) => {
      const f = c.findIndex((p) => p.key === l);
      f !== -1 && (d.push(c[f]), c.splice(f, 1));
    }), {
      orderedGroups: d,
      orderedKeys: a,
      searchValue: u,
      updateActiveGroup: r,
      hasSearch: i,
      hasGroupIcons: s,
      placeholder: o,
      icons: {
        smileys_people: RN,
        animals_nature: RLe,
        food_drink: BLe,
        activities: FLe,
        travel_places: ULe,
        objects: $Le,
        symbols: HLe,
        flags: jLe,
        ...e.options.groupIcons,
        recent: zLe
      }
    };
  }
}), VLe = {
  key: 0,
  class: "v3-header"
}, WLe = {
  key: 0,
  class: "v3-groups"
}, QLe = ["onClick"], GLe = ["title"], YLe = ["src"], XLe = {
  key: 1,
  class: "v3-spacing"
}, KLe = {
  key: 2,
  class: "v3-search"
}, ZLe = ["placeholder"];
function JLe(t, e, n, r, i, s) {
  return t.hasGroupIcons || t.hasSearch ? (X(), se("div", VLe, [
    t.hasGroupIcons ? (X(), se("div", WLe, [
      (X(!0), se(wt, null, on(t.orderedGroups, (a) => (X(), se("button", {
        key: a.key,
        type: "button",
        class: vt(["v3-group", {
          "v3-is-hidden": !t.icons[a.key]
        }]),
        onClick: (o) => t.updateActiveGroup(a.key)
      }, [
        W("span", {
          title: a.title,
          class: "v3-icon"
        }, [
          W("img", {
            src: t.icons[a.key],
            alt: ""
          }, null, 8, YLe)
        ], 8, GLe)
      ], 10, QLe))), 128))
    ])) : Fe("", !0),
    t.hasGroupIcons && t.hasSearch ? (X(), se("div", XLe)) : Fe("", !0),
    t.hasSearch ? (X(), se("div", KLe, [
      Gt(W("input", {
        "onUpdate:modelValue": e[0] || (e[0] = (a) => t.searchValue = a),
        type: "text",
        placeholder: t.placeholder
      }, null, 8, ZLe), [
        [ds, t.searchValue]
      ])
    ])) : Fe("", !0)
  ])) : Fe("", !0);
}
var e7e = /* @__PURE__ */ Nh(qLe, [["render", JLe]]);
const t7e = Ze({
  name: "Header",
  setup() {
    const { state: t, updateSkinTone: e } = pn("store"), n = Se(!1), r = Se(!1), i = de(() => t.skinTone), s = de(
      () => t.options.staticTexts.skinTone || "Skin tone"
    ), a = de(() => !t.options.disableSkinTones), o = BN() ? "is-mac" : "", u = de(() => ({
      ...t.emoji,
      src: _N + "/" + t.emoji[ih] + ".png"
    }));
    function c(f = !0) {
      n.value = f;
    }
    function d() {
      n.value = !n.value;
    }
    function l(f) {
      e(f), c(!1);
    }
    return Ct(
      () => t.emoji,
      () => {
        r.value = !1;
      }
    ), {
      emoji: u,
      SKIN_TONES: QNe,
      updateSkinToneState: c,
      skinTone: n,
      stateSkinTone: i,
      selectSkinTone: l,
      toggleSkinToneState: d,
      EMOJI_RESULT_KEY: ih,
      EMOJI_NAME_KEY: Yg,
      skinToneText: s,
      hasSkinTones: a,
      native: t.options.native,
      unicodeToEmoji: wm,
      platform: o,
      hasError: r
    };
  }
}), n7e = { class: "v3-foot-left" }, r7e = { key: 0 }, i7e = ["alt", "src"], s7e = { class: "v3-text" }, a7e = { class: "v3-text" }, o7e = ["onClick"];
function u7e(t, e, n, r, i, s) {
  return X(), se("div", {
    class: "v3-footer",
    onMouseleave: e[2] || (e[2] = (a) => t.updateSkinToneState(!1))
  }, [
    W("div", n7e, [
      W("span", {
        class: vt([t.platform, "v3-icon"])
      }, [
        t.native || t.hasError ? (X(), se("span", r7e, _e(t.unicodeToEmoji(t.emoji.r)), 1)) : (X(), se("img", {
          key: 1,
          alt: t.unicodeToEmoji(t.emoji.r),
          src: t.emoji.src,
          onError: e[0] || (e[0] = (a) => t.hasError = !0)
        }, null, 40, i7e))
      ], 2),
      W("span", s7e, " :" + _e(t.emoji[t.EMOJI_NAME_KEY][1] || t.emoji[t.EMOJI_NAME_KEY][0]) + ": ", 1)
    ]),
    t.hasSkinTones ? (X(), se(wt, { key: 0 }, [
      W("button", {
        type: "button",
        class: "v3-tone",
        onClick: e[1] || (e[1] = (...a) => t.toggleSkinToneState && t.toggleSkinToneState(...a))
      }, [
        W("span", a7e, _e(t.skinToneText), 1),
        W("span", {
          class: vt(`v3-icon v3-tone-${t.stateSkinTone}`)
        }, null, 2)
      ]),
      W("div", {
        class: vt([t.skinTone ? "v3-is-open" : "", "v3-skin-tones"])
      }, [
        (X(!0), se(wt, null, on(t.SKIN_TONES, (a) => (X(), se("button", {
          key: a,
          type: "button",
          class: vt(["v3-skin-tone-" + a, "v3-skin-tone"]),
          onClick: (o) => t.selectSkinTone(a)
        }, null, 10, o7e))), 128))
      ], 2)
    ], 64)) : Fe("", !0)
  ], 32);
}
var l7e = /* @__PURE__ */ Nh(t7e, [["render", u7e]]);
const c7e = Ze({
  name: "PickerRoot",
  components: {
    Header: e7e,
    Body: PLe,
    Footer: l7e
  },
  props: {
    type: {
      type: String,
      default: ""
    },
    text: {
      type: String,
      default: ""
    },
    additionalGroups: {
      type: Object,
      default: () => ({})
    },
    groupOrder: {
      type: Array,
      default: () => []
    },
    groupIcons: {
      type: Object,
      default: () => ({})
    },
    groupNames: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    select: (t) => !0,
    "update:text": (t) => !0
  },
  setup(t, { emit: e }) {
    const n = Se(), r = Se(), i = Se(), s = Se(!1), a = Se(t.text), o = t.type === "input" || t.type === "textarea";
    let u = -1;
    const { state: c } = pn("store"), d = de(() => c.options.colorTheme);
    function l(y) {
      if (o) {
        const b = c.options.mode;
        b === "prepend" ? a.value = y.i + a.value : b === "insert" && u !== -1 ? (a.value = `${a.value.slice(0, u)}${y.i}${a.value.slice(u)}`, u += y.i.length) : a.value += y.i, e("update:text", a.value);
      }
      e("select", y);
    }
    function f() {
      var y;
      n.value && (u = ((y = n.value) == null ? void 0 : y.selectionEnd) || -1);
    }
    function p(y) {
      var b;
      !((b = y.target) != null && b.closest(
        ".v3-input-picker-wrap"
      )) && s.value && (s.value = !1);
    }
    function m() {
      if (r.value && i.value && o) {
        let y = c.options.offset;
        typeof y != "number" && (y = 6), xLe(r.value, i.value, {
          placement: "bottom-end",
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, y]
              }
            }
          ]
        }), document.body.addEventListener("click", p);
      }
    }
    function g(y) {
      a.value = y.target.value || "", e("update:text", a.value);
    }
    return Tr(() => {
      m();
    }), mi(() => {
      document.body.removeEventListener("click", p);
    }), {
      face: RN,
      open: s,
      onSelect: l,
      input: a,
      elem: n,
      updateCursor: f,
      button: r,
      picker: i,
      isInputType: o,
      onChangeText: g,
      colorTheme: d
    };
  }
}), d7e = {
  key: 0,
  class: "v3-input-emoji-picker"
}, f7e = { class: "v3-input-picker-root" }, h7e = ["value"], p7e = ["value"], m7e = ["src"];
function g7e(t, e, n, r, i, s) {
  const a = vo("Header"), o = vo("Body"), u = vo("Footer");
  return t.isInputType ? (X(), se("div", d7e, [
    W("div", f7e, [
      t.type === "input" ? (X(), se("input", {
        key: 0,
        ref: "elem",
        value: t.input,
        type: "text",
        class: "v3-emoji-picker-input",
        onInput: e[0] || (e[0] = (...c) => t.onChangeText && t.onChangeText(...c)),
        onBlur: e[1] || (e[1] = (...c) => t.updateCursor && t.updateCursor(...c))
      }, null, 40, h7e)) : (X(), se("textarea", {
        key: 1,
        ref: "elem",
        value: t.input,
        class: "v3-emoji-picker-textarea",
        onInput: e[2] || (e[2] = (...c) => t.onChangeText && t.onChangeText(...c)),
        onBlur: e[3] || (e[3] = (...c) => t.updateCursor && t.updateCursor(...c))
      }, null, 40, p7e)),
      W("div", {
        class: vt(["v3-input-picker-wrap", t.open ? "v3-picker-is-open" : ""])
      }, [
        W("button", {
          ref: "button",
          type: "button",
          class: "v3-input-picker-icon",
          onClick: e[4] || (e[4] = (c) => t.open = !t.open)
        }, [
          W("img", {
            src: t.face,
            alt: ""
          }, null, 8, m7e)
        ], 512),
        W("div", {
          ref: "picker",
          class: vt(["v3-emoji-picker", "v3-color-theme-" + t.colorTheme])
        }, [
          et(a),
          et(o, { onSelect: t.onSelect }, null, 8, ["onSelect"]),
          et(u)
        ], 2)
      ], 2)
    ])
  ])) : (X(), se("div", {
    key: 1,
    class: vt(["v3-emoji-picker", "v3-color-theme-" + t.colorTheme])
  }, [
    et(a),
    et(o, { onSelect: t.onSelect }, null, 8, ["onSelect"]),
    et(u)
  ], 2));
}
var A7e = /* @__PURE__ */ Nh(c7e, [["render", g7e]]);
const b7e = Ze({
  name: "Picker",
  components: {
    PickerRoot: A7e
  },
  props: {
    native: {
      type: Boolean,
      default: !1
    },
    hideSearch: {
      type: Boolean,
      default: !1
    },
    hideGroupIcons: {
      type: Boolean,
      default: !1
    },
    hideGroupNames: {
      type: Boolean,
      default: !1
    },
    staticTexts: {
      type: Object,
      default: () => ({})
    },
    disableStickyGroupNames: {
      type: Boolean,
      default: !1
    },
    disabledGroups: {
      type: Array,
      default: () => []
    },
    groupNames: {
      type: Object,
      default: () => ({})
    },
    disableSkinTones: {
      type: Boolean,
      default: !1
    },
    text: {
      type: String,
      default: ""
    },
    mode: {
      type: String,
      default: "insert"
    },
    offset: {
      type: Number,
      default: 6
    },
    additionalGroups: {
      type: Object,
      default: () => ({})
    },
    groupOrder: {
      type: Array,
      default: () => []
    },
    groupIcons: {
      type: Object,
      default: () => ({})
    },
    pickerType: {
      type: String,
      default: ""
    },
    displayRecent: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: "light"
    }
  },
  emits: {
    "update:text": (t) => !0,
    select: (t) => !0
  },
  setup(t, { emit: e }) {
    const n = Se(t.text);
    function r(s) {
      n.value = s || "", e("update:text", n.value);
    }
    const i = b9e();
    return i.updateOptions({
      native: t.native,
      hideSearch: t.hideSearch,
      hideGroupIcons: t.hideGroupIcons,
      hideGroupNames: t.hideGroupNames,
      staticTexts: { ...GNe, ...t.staticTexts },
      disableStickyGroupNames: t.disableStickyGroupNames,
      disabledGroups: t.disabledGroups,
      groupNames: { ...EN, ...t.groupNames },
      disableSkinTones: t.disableSkinTones,
      displayRecent: t.displayRecent,
      additionalGroups: t.additionalGroups,
      mode: t.mode,
      offset: t.offset,
      groupOrder: t.groupOrder,
      groupIcons: t.groupIcons,
      colorTheme: YNe.includes(t.theme) ? t.theme : "light"
    }), Ba("store", i), {
      type: t.pickerType,
      input: n,
      onChangeText: r
    };
  }
});
function y7e(t, e, n, r, i, s) {
  const a = vo("picker-root");
  return X(), gt(a, {
    type: t.type,
    text: t.input,
    onSelect: e[0] || (e[0] = (o) => t.$emit("select", o)),
    "onUpdate:text": t.onChangeText
  }, null, 8, ["type", "text", "onUpdate:text"]);
}
var v7e = /* @__PURE__ */ Nh(b7e, [["render", y7e]]);
/*!
 * hash-wasm (https://www.npmjs.com/package/hash-wasm)
 * (c) Dani Biro
 * @license MIT
 */
function wf(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(a) {
      a(s);
    });
  }
  return new (n || (n = Promise))(function(s, a) {
    function o(d) {
      try {
        c(r.next(d));
      } catch (l) {
        a(l);
      }
    }
    function u(d) {
      try {
        c(r.throw(d));
      } catch (l) {
        a(l);
      }
    }
    function c(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    c((r = r.apply(t, [])).next());
  });
}
class rr {
  constructor() {
    this.mutex = Promise.resolve();
  }
  lock() {
    let e = () => {
    };
    return this.mutex = this.mutex.then(() => new Promise(e)), new Promise((n) => {
      e = n;
    });
  }
  dispatch(e) {
    return wf(this, void 0, void 0, function* () {
      const n = yield this.lock();
      try {
        return yield Promise.resolve(e());
      } finally {
        n();
      }
    });
  }
}
var D2;
function T7e() {
  return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global;
}
const Ny = T7e(), M2 = (D2 = Ny.Buffer) !== null && D2 !== void 0 ? D2 : null, _7e = Ny.TextEncoder ? new Ny.TextEncoder() : null;
function UN(t, e) {
  return (t & 15) + (t >> 6 | t >> 3 & 8) << 4 | (e & 15) + (e >> 6 | e >> 3 & 8);
}
function E7e(t, e) {
  const n = e.length >> 1;
  for (let r = 0; r < n; r++) {
    const i = r << 1;
    t[r] = UN(e.charCodeAt(i), e.charCodeAt(i + 1));
  }
}
function x7e(t, e) {
  if (t.length !== e.length * 2)
    return !1;
  for (let n = 0; n < e.length; n++) {
    const r = n << 1;
    if (e[n] !== UN(t.charCodeAt(r), t.charCodeAt(r + 1)))
      return !1;
  }
  return !0;
}
const QC = 87, GC = 48;
function YC(t, e, n) {
  let r = 0;
  for (let i = 0; i < n; i++) {
    let s = e[i] >>> 4;
    t[r++] = s > 9 ? s + QC : s + GC, s = e[i] & 15, t[r++] = s > 9 ? s + QC : s + GC;
  }
  return String.fromCharCode.apply(null, t);
}
const XC = M2 !== null ? (t) => {
  if (typeof t == "string") {
    const e = M2.from(t, "utf8");
    return new Uint8Array(e.buffer, e.byteOffset, e.length);
  }
  if (M2.isBuffer(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.length);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Invalid data type!");
} : (t) => {
  if (typeof t == "string")
    return _7e.encode(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Invalid data type!");
}, KC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", tf = new Uint8Array(256);
for (let t = 0; t < KC.length; t++)
  tf[KC.charCodeAt(t)] = t;
function w7e(t) {
  let e = Math.floor(t.length * 0.75);
  const n = t.length;
  return t[n - 1] === "=" && (e -= 1, t[n - 2] === "=" && (e -= 1)), e;
}
function C7e(t) {
  const e = w7e(t), n = t.length, r = new Uint8Array(e);
  let i = 0;
  for (let s = 0; s < n; s += 4) {
    const a = tf[t.charCodeAt(s)], o = tf[t.charCodeAt(s + 1)], u = tf[t.charCodeAt(s + 2)], c = tf[t.charCodeAt(s + 3)];
    r[i] = a << 2 | o >> 4, i += 1, r[i] = (o & 15) << 4 | u >> 2, i += 1, r[i] = (u & 3) << 6 | c & 63, i += 1;
  }
  return r;
}
const Qp = 16 * 1024, Hd = 4, S7e = new rr(), O2 = /* @__PURE__ */ new Map();
function I7e(t, e) {
  return wf(this, void 0, void 0, function* () {
    let n = null, r = null, i = !1;
    if (typeof WebAssembly > "u")
      throw new Error("WebAssembly is not supported in this environment!");
    const s = (S, M = 0) => {
      r.set(S, M);
    }, a = () => r, o = () => n.exports, u = (S) => {
      n.exports.Hash_SetMemorySize(S);
      const M = n.exports.Hash_GetBuffer(), O = n.exports.memory.buffer;
      r = new Uint8Array(O, M, S);
    }, c = () => new DataView(n.exports.memory.buffer).getUint32(n.exports.STATE_SIZE, !0), d = S7e.dispatch(() => wf(this, void 0, void 0, function* () {
      if (!O2.has(t.name)) {
        const M = C7e(t.data), O = WebAssembly.compile(M);
        O2.set(t.name, O);
      }
      const S = yield O2.get(t.name);
      n = yield WebAssembly.instantiate(S, {
        // env: {
        //   emscripten_memcpy_big: (dest, src, num) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     memView.set(memView.subarray(src, src + num), dest);
        //   },
        //   print_memory: (offset, len) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     console.log('print_int32', memView.subarray(offset, offset + len));
        //   },
        // },
      });
    })), l = () => wf(this, void 0, void 0, function* () {
      n || (yield d);
      const S = n.exports.Hash_GetBuffer(), M = n.exports.memory.buffer;
      r = new Uint8Array(M, S, Qp);
    }), f = (S = null) => {
      i = !0, n.exports.Hash_Init(S);
    }, p = (S) => {
      let M = 0;
      for (; M < S.length; ) {
        const O = S.subarray(M, M + Qp);
        M += O.length, r.set(O), n.exports.Hash_Update(O.length);
      }
    }, m = (S) => {
      if (!i)
        throw new Error("update() called before init()");
      const M = XC(S);
      p(M);
    }, g = new Uint8Array(e * 2), y = (S, M = null) => {
      if (!i)
        throw new Error("digest() called before init()");
      return i = !1, n.exports.Hash_Final(M), S === "binary" ? r.slice(0, e) : YC(g, r, e);
    }, b = () => {
      if (!i)
        throw new Error("save() can only be called after init() and before digest()");
      const S = n.exports.Hash_GetState(), M = c(), O = n.exports.memory.buffer, T = new Uint8Array(O, S, M), N = new Uint8Array(Hd + M);
      return E7e(N, t.hash), N.set(T, Hd), N;
    }, E = (S) => {
      if (!(S instanceof Uint8Array))
        throw new Error("load() expects an Uint8Array generated by save()");
      const M = n.exports.Hash_GetState(), O = c(), T = Hd + O, N = n.exports.memory.buffer;
      if (S.length !== T)
        throw new Error(`Bad state length (expected ${T} bytes, got ${S.length})`);
      if (!x7e(t.hash, S.subarray(0, Hd)))
        throw new Error("This state was written by an incompatible hash implementation");
      const H = S.subarray(Hd);
      new Uint8Array(N, M, O).set(H), i = !0;
    }, v = (S) => typeof S == "string" ? S.length < Qp / 4 : S.byteLength < Qp;
    let _ = v;
    switch (t.name) {
      case "argon2":
      case "scrypt":
        _ = () => !0;
        break;
      case "blake2b":
      case "blake2s":
        _ = (S, M) => M <= 512 && v(S);
        break;
      case "blake3":
        _ = (S, M) => M === 0 && v(S);
        break;
      case "xxhash64":
      // cannot simplify
      case "xxhash3":
      case "xxhash128":
      case "crc64":
        _ = () => !1;
        break;
    }
    const D = (S, M = null, O = null) => {
      if (!_(S, M))
        return f(M), m(S), y("hex", O);
      const T = XC(S);
      return r.set(T), n.exports.Hash_Calculate(T.length, M, O), YC(g, r, e);
    };
    return yield l(), {
      getMemory: a,
      writeMemory: s,
      getExports: o,
      setMemorySize: u,
      init: f,
      update: m,
      digest: y,
      save: b,
      load: E,
      calculate: D,
      hashLength: e
    };
  });
}
function k7e(t, e, n) {
  return wf(this, void 0, void 0, function* () {
    const r = yield t.lock(), i = yield I7e(e, n);
    return r(), i;
  });
}
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
var D7e = "sha1", M7e = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwkIAAECAwECAAEFBAEBAgIGDgJ/AUHgiQULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAILSGFzaF9VcGRhdGUABApIYXNoX0ZpbmFsAAUNSGFzaF9HZXRTdGF0ZQAGDkhhc2hfQ2FsY3VsYXRlAAcKU1RBVEVfU0laRQMBCpoqCAUAQYAJC68iCgF+An8BfgF/AX4DfwF+AX8Bfkd/QQAgACkDECIBQiCIpyICQRh0IAJBgP4DcUEIdHIgAUIoiKdBgP4DcSABQjiIp3JyIgMgACkDCCIEQiCIpyICQRh0IAJBgP4DcUEIdHIgBEIoiKdBgP4DcSAEQjiIp3JyIgVzIAApAygiBkIgiKciAkEYdCACQYD+A3FBCHRyIAZCKIinQYD+A3EgBkI4iKdyciIHcyAEpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciIIIAApAwAiBKciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCXMgACkDICIKpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciILcyAAKQMwIgxCIIinIgJBGHQgAkGA/gNxQQh0ciAMQiiIp0GA/gNxIAxCOIincnIiAnNBAXciDXNBAXciDiAFIARCIIinIg9BGHQgD0GA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiEHMgCkIgiKciD0EYdCAPQYD+A3FBCHRyIApCKIinQYD+A3EgCkI4iKdyciIRcyAAKQM4IgSnIg9BGHQgD0GA/gNxQQh0ciAPQQh2QYD+A3EgD0EYdnJyIg9zQQF3IhJzIAcgEXMgEnMgCyAAKQMYIgqnIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIhNzIA9zIA5zQQF3IgBzQQF3IhRzIA0gD3MgAHMgAiAHcyAOcyAGpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIWIAtzIA1zIApCIIinIhVBGHQgFUGA/gNxQQh0ciAKQiiIp0GA/gNxIApCOIincnIiFyADcyACcyABpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIYIAhzIBZzIARCIIinIhVBGHQgFUGA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiFXNBAXciGXNBAXciGnNBAXciG3NBAXciHHNBAXciHXNBAXciHiASIBVzIBEgF3MgFXMgEyAYcyAMpyIfQRh0IB9BgP4DcUEIdHIgH0EIdkGA/gNxIB9BGHZyciIgcyASc0EBdyIfc0EBdyIhcyAPICBzIB9zIBRzQQF3IiJzQQF3IiNzIBQgIXMgI3MgACAfcyAicyAec0EBdyIkc0EBdyIlcyAdICJzICRzIBwgFHMgHnMgGyAAcyAdcyAaIA5zIBxzIBkgDXMgG3MgFSACcyAacyAgIBZzIBlzICFzQQF3IiZzQQF3IidzQQF3IihzQQF3IilzQQF3IipzQQF3IitzQQF3IixzQQF3Ii0gIyAncyAhIBpzICdzIB8gGXMgJnMgI3NBAXciLnNBAXciL3MgIiAmcyAucyAlc0EBdyIwc0EBdyIxcyAlIC9zIDFzICQgLnMgMHMgLXNBAXciMnNBAXciM3MgLCAwcyAycyArICVzIC1zICogJHMgLHMgKSAecyArcyAoIB1zICpzICcgHHMgKXMgJiAbcyAocyAvc0EBdyI0c0EBdyI1c0EBdyI2c0EBdyI3c0EBdyI4c0EBdyI5c0EBdyI6c0EBdyI7IDEgNXMgLyApcyA1cyAuIChzIDRzIDFzQQF3IjxzQQF3Ij1zIDAgNHMgPHMgM3NBAXciPnNBAXciP3MgMyA9cyA/cyAyIDxzID5zIDtzQQF3IkBzQQF3IkFzIDogPnMgQHMgOSAzcyA7cyA4IDJzIDpzIDcgLXMgOXMgNiAscyA4cyA1ICtzIDdzIDQgKnMgNnMgPXNBAXciQnNBAXciQ3NBAXciRHNBAXciRXNBAXciRnNBAXciR3NBAXciSHNBAXciSSA+IEJzIDwgNnMgQnMgP3NBAXciSnMgQXNBAXciSyA9IDdzIENzIEpzQQF3IkwgRCA5IDIgMSA0ICkgHSAUIB8gFSAWQQAoAoCJASJNQQV3QQAoApCJASJOaiAJakEAKAKMiQEiT0EAKAKIiQEiCXNBACgChIkBIlBxIE9zakGZ84nUBWoiUUEedyJSIANqIFBBHnciAyAFaiBPIAMgCXMgTXEgCXNqIBBqIFFBBXdqQZnzidQFaiIQIFIgTUEedyIFc3EgBXNqIAkgCGogUSADIAVzcSADc2ogEEEFd2pBmfOJ1AVqIlFBBXdqQZnzidQFaiJTIFFBHnciAyAQQR53IghzcSAIc2ogBSAYaiBRIAggUnNxIFJzaiBTQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhhBHnciUmogU0EedyIWIAtqIAggE2ogBSAWIANzcSADc2ogGEEFd2pBmfOJ1AVqIgggUiAFQR53IgtzcSALc2ogAyAXaiAYIAsgFnNxIBZzaiAIQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhMgBUEedyIWIAhBHnciA3NxIANzaiALIBFqIAUgAyBSc3EgUnNqIBNBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiUkEedyILaiACIBNBHnciFWogByADaiARIBUgFnNxIBZzaiBSQQV3akGZ84nUBWoiByALIBFBHnciAnNxIAJzaiAgIBZqIFIgAiAVc3EgFXNqIAdBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiFiARQR53IhUgB0EedyIHc3EgB3NqIA8gAmogESAHIAtzcSALc2ogFkEFd2pBmfOJ1AVqIgtBBXdqQZnzidQFaiIRQR53IgJqIBIgFWogESALQR53Ig8gFkEedyISc3EgEnNqIA0gB2ogCyASIBVzcSAVc2ogEUEFd2pBmfOJ1AVqIg1BBXdqQZnzidQFaiIVQR53Ih8gDUEedyIHcyAZIBJqIA0gAiAPc3EgD3NqIBVBBXdqQZnzidQFaiINc2ogDiAPaiAVIAcgAnNxIAJzaiANQQV3akGZ84nUBWoiAkEFd2pBodfn9gZqIg5BHnciD2ogACAfaiACQR53IgAgDUEedyINcyAOc2ogGiAHaiANIB9zIAJzaiAOQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg5BHnciEiACQR53IhRzICEgDWogDyAAcyACc2ogDkEFd2pBodfn9gZqIgJzaiAbIABqIBQgD3MgDnNqIAJBBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyIOaiAcIBJqIABBHnciDyACQR53IgJzIA1zaiAmIBRqIAIgEnMgAHNqIA1BBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyISIABBHnciFHMgIiACaiAOIA9zIABzaiANQQV3akGh1+f2BmoiAHNqICcgD2ogFCAOcyANc2ogAEEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53Ig5qICggEmogAkEedyIPIABBHnciAHMgDXNqICMgFGogACAScyACc2ogDUEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53IhIgAkEedyIUcyAeIABqIA4gD3MgAnNqIA1BBXdqQaHX5/YGaiIAc2ogLiAPaiAUIA5zIA1zaiAAQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg1BHnciDmogKiAAQR53IgBqIA4gAkEedyIPcyAkIBRqIAAgEnMgAnNqIA1BBXdqQaHX5/YGaiIUc2ogLyASaiAPIABzIA1zaiAUQQV3akGh1+f2BmoiDUEFd2pBodfn9gZqIgAgDUEedyICciAUQR53IhJxIAAgAnFyaiAlIA9qIBIgDnMgDXNqIABBBXdqQaHX5/YGaiINQQV3akHc+e74eGoiDkEedyIPaiA1IABBHnciAGogKyASaiANIAByIAJxIA0gAHFyaiAOQQV3akHc+e74eGoiEiAPciANQR53Ig1xIBIgD3FyaiAwIAJqIA4gDXIgAHEgDiANcXJqIBJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAiAAQR53Ig5yIBJBHnciEnEgAiAOcXJqICwgDWogACASciAPcSAAIBJxcmogAkEFd2pB3Pnu+HhqIgBBBXdqQdz57vh4aiINQR53Ig9qIDwgAkEedyICaiA2IBJqIAAgAnIgDnEgACACcXJqIA1BBXdqQdz57vh4aiISIA9yIABBHnciAHEgEiAPcXJqIC0gDmogDSAAciACcSANIABxcmogEkEFd2pB3Pnu+HhqIgJBBXdqQdz57vh4aiINIAJBHnciDnIgEkEedyIScSANIA5xcmogNyAAaiACIBJyIA9xIAIgEnFyaiANQQV3akHc+e74eGoiAEEFd2pB3Pnu+HhqIgJBHnciD2ogMyANQR53Ig1qID0gEmogACANciAOcSAAIA1xcmogAkEFd2pB3Pnu+HhqIhIgD3IgAEEedyIAcSASIA9xcmogOCAOaiACIAByIA1xIAIgAHFyaiASQQV3akHc+e74eGoiAkEFd2pB3Pnu+HhqIg0gAkEedyIOciASQR53IhJxIA0gDnFyaiBCIABqIAIgEnIgD3EgAiAScXJqIA1BBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyIPaiBDIA5qIAIgAEEedyIUciANQR53Ig1xIAIgFHFyaiA+IBJqIAAgDXIgDnEgACANcXJqIAJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyISIABBHnciDnMgOiANaiAAIA9yIBRxIAAgD3FyaiACQQV3akHc+e74eGoiAHNqID8gFGogAiAOciAPcSACIA5xcmogAEEFd2pB3Pnu+HhqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEogEmogAkEedyIUIABBHnciAHMgDXNqIDsgDmogACAScyACc2ogDUEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig4gAkEedyIScyBFIABqIA8gFHMgAnNqIA1BBXdqQdaDi9N8aiIAc2ogQCAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciD2ogQSAOaiACQR53IhQgAEEedyIAcyANc2ogRiASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzIEIgOHMgRHMgTHNBAXciFSAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEcgFGogEiAPcyANc2ogAEEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEggDmogAkEedyIUIABBHnciAHMgDXNqIEMgOXMgRXMgFXNBAXciGSASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzID8gQ3MgTHMgS3NBAXciGiAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEQgOnMgRnMgGXNBAXciGyAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDyBOajYCkIkBQQAgTyBKIERzIBVzIBpzQQF3IhQgEmogAEEedyIAIA5zIAJzaiANQQV3akHWg4vTfGoiEkEedyIVajYCjIkBQQAgCSBFIDtzIEdzIBtzQQF3IA5qIAJBHnciAiAAcyANc2ogEkEFd2pB1oOL03xqIg1BHndqNgKIiQFBACBQIEAgSnMgS3MgSXNBAXcgAGogDyACcyASc2ogDUEFd2pB1oOL03xqIgBqNgKEiQFBACBNIEwgRXMgGXMgFHNBAXdqIAJqIBUgD3MgDXNqIABBBXdqQdaDi9N8ajYCgIkBCzoAQQBC/rnrxemOlZkQNwKIiQFBAEKBxpS6lvHq5m83AoCJAUEAQvDDy54MNwKQiQFBAEEANgKYiQELqAMBCH9BACECQQBBACgClIkBIgMgAUEDdGoiBDYClIkBQQBBACgCmIkBIAQgA0lqIAFBHXZqNgKYiQECQCADQQN2QT9xIgUgAWpBwABJDQBBwAAgBWsiAkEDcSEGQQAhAwJAIAVBP3NBA0kNACAFQYCJAWohByACQfwAcSEIQQAhAwNAIAcgA2oiBEEcaiAAIANqIgktAAA6AAAgBEEdaiAJQQFqLQAAOgAAIARBHmogCUECai0AADoAACAEQR9qIAlBA2otAAA6AAAgCCADQQRqIgNHDQALCwJAIAZFDQAgACADaiEEIAMgBWpBnIkBaiEDA0AgAyAELQAAOgAAIARBAWohBCADQQFqIQMgBkF/aiIGDQALC0GciQEQASAFQf8AcyEDQQAhBSADIAFPDQADQCAAIAJqEAEgAkH/AGohAyACQcAAaiIEIQIgAyABSQ0ACyAEIQILAkAgASACRg0AIAEgAmshCSAAIAJqIQIgBUGciQFqIQNBACEEA0AgAyACLQAAOgAAIAJBAWohAiADQQFqIQMgCSAEQQFqIgRB/wFxSw0ACwsLCQBBgAkgABADC6YDAQJ/IwBBEGsiACQAIABBgAE6AAcgAEEAKAKYiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAggAEEAKAKUiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAwgAEEHakEBEAMCQEEAKAKUiQFB+ANxQcADRg0AA0AgAEEAOgAHIABBB2pBARADQQAoApSJAUH4A3FBwANHDQALCyAAQQhqQQgQA0EAQQAoAoCJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAlBAEEAKAKEiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AoQJQQBBACgCiIkBIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyNgKICUEAQQAoAoyJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCjAlBAEEAKAKQiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2ApAJIABBEGokAAsGAEGAiQELQwBBAEL+uevF6Y6VmRA3AoiJAUEAQoHGlLqW8ermbzcCgIkBQQBC8MPLngw3ApCJAUEAQQA2ApiJAUGACSAAEAMQBQsLCwEAQYAICwRcAAAA", O7e = "6b530c24", N7e = {
  name: D7e,
  data: M7e,
  hash: O7e
};
const L7e = new rr();
let Gp = null;
function Ly(t) {
  if (Gp === null)
    return k7e(L7e, N7e, 20).then((e) => (Gp = e, Gp.calculate(t)));
  try {
    const e = Gp.calculate(t);
    return Promise.resolve(e);
  } catch (e) {
    return Promise.reject(e);
  }
}
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
new rr();
const N2 = (t) => new Promise((e, n) => {
  const r = new FileReader();
  r.onload = () => {
    const i = new Image();
    i.src = r.result, i.onload = async () => {
      e({
        id: await Ly(i.src),
        width: i.width,
        height: i.height,
        thumbnailUrl: i.src,
        originalUrl: i.src
      });
    }, i.onerror = () => n;
  }, r.onerror = () => {
    n(r.error);
  }, r.readAsDataURL(t);
}), P7e = (t) => new Promise((e, n) => {
  const r = document.createElement("canvas"), i = r.getContext("2d");
  if (!i) {
    n(new Error("Could not get canvas context"));
    return;
  }
  const s = document.createElement("video");
  s.src = URL.createObjectURL(t), s.autoplay = !0, s.onloadedmetadata = () => {
    r.width = s.videoWidth, r.height = s.videoHeight;
  }, s.onloadeddata = () => {
    i.drawImage(s, 0, 0, r.width, r.height), r.toBlob(async (a) => {
      if (!a) {
        n(new Error("Could not create blob"));
        return;
      }
      const o = new File([a], "snapshot.jpg", {
        type: "image/jpeg"
      }), u = new FileReader();
      u.readAsDataURL(a), u.onloadend = async () => {
        e({
          id: await Ly(s.src),
          width: r.width,
          height: r.height,
          duration: s.duration,
          thumbnailUrl: u.result,
          originalUrl: "",
          thumbnailFile: {
            id: await Ly(r.toDataURL()),
            file: o
          }
        });
      };
    }, "image/jpeg");
  }, s.onerror = () => n;
}), Kg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFSElEQVR4nO1azW9bRRBfia8jggKlfPSAACFF4f8AKkQ/0lYFxAFw6lnHeMYNCRdmbJqkEtAol6KKK4iqd+DAAYFEKyq+BEJUcKINLVAqoCQF0jageXYav33P4a3f87Mj/JNWSuzd2R3v7MxvdtaYAQYYYIAB/qew43wHVOVJIJkFlPct8Ukg+dWS/KMNSH4HlG+A5D2LfLBEsqtQ2b/JrCdYO73BEpNF/sQSL68ol7QByhWL8pElea4wceBG068Yxf13WuRDFuVPXyXXaH9YkrlyeWqj6Rcw8/UWWYD4YoaKhhvyBSCeLBQOX9dTZS3Wh4H4y/aL5ctAfMyiTBWrvA0q9aHi5MxNunBt+nfwWZW3aR8gOR6YdHvFT1ji+3uibIlkFyAvtFnYKYsyoWbuK3fseb5LdxNQTrc3c95i8gQgl+McEhD/bKtcUDPP5KhUeK9FORdnOfqdyQMWuRLrXUneROSbM5/PTm8AkrdilF4uoTxtugmo8o7oGeMlS/xM961KRhtzhXe6RPxYNx3UReeXXixVaw+ZnADID+ucjr/4rTxevy/TicbG5m6IemNeylPZFRSrtUfcnQbkz5j52swmAZJazBnquhm3Q+DMogytmonwcpk3R0wZ+Q3TYwDyETdcwT6+PQPB8roberrhjX1RIL4FiH9xdvnlVEL3Vvm2CDeucsH0CYrI4JzlBWVvHQu0KBMug8qCVGTqTB1GBiTFjgVaks/DCstE4rFY2wrEP1rieYu17Qn6b7fEZ7SpJ046j9JQR+HjphMUK3yPG+R9uLFF+SlEBZH3tO/Le4I+q2fxh8TrpJfuDpMhXh4bm7o16firsBV5ynFWx4wHwgpfVXp3tB/vblW22XfeZy4g+bh1fIlqIz7jAwDKYcecp4wHdFJXEUC5pFlWOOOSS9Ef5r+PQCssyozjaw76jA9gUT4IC6ltNZ6ACu+MUwhIHm/y8sh3JeQnvOep8g4nJr/tK8MAyfeh3anUh7yFNE3WVUz/j/sszuSTzVEfdsLTtx0IkVD8TUM24k23val3QkKc43fOW4h1Evy08bdhdm56t2riaeOx42D/8hIwMnL0GndhqRWOPc9N867wzp4qrHDvq9KZdG1kLZPu1Flla9LIp9ar07Ik33kLAeIPexGWtDSTNiwB8jud7Mwh51xM+40PuHEuxAOID4TXKrM+4wPojWAaUm5Rzqaglmf85tIL+tbj14ETLJd5s7M7V/SSPPEigsyns+TBR+HgRsZJHjSPTzo+BIvylWPWkyYhtDqwku75poc+lQWL8kIaSwwBUMadXT7dbxcAQb7dska9BelYYLk8tRFQ/g6dr7xKHAkAyCXHOy9opSKdUJLXHJM5r4He9EPhPVJ34ldSCy6r83ISCa31mB4DiI+GeQJfyOSaVmGRX4zhwKOmR7AktmsX8S23g1875rOktR6TM9SDR2gpyaeZvw6ASn0opgC+mKfSjVAXLqY1XgLxvV2ZsNSggtFyaQ6eW804loYSP5prKLCrIeFIN7y3XrlGHFSTUQHKsyavJw8Q8/hEaz0a+PXMZ+M3uKRhMEbZy7kpu4JGetfmUQvxvNJQvSQ3ntAxDboYZlCtZ7brZtwOJeIHgPiLeKUbCUdwSY4yE+SsWB/WmxOlp9r07+I+fjD48TTFQz6x1rMl9cZdc1BJoeFAnwlq4G+30Azaoj5+6yceb4KnhyRzkTcYKZoeGUB5NTMG1bVCtTo1p96TvPGypngahvqh8O6dbQWxm2TWkrzbfD58XjOwoAUemE/qd9pH+3acvA8wwAADDGDWP/4FAPVu0JK6ZhcAAAAASUVORK5CYII=", R7e = {
  key: 0,
  class: "mb-3 flex gap-2 rounded-lg bg-gray-200 p-2 dark:bg-zinc-600"
}, B7e = { class: "flex flex-col gap-1" }, F7e = { class: "text-sm font-bold text-gray-600 dark:text-gray-300" }, U7e = { class: "multiline-ellipsis text-xs text-gray-500 dark:text-gray-300" }, $7e = { class: "ml-auto flex shrink-0 gap-2" }, H7e = { key: 0 }, j7e = { key: 1 }, z7e = {
  src: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
  class: "h-[2.8rem] w-[2.8rem] border-0 object-contain"
}, q7e = {
  key: 2,
  class: "h-10 w-10 rounded object-cover"
}, V7e = /* @__PURE__ */ Ze({
  __name: "ReplyMessagePreview",
  setup(t) {
    const e = Yt(), n = de(() => {
      var d;
      const { replyId: c } = e.state.imkit;
      return (d = e.state.imkit.messageMultiList.main) == null ? void 0 : d.map.get(c);
    }), r = de(() => {
      const c = n.value;
      if (c)
        return e.state.imkit.users[c.senderId];
    }), i = de(() => {
      if (n.value.type === ft.Text)
        return n.value.text;
      if (n.value.type === ft.Image || n.value.type === ft.Sticker || n.value.type === ft.Video) {
        const { t: c } = Ri();
        return {
          // [MessageType.Text]: t('text'),
          [ft.Image]: c("image"),
          [ft.Video]: c("video"),
          [ft.Sticker]: c("sticker")
        }[n.value.type];
      }
      return "";
    }), s = de(() => {
      if (n.value.type === ft.Image)
        return n.value.images[0];
    }), a = de(() => n.value), o = de(() => n.value), u = () => {
      e.commit("imkit/setState", { replyId: "" });
    };
    return (c, d) => {
      var f, p, m;
      const l = Mc("src");
      return n.value ? (X(), se("div", R7e, [
        et(Zr, {
          class: "row-span-2 h-6 w-6 shrink-0 rounded-lg bg-gray-300 text-sm",
          url: ((f = r.value) == null ? void 0 : f.avatarUrl) ?? "",
          name: ((p = r.value) == null ? void 0 : p.nickname) ?? ""
        }, null, 8, ["url", "name"]),
        W("div", B7e, [
          W("div", F7e, _e((m = r.value) == null ? void 0 : m.nickname), 1),
          W("div", U7e, _e(i.value), 1)
        ]),
        W("div", $7e, [
          n.value.type === ke(ft).Sticker ? (X(), se("div", H7e, [
            et(oD, {
              class: vt({
                "h-[2.8rem] w-[2.8rem]": !0
              }),
              message: a.value
            }, null, 8, ["message"])
          ])) : Fe("", !0),
          n.value.type === ke(ft).Video ? (X(), se("div", j7e, [
            Gt(W("img", z7e, null, 512), [
              [l, o.value.video.thumbnailUrl]
            ])
          ])) : Fe("", !0),
          s.value ? Gt((X(), se("img", q7e, null, 512)), [
            [l, s.value.thumbnailUrl]
          ]) : Fe("", !0),
          W("img", {
            src: Kg,
            class: "h-5 w-5 cursor-pointer text-gray-400",
            onClick: u
          })
        ])
      ])) : Fe("", !0);
    };
  }
}), W7e = /* @__PURE__ */ mn(V7e, [["__scopeId", "data-v-2372bd67"]]);
function Lh(t, e, n) {
  var r = n || {}, i = r.noTrailing, s = i === void 0 ? !1 : i, a = r.noLeading, o = a === void 0 ? !1 : a, u = r.debounceMode, c = u === void 0 ? void 0 : u, d, l = !1, f = 0;
  function p() {
    d && clearTimeout(d);
  }
  function m(y) {
    var b = y || {}, E = b.upcomingOnly, v = E === void 0 ? !1 : E;
    p(), l = !v;
  }
  function g() {
    for (var y = arguments.length, b = new Array(y), E = 0; E < y; E++)
      b[E] = arguments[E];
    var v = this, _ = Date.now() - f;
    if (l)
      return;
    function D() {
      f = Date.now(), e.apply(v, b);
    }
    function S() {
      d = void 0;
    }
    !o && c && !d && D(), p(), c === void 0 && _ > t ? o ? (f = Date.now(), s || (d = setTimeout(c ? S : D, t))) : D() : s !== !0 && (d = setTimeout(c ? S : D, c === void 0 ? t - _ : t));
  }
  return g.cancel = m, g;
}
function x_(t, e, n) {
  var r = n || {}, i = r.atBegin, s = i === void 0 ? !1 : i;
  return Lh(t, e, {
    debounceMode: s !== !1
  });
}
var $N = /* @__PURE__ */ ((t) => (t[t.Map = 0] = "Map", t[t.CurrentPosition = 1] = "CurrentPosition", t))($N || {});
class Yp {
  constructor(e, n, r = null) {
    Ke(this, "lat");
    Ke(this, "lng");
    Ke(this, "address");
    this.lat = e, this.lng = n, this.address = r;
  }
  get isValid() {
    return this.address !== null;
  }
}
const Q7e = Ze({
  components: {
    GoogleMap: XM,
    CustomMarker: KM,
    CloseSvg: Br,
    VueFinalModal: pr
  },
  setup() {
    const t = $n(), { t: e } = Ri(), n = Yt(), r = n.state.imkit.config.mapApiKey, i = Se(), s = Se(new Yp(21.30895, -157.826182)), a = Se({ lat: s.value.lat, lng: s.value.lng }), o = de(() => ({
      position: {
        lat: s.value.lat,
        lng: s.value.lng
      }
    })), u = Se(""), c = Se(!1), d = Se(10), l = Se(!1), f = Se(""), p = () => new Promise((b, E) => {
      c.value = !0, navigator.geolocation.getCurrentPosition(
        (v) => {
          let { latitude: _, longitude: D } = v.coords;
          f.value = "", c.value = !1, b({ lat: _, lng: D });
        },
        (v) => {
          switch (c.value = !1, v.code) {
            case v.PERMISSION_DENIED:
              f.value = e(
                "noAccessLocationPermission"
              );
              break;
            case v.POSITION_UNAVAILABLE:
              f.value = e(
                "locationInfoUnavailable"
              );
              break;
            case v.TIMEOUT:
              f.value = e(
                "requestLocationTimeout"
              );
              break;
          }
          E(v);
        },
        {
          enableHighAccuracy: !0,
          timeout: 1e4,
          maximumAge: 0
        }
      );
    }), m = async (b, E) => {
      try {
        const { data: v } = await Qn.get(
          `https://maps.googleapis.com/maps/api/geocode/json?latlng=${b},${E}&key=${r}`
        );
        if (v.error_message)
          throw new Error(v.error_message);
        return v.results[0].formatted_address;
      } catch (v) {
        throw f.value = e("addressUnavailable"), v;
      }
    }, g = Lh(
      700,
      async (b) => {
        var E, v;
        try {
          if (b === 0) {
            const S = (E = i.value) == null ? void 0 : E.map.getCenter();
            if (S) {
              const { lat: M, lng: O } = S;
              s.value = new Yp(M(), O());
            }
          } else if (b === 1) {
            const { lat: S, lng: M } = await p();
            s.value = new Yp(S, M), d.value = 17, (v = i.value) == null || v.map.panTo({ lat: S, lng: M });
          }
          let { lat: _, lng: D } = s.value;
          D = ((D + 180) % 360 + 360) % 360 - 180, _ = Math.max(Math.min(_, 90), -90), u.value = await m(_, D), s.value = new Yp(_, D, u.value);
        } catch (_) {
          console.error(_);
        }
      },
      { noLeading: !1, noTrailing: !1 }
    ), y = async () => {
      l.value = !0;
      const b = {
        roomId: n.state.imkit.selectedRoomId,
        messageType: "location",
        message: u.value,
        latitude: o.value.position.lat,
        longitude: o.value.position.lng
      };
      t.closeAll(), await n.dispatch("imkit/sendMessage", b), l.value = !1;
    };
    return g(
      1
      /* CurrentPosition */
    ), {
      vfm: t,
      t: e,
      apiKey: r,
      mapRef: i,
      location: s,
      center: a,
      markerOptions: o,
      address: u,
      isGettingCurrentPosition: c,
      zoom: d,
      isRequesting: l,
      geolocationPositionErrorMessage: f,
      debounceLocationChange: g,
      LocationSource: $N,
      send: y
    };
  }
}), G7e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAACXElEQVR4nO2Zv2sUQRTHH4qKhYWFiljYSqLVFbl9M3aiQbAzWFgGrA0Wlrvz7oKKRLAMWomN9w8o2AdLG7EJgj8awUKy995GRFcWklxiSLxzf8zMMh/49vtlZt/37XcBAoFAIBAIBAL7oyidVsRGGXnUpfQCtBF8kB9TSTaviFcUSb4lwxLF6XloC2gkQuKnSJzuMLpNSPwQfEYvrp1A4gUkfreXyb9OOQHviPMDupddQuJnxTUdy+iW0mnwhW6fz2iSu2j4w2QmN8Ur4DpTcX5YGb6GJAMk/vl/RjeUZPPgKlG8fg4N31ckX0uZHA2rtJje4BLdpfyoNjKHhl8rw7+rMDoaVvIEXEETd5BkWRleq9TkdvW5a9fkve/HNfEtNPK2NpOjYfXewziRMu/vgmdxImVO90exnPgVJ1TmdGXgVZyokorM8EotRjGRG7u+TiwLiT8Wc6N6szS8attcox8KiuSOdXO7xL+inpytxfDF/vC0Mrxq3+QOvYK6p7LeXAvtm82LZ4GmV0UkzqwYNvJt9nF+BJpmZjE9VSwciuRzw+/vEthkqvHr7lCroWu/7o62GjN1XXeXW42qr7uTrcZ+IMmb1rQa44CJ3PS61ZiUznJ+SBn54lerUZJi4fei1aiKKE5PouF1J1uNulDEzyc6XcMvwGc0cWciw73sMvgOjhlRaPjT3CA/CL6DY0YUksTQBjpjRVSNrYaLEYVGXkKbiP4RURHxdWgbaq+IstVq2Isoy61G8xHlUKtRf0Q52mpU/GNu1UoFa4uNsv+27g1nrT1EIBAIBAJghT+Mm9s2KhDbfwAAAABJRU5ErkJggg==", HN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAACy0lEQVR4nO1Zu24TQRRdAaGg5FHx+AsQfIgFgj5NZOeeSQGi2Y7QWiQKiCaW0iFCAaHhD1JEAoUPIKQiMRKR7Jld4wy66weOsbUzuzO7RvKRrmTJo/U5O/feOXMdBHPMMUdu6ErlfHt5+Z4ieiqBt5LoqyT6KYE4id7nff6O17SAuzoMzwVloy3ETUn0XBEdKkBbxncJrLaq1RuFEz+pVq8p4JUkijIQPxOy94yNEyGuFkI+Ah5KomZe4hPiOAIeeCOuFxcXFPDaA3F9Johe8m+5Jn9JAh+9k8cwrXb4N12RXyiSvPobn3QYXswtoJC0wdTYyEW+TfSoRPKaIxLifibyv5aWriiio7IFSKJmphbLfb5s8moQROtW5Pl0tDqkhNBxvW5MKFkrhM0uRO1a7ZaxgMQeWJD/vburdberO1tb6eQ3N5O13b09rVZWzEUAq0bk2WSxT7EiP0CKiAH54fI9CxFEh2waUwUkrtIiFUYJDUTEjca/axuNyWvrFqkH3EkVwHbXpsDG3+qknZi2JjZIubFdeGKS/9tWD00R4Yw8kjp4ky4A2Ld98FQRp6e9cEBe9brRF5MdyGyVJ4pwRF71UujIRECuS0oiYvyt93cjF3kkKaRKFdApSEDTZwp1vKcQ/Bdxx3MRbzsh3y9Yk3NCuWyjrg6y0YJ1KOJxqgAeOs2slajVbpuZOaKDrGYu9mXmgG/G0zy2rlnsdOzTThM9MyI/kxcaQLWA64ENeCJgWWD+guhFYAsNXJ6FS70CjjPPTXlWWbaASIhKkAc8qyxRwFqQF3wPlcC7oslL4IMOwwu5BQyHu0Q7hZEneu9suDs2Xi+iM605e/OTwLNKT93pR+6CtZybrvMB4yDXFfd5bttB0eDTMbEdpt5pNIgO2B5Yn7A+wCaLh048t2HPzhcPvtmxHelHUwKf+Tu2xOwqZ+Jv1jnmCP5//AFGuxmMzLZJIgAAAABJRU5ErkJggg==", Y7e = { class: "relative flex justify-center" }, X7e = {
  key: 0,
  class: "absolute bottom-2 flex items-center gap-1 rounded-full bg-white/85 p-2 text-xs shadow-lg transition duration-150 ease-in-out dark:bg-zinc-800"
}, K7e = ["disabled"], Z7e = {
  key: 0,
  class: "flex h-10.5 w-full items-center justify-center"
}, J7e = { class: "text-base font-semibold" }, ePe = { class: "text-xs" };
function tPe(t, e, n, r, i, s) {
  const a = vo("CustomMarker"), o = vo("google-map"), u = vo("CloseSvg"), c = vo("vue-final-modal");
  return X(), gt(c, {
    class: "flex items-center justify-center",
    "content-class": "flex flex-col bg-white dark:bg-zinc-800 rounded-lg overflow-hidden sm:w-[450px] w-[350px]",
    "content-transition": "vfm-fade",
    "overlay-transition": "vfm-fade"
  }, {
    default: Zt(() => [
      W("div", Y7e, [
        et(o, {
          ref: "mapRef",
          "api-key": t.apiKey,
          center: t.center,
          zoom: t.zoom,
          "disable-default-ui": !0,
          class: "h-[250px] w-[350px] sm:h-[350px] sm:w-[450px]",
          onCenter_changed: e[0] || (e[0] = (d) => t.debounceLocationChange(t.LocationSource.Map))
        }, {
          default: Zt(() => [
            et(a, { options: t.markerOptions }, null, 8, ["options"])
          ]),
          _: 1
        }, 8, ["api-key", "center", "zoom"]),
        W("button", {
          class: "absolute top-2 right-2 flex items-center justify-center rounded-full shadow-lg",
          onClick: e[1] || (e[1] = (d) => t.vfm.closeAll())
        }, [
          et(u, { class: "h-9 w-9" })
        ]),
        W("button", {
          class: "absolute right-2 bottom-2 flex h-9 w-9 items-center justify-center rounded-full bg-white shadow-lg dark:bg-zinc-800",
          onClick: e[2] || (e[2] = (d) => t.debounceLocationChange(t.LocationSource.CurrentPosition))
        }, [
          W("img", {
            class: vt(["h-5 w-5", { "animate-pulse": t.isGettingCurrentPosition }]),
            src: G7e
          }, null, 2)
        ]),
        et(Lu, null, {
          default: Zt(() => [
            t.geolocationPositionErrorMessage ? (X(), se("div", X7e, [
              e[4] || (e[4] = W("img", {
                class: "h-4 w-4",
                src: HN
              }, null, -1)),
              An(" " + _e(t.geolocationPositionErrorMessage), 1)
            ])) : Fe("", !0)
          ]),
          _: 1
        })
      ]),
      W("button", {
        class: "disabled:( cursor-not-allowed) m-2 flex flex-col items-center gap-0.5 rounded-lg bg-blue-400 p-2 text-white",
        disabled: t.isGettingCurrentPosition || t.isRequesting || !t.location.isValid,
        onClick: e[3] || (e[3] = (...d) => t.send && t.send(...d))
      }, [
        t.isRequesting ? (X(), se("div", Z7e, e[5] || (e[5] = [
          W("svg", {
            class: "h-6 w-6 animate-spin fill-blue-300 text-gray-200",
            viewBox: "0 0 100 101",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
          }, [
            W("path", {
              d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
              fill: "currentColor"
            }),
            W("path", {
              d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
              fill: "currentFill"
            })
          ], -1)
        ]))) : (X(), se(wt, { key: 1 }, [
          W("div", J7e, _e(t.$t("sendCurrentLocation")), 1),
          W("div", ePe, _e(t.address), 1)
        ], 64))
      ], 8, K7e)
    ]),
    _: 1
  });
}
const nPe = /* @__PURE__ */ mn(Q7e, [["render", tPe], ["__scopeId", "data-v-9f90f239"]]), jN = "1.83.1", rPe = /* @__PURE__ */ Ze({
  __name: "VersionModal",
  setup(t) {
    const e = $n(), n = () => {
      e.closeAll();
    };
    return (r, i) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col gap-3 max-w-[420px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        An(" IMKIT version: " + _e(ke(jN)) + " ", 1),
        W("button", {
          class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 grow rounded-lg bg-blue-400 text-base text-white",
          onClick: n
        }, _e(r.$t("confirm")), 1)
      ]),
      _: 1
    }));
  }
});
var L2 = { exports: {} }, ZC;
function iPe() {
  return ZC || (ZC = 1, function(t) {
    /**
     * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. 
     * @summary Record audio, video or screen inside the browser.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef RecordRTC
     * @class
     * @example
     * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {
     *     type: 'video', // audio or video or gif or canvas
     *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc
     * });
     * recorder.startRecording();
     * @see For further information:
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
     * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}
     */
    function e(P, I) {
      if (!P)
        throw "First parameter is required.";
      I = I || {
        type: "video"
      }, I = new n(P, I);
      var G = this;
      function te(Ie) {
        return I.disableLogs || console.log("RecordRTC version: ", G.version), Ie && (I = new n(P, Ie)), I.disableLogs || console.log("started recording " + I.type + " stream."), $e ? ($e.clearRecordedData(), $e.record(), Ce("recording"), G.recordingDuration && ve(), G) : (ee(function() {
          G.recordingDuration && ve();
        }), G);
      }
      function ee(Ie) {
        Ie && (I.initCallback = function() {
          Ie(), Ie = I.initCallback = null;
        });
        var ne = new r(P, I);
        $e = new ne(P, I), $e.record(), Ce("recording"), I.disableLogs || console.log("Initialized recorderType:", $e.constructor.name, "for output-type:", I.type);
      }
      function Z(Ie) {
        if (Ie = Ie || function() {
        }, !$e) {
          qe();
          return;
        }
        if (G.state === "paused") {
          G.resumeRecording(), setTimeout(function() {
            Z(Ie);
          }, 1);
          return;
        }
        G.state !== "recording" && !I.disableLogs && console.warn('Recording state should be: "recording", however current state is: ', G.state), I.disableLogs || console.log("Stopped recording " + I.type + " stream."), I.type !== "gif" ? $e.stop(ne) : ($e.stop(), ne()), Ce("stopped");
        function ne(ue) {
          if (!$e) {
            typeof Ie.call == "function" ? Ie.call(G, "") : Ie("");
            return;
          }
          Object.keys($e).forEach(function(je) {
            typeof $e[je] != "function" && (G[je] = $e[je]);
          });
          var ie = $e.blob;
          if (!ie)
            if (ue)
              $e.blob = ie = ue;
            else
              throw "Recording failed.";
          if (ie && !I.disableLogs && console.log(ie.type, "->", b(ie.size)), Ie) {
            var Te;
            try {
              Te = d.createObjectURL(ie);
            } catch {
            }
            typeof Ie.call == "function" ? Ie.call(G, Te) : Ie(Te);
          }
          I.autoWriteToDisk && be(function(je) {
            var We = {};
            We[I.type + "Blob"] = je, U.Store(We);
          });
        }
      }
      function ye() {
        if (!$e) {
          qe();
          return;
        }
        if (G.state !== "recording") {
          I.disableLogs || console.warn("Unable to pause the recording. Recording state: ", G.state);
          return;
        }
        Ce("paused"), $e.pause(), I.disableLogs || console.log("Paused recording.");
      }
      function he() {
        if (!$e) {
          qe();
          return;
        }
        if (G.state !== "paused") {
          I.disableLogs || console.warn("Unable to resume the recording. Recording state: ", G.state);
          return;
        }
        Ce("recording"), $e.resume(), I.disableLogs || console.log("Resumed recording.");
      }
      function Ee(Ie) {
        postMessage(new FileReaderSync().readAsDataURL(Ie));
      }
      function be(Ie, ne) {
        if (!Ie)
          throw "Pass a callback function over getDataURL.";
        var ue = ne ? ne.blob : ($e || {}).blob;
        if (!ue) {
          I.disableLogs || console.warn("Blob encoder did not finish its job yet."), setTimeout(function() {
            be(Ie, ne);
          }, 1e3);
          return;
        }
        if (typeof Worker < "u" && !navigator.mozGetUserMedia) {
          var ie = je(Ee);
          ie.onmessage = function(We) {
            Ie(We.data);
          }, ie.postMessage(ue);
        } else {
          var Te = new FileReader();
          Te.readAsDataURL(ue), Te.onload = function(We) {
            Ie(We.target.result);
          };
        }
        function je(We) {
          try {
            var Qe = d.createObjectURL(new Blob([
              We.toString(),
              "this.onmessage =  function (eee) {" + We.name + "(eee.data);}"
            ], {
              type: "application/javascript"
            })), xe = new Worker(Qe);
            return d.revokeObjectURL(Qe), xe;
          } catch {
          }
        }
      }
      function ve(Ie) {
        if (Ie = Ie || 0, G.state === "paused") {
          setTimeout(function() {
            ve(Ie);
          }, 1e3);
          return;
        }
        if (G.state !== "stopped") {
          if (Ie >= G.recordingDuration) {
            Z(G.onRecordingStopped);
            return;
          }
          Ie += 1e3, setTimeout(function() {
            ve(Ie);
          }, 1e3);
        }
      }
      function Ce(Ie) {
        G && (G.state = Ie, typeof G.onStateChanged.call == "function" ? G.onStateChanged.call(G, Ie) : G.onStateChanged(Ie));
      }
      var Ne = 'It seems that recorder is destroyed or "startRecording" is not invoked for ' + I.type + " recorder.";
      function qe() {
        I.disableLogs !== !0 && console.warn(Ne);
      }
      var $e, Xe = {
        /**
         * This method starts the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var recorder = RecordRTC(mediaStream, {
         *     type: 'video'
         * });
         * recorder.startRecording();
         */
        startRecording: te,
        /**
         * This method stops the recording. It is strongly recommended to get "blob" or "URI" inside the callback to make sure all recorders finished their job.
         * @param {function} callback - Callback to get the recorded blob.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     // use either "this" or "recorder" object; both are identical
         *     video.src = this.toURL();
         *     var blob = this.getBlob();
         * });
         */
        stopRecording: Z,
        /**
         * This method pauses the recording. You can resume recording using "resumeRecording" method.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo Firefox is unable to pause the recording. Fix it.
         * @example
         * recorder.pauseRecording();  // pause the recording
         * recorder.resumeRecording(); // resume again
         */
        pauseRecording: ye,
        /**
         * This method resumes the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.pauseRecording();  // first of all, pause the recording
         * recorder.resumeRecording(); // now resume it
         */
        resumeRecording: he,
        /**
         * This method initializes the recording.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo This method should be deprecated.
         * @example
         * recorder.initRecorder();
         */
        initRecorder: ee,
        /**
         * Ask RecordRTC to auto-stop the recording after 5 minutes.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var fiveMinutes = 5 * 1000 * 60;
         * recorder.setRecordingDuration(fiveMinutes, function() {
         *    var blob = this.getBlob();
         *    video.src = this.toURL();
         * });
         * 
         * // or otherwise
         * recorder.setRecordingDuration(fiveMinutes).onRecordingStopped(function() {
         *    var blob = this.getBlob();
         *    video.src = this.toURL();
         * });
         */
        setRecordingDuration: function(Ie, ne) {
          if (typeof Ie > "u")
            throw "recordingDuration is required.";
          if (typeof Ie != "number")
            throw "recordingDuration must be a number.";
          return G.recordingDuration = Ie, G.onRecordingStopped = ne || function() {
          }, {
            onRecordingStopped: function(ue) {
              G.onRecordingStopped = ue;
            }
          };
        },
        /**
         * This method can be used to clear/reset all the recorded data.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo Figure out the difference between "reset" and "clearRecordedData" methods.
         * @example
         * recorder.clearRecordedData();
         */
        clearRecordedData: function() {
          if (!$e) {
            qe();
            return;
          }
          $e.clearRecordedData(), I.disableLogs || console.log("Cleared old recorded data.");
        },
        /**
         * Get the recorded blob. Use this method inside the "stopRecording" callback.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     var blob = this.getBlob();
         *
         *     var file = new File([blob], 'filename.webm', {
         *         type: 'video/webm'
         *     });
         *
         *     var formData = new FormData();
         *     formData.append('file', file); // upload "File" object rather than a "Blob"
         *     uploadToServer(formData);
         * });
         * @returns {Blob} Returns recorded data as "Blob" object.
         */
        getBlob: function() {
          if (!$e) {
            qe();
            return;
          }
          return $e.blob;
        },
        /**
         * Get data-URI instead of Blob.
         * @param {function} callback - Callback to get the Data-URI.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     recorder.getDataURL(function(dataURI) {
         *         video.src = dataURI;
         *     });
         * });
         */
        getDataURL: be,
        /**
         * Get virtual/temporary URL. Usage of this URL is limited to current tab.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     video.src = this.toURL();
         * });
         * @returns {String} Returns a virtual/temporary URL for the recorded "Blob".
         */
        toURL: function() {
          if (!$e) {
            qe();
            return;
          }
          return d.createObjectURL($e.blob);
        },
        /**
         * Get internal recording object (i.e. internal module) e.g. MutliStreamRecorder, MediaStreamRecorder, StereoAudioRecorder or WhammyRecorder etc.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * var internalRecorder = recorder.getInternalRecorder();
         * if(internalRecorder instanceof MultiStreamRecorder) {
         *     internalRecorder.addStreams([newAudioStream]);
         *     internalRecorder.resetVideoStreams([screenStream]);
         * }
         * @returns {Object} Returns internal recording object.
         */
        getInternalRecorder: function() {
          return $e;
        },
        /**
         * Invoke save-as dialog to save the recorded blob into your disk.
         * @param {string} fileName - Set your own file name.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.stopRecording(function() {
         *     this.save('file-name');
         *
         *     // or manually:
         *     invokeSaveAsDialog(this.getBlob(), 'filename.webm');
         * });
         */
        save: function(Ie) {
          if (!$e) {
            qe();
            return;
          }
          E($e.blob, Ie);
        },
        /**
         * This method gets a blob from indexed-DB storage.
         * @param {function} callback - Callback to get the recorded blob.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.getFromDisk(function(dataURL) {
         *     video.src = dataURL;
         * });
         */
        getFromDisk: function(Ie) {
          if (!$e) {
            qe();
            return;
          }
          e.getFromDisk(I.type, Ie);
        },
        /**
         * This method appends an array of webp images to the recorded video-blob. It takes an "array" object.
         * @type {Array.<Array>}
         * @param {Array} arrayOfWebPImages - Array of webp images.
         * @method
         * @memberof RecordRTC
         * @instance
         * @todo This method should be deprecated.
         * @example
         * var arrayOfWebPImages = [];
         * arrayOfWebPImages.push({
         *     duration: index,
         *     image: 'data:image/webp;base64,...'
         * });
         * recorder.setAdvertisementArray(arrayOfWebPImages);
         */
        setAdvertisementArray: function(Ie) {
          I.advertisement = [];
          for (var ne = Ie.length, ue = 0; ue < ne; ue++)
            I.advertisement.push({
              duration: ue,
              image: Ie[ue]
            });
        },
        /**
         * It is equivalent to <code class="str">"recorder.getBlob()"</code> method. Usage of "getBlob" is recommended, though.
         * @property {Blob} blob - Recorded Blob can be accessed using this property.
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     var blob = this.blob;
         *
         *     // below one is recommended
         *     var blob = this.getBlob();
         * });
         */
        blob: null,
        /**
         * This works only with {recorderType:StereoAudioRecorder}. Use this property on "stopRecording" to verify the encoder's sample-rates.
         * @property {number} bufferSize - Buffer-size used to encode the WAV container
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     alert('Recorder used this buffer-size: ' + this.bufferSize);
         * });
         */
        bufferSize: 0,
        /**
         * This works only with {recorderType:StereoAudioRecorder}. Use this property on "stopRecording" to verify the encoder's sample-rates.
         * @property {number} sampleRate - Sample-rates used to encode the WAV container
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     alert('Recorder used these sample-rates: ' + this.sampleRate);
         * });
         */
        sampleRate: 0,
        /**
         * {recorderType:StereoAudioRecorder} returns ArrayBuffer object.
         * @property {ArrayBuffer} buffer - Audio ArrayBuffer, supported only in Chrome.
         * @memberof RecordRTC
         * @instance
         * @readonly
         * @example
         * recorder.stopRecording(function() {
         *     var arrayBuffer = this.buffer;
         *     alert(arrayBuffer.byteLength);
         * });
         */
        buffer: null,
        /**
         * This method resets the recorder. So that you can reuse single recorder instance many times.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.reset();
         * recorder.startRecording();
         */
        reset: function() {
          G.state === "recording" && !I.disableLogs && console.warn("Stop an active recorder."), $e && typeof $e.clearRecordedData == "function" && $e.clearRecordedData(), $e = null, Ce("inactive"), G.blob = null;
        },
        /**
         * This method is called whenever recorder's state changes. Use this as an "event".
         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.
         * @method
         * @memberof RecordRTC
         * @instance
         * @example
         * recorder.onStateChanged = function(state) {
         *     console.log('Recorder state: ', state);
         * };
         */
        onStateChanged: function(Ie) {
          I.disableLogs || console.log("Recorder state changed:", Ie);
        },
        /**
         * A recorder can have inactive, recording, paused or stopped states.
         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.
         * @memberof RecordRTC
         * @static
         * @readonly
         * @example
         * // this looper function will keep you updated about the recorder's states.
         * (function looper() {
         *     document.querySelector('h1').innerHTML = 'Recorder\'s state is: ' + recorder.state;
         *     if(recorder.state === 'stopped') return; // ignore+stop
         *     setTimeout(looper, 1000); // update after every 3-seconds
         * })();
         * recorder.startRecording();
         */
        state: "inactive",
        /**
         * Get recorder's readonly state.
         * @method
         * @memberof RecordRTC
         * @example
         * var state = recorder.getState();
         * @returns {String} Returns recording state.
         */
        getState: function() {
          return G.state;
        },
        /**
         * Destroy RecordRTC instance. Clear all recorders and objects.
         * @method
         * @memberof RecordRTC
         * @example
         * recorder.destroy();
         */
        destroy: function() {
          var Ie = I.disableLogs;
          I = {
            disableLogs: !0
          }, G.reset(), Ce("destroyed"), Xe = G = null, M.AudioContextConstructor && (M.AudioContextConstructor.close(), M.AudioContextConstructor = null), I.disableLogs = Ie, I.disableLogs || console.log("RecordRTC is destroyed.");
        },
        /**
         * RecordRTC version number
         * @property {String} version - Release version number.
         * @memberof RecordRTC
         * @static
         * @readonly
         * @example
         * alert(recorder.version);
         */
        version: "5.6.2"
      };
      if (!this)
        return G = Xe, Xe;
      for (var at in Xe)
        this[at] = Xe[at];
      return G = this, Xe;
    }
    e.version = "5.6.2", t.exports = e, e.getFromDisk = function(P, I) {
      if (!I)
        throw "callback is mandatory.";
      console.log("Getting recorded " + (P === "all" ? "blobs" : P + " blob ") + " from disk!"), U.Fetch(function(G, te) {
        P !== "all" && te === P + "Blob" && I && I(G), P === "all" && I && I(G, te.replace("Blob", ""));
      });
    }, e.writeToDisk = function(P) {
      console.log("Writing recorded blob(s) to disk!"), P = P || {}, P.audio && P.video && P.gif ? P.audio.getDataURL(function(I) {
        P.video.getDataURL(function(G) {
          P.gif.getDataURL(function(te) {
            U.Store({
              audioBlob: I,
              videoBlob: G,
              gifBlob: te
            });
          });
        });
      }) : P.audio && P.video ? P.audio.getDataURL(function(I) {
        P.video.getDataURL(function(G) {
          U.Store({
            audioBlob: I,
            videoBlob: G
          });
        });
      }) : P.audio && P.gif ? P.audio.getDataURL(function(I) {
        P.gif.getDataURL(function(G) {
          U.Store({
            audioBlob: I,
            gifBlob: G
          });
        });
      }) : P.video && P.gif ? P.video.getDataURL(function(I) {
        P.gif.getDataURL(function(G) {
          U.Store({
            videoBlob: I,
            gifBlob: G
          });
        });
      }) : P.audio ? P.audio.getDataURL(function(I) {
        U.Store({
          audioBlob: I
        });
      }) : P.video ? P.video.getDataURL(function(I) {
        U.Store({
          videoBlob: I
        });
      }) : P.gif && P.gif.getDataURL(function(I) {
        U.Store({
          gifBlob: I
        });
      });
    };
    /**
     * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.
     * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid "config" object.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef RecordRTCConfiguration
     * @class
     * @example
     * var options = RecordRTCConfiguration(mediaStream, options);
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
     * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}
     */
    function n(P, I) {
      return !I.recorderType && !I.type && (I.audio && I.video ? I.type = "video" : I.audio && !I.video && (I.type = "audio")), I.recorderType && !I.type && (I.recorderType === $ || I.recorderType === H || typeof Q < "u" && I.recorderType === Q ? I.type = "video" : I.recorderType === V ? I.type = "gif" : I.recorderType === N ? I.type = "audio" : I.recorderType === T && (_(P, "audio").length && _(P, "video").length || !_(P, "audio").length && _(P, "video").length ? I.type = "video" : _(P, "audio").length && !_(P, "video").length && (I.type = "audio"))), typeof T < "u" && typeof MediaRecorder < "u" && "requestData" in MediaRecorder.prototype && (I.mimeType || (I.mimeType = "video/webm"), I.type || (I.type = I.mimeType.split("/")[0]), I.bitsPerSecond), I.type || (I.mimeType && (I.type = I.mimeType.split("/")[0]), I.type || (I.type = "audio")), I;
    }
    /**
     * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.
     * @summary It returns best recorder-type available for your browser.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef GetRecorderType
     * @class
     * @example
     * var RecorderType = GetRecorderType(options);
     * var recorder = new RecorderType(options);
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
     * @param {object} config - {type:"video", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
     */
    function r(P, I) {
      var G;
      return (m || l || f) && (G = N), typeof MediaRecorder < "u" && "requestData" in MediaRecorder.prototype && !m && (G = T), I.type === "video" && (m || f) && (G = $, typeof Q < "u" && typeof ReadableStream < "u" && (G = Q)), I.type === "gif" && (G = V), I.type === "canvas" && (G = H), O() && G !== H && G !== V && typeof MediaRecorder < "u" && "requestData" in MediaRecorder.prototype && (_(P, "video").length || _(P, "audio").length) && (I.type === "audio" ? typeof MediaRecorder.isTypeSupported == "function" && MediaRecorder.isTypeSupported("audio/webm") && (G = T) : typeof MediaRecorder.isTypeSupported == "function" && MediaRecorder.isTypeSupported("video/webm") && (G = T)), P instanceof Array && P.length && (G = R), I.recorderType && (G = I.recorderType), !I.disableLogs && G && G.name && console.log("Using recorderType:", G.name || G.constructor.name), !G && g && (G = T), G;
    }
    /**
     * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.
     * @summary MRecordRTC stands for "Multiple-RecordRTC".
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef MRecordRTC
     * @class
     * @example
     * var recorder = new MRecordRTC();
     * recorder.addStream(MediaStream);
     * recorder.mediaType = {
     *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder
     *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder
     *     gif: true    // or GifRecorder
     * };
     * // mimeType is optional and should be set only in advance cases.
     * recorder.mimeType = {
     *     audio: 'audio/wav',
     *     video: 'video/webm',
     *     gif:   'image/gif'
     * };
     * recorder.startRecording();
     * @see For further information:
     * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
     * @requires {@link RecordRTC}
     */
    function i(P) {
      this.addStream = function(I) {
        I && (P = I);
      }, this.mediaType = {
        audio: !0,
        video: !0
      }, this.startRecording = function() {
        var I = this.mediaType, G, te = this.mimeType || {
          audio: null,
          video: null,
          gif: null
        };
        if (typeof I.audio != "function" && O() && !_(P, "audio").length && (I.audio = !1), typeof I.video != "function" && O() && !_(P, "video").length && (I.video = !1), typeof I.gif != "function" && O() && !_(P, "video").length && (I.gif = !1), !I.audio && !I.video && !I.gif)
          throw "MediaStream must have either audio or video tracks.";
        if (I.audio && (G = null, typeof I.audio == "function" && (G = I.audio), this.audioRecorder = new e(P, {
          type: "audio",
          bufferSize: this.bufferSize,
          sampleRate: this.sampleRate,
          numberOfAudioChannels: this.numberOfAudioChannels || 2,
          disableLogs: this.disableLogs,
          recorderType: G,
          mimeType: te.audio,
          timeSlice: this.timeSlice,
          onTimeStamp: this.onTimeStamp
        }), I.video || this.audioRecorder.startRecording()), I.video) {
          G = null, typeof I.video == "function" && (G = I.video);
          var ee = P;
          if (O() && I.audio && typeof I.audio == "function") {
            var Z = _(P, "video")[0];
            p ? (ee = new y(), ee.addTrack(Z), G && G === $ && (G = T)) : (ee = new y(), ee.addTrack(Z));
          }
          this.videoRecorder = new e(ee, {
            type: "video",
            video: this.video,
            canvas: this.canvas,
            frameInterval: this.frameInterval || 10,
            disableLogs: this.disableLogs,
            recorderType: G,
            mimeType: te.video,
            timeSlice: this.timeSlice,
            onTimeStamp: this.onTimeStamp,
            workerPath: this.workerPath,
            webAssemblyPath: this.webAssemblyPath,
            frameRate: this.frameRate,
            // used by WebAssemblyRecorder; values: usually 30; accepts any.
            bitrate: this.bitrate
            // used by WebAssemblyRecorder; values: 0 to 1000+
          }), I.audio || this.videoRecorder.startRecording();
        }
        if (I.audio && I.video) {
          var ye = this, he = O() === !0;
          (I.audio instanceof N && I.video || I.audio !== !0 && I.video !== !0 && I.audio !== I.video) && (he = !1), he === !0 ? (ye.audioRecorder = null, ye.videoRecorder.startRecording()) : ye.videoRecorder.initRecorder(function() {
            ye.audioRecorder.initRecorder(function() {
              ye.videoRecorder.startRecording(), ye.audioRecorder.startRecording();
            });
          });
        }
        I.gif && (G = null, typeof I.gif == "function" && (G = I.gif), this.gifRecorder = new e(P, {
          type: "gif",
          frameRate: this.frameRate || 200,
          quality: this.quality || 10,
          disableLogs: this.disableLogs,
          recorderType: G,
          mimeType: te.gif
        }), this.gifRecorder.startRecording());
      }, this.stopRecording = function(I) {
        I = I || function() {
        }, this.audioRecorder && this.audioRecorder.stopRecording(function(G) {
          I(G, "audio");
        }), this.videoRecorder && this.videoRecorder.stopRecording(function(G) {
          I(G, "video");
        }), this.gifRecorder && this.gifRecorder.stopRecording(function(G) {
          I(G, "gif");
        });
      }, this.pauseRecording = function() {
        this.audioRecorder && this.audioRecorder.pauseRecording(), this.videoRecorder && this.videoRecorder.pauseRecording(), this.gifRecorder && this.gifRecorder.pauseRecording();
      }, this.resumeRecording = function() {
        this.audioRecorder && this.audioRecorder.resumeRecording(), this.videoRecorder && this.videoRecorder.resumeRecording(), this.gifRecorder && this.gifRecorder.resumeRecording();
      }, this.getBlob = function(I) {
        var G = {};
        return this.audioRecorder && (G.audio = this.audioRecorder.getBlob()), this.videoRecorder && (G.video = this.videoRecorder.getBlob()), this.gifRecorder && (G.gif = this.gifRecorder.getBlob()), I && I(G), G;
      }, this.destroy = function() {
        this.audioRecorder && (this.audioRecorder.destroy(), this.audioRecorder = null), this.videoRecorder && (this.videoRecorder.destroy(), this.videoRecorder = null), this.gifRecorder && (this.gifRecorder.destroy(), this.gifRecorder = null);
      }, this.getDataURL = function(I) {
        this.getBlob(function(ee) {
          ee.audio && ee.video ? G(ee.audio, function(Z) {
            G(ee.video, function(ye) {
              I({
                audio: Z,
                video: ye
              });
            });
          }) : ee.audio ? G(ee.audio, function(Z) {
            I({
              audio: Z
            });
          }) : ee.video && G(ee.video, function(Z) {
            I({
              video: Z
            });
          });
        });
        function G(ee, Z) {
          if (typeof Worker < "u") {
            var ye = te(function(be) {
              postMessage(new FileReaderSync().readAsDataURL(be));
            });
            ye.onmessage = function(Ee) {
              Z(Ee.data);
            }, ye.postMessage(ee);
          } else {
            var he = new FileReader();
            he.readAsDataURL(ee), he.onload = function(Ee) {
              Z(Ee.target.result);
            };
          }
        }
        function te(ee) {
          var Z = d.createObjectURL(new Blob([
            ee.toString(),
            "this.onmessage =  function (eee) {" + ee.name + "(eee.data);}"
          ], {
            type: "application/javascript"
          })), ye = new Worker(Z), he;
          if (typeof d < "u")
            he = d;
          else if (typeof webkitURL < "u")
            he = webkitURL;
          else
            throw "Neither URL nor webkitURL detected.";
          return he.revokeObjectURL(Z), ye;
        }
      }, this.writeToDisk = function() {
        e.writeToDisk({
          audio: this.audioRecorder,
          video: this.videoRecorder,
          gif: this.gifRecorder
        });
      }, this.save = function(I) {
        I = I || {
          audio: !0,
          video: !0,
          gif: !0
        }, I.audio && this.audioRecorder && this.audioRecorder.save(typeof I.audio == "string" ? I.audio : ""), I.video && this.videoRecorder && this.videoRecorder.save(typeof I.video == "string" ? I.video : ""), I.gif && this.gifRecorder && this.gifRecorder.save(typeof I.gif == "string" ? I.gif : "");
      };
    }
    i.getFromDisk = e.getFromDisk, i.writeToDisk = e.writeToDisk, typeof e < "u" && (e.MRecordRTC = i);
    var s = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
    (function(P) {
      P && (typeof window < "u" || typeof cn > "u" || (cn.navigator = {
        userAgent: s,
        getUserMedia: function() {
        }
      }, cn.console || (cn.console = {}), (typeof cn.console.log > "u" || typeof cn.console.error > "u") && (cn.console.error = cn.console.log = cn.console.log || function() {
        console.log(arguments);
      }), typeof document > "u" && (P.document = {
        documentElement: {
          appendChild: function() {
            return "";
          }
        }
      }, document.createElement = document.captureStream = document.mozCaptureStream = function() {
        var I = {
          getContext: function() {
            return I;
          },
          play: function() {
          },
          pause: function() {
          },
          drawImage: function() {
          },
          toDataURL: function() {
            return "";
          },
          style: {}
        };
        return I;
      }, P.HTMLVideoElement = function() {
      }), typeof location > "u" && (P.location = {
        protocol: "file:",
        href: "",
        hash: ""
      }), typeof screen > "u" && (P.screen = {
        width: 0,
        height: 0
      }), typeof d > "u" && (P.URL = {
        createObjectURL: function() {
          return "";
        },
        revokeObjectURL: function() {
          return "";
        }
      }), P.window = cn));
    })(typeof cn < "u" ? cn : null);
    var a = window.requestAnimationFrame;
    if (typeof a > "u") {
      if (typeof webkitRequestAnimationFrame < "u")
        a = webkitRequestAnimationFrame;
      else if (typeof mozRequestAnimationFrame < "u")
        a = mozRequestAnimationFrame;
      else if (typeof msRequestAnimationFrame < "u")
        a = msRequestAnimationFrame;
      else if (typeof a > "u") {
        var o = 0;
        a = function(P, I) {
          var G = (/* @__PURE__ */ new Date()).getTime(), te = Math.max(0, 16 - (G - o)), ee = setTimeout(function() {
            P(G + te);
          }, te);
          return o = G + te, ee;
        };
      }
    }
    var u = window.cancelAnimationFrame;
    typeof u > "u" && (typeof webkitCancelAnimationFrame < "u" ? u = webkitCancelAnimationFrame : typeof mozCancelAnimationFrame < "u" ? u = mozCancelAnimationFrame : typeof msCancelAnimationFrame < "u" ? u = msCancelAnimationFrame : typeof u > "u" && (u = function(P) {
      clearTimeout(P);
    }));
    var c = window.AudioContext;
    typeof c > "u" && (typeof webkitAudioContext < "u" && (c = webkitAudioContext), typeof mozAudioContext < "u" && (c = mozAudioContext));
    var d = window.URL;
    typeof d > "u" && typeof webkitURL < "u" && (d = webkitURL), typeof navigator < "u" && typeof navigator.getUserMedia > "u" && (typeof navigator.webkitGetUserMedia < "u" && (navigator.getUserMedia = navigator.webkitGetUserMedia), typeof navigator.mozGetUserMedia < "u" && (navigator.getUserMedia = navigator.mozGetUserMedia));
    var l = navigator.userAgent.indexOf("Edge") !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob), f = !!window.opera || navigator.userAgent.indexOf("OPR/") !== -1, p = navigator.userAgent.toLowerCase().indexOf("firefox") > -1 && "netscape" in window && / rv:/.test(navigator.userAgent), m = !f && !l && !!navigator.webkitGetUserMedia || v() || navigator.userAgent.toLowerCase().indexOf("chrome/") !== -1, g = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    g && !m && navigator.userAgent.indexOf("CriOS") !== -1 && (g = !1, m = !0);
    var y = window.MediaStream;
    typeof y > "u" && typeof webkitMediaStream < "u" && (y = webkitMediaStream), typeof y < "u" && typeof y.prototype.stop > "u" && (y.prototype.stop = function() {
      this.getTracks().forEach(function(P) {
        P.stop();
      });
    });
    function b(P) {
      var I = 1e3, G = ["Bytes", "KB", "MB", "GB", "TB"];
      if (P === 0)
        return "0 Bytes";
      var te = parseInt(Math.floor(Math.log(P) / Math.log(I)), 10);
      return (P / Math.pow(I, te)).toPrecision(3) + " " + G[te];
    }
    function E(P, I) {
      if (!P)
        throw "Blob object is required.";
      if (!P.type)
        try {
          P.type = "video/webm";
        } catch {
        }
      var G = (P.type || "video/webm").split("/")[1];
      if (G.indexOf(";") !== -1 && (G = G.split(";")[0]), I && I.indexOf(".") !== -1) {
        var te = I.split(".");
        I = te[0], G = te[1];
      }
      var ee = (I || Math.round(Math.random() * 9999999999) + 888888888) + "." + G;
      if (typeof navigator.msSaveOrOpenBlob < "u")
        return navigator.msSaveOrOpenBlob(P, ee);
      if (typeof navigator.msSaveBlob < "u")
        return navigator.msSaveBlob(P, ee);
      var Z = document.createElement("a");
      Z.href = d.createObjectURL(P), Z.download = ee, Z.style = "display:none;opacity:0;color:transparent;", (document.body || document.documentElement).appendChild(Z), typeof Z.click == "function" ? Z.click() : (Z.target = "_blank", Z.dispatchEvent(new MouseEvent("click", {
        view: window,
        bubbles: !0,
        cancelable: !0
      }))), d.revokeObjectURL(Z.href);
    }
    function v() {
      return !!(typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && process.versions.electron || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0);
    }
    function _(P, I) {
      return !P || !P.getTracks ? [] : P.getTracks().filter(function(G) {
        return G.kind === (I || "audio");
      });
    }
    function D(P, I) {
      "srcObject" in I ? I.srcObject = P : "mozSrcObject" in I ? I.mozSrcObject = P : I.srcObject = P;
    }
    function S(P, I) {
      if (typeof EBML > "u")
        throw new Error("Please link: https://www.webrtc-experiment.com/EBML.js");
      var G = new EBML.Reader(), te = new EBML.Decoder(), ee = EBML.tools, Z = new FileReader();
      Z.onload = function(ye) {
        var he = te.decode(this.result);
        he.forEach(function(Ce) {
          G.read(Ce);
        }), G.stop();
        var Ee = ee.makeMetadataSeekable(G.metadatas, G.duration, G.cues), be = this.result.slice(G.metadataSize), ve = new Blob([Ee, be], {
          type: "video/webm"
        });
        I(ve);
      }, Z.readAsArrayBuffer(P);
    }
    typeof e < "u" && (e.invokeSaveAsDialog = E, e.getTracks = _, e.getSeekableBlob = S, e.bytesToSize = b, e.isElectron = v);
    /**
     * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. "new AudioContext".
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @example
     * Storage.AudioContext === webkitAudioContext
     * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     */
    var M = {};
    typeof c < "u" ? M.AudioContext = c : typeof webkitAudioContext < "u" && (M.AudioContext = webkitAudioContext), typeof e < "u" && (e.Storage = M);
    function O() {
      if (p || g || l)
        return !0;
      var P = navigator.userAgent, I = "" + parseFloat(navigator.appVersion), G = parseInt(navigator.appVersion, 10), te, ee;
      return (m || f) && (te = P.indexOf("Chrome"), I = P.substring(te + 7)), (ee = I.indexOf(";")) !== -1 && (I = I.substring(0, ee)), (ee = I.indexOf(" ")) !== -1 && (I = I.substring(0, ee)), G = parseInt("" + I, 10), isNaN(G) && (I = "" + parseFloat(navigator.appVersion), G = parseInt(navigator.appVersion, 10)), G >= 49;
    }
    /**
     * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.
     * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://github.com/muaz-khan|Muaz Khan}
     * @typedef MediaStreamRecorder
     * @class
     * @example
     * var config = {
     *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis
     *     audioBitsPerSecond : 256 * 8 * 1024,
     *     videoBitsPerSecond : 256 * 8 * 1024,
     *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two
     *     checkForInactiveTracks: true,
     *     timeSlice: 1000, // concatenate intervals based blobs
     *     ondataavailable: function() {} // get intervals based blobs
     * }
     * var recorder = new MediaStreamRecorder(mediaStream, config);
     * recorder.record();
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     *
     *     // or
     *     var blob = recorder.blob;
     * });
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
     * @param {object} config - {disableLogs:true, initCallback: function, mimeType: "video/webm", timeSlice: 1000}
     * @throws Will throw an error if first argument "MediaStream" is missing. Also throws error if "MediaRecorder API" are not supported by the browser.
     */
    function T(P, I) {
      var ve = this;
      if (typeof P > "u")
        throw 'First argument "MediaStream" is required.';
      if (typeof MediaRecorder > "u")
        throw "Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.";
      if (I = I || {
        // bitsPerSecond: 256 * 8 * 1024,
        mimeType: "video/webm"
      }, I.type === "audio") {
        if (_(P, "video").length && _(P, "audio").length) {
          var G;
          navigator.mozGetUserMedia ? (G = new y(), G.addTrack(_(P, "audio")[0])) : G = new y(_(P, "audio")), P = G;
        }
        (!I.mimeType || I.mimeType.toString().toLowerCase().indexOf("audio") === -1) && (I.mimeType = m ? "audio/webm" : "audio/ogg"), I.mimeType && I.mimeType.toString().toLowerCase() !== "audio/ogg" && navigator.mozGetUserMedia && (I.mimeType = "audio/ogg");
      }
      var te = [];
      this.getArrayOfBlobs = function() {
        return te;
      }, this.record = function() {
        ve.blob = null, ve.clearRecordedData(), ve.timestamps = [], be = [], te = [];
        var Ce = I;
        I.disableLogs || console.log("Passing following config over MediaRecorder API.", Ce), he && (he = null), m && !O() && (Ce = "video/vp8"), typeof MediaRecorder.isTypeSupported == "function" && Ce.mimeType && (MediaRecorder.isTypeSupported(Ce.mimeType) || (I.disableLogs || console.warn("MediaRecorder API seems unable to record mimeType:", Ce.mimeType), Ce.mimeType = I.type === "audio" ? "audio/webm" : "video/webm"));
        try {
          he = new MediaRecorder(P, Ce), I.mimeType = Ce.mimeType;
        } catch {
          he = new MediaRecorder(P);
        }
        Ce.mimeType && !MediaRecorder.isTypeSupported && "canRecordMimeType" in he && he.canRecordMimeType(Ce.mimeType) === !1 && (I.disableLogs || console.warn("MediaRecorder API seems unable to record mimeType:", Ce.mimeType)), he.ondataavailable = function(Ne) {
          if (Ne.data && be.push("ondataavailable: " + b(Ne.data.size)), typeof I.timeSlice == "number") {
            if (Ne.data && Ne.data.size && (te.push(Ne.data), ee(), typeof I.ondataavailable == "function")) {
              var qe = I.getNativeBlob ? Ne.data : new Blob([Ne.data], {
                type: Z(Ce)
              });
              I.ondataavailable(qe);
            }
            return;
          }
          if (!Ne.data || !Ne.data.size || Ne.data.size < 100 || ve.blob) {
            ve.recordingCallback && (ve.recordingCallback(new Blob([], {
              type: Z(Ce)
            })), ve.recordingCallback = null);
            return;
          }
          ve.blob = I.getNativeBlob ? Ne.data : new Blob([Ne.data], {
            type: Z(Ce)
          }), ve.recordingCallback && (ve.recordingCallback(ve.blob), ve.recordingCallback = null);
        }, he.onstart = function() {
          be.push("started");
        }, he.onpause = function() {
          be.push("paused");
        }, he.onresume = function() {
          be.push("resumed");
        }, he.onstop = function() {
          be.push("stopped");
        }, he.onerror = function(Ne) {
          Ne && (Ne.name || (Ne.name = "UnknownError"), be.push("error: " + Ne), I.disableLogs || (Ne.name.toString().toLowerCase().indexOf("invalidstate") !== -1 ? console.error("The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.", Ne) : Ne.name.toString().toLowerCase().indexOf("notsupported") !== -1 ? console.error("MIME type (", Ce.mimeType, ") is not supported.", Ne) : Ne.name.toString().toLowerCase().indexOf("security") !== -1 ? console.error("MediaRecorder security error", Ne) : Ne.name === "OutOfMemory" ? console.error("The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.", Ne) : Ne.name === "IllegalStreamModification" ? console.error("A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.", Ne) : Ne.name === "OtherRecordingError" ? console.error("Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.", Ne) : Ne.name === "GenericError" ? console.error("The UA cannot provide the codec or recording option that has been requested.", Ne) : console.error("MediaRecorder Error", Ne)), function(qe) {
            if (!ve.manuallyStopped && he && he.state === "inactive") {
              delete I.timeslice, he.start(10 * 60 * 1e3);
              return;
            }
            setTimeout(qe, 1e3);
          }(), he.state !== "inactive" && he.state !== "stopped" && he.stop());
        }, typeof I.timeSlice == "number" ? (ee(), he.start(I.timeSlice)) : he.start(36e5), I.initCallback && I.initCallback();
      }, this.timestamps = [];
      function ee() {
        ve.timestamps.push((/* @__PURE__ */ new Date()).getTime()), typeof I.onTimeStamp == "function" && I.onTimeStamp(ve.timestamps[ve.timestamps.length - 1], ve.timestamps);
      }
      function Z(Ce) {
        return he && he.mimeType ? he.mimeType : Ce.mimeType || "video/webm";
      }
      this.stop = function(Ce) {
        Ce = Ce || function() {
        }, ve.manuallyStopped = !0, he && (this.recordingCallback = Ce, he.state === "recording" && he.stop(), typeof I.timeSlice == "number" && setTimeout(function() {
          ve.blob = new Blob(te, {
            type: Z(I)
          }), ve.recordingCallback(ve.blob);
        }, 100));
      }, this.pause = function() {
        he && he.state === "recording" && he.pause();
      }, this.resume = function() {
        he && he.state === "paused" && he.resume();
      }, this.clearRecordedData = function() {
        he && he.state === "recording" && ve.stop(ye), ye();
      };
      function ye() {
        te = [], he = null, ve.timestamps = [];
      }
      var he;
      this.getInternalRecorder = function() {
        return he;
      };
      function Ee() {
        if ("active" in P) {
          if (!P.active)
            return !1;
        } else if ("ended" in P && P.ended)
          return !1;
        return !0;
      }
      this.blob = null, this.getState = function() {
        return he && he.state || "inactive";
      };
      var be = [];
      this.getAllStates = function() {
        return be;
      }, typeof I.checkForInactiveTracks > "u" && (I.checkForInactiveTracks = !1);
      var ve = this;
      (function Ce() {
        if (!(!he || I.checkForInactiveTracks === !1)) {
          if (Ee() === !1) {
            I.disableLogs || console.log("MediaStream seems stopped."), ve.stop();
            return;
          }
          setTimeout(Ce, 1e3);
        }
      })(), this.name = "MediaStreamRecorder", this.toString = function() {
        return this.name;
      };
    }
    typeof e < "u" && (e.MediaStreamRecorder = T);
    /**
     * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring "stereo" audio-recording in chrome.
     * @summary JavaScript standalone object for stereo audio recording.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef StereoAudioRecorder
     * @class
     * @example
     * var recorder = new StereoAudioRecorder(MediaStream, {
     *     sampleRate: 44100,
     *     bufferSize: 4096
     * });
     * recorder.record();
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
     * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}
     */
    function N(P, I) {
      if (!_(P, "audio").length)
        throw "Your stream has no audio tracks.";
      I = I || {};
      var G = this, te = [], ee = [], Z = !1, ye = 0, he, Ee = 2, be = I.desiredSampRate;
      I.leftChannel === !0 && (Ee = 1), I.numberOfAudioChannels === 1 && (Ee = 1), (!Ee || Ee < 1) && (Ee = 2), I.disableLogs || console.log("StereoAudioRecorder is set to record number of channels: " + Ee), typeof I.checkForInactiveTracks > "u" && (I.checkForInactiveTracks = !0);
      function ve() {
        if (I.checkForInactiveTracks === !1)
          return !0;
        if ("active" in P) {
          if (!P.active)
            return !1;
        } else if ("ended" in P && P.ended)
          return !1;
        return !0;
      }
      this.record = function() {
        if (ve() === !1)
          throw "Please make sure MediaStream is active.";
        ue(), Te = ne = !1, Z = !0, typeof I.timeSlice < "u" && Qe();
      };
      function Ce(xe, Be) {
        function At(Rt, Xt) {
          var jt = Rt.numberOfAudioChannels, Tt = Rt.leftBuffers.slice(0), bn = Rt.rightBuffers.slice(0), Ve = Rt.sampleRate, ut = Rt.internalInterleavedLength, _t = Rt.desiredSampRate;
          jt === 2 && (Tt = Hn(Tt, ut), bn = Hn(bn, ut), _t && (Tt = zt(Tt, _t, Ve), bn = zt(bn, _t, Ve))), jt === 1 && (Tt = Hn(Tt, ut), _t && (Tt = zt(Tt, _t, Ve))), _t && (Ve = _t);
          function zt(gn, Kn, Rn) {
            var On = Math.round(gn.length * (Kn / Rn)), $t = [], ur = Number((gn.length - 1) / (On - 1));
            $t[0] = gn[0];
            for (var Or = 1; Or < On - 1; Or++) {
              var Nn = Or * ur, Nr = Number(Math.floor(Nn)).toFixed(), ii = Number(Math.ceil(Nn)).toFixed(), rn = Nn - Nr;
              $t[Or] = wn(gn[Nr], gn[ii], rn);
            }
            return $t[On - 1] = gn[gn.length - 1], $t;
          }
          function wn(gn, Kn, Rn) {
            return gn + (Kn - gn) * Rn;
          }
          function Hn(gn, Kn) {
            for (var Rn = new Float64Array(Kn), On = 0, $t = gn.length, ur = 0; ur < $t; ur++) {
              var Or = gn[ur];
              Rn.set(Or, On), On += Or.length;
            }
            return Rn;
          }
          function jn(gn, Kn) {
            for (var Rn = gn.length + Kn.length, On = new Float64Array(Rn), $t = 0, ur = 0; ur < Rn; )
              On[ur++] = gn[$t], On[ur++] = Kn[$t], $t++;
            return On;
          }
          function Y(gn, Kn, Rn) {
            for (var On = Rn.length, $t = 0; $t < On; $t++)
              gn.setUint8(Kn + $t, Rn.charCodeAt($t));
          }
          var J;
          jt === 2 && (J = jn(Tt, bn)), jt === 1 && (J = Tt);
          var me = J.length, Oe = 44 + me * 2, rt = new ArrayBuffer(Oe), ht = new DataView(rt);
          Y(ht, 0, "RIFF"), ht.setUint32(4, 36 + me * 2, !0), Y(ht, 8, "WAVE"), Y(ht, 12, "fmt "), ht.setUint32(16, 16, !0), ht.setUint16(20, 1, !0), ht.setUint16(22, jt, !0), ht.setUint32(24, Ve, !0), ht.setUint32(28, Ve * jt * 2, !0), ht.setUint16(32, jt * 2, !0), ht.setUint16(34, 16, !0), Y(ht, 36, "data"), ht.setUint32(40, me * 2, !0);
          for (var qt = me, Bt = 44, mr = 1, wr = 0; wr < qt; wr++)
            ht.setInt16(Bt, J[wr] * (32767 * mr), !0), Bt += 2;
          if (Xt)
            return Xt({
              buffer: rt,
              view: ht
            });
          postMessage({
            buffer: rt,
            view: ht
          });
        }
        if (xe.noWorker) {
          At(xe, function(Rt) {
            Be(Rt.buffer, Rt.view);
          });
          return;
        }
        var xt = Ne(At);
        xt.onmessage = function(Rt) {
          Be(Rt.data.buffer, Rt.data.view), d.revokeObjectURL(xt.workerURL), xt.terminate();
        }, xt.postMessage(xe);
      }
      function Ne(xe) {
        var Be = d.createObjectURL(new Blob([
          xe.toString(),
          ";this.onmessage =  function (eee) {" + xe.name + "(eee.data);}"
        ], {
          type: "application/javascript"
        })), At = new Worker(Be);
        return At.workerURL = Be, At;
      }
      this.stop = function(xe) {
        xe = xe || function() {
        }, Z = !1, Ce({
          desiredSampRate: be,
          sampleRate: Ie,
          numberOfAudioChannels: Ee,
          internalInterleavedLength: ye,
          leftBuffers: te,
          rightBuffers: Ee === 1 ? [] : ee,
          noWorker: I.noWorker
        }, function(Be, At) {
          G.blob = new Blob([At], {
            type: "audio/wav"
          }), G.buffer = new ArrayBuffer(At.buffer.byteLength), G.view = At, G.sampleRate = be || Ie, G.bufferSize = at, G.length = ye, Te = !1, xe && xe(G.blob);
        });
      }, typeof e.Storage > "u" && (e.Storage = {
        AudioContextConstructor: null,
        AudioContext: window.AudioContext || window.webkitAudioContext
      }), (!e.Storage.AudioContextConstructor || e.Storage.AudioContextConstructor.state === "closed") && (e.Storage.AudioContextConstructor = new e.Storage.AudioContext());
      var qe = e.Storage.AudioContextConstructor, $e = qe.createMediaStreamSource(P), Xe = [0, 256, 512, 1024, 2048, 4096, 8192, 16384], at = typeof I.bufferSize > "u" ? 4096 : I.bufferSize;
      if (Xe.indexOf(at) === -1 && (I.disableLogs || console.log("Legal values for buffer-size are " + JSON.stringify(Xe, null, "	"))), qe.createJavaScriptNode)
        he = qe.createJavaScriptNode(at, Ee, Ee);
      else if (qe.createScriptProcessor)
        he = qe.createScriptProcessor(at, Ee, Ee);
      else
        throw "WebAudio API has no support on this browser.";
      $e.connect(he), I.bufferSize || (at = he.bufferSize);
      var Ie = typeof I.sampleRate < "u" ? I.sampleRate : qe.sampleRate || 44100;
      (Ie < 22050 || Ie > 96e3) && (I.disableLogs || console.log("sample-rate must be under range 22050 and 96000.")), I.disableLogs || I.desiredSampRate && console.log("Desired sample-rate: " + I.desiredSampRate);
      var ne = !1;
      this.pause = function() {
        ne = !0;
      }, this.resume = function() {
        if (ve() === !1)
          throw "Please make sure MediaStream is active.";
        if (!Z) {
          I.disableLogs || console.log("Seems recording has been restarted."), this.record();
          return;
        }
        ne = !1;
      }, this.clearRecordedData = function() {
        I.checkForInactiveTracks = !1, Z && this.stop(ie), ie();
      };
      function ue() {
        te = [], ee = [], ye = 0, Te = !1, Z = !1, ne = !1, qe = null, G.leftchannel = te, G.rightchannel = ee, G.numberOfAudioChannels = Ee, G.desiredSampRate = be, G.sampleRate = Ie, G.recordingLength = ye, We = {
          left: [],
          right: [],
          recordingLength: 0
        };
      }
      function ie() {
        he && (he.onaudioprocess = null, he.disconnect(), he = null), $e && ($e.disconnect(), $e = null), ue();
      }
      this.name = "StereoAudioRecorder", this.toString = function() {
        return this.name;
      };
      var Te = !1;
      function je(xe) {
        if (!ne) {
          if (ve() === !1 && (I.disableLogs || console.log("MediaStream seems stopped."), he.disconnect(), Z = !1), !Z) {
            $e && ($e.disconnect(), $e = null);
            return;
          }
          Te || (Te = !0, I.onAudioProcessStarted && I.onAudioProcessStarted(), I.initCallback && I.initCallback());
          var Be = xe.inputBuffer.getChannelData(0), At = new Float32Array(Be);
          if (te.push(At), Ee === 2) {
            var xt = xe.inputBuffer.getChannelData(1), Rt = new Float32Array(xt);
            ee.push(Rt);
          }
          ye += at, G.recordingLength = ye, typeof I.timeSlice < "u" && (We.recordingLength += at, We.left.push(At), Ee === 2 && We.right.push(Rt));
        }
      }
      he.onaudioprocess = je, qe.createMediaStreamDestination ? he.connect(qe.createMediaStreamDestination()) : he.connect(qe.destination), this.leftchannel = te, this.rightchannel = ee, this.numberOfAudioChannels = Ee, this.desiredSampRate = be, this.sampleRate = Ie, G.recordingLength = ye;
      var We = {
        left: [],
        right: [],
        recordingLength: 0
      };
      function Qe() {
        !Z || typeof I.ondataavailable != "function" || typeof I.timeSlice > "u" || (We.left.length ? (Ce({
          desiredSampRate: be,
          sampleRate: Ie,
          numberOfAudioChannels: Ee,
          internalInterleavedLength: We.recordingLength,
          leftBuffers: We.left,
          rightBuffers: Ee === 1 ? [] : We.right
        }, function(xe, Be) {
          var At = new Blob([Be], {
            type: "audio/wav"
          });
          I.ondataavailable(At), setTimeout(Qe, I.timeSlice);
        }), We = {
          left: [],
          right: [],
          recordingLength: 0
        }) : setTimeout(Qe, I.timeSlice));
      }
    }
    typeof e < "u" && (e.StereoAudioRecorder = N);
    /**
     * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.
     * @summary HTML2Canvas recording into video WebM.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef CanvasRecorder
     * @class
     * @example
     * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });
     * recorder.record();
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.
     * @param {object} config - {disableLogs:true, initCallback: function}
     */
    function H(P, I) {
      if (typeof html2canvas > "u")
        throw "Please link: https://www.webrtc-experiment.com/screenshot.js";
      I = I || {}, I.frameInterval || (I.frameInterval = 10);
      var G = !1;
      ["captureStream", "mozCaptureStream", "webkitCaptureStream"].forEach(function(Xe) {
        Xe in document.createElement("canvas") && (G = !0);
      });
      var te = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome, ee = 50, Z = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
      te && Z && Z[2] && (ee = parseInt(Z[2], 10)), te && ee < 52 && (G = !1), I.useWhammyRecorder && (G = !1);
      var ye, he;
      if (G)
        if (I.disableLogs || console.log("Your browser supports both MediRecorder API and canvas.captureStream!"), P instanceof HTMLCanvasElement)
          ye = P;
        else if (P instanceof CanvasRenderingContext2D)
          ye = P.canvas;
        else
          throw "Please pass either HTMLCanvasElement or CanvasRenderingContext2D.";
      else navigator.mozGetUserMedia && (I.disableLogs || console.error("Canvas recording is NOT supported in Firefox."));
      var Ee;
      this.record = function() {
        if (Ee = !0, G && !I.useWhammyRecorder) {
          var Xe;
          "captureStream" in ye ? Xe = ye.captureStream(25) : "mozCaptureStream" in ye ? Xe = ye.mozCaptureStream(25) : "webkitCaptureStream" in ye && (Xe = ye.webkitCaptureStream(25));
          try {
            var at = new y();
            at.addTrack(_(Xe, "video")[0]), Xe = at;
          } catch {
          }
          if (!Xe)
            throw "captureStream API are NOT available.";
          he = new T(Xe, {
            mimeType: I.mimeType || "video/webm"
          }), he.record();
        } else
          $e.frames = [], qe = (/* @__PURE__ */ new Date()).getTime(), Ne();
        I.initCallback && I.initCallback();
      }, this.getWebPImages = function(Xe) {
        if (P.nodeName.toLowerCase() !== "canvas") {
          Xe();
          return;
        }
        var at = $e.frames.length;
        $e.frames.forEach(function(Ie, ne) {
          var ue = at - ne;
          I.disableLogs || console.log(ue + "/" + at + " frames remaining"), I.onEncodingCallback && I.onEncodingCallback(ue, at);
          var ie = Ie.image.toDataURL("image/webp", 1);
          $e.frames[ne].image = ie;
        }), I.disableLogs || console.log("Generating WebM"), Xe();
      }, this.stop = function(Xe) {
        Ee = !1;
        var at = this;
        if (G && he) {
          he.stop(Xe);
          return;
        }
        this.getWebPImages(function() {
          $e.compile(function(Ie) {
            I.disableLogs || console.log("Recording finished!"), at.blob = Ie, at.blob.forEach && (at.blob = new Blob([], {
              type: "video/webm"
            })), Xe && Xe(at.blob), $e.frames = [];
          });
        });
      };
      var be = !1;
      this.pause = function() {
        if (be = !0, he instanceof T) {
          he.pause();
          return;
        }
      }, this.resume = function() {
        if (be = !1, he instanceof T) {
          he.resume();
          return;
        }
        Ee || this.record();
      }, this.clearRecordedData = function() {
        Ee && this.stop(ve), ve();
      };
      function ve() {
        $e.frames = [], Ee = !1, be = !1;
      }
      this.name = "CanvasRecorder", this.toString = function() {
        return this.name;
      };
      function Ce() {
        var Xe = document.createElement("canvas"), at = Xe.getContext("2d");
        return Xe.width = P.width, Xe.height = P.height, at.drawImage(P, 0, 0), Xe;
      }
      function Ne() {
        if (be)
          return qe = (/* @__PURE__ */ new Date()).getTime(), setTimeout(Ne, 500);
        if (P.nodeName.toLowerCase() === "canvas") {
          var Xe = (/* @__PURE__ */ new Date()).getTime() - qe;
          qe = (/* @__PURE__ */ new Date()).getTime(), $e.frames.push({
            image: Ce(),
            duration: Xe
          }), Ee && setTimeout(Ne, I.frameInterval);
          return;
        }
        html2canvas(P, {
          grabMouse: typeof I.showMousePointer > "u" || I.showMousePointer,
          onrendered: function(at) {
            var Ie = (/* @__PURE__ */ new Date()).getTime() - qe;
            if (!Ie)
              return setTimeout(Ne, I.frameInterval);
            qe = (/* @__PURE__ */ new Date()).getTime(), $e.frames.push({
              image: at.toDataURL("image/webp", 1),
              duration: Ie
            }), Ee && setTimeout(Ne, I.frameInterval);
          }
        });
      }
      var qe = (/* @__PURE__ */ new Date()).getTime(), $e = new j.Video(100);
    }
    typeof e < "u" && (e.CanvasRecorder = H);
    /**
     * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.
     * @summary Video recording feature in Chrome.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef WhammyRecorder
     * @class
     * @example
     * var recorder = new WhammyRecorder(mediaStream);
     * recorder.record();
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
     * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}
     */
    function $(P, I) {
      I = I || {}, I.frameInterval || (I.frameInterval = 10), I.disableLogs || console.log("Using frames-interval:", I.frameInterval), this.record = function() {
        I.width || (I.width = 320), I.height || (I.height = 240), I.video || (I.video = {
          width: I.width,
          height: I.height
        }), I.canvas || (I.canvas = {
          width: I.width,
          height: I.height
        }), Ee.width = I.canvas.width || 320, Ee.height = I.canvas.height || 240, be = Ee.getContext("2d"), I.video && I.video instanceof HTMLVideoElement ? (ve = I.video.cloneNode(), I.initCallback && I.initCallback()) : (ve = document.createElement("video"), D(P, ve), ve.onloadedmetadata = function() {
          I.initCallback && I.initCallback();
        }, ve.width = I.video.width, ve.height = I.video.height), ve.muted = !0, ve.play(), Ce = (/* @__PURE__ */ new Date()).getTime(), Ne = new j.Video(), I.disableLogs || (console.log("canvas resolutions", Ee.width, "*", Ee.height), console.log("video width/height", ve.width || Ee.width, "*", ve.height || Ee.height)), G(I.frameInterval);
      };
      function G(qe) {
        qe = typeof qe < "u" ? qe : 10;
        var $e = (/* @__PURE__ */ new Date()).getTime() - Ce;
        if (!$e)
          return setTimeout(G, qe, qe);
        if (ye)
          return Ce = (/* @__PURE__ */ new Date()).getTime(), setTimeout(G, 100);
        Ce = (/* @__PURE__ */ new Date()).getTime(), ve.paused && ve.play(), be.drawImage(ve, 0, 0, Ee.width, Ee.height), Ne.frames.push({
          duration: $e,
          image: Ee.toDataURL("image/webp")
        }), Z || setTimeout(G, qe, qe);
      }
      function te(qe) {
        var $e = -1, Xe = qe.length;
        (function at() {
          if ($e++, $e === Xe) {
            qe.callback();
            return;
          }
          setTimeout(function() {
            qe.functionToLoop(at, $e);
          }, 1);
        })();
      }
      function ee(qe, $e, Xe, at, Ie) {
        var ne = document.createElement("canvas");
        ne.width = Ee.width, ne.height = Ee.height;
        var ue = ne.getContext("2d"), ie = [], Te = qe.length, je = {
          r: 0,
          g: 0,
          b: 0
        }, We = Math.sqrt(
          Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2)
        ), Qe = 0, xe = 0, Be = !1;
        te({
          length: Te,
          functionToLoop: function(At, xt) {
            var Rt, Xt, jt, Tt = function() {
              !Be && jt - Rt <= jt * xe || (Be = !0, ie.push(qe[xt])), At();
            };
            if (Be)
              Tt();
            else {
              var bn = new Image();
              bn.onload = function() {
                ue.drawImage(bn, 0, 0, Ee.width, Ee.height);
                var Ve = ue.getImageData(0, 0, Ee.width, Ee.height);
                Rt = 0, Xt = Ve.data.length, jt = Ve.data.length / 4;
                for (var ut = 0; ut < Xt; ut += 4) {
                  var _t = {
                    r: Ve.data[ut],
                    g: Ve.data[ut + 1],
                    b: Ve.data[ut + 2]
                  }, zt = Math.sqrt(
                    Math.pow(_t.r - je.r, 2) + Math.pow(_t.g - je.g, 2) + Math.pow(_t.b - je.b, 2)
                  );
                  zt <= We * Qe && Rt++;
                }
                Tt();
              }, bn.src = qe[xt].image;
            }
          },
          callback: function() {
            ie = ie.concat(qe.slice(Te)), ie.length <= 0 && ie.push(qe[qe.length - 1]), Ie(ie);
          }
        });
      }
      var Z = !1;
      this.stop = function(qe) {
        qe = qe || function() {
        }, Z = !0;
        var $e = this;
        setTimeout(function() {
          ee(Ne.frames, -1, null, null, function(Xe) {
            Ne.frames = Xe, I.advertisement && I.advertisement.length && (Ne.frames = I.advertisement.concat(Ne.frames)), Ne.compile(function(at) {
              $e.blob = at, $e.blob.forEach && ($e.blob = new Blob([], {
                type: "video/webm"
              })), qe && qe($e.blob);
            });
          });
        }, 10);
      };
      var ye = !1;
      this.pause = function() {
        ye = !0;
      }, this.resume = function() {
        ye = !1, Z && this.record();
      }, this.clearRecordedData = function() {
        Z || this.stop(he), he();
      };
      function he() {
        Ne.frames = [], Z = !0, ye = !1;
      }
      this.name = "WhammyRecorder", this.toString = function() {
        return this.name;
      };
      var Ee = document.createElement("canvas"), be = Ee.getContext("2d"), ve, Ce, Ne;
    }
    typeof e < "u" && (e.WhammyRecorder = $);
    /**
     * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}
     * @summary A real time javascript webm encoder based on a canvas hack.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef Whammy
     * @class
     * @example
     * var recorder = new Whammy().Video(15);
     * recorder.add(context || canvas || dataURL);
     * var output = recorder.compile();
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     */
    var j = function() {
      function P(te) {
        this.frames = [], this.duration = te || 1, this.quality = 0.8;
      }
      P.prototype.add = function(te, ee) {
        if ("canvas" in te && (te = te.canvas), "toDataURL" in te && (te = te.toDataURL("image/webp", this.quality)), !/^data:image\/webp;base64,/ig.test(te))
          throw "Input must be formatted properly as a base64 encoded DataURI of type image/webp";
        this.frames.push({
          image: te,
          duration: ee || this.duration
        });
      };
      function I(te) {
        var ee = d.createObjectURL(new Blob([
          te.toString(),
          "this.onmessage =  function (eee) {" + te.name + "(eee.data);}"
        ], {
          type: "application/javascript"
        })), Z = new Worker(ee);
        return d.revokeObjectURL(ee), Z;
      }
      function G(te) {
        function ee(Ie) {
          var ne = ye(Ie);
          if (!ne)
            return [];
          for (var ue = 3e4, ie = [{
            id: 440786851,
            // EBML
            data: [{
              data: 1,
              id: 17030
              // EBMLVersion
            }, {
              data: 1,
              id: 17143
              // EBMLReadVersion
            }, {
              data: 4,
              id: 17138
              // EBMLMaxIDLength
            }, {
              data: 8,
              id: 17139
              // EBMLMaxSizeLength
            }, {
              data: "webm",
              id: 17026
              // DocType
            }, {
              data: 2,
              id: 17031
              // DocTypeVersion
            }, {
              data: 2,
              id: 17029
              // DocTypeReadVersion
            }]
          }, {
            id: 408125543,
            // Segment
            data: [{
              id: 357149030,
              // Info
              data: [{
                data: 1e6,
                //do things in millisecs (num of nanosecs for duration scale)
                id: 2807729
                // TimecodeScale
              }, {
                data: "whammy",
                id: 19840
                // MuxingApp
              }, {
                data: "whammy",
                id: 22337
                // WritingApp
              }, {
                data: Xe(ne.duration),
                id: 17545
                // Duration
              }]
            }, {
              id: 374648427,
              // Tracks
              data: [{
                id: 174,
                // TrackEntry
                data: [{
                  data: 1,
                  id: 215
                  // TrackNumber
                }, {
                  data: 1,
                  id: 29637
                  // TrackUID
                }, {
                  data: 0,
                  id: 156
                  // FlagLacing
                }, {
                  data: "und",
                  id: 2274716
                  // Language
                }, {
                  data: "V_VP8",
                  id: 134
                  // CodecID
                }, {
                  data: "VP8",
                  id: 2459272
                  // CodecName
                }, {
                  data: 1,
                  id: 131
                  // TrackType
                }, {
                  id: 224,
                  // Video
                  data: [{
                    data: ne.width,
                    id: 176
                    // PixelWidth
                  }, {
                    data: ne.height,
                    id: 186
                    // PixelHeight
                  }]
                }]
              }]
            }]
          }], Te = 0, je = 0; Te < Ie.length; ) {
            var We = [], Qe = 0;
            do
              We.push(Ie[Te]), Qe += Ie[Te].duration, Te++;
            while (Te < Ie.length && Qe < ue);
            var xe = 0, Be = {
              id: 524531317,
              // Cluster
              data: Z(je, xe, We)
            };
            ie[1].data.push(Be), je += Qe;
          }
          return ve(ie);
        }
        function Z(Ie, ne, ue) {
          return [{
            data: Ie,
            id: 231
            // Timecode
          }].concat(ue.map(function(ie) {
            var Te = Ce({
              frame: ie.data.slice(4),
              trackNum: 1,
              timecode: Math.round(ne)
            });
            return ne += ie.duration, {
              data: Te,
              id: 163
            };
          }));
        }
        function ye(Ie) {
          if (!Ie[0]) {
            postMessage({
              error: "Something went wrong. Maybe WebP format is not supported in the current browser."
            });
            return;
          }
          for (var ne = Ie[0].width, ue = Ie[0].height, ie = Ie[0].duration, Te = 1; Te < Ie.length; Te++)
            ie += Ie[Te].duration;
          return {
            duration: ie,
            width: ne,
            height: ue
          };
        }
        function he(Ie) {
          for (var ne = []; Ie > 0; )
            ne.push(Ie & 255), Ie = Ie >> 8;
          return new Uint8Array(ne.reverse());
        }
        function Ee(Ie) {
          return new Uint8Array(Ie.split("").map(function(ne) {
            return ne.charCodeAt(0);
          }));
        }
        function be(Ie) {
          var ne = [], ue = Ie.length % 8 ? new Array(9 - Ie.length % 8).join("0") : "";
          Ie = ue + Ie;
          for (var ie = 0; ie < Ie.length; ie += 8)
            ne.push(parseInt(Ie.substr(ie, 8), 2));
          return new Uint8Array(ne);
        }
        function ve(Ie) {
          for (var ne = [], ue = 0; ue < Ie.length; ue++) {
            var ie = Ie[ue].data;
            typeof ie == "object" && (ie = ve(ie)), typeof ie == "number" && (ie = be(ie.toString(2))), typeof ie == "string" && (ie = Ee(ie));
            var Te = ie.size || ie.byteLength || ie.length, je = Math.ceil(Math.ceil(Math.log(Te) / Math.log(2)) / 8), We = Te.toString(2), Qe = new Array(je * 7 + 7 + 1 - We.length).join("0") + We, xe = new Array(je).join("0") + "1" + Qe;
            ne.push(he(Ie[ue].id)), ne.push(be(xe)), ne.push(ie);
          }
          return new Blob(ne, {
            type: "video/webm"
          });
        }
        function Ce(Ie) {
          var ne = 0;
          ne |= 128;
          var ue = [Ie.trackNum | 128, Ie.timecode >> 8, Ie.timecode & 255, ne].map(function(ie) {
            return String.fromCharCode(ie);
          }).join("") + Ie.frame;
          return ue;
        }
        function Ne(Ie) {
          for (var ne = Ie.RIFF[0].WEBP[0], ue = ne.indexOf("*"), ie = 0, Te = []; ie < 4; ie++)
            Te[ie] = ne.charCodeAt(ue + 3 + ie);
          var je, We, Qe;
          return Qe = Te[1] << 8 | Te[0], je = Qe & 16383, Qe = Te[3] << 8 | Te[2], We = Qe & 16383, {
            width: je,
            height: We,
            data: ne,
            riff: Ie
          };
        }
        function qe(Ie, ne) {
          return parseInt(Ie.substr(ne + 4, 4).split("").map(function(ue) {
            var ie = ue.charCodeAt(0).toString(2);
            return new Array(8 - ie.length + 1).join("0") + ie;
          }).join(""), 2);
        }
        function $e(Ie) {
          for (var ne = 0, ue = {}; ne < Ie.length; ) {
            var ie = Ie.substr(ne, 4), Te = qe(Ie, ne), je = Ie.substr(ne + 4 + 4, Te);
            ne += 8 + Te, ue[ie] = ue[ie] || [], ie === "RIFF" || ie === "LIST" ? ue[ie].push($e(je)) : ue[ie].push(je);
          }
          return ue;
        }
        function Xe(Ie) {
          return [].slice.call(
            new Uint8Array(new Float64Array([Ie]).buffer),
            0
          ).map(function(ne) {
            return String.fromCharCode(ne);
          }).reverse().join("");
        }
        var at = new ee(te.map(function(Ie) {
          var ne = Ne($e(atob(Ie.image.slice(23))));
          return ne.duration = Ie.duration, ne;
        }));
        postMessage(at);
      }
      return P.prototype.compile = function(te) {
        var ee = I(G);
        ee.onmessage = function(Z) {
          if (Z.data.error) {
            console.error(Z.data.error);
            return;
          }
          te(Z.data);
        }, ee.postMessage(this.frames);
      }, {
        /**
         * A more abstract-ish API.
         * @method
         * @memberof Whammy
         * @example
         * recorder = new Whammy().Video(0.8, 100);
         * @param {?number} speed - 0.8
         * @param {?number} quality - 100
         */
        Video: P
      };
    }();
    typeof e < "u" && (e.Whammy = j);
    /**
     * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.
     * @summary Writing blobs into IndexedDB.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @example
     * DiskStorage.Store({
     *     audioBlob: yourAudioBlob,
     *     videoBlob: yourVideoBlob,
     *     gifBlob  : yourGifBlob
     * });
     * DiskStorage.Fetch(function(dataURL, type) {
     *     if(type === 'audioBlob') { }
     *     if(type === 'videoBlob') { }
     *     if(type === 'gifBlob')   { }
     * });
     * // DiskStorage.dataStoreName = 'recordRTC';
     * // DiskStorage.onError = function(error) { };
     * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
     * @property {function} Fetch - This method fetches stored blobs from IndexedDB.
     * @property {function} Store - This method stores blobs in IndexedDB.
     * @property {function} onError - This function is invoked for any known/unknown error.
     * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     */
    var U = {
      /**
       * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
       * @method
       * @memberof DiskStorage
       * @internal
       * @example
       * DiskStorage.init();
       */
      init: function() {
        var P = this;
        if (typeof indexedDB > "u" || typeof indexedDB.open > "u") {
          console.error("IndexedDB API are not available in this browser.");
          return;
        }
        var I = 1, G = this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, ""), te, ee = indexedDB.open(G, I);
        function Z(he) {
          he.createObjectStore(P.dataStoreName);
        }
        function ye() {
          var he = te.transaction([P.dataStoreName], "readwrite");
          P.videoBlob && he.objectStore(P.dataStoreName).put(P.videoBlob, "videoBlob"), P.gifBlob && he.objectStore(P.dataStoreName).put(P.gifBlob, "gifBlob"), P.audioBlob && he.objectStore(P.dataStoreName).put(P.audioBlob, "audioBlob");
          function Ee(be) {
            he.objectStore(P.dataStoreName).get(be).onsuccess = function(ve) {
              P.callback && P.callback(ve.target.result, be);
            };
          }
          Ee("audioBlob"), Ee("videoBlob"), Ee("gifBlob");
        }
        ee.onerror = P.onError, ee.onsuccess = function() {
          if (te = ee.result, te.onerror = P.onError, te.setVersion)
            if (te.version !== I) {
              var he = te.setVersion(I);
              he.onsuccess = function() {
                Z(te), ye();
              };
            } else
              ye();
          else
            ye();
        }, ee.onupgradeneeded = function(he) {
          Z(he.target.result);
        };
      },
      /**
       * This method fetches stored blobs from IndexedDB.
       * @method
       * @memberof DiskStorage
       * @internal
       * @example
       * DiskStorage.Fetch(function(dataURL, type) {
       *     if(type === 'audioBlob') { }
       *     if(type === 'videoBlob') { }
       *     if(type === 'gifBlob')   { }
       * });
       */
      Fetch: function(P) {
        return this.callback = P, this.init(), this;
      },
      /**
       * This method stores blobs in IndexedDB.
       * @method
       * @memberof DiskStorage
       * @internal
       * @example
       * DiskStorage.Store({
       *     audioBlob: yourAudioBlob,
       *     videoBlob: yourVideoBlob,
       *     gifBlob  : yourGifBlob
       * });
       */
      Store: function(P) {
        return this.audioBlob = P.audioBlob, this.videoBlob = P.videoBlob, this.gifBlob = P.gifBlob, this.init(), this;
      },
      /**
       * This function is invoked for any known/unknown error.
       * @method
       * @memberof DiskStorage
       * @internal
       * @example
       * DiskStorage.onError = function(error){
       *     alerot( JSON.stringify(error) );
       * };
       */
      onError: function(P) {
        console.error(JSON.stringify(P, null, "	"));
      },
      /**
       * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.
       * @memberof DiskStorage
       * @internal
       * @example
       * DiskStorage.dataStoreName = 'recordRTC';
       */
      dataStoreName: "recordRTC",
      dbName: null
    };
    typeof e < "u" && (e.DiskStorage = U);
    /**
     * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef GifRecorder
     * @class
     * @example
     * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });
     * recorder.record();
     * recorder.stop(function(blob) {
     *     img.src = URL.createObjectURL(blob);
     * });
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.
     * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}
     */
    function V(P, I) {
      if (typeof GIFEncoder > "u") {
        var G = document.createElement("script");
        G.src = "https://www.webrtc-experiment.com/gif-recorder.js", (document.body || document.documentElement).appendChild(G);
      }
      I = I || {};
      var te = P instanceof CanvasRenderingContext2D || P instanceof HTMLCanvasElement;
      this.record = function() {
        if (typeof GIFEncoder > "u") {
          setTimeout(qe.record, 1e3);
          return;
        }
        if (!Ee) {
          setTimeout(qe.record, 1e3);
          return;
        }
        te || (I.width || (I.width = be.offsetWidth || 320), I.height || (I.height = be.offsetHeight || 240), I.video || (I.video = {
          width: I.width,
          height: I.height
        }), I.canvas || (I.canvas = {
          width: I.width,
          height: I.height
        }), ye.width = I.canvas.width || 320, ye.height = I.canvas.height || 240, be.width = I.video.width || 320, be.height = I.video.height || 240), Ne = new GIFEncoder(), Ne.setRepeat(0), Ne.setDelay(I.frameRate || 200), Ne.setQuality(I.quality || 10), Ne.start(), typeof I.onGifRecordingStarted == "function" && I.onGifRecordingStarted();
        function $e(Xe) {
          if (qe.clearedRecordedData !== !0) {
            if (ee)
              return setTimeout(function() {
                $e(Xe);
              }, 100);
            ve = a($e), typeof Ce === void 0 && (Ce = Xe), !(Xe - Ce < 90) && (!te && be.paused && be.play(), te || he.drawImage(be, 0, 0, ye.width, ye.height), I.onGifPreview && I.onGifPreview(ye.toDataURL("image/png")), Ne.addFrame(he), Ce = Xe);
          }
        }
        ve = a($e), I.initCallback && I.initCallback();
      }, this.stop = function($e) {
        $e = $e || function() {
        }, ve && u(ve), this.blob = new Blob([new Uint8Array(Ne.stream().bin)], {
          type: "image/gif"
        }), $e(this.blob), Ne.stream().bin = [];
      };
      var ee = !1;
      this.pause = function() {
        ee = !0;
      }, this.resume = function() {
        ee = !1;
      }, this.clearRecordedData = function() {
        qe.clearedRecordedData = !0, Z();
      };
      function Z() {
        Ne && (Ne.stream().bin = []);
      }
      this.name = "GifRecorder", this.toString = function() {
        return this.name;
      };
      var ye = document.createElement("canvas"), he = ye.getContext("2d");
      te && (P instanceof CanvasRenderingContext2D ? (he = P, ye = he.canvas) : P instanceof HTMLCanvasElement && (he = P.getContext("2d"), ye = P));
      var Ee = !0;
      if (!te) {
        var be = document.createElement("video");
        be.muted = !0, be.autoplay = !0, be.playsInline = !0, Ee = !1, be.onloadedmetadata = function() {
          Ee = !0;
        }, D(P, be), be.play();
      }
      var ve = null, Ce, Ne, qe = this;
    }
    typeof e < "u" && (e.GifRecorder = V);
    function B(P, I) {
      var G = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
      (function(ie) {
        typeof e < "u" || ie && (typeof window < "u" || typeof cn > "u" || (cn.navigator = {
          userAgent: G,
          getUserMedia: function() {
          }
        }, cn.console || (cn.console = {}), (typeof cn.console.log > "u" || typeof cn.console.error > "u") && (cn.console.error = cn.console.log = cn.console.log || function() {
          console.log(arguments);
        }), typeof document > "u" && (ie.document = {
          documentElement: {
            appendChild: function() {
              return "";
            }
          }
        }, document.createElement = document.captureStream = document.mozCaptureStream = function() {
          var Te = {
            getContext: function() {
              return Te;
            },
            play: function() {
            },
            pause: function() {
            },
            drawImage: function() {
            },
            toDataURL: function() {
              return "";
            },
            style: {}
          };
          return Te;
        }, ie.HTMLVideoElement = function() {
        }), typeof location > "u" && (ie.location = {
          protocol: "file:",
          href: "",
          hash: ""
        }), typeof screen > "u" && (ie.screen = {
          width: 0,
          height: 0
        }), typeof be > "u" && (ie.URL = {
          createObjectURL: function() {
            return "";
          },
          revokeObjectURL: function() {
            return "";
          }
        }), ie.window = cn));
      })(typeof cn < "u" ? cn : null), I = I || "multi-streams-mixer";
      var te = [], ee = !1, Z = document.createElement("canvas"), ye = Z.getContext("2d");
      Z.style.opacity = 0, Z.style.position = "absolute", Z.style.zIndex = -1, Z.style.top = "-1000em", Z.style.left = "-1000em", Z.className = I, (document.body || document.documentElement).appendChild(Z), this.disableLogs = !1, this.frameInterval = 10, this.width = 360, this.height = 240, this.useGainNode = !0;
      var he = this, Ee = window.AudioContext;
      typeof Ee > "u" && (typeof webkitAudioContext < "u" && (Ee = webkitAudioContext), typeof mozAudioContext < "u" && (Ee = mozAudioContext));
      var be = window.URL;
      typeof be > "u" && typeof webkitURL < "u" && (be = webkitURL), typeof navigator < "u" && typeof navigator.getUserMedia > "u" && (typeof navigator.webkitGetUserMedia < "u" && (navigator.getUserMedia = navigator.webkitGetUserMedia), typeof navigator.mozGetUserMedia < "u" && (navigator.getUserMedia = navigator.mozGetUserMedia));
      var ve = window.MediaStream;
      typeof ve > "u" && typeof webkitMediaStream < "u" && (ve = webkitMediaStream), typeof ve < "u" && typeof ve.prototype.stop > "u" && (ve.prototype.stop = function() {
        this.getTracks().forEach(function(ie) {
          ie.stop();
        });
      });
      var Ce = {};
      typeof Ee < "u" ? Ce.AudioContext = Ee : typeof webkitAudioContext < "u" && (Ce.AudioContext = webkitAudioContext);
      function Ne(ie, Te) {
        "srcObject" in Te ? Te.srcObject = ie : "mozSrcObject" in Te ? Te.mozSrcObject = ie : Te.srcObject = ie;
      }
      this.startDrawingFrames = function() {
        qe();
      };
      function qe() {
        if (!ee) {
          var ie = te.length, Te = !1, je = [];
          if (te.forEach(function(Qe) {
            Qe.stream || (Qe.stream = {}), Qe.stream.fullcanvas ? Te = Qe : je.push(Qe);
          }), Te)
            Z.width = Te.stream.width, Z.height = Te.stream.height;
          else if (je.length) {
            Z.width = ie > 1 ? je[0].width * 2 : je[0].width;
            var We = 1;
            (ie === 3 || ie === 4) && (We = 2), (ie === 5 || ie === 6) && (We = 3), (ie === 7 || ie === 8) && (We = 4), (ie === 9 || ie === 10) && (We = 5), Z.height = je[0].height * We;
          } else
            Z.width = he.width || 360, Z.height = he.height || 240;
          Te && Te instanceof HTMLVideoElement && $e(Te), je.forEach(function(Qe, xe) {
            $e(Qe, xe);
          }), setTimeout(qe, he.frameInterval);
        }
      }
      function $e(ie, Te) {
        if (!ee) {
          var je = 0, We = 0, Qe = ie.width, xe = ie.height;
          Te === 1 && (je = ie.width), Te === 2 && (We = ie.height), Te === 3 && (je = ie.width, We = ie.height), Te === 4 && (We = ie.height * 2), Te === 5 && (je = ie.width, We = ie.height * 2), Te === 6 && (We = ie.height * 3), Te === 7 && (je = ie.width, We = ie.height * 3), typeof ie.stream.left < "u" && (je = ie.stream.left), typeof ie.stream.top < "u" && (We = ie.stream.top), typeof ie.stream.width < "u" && (Qe = ie.stream.width), typeof ie.stream.height < "u" && (xe = ie.stream.height), ye.drawImage(ie, je, We, Qe, xe), typeof ie.stream.onRender == "function" && ie.stream.onRender(ye, je, We, Qe, xe, Te);
        }
      }
      function Xe() {
        ee = !1;
        var ie = at(), Te = Ie();
        return Te && Te.getTracks().filter(function(je) {
          return je.kind === "audio";
        }).forEach(function(je) {
          ie.addTrack(je);
        }), P.forEach(function(je) {
          je.fullcanvas;
        }), ie;
      }
      function at() {
        ue();
        var ie;
        "captureStream" in Z ? ie = Z.captureStream() : "mozCaptureStream" in Z ? ie = Z.mozCaptureStream() : he.disableLogs || console.error("Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features");
        var Te = new ve();
        return ie.getTracks().filter(function(je) {
          return je.kind === "video";
        }).forEach(function(je) {
          Te.addTrack(je);
        }), Z.stream = Te, Te;
      }
      function Ie() {
        Ce.AudioContextConstructor || (Ce.AudioContextConstructor = new Ce.AudioContext()), he.audioContext = Ce.AudioContextConstructor, he.audioSources = [], he.useGainNode === !0 && (he.gainNode = he.audioContext.createGain(), he.gainNode.connect(he.audioContext.destination), he.gainNode.gain.value = 0);
        var ie = 0;
        if (P.forEach(function(Te) {
          if (Te.getTracks().filter(function(We) {
            return We.kind === "audio";
          }).length) {
            ie++;
            var je = he.audioContext.createMediaStreamSource(Te);
            he.useGainNode === !0 && je.connect(he.gainNode), he.audioSources.push(je);
          }
        }), !!ie)
          return he.audioDestination = he.audioContext.createMediaStreamDestination(), he.audioSources.forEach(function(Te) {
            Te.connect(he.audioDestination);
          }), he.audioDestination.stream;
      }
      function ne(ie) {
        var Te = document.createElement("video");
        return Ne(ie, Te), Te.className = I, Te.muted = !0, Te.volume = 0, Te.width = ie.width || he.width || 360, Te.height = ie.height || he.height || 240, Te.play(), Te;
      }
      this.appendStreams = function(ie) {
        if (!ie)
          throw "First parameter is required.";
        ie instanceof Array || (ie = [ie]), ie.forEach(function(Te) {
          var je = new ve();
          if (Te.getTracks().filter(function(xe) {
            return xe.kind === "video";
          }).length) {
            var We = ne(Te);
            We.stream = Te, te.push(We), je.addTrack(Te.getTracks().filter(function(xe) {
              return xe.kind === "video";
            })[0]);
          }
          if (Te.getTracks().filter(function(xe) {
            return xe.kind === "audio";
          }).length) {
            var Qe = he.audioContext.createMediaStreamSource(Te);
            he.audioDestination = he.audioContext.createMediaStreamDestination(), Qe.connect(he.audioDestination), je.addTrack(he.audioDestination.stream.getTracks().filter(function(xe) {
              return xe.kind === "audio";
            })[0]);
          }
          P.push(je);
        });
      }, this.releaseStreams = function() {
        te = [], ee = !0, he.gainNode && (he.gainNode.disconnect(), he.gainNode = null), he.audioSources.length && (he.audioSources.forEach(function(ie) {
          ie.disconnect();
        }), he.audioSources = []), he.audioDestination && (he.audioDestination.disconnect(), he.audioDestination = null), he.audioContext && he.audioContext.close(), he.audioContext = null, ye.clearRect(0, 0, Z.width, Z.height), Z.stream && (Z.stream.stop(), Z.stream = null);
      }, this.resetVideoStreams = function(ie) {
        ie && !(ie instanceof Array) && (ie = [ie]), ue(ie);
      };
      function ue(ie) {
        te = [], ie = ie || P, ie.forEach(function(Te) {
          if (Te.getTracks().filter(function(We) {
            return We.kind === "video";
          }).length) {
            var je = ne(Te);
            je.stream = Te, te.push(je);
          }
        });
      }
      this.name = "MultiStreamsMixer", this.toString = function() {
        return this.name;
      }, this.getMixedStream = Xe;
    }
    typeof e > "u" && (t.exports = B);
    /**
     * MultiStreamRecorder can record multiple videos in single container.
     * @summary Multi-videos recorder.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef MultiStreamRecorder
     * @class
     * @example
     * var options = {
     *     mimeType: 'video/webm'
     * }
     * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);
     * recorder.record();
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     *
     *     // or
     *     var blob = recorder.blob;
     * });
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStreams} mediaStreams - Array of MediaStreams.
     * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: "video/webm"}
     */
    function R(P, I) {
      P = P || [];
      var G = this, te, ee;
      I = I || {
        elementClass: "multi-streams-mixer",
        mimeType: "video/webm",
        video: {
          width: 360,
          height: 240
        }
      }, I.frameInterval || (I.frameInterval = 10), I.video || (I.video = {}), I.video.width || (I.video.width = 360), I.video.height || (I.video.height = 240), this.record = function() {
        te = new B(P, I.elementClass || "multi-streams-mixer"), Z().length && (te.frameInterval = I.frameInterval || 10, te.width = I.video.width || 360, te.height = I.video.height || 240, te.startDrawingFrames()), I.previewStream && typeof I.previewStream == "function" && I.previewStream(te.getMixedStream()), ee = new T(te.getMixedStream(), I), ee.record();
      };
      function Z() {
        var ye = [];
        return P.forEach(function(he) {
          _(he, "video").forEach(function(Ee) {
            ye.push(Ee);
          });
        }), ye;
      }
      this.stop = function(ye) {
        ee && ee.stop(function(he) {
          G.blob = he, ye(he), G.clearRecordedData();
        });
      }, this.pause = function() {
        ee && ee.pause();
      }, this.resume = function() {
        ee && ee.resume();
      }, this.clearRecordedData = function() {
        ee && (ee.clearRecordedData(), ee = null), te && (te.releaseStreams(), te = null);
      }, this.addStreams = function(ye) {
        if (!ye)
          throw "First parameter is required.";
        ye instanceof Array || (ye = [ye]), P.concat(ye), !(!ee || !te) && (te.appendStreams(ye), I.previewStream && typeof I.previewStream == "function" && I.previewStream(te.getMixedStream()));
      }, this.resetVideoStreams = function(ye) {
        te && (ye && !(ye instanceof Array) && (ye = [ye]), te.resetVideoStreams(ye));
      }, this.getMixer = function() {
        return te;
      }, this.name = "MultiStreamRecorder", this.toString = function() {
        return this.name;
      };
    }
    typeof e < "u" && (e.MultiStreamRecorder = R);
    /**
     * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}
     * @summary Promises for {@link RecordRTC}
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef RecordRTCPromisesHandler
     * @class
     * @example
     * var recorder = new RecordRTCPromisesHandler(mediaStream, options);
     * recorder.startRecording()
     *         .then(successCB)
     *         .catch(errorCB);
     * // Note: You can access all RecordRTC API using "recorder.recordRTC" e.g. 
     * recorder.recordRTC.onStateChanged = function(state) {};
     * recorder.recordRTC.setRecordingDuration(5000);
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.
     * @param {object} config - {type:"video", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}
     * @throws Will throw an error if "new" keyword is not used to initiate "RecordRTCPromisesHandler". Also throws error if first argument "MediaStream" is missing.
     * @requires {@link RecordRTC}
     */
    function K(P, I) {
      if (!this)
        throw 'Use "new RecordRTCPromisesHandler()"';
      if (typeof P > "u")
        throw 'First argument "MediaStream" is required.';
      var G = this;
      G.recordRTC = new e(P, I), this.startRecording = function() {
        return new Promise(function(te, ee) {
          try {
            G.recordRTC.startRecording(), te();
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.stopRecording = function() {
        return new Promise(function(te, ee) {
          try {
            G.recordRTC.stopRecording(function(Z) {
              if (G.blob = G.recordRTC.getBlob(), !G.blob || !G.blob.size) {
                ee("Empty blob.", G.blob);
                return;
              }
              te(Z);
            });
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.pauseRecording = function() {
        return new Promise(function(te, ee) {
          try {
            G.recordRTC.pauseRecording(), te();
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.resumeRecording = function() {
        return new Promise(function(te, ee) {
          try {
            G.recordRTC.resumeRecording(), te();
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.getDataURL = function(te) {
        return new Promise(function(ee, Z) {
          try {
            G.recordRTC.getDataURL(function(ye) {
              ee(ye);
            });
          } catch (ye) {
            Z(ye);
          }
        });
      }, this.getBlob = function() {
        return new Promise(function(te, ee) {
          try {
            te(G.recordRTC.getBlob());
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.getInternalRecorder = function() {
        return new Promise(function(te, ee) {
          try {
            te(G.recordRTC.getInternalRecorder());
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.reset = function() {
        return new Promise(function(te, ee) {
          try {
            te(G.recordRTC.reset());
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.destroy = function() {
        return new Promise(function(te, ee) {
          try {
            te(G.recordRTC.destroy());
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.getState = function() {
        return new Promise(function(te, ee) {
          try {
            te(G.recordRTC.getState());
          } catch (Z) {
            ee(Z);
          }
        });
      }, this.blob = null, this.version = "5.6.2";
    }
    typeof e < "u" && (e.RecordRTCPromisesHandler = K);
    /**
     * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.
     * @summary Video recording feature in Chrome, Firefox and maybe Edge.
     * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}
     * @author {@link https://MuazKhan.com|Muaz Khan}
     * @typedef WebAssemblyRecorder
     * @class
     * @example
     * var recorder = new WebAssemblyRecorder(mediaStream);
     * recorder.record();
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
     * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.
     * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024, realtime: true}
     */
    function Q(P, I) {
      (typeof ReadableStream > "u" || typeof WritableStream > "u") && console.error("Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js"), I = I || {}, I.width = I.width || 640, I.height = I.height || 480, I.frameRate = I.frameRate || 30, I.bitrate = I.bitrate || 1200, I.realtime = I.realtime || !0;
      var G;
      function te() {
        return new ReadableStream({
          start: function(be) {
            var ve = document.createElement("canvas"), Ce = document.createElement("video"), Ne = !0;
            Ce.srcObject = P, Ce.muted = !0, Ce.height = I.height, Ce.width = I.width, Ce.volume = 0, Ce.onplaying = function() {
              ve.width = I.width, ve.height = I.height;
              var qe = ve.getContext("2d"), $e = 1e3 / I.frameRate, Xe = setInterval(function() {
                if (G && (clearInterval(Xe), be.close()), Ne && (Ne = !1, I.onVideoProcessStarted && I.onVideoProcessStarted()), qe.drawImage(Ce, 0, 0), be._controlledReadableStream.state !== "closed")
                  try {
                    be.enqueue(
                      qe.getImageData(0, 0, I.width, I.height)
                    );
                  } catch {
                  }
              }, $e);
            }, Ce.play();
          }
        });
      }
      var ee;
      function Z(be, ve) {
        if (!I.workerPath && !ve) {
          G = !1, fetch(
            "https://unpkg.com/webm-wasm@latest/dist/webm-worker.js"
          ).then(function(Ne) {
            Ne.arrayBuffer().then(function(qe) {
              Z(be, qe);
            });
          });
          return;
        }
        if (!I.workerPath && ve instanceof ArrayBuffer) {
          var Ce = new Blob([ve], {
            type: "text/javascript"
          });
          I.workerPath = d.createObjectURL(Ce);
        }
        I.workerPath || console.error("workerPath parameter is missing."), ee = new Worker(I.workerPath), ee.postMessage(I.webAssemblyPath || "https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm"), ee.addEventListener("message", function(Ne) {
          Ne.data === "READY" ? (ee.postMessage({
            width: I.width,
            height: I.height,
            bitrate: I.bitrate || 1200,
            timebaseDen: I.frameRate || 30,
            realtime: I.realtime
          }), te().pipeTo(new WritableStream({
            write: function(qe) {
              if (G) {
                console.error("Got image, but recorder is finished!");
                return;
              }
              ee.postMessage(qe.data.buffer, [qe.data.buffer]);
            }
          }))) : Ne.data && (ye || Ee.push(Ne.data));
        });
      }
      this.record = function() {
        Ee = [], ye = !1, this.blob = null, Z(P), typeof I.initCallback == "function" && I.initCallback();
      };
      var ye;
      this.pause = function() {
        ye = !0;
      }, this.resume = function() {
        ye = !1;
      };
      function he(be) {
        if (!ee) {
          be && be();
          return;
        }
        ee.addEventListener("message", function(ve) {
          ve.data === null && (ee.terminate(), ee = null, be && be());
        }), ee.postMessage(null);
      }
      var Ee = [];
      this.stop = function(be) {
        G = !0;
        var ve = this;
        he(function() {
          ve.blob = new Blob(Ee, {
            type: "video/webm"
          }), be(ve.blob);
        });
      }, this.name = "WebAssemblyRecorder", this.toString = function() {
        return this.name;
      }, this.clearRecordedData = function() {
        Ee = [], ye = !1, this.blob = null;
      }, this.blob = null;
    }
    typeof e < "u" && (e.WebAssemblyRecorder = Q);
  }(L2)), L2.exports;
}
var sPe = iPe(), P2 = {}, R2, JC;
function aPe() {
  if (JC) return R2;
  JC = 1;
  function t(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  return R2 = t, R2;
}
var B2 = { exports: {} }, eS;
function oPe() {
  return eS || (eS = 1, function(t) {
    var e = function(n) {
      var r = Object.prototype, i = r.hasOwnProperty, s = Object.defineProperty || function(Q, P, I) {
        Q[P] = I.value;
      }, a, o = typeof Symbol == "function" ? Symbol : {}, u = o.iterator || "@@iterator", c = o.asyncIterator || "@@asyncIterator", d = o.toStringTag || "@@toStringTag";
      function l(Q, P, I) {
        return Object.defineProperty(Q, P, {
          value: I,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), Q[P];
      }
      try {
        l({}, "");
      } catch {
        l = function(P, I, G) {
          return P[I] = G;
        };
      }
      function f(Q, P, I, G) {
        var te = P && P.prototype instanceof v ? P : v, ee = Object.create(te.prototype), Z = new B(G || []);
        return s(ee, "_invoke", { value: $(Q, I, Z) }), ee;
      }
      n.wrap = f;
      function p(Q, P, I) {
        try {
          return { type: "normal", arg: Q.call(P, I) };
        } catch (G) {
          return { type: "throw", arg: G };
        }
      }
      var m = "suspendedStart", g = "suspendedYield", y = "executing", b = "completed", E = {};
      function v() {
      }
      function _() {
      }
      function D() {
      }
      var S = {};
      l(S, u, function() {
        return this;
      });
      var M = Object.getPrototypeOf, O = M && M(M(R([])));
      O && O !== r && i.call(O, u) && (S = O);
      var T = D.prototype = v.prototype = Object.create(S);
      _.prototype = D, s(T, "constructor", { value: D, configurable: !0 }), s(
        D,
        "constructor",
        { value: _, configurable: !0 }
      ), _.displayName = l(
        D,
        d,
        "GeneratorFunction"
      );
      function N(Q) {
        ["next", "throw", "return"].forEach(function(P) {
          l(Q, P, function(I) {
            return this._invoke(P, I);
          });
        });
      }
      n.isGeneratorFunction = function(Q) {
        var P = typeof Q == "function" && Q.constructor;
        return P ? P === _ || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (P.displayName || P.name) === "GeneratorFunction" : !1;
      }, n.mark = function(Q) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(Q, D) : (Q.__proto__ = D, l(Q, d, "GeneratorFunction")), Q.prototype = Object.create(T), Q;
      }, n.awrap = function(Q) {
        return { __await: Q };
      };
      function H(Q, P) {
        function I(ee, Z, ye, he) {
          var Ee = p(Q[ee], Q, Z);
          if (Ee.type === "throw")
            he(Ee.arg);
          else {
            var be = Ee.arg, ve = be.value;
            return ve && typeof ve == "object" && i.call(ve, "__await") ? P.resolve(ve.__await).then(function(Ce) {
              I("next", Ce, ye, he);
            }, function(Ce) {
              I("throw", Ce, ye, he);
            }) : P.resolve(ve).then(function(Ce) {
              be.value = Ce, ye(be);
            }, function(Ce) {
              return I("throw", Ce, ye, he);
            });
          }
        }
        var G;
        function te(ee, Z) {
          function ye() {
            return new P(function(he, Ee) {
              I(ee, Z, he, Ee);
            });
          }
          return G = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          G ? G.then(
            ye,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            ye
          ) : ye();
        }
        s(this, "_invoke", { value: te });
      }
      N(H.prototype), l(H.prototype, c, function() {
        return this;
      }), n.AsyncIterator = H, n.async = function(Q, P, I, G, te) {
        te === void 0 && (te = Promise);
        var ee = new H(
          f(Q, P, I, G),
          te
        );
        return n.isGeneratorFunction(P) ? ee : ee.next().then(function(Z) {
          return Z.done ? Z.value : ee.next();
        });
      };
      function $(Q, P, I) {
        var G = m;
        return function(ee, Z) {
          if (G === y)
            throw new Error("Generator is already running");
          if (G === b) {
            if (ee === "throw")
              throw Z;
            return K();
          }
          for (I.method = ee, I.arg = Z; ; ) {
            var ye = I.delegate;
            if (ye) {
              var he = j(ye, I);
              if (he) {
                if (he === E) continue;
                return he;
              }
            }
            if (I.method === "next")
              I.sent = I._sent = I.arg;
            else if (I.method === "throw") {
              if (G === m)
                throw G = b, I.arg;
              I.dispatchException(I.arg);
            } else I.method === "return" && I.abrupt("return", I.arg);
            G = y;
            var Ee = p(Q, P, I);
            if (Ee.type === "normal") {
              if (G = I.done ? b : g, Ee.arg === E)
                continue;
              return {
                value: Ee.arg,
                done: I.done
              };
            } else Ee.type === "throw" && (G = b, I.method = "throw", I.arg = Ee.arg);
          }
        };
      }
      function j(Q, P) {
        var I = P.method, G = Q.iterator[I];
        if (G === a)
          return P.delegate = null, I === "throw" && Q.iterator.return && (P.method = "return", P.arg = a, j(Q, P), P.method === "throw") || I !== "return" && (P.method = "throw", P.arg = new TypeError(
            "The iterator does not provide a '" + I + "' method"
          )), E;
        var te = p(G, Q.iterator, P.arg);
        if (te.type === "throw")
          return P.method = "throw", P.arg = te.arg, P.delegate = null, E;
        var ee = te.arg;
        if (!ee)
          return P.method = "throw", P.arg = new TypeError("iterator result is not an object"), P.delegate = null, E;
        if (ee.done)
          P[Q.resultName] = ee.value, P.next = Q.nextLoc, P.method !== "return" && (P.method = "next", P.arg = a);
        else
          return ee;
        return P.delegate = null, E;
      }
      N(T), l(T, d, "Generator"), l(T, u, function() {
        return this;
      }), l(T, "toString", function() {
        return "[object Generator]";
      });
      function U(Q) {
        var P = { tryLoc: Q[0] };
        1 in Q && (P.catchLoc = Q[1]), 2 in Q && (P.finallyLoc = Q[2], P.afterLoc = Q[3]), this.tryEntries.push(P);
      }
      function V(Q) {
        var P = Q.completion || {};
        P.type = "normal", delete P.arg, Q.completion = P;
      }
      function B(Q) {
        this.tryEntries = [{ tryLoc: "root" }], Q.forEach(U, this), this.reset(!0);
      }
      n.keys = function(Q) {
        var P = Object(Q), I = [];
        for (var G in P)
          I.push(G);
        return I.reverse(), function te() {
          for (; I.length; ) {
            var ee = I.pop();
            if (ee in P)
              return te.value = ee, te.done = !1, te;
          }
          return te.done = !0, te;
        };
      };
      function R(Q) {
        if (Q) {
          var P = Q[u];
          if (P)
            return P.call(Q);
          if (typeof Q.next == "function")
            return Q;
          if (!isNaN(Q.length)) {
            var I = -1, G = function te() {
              for (; ++I < Q.length; )
                if (i.call(Q, I))
                  return te.value = Q[I], te.done = !1, te;
              return te.value = a, te.done = !0, te;
            };
            return G.next = G;
          }
        }
        return { next: K };
      }
      n.values = R;
      function K() {
        return { value: a, done: !0 };
      }
      return B.prototype = {
        constructor: B,
        reset: function(Q) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = a, this.done = !1, this.delegate = null, this.method = "next", this.arg = a, this.tryEntries.forEach(V), !Q)
            for (var P in this)
              P.charAt(0) === "t" && i.call(this, P) && !isNaN(+P.slice(1)) && (this[P] = a);
        },
        stop: function() {
          this.done = !0;
          var Q = this.tryEntries[0], P = Q.completion;
          if (P.type === "throw")
            throw P.arg;
          return this.rval;
        },
        dispatchException: function(Q) {
          if (this.done)
            throw Q;
          var P = this;
          function I(he, Ee) {
            return ee.type = "throw", ee.arg = Q, P.next = he, Ee && (P.method = "next", P.arg = a), !!Ee;
          }
          for (var G = this.tryEntries.length - 1; G >= 0; --G) {
            var te = this.tryEntries[G], ee = te.completion;
            if (te.tryLoc === "root")
              return I("end");
            if (te.tryLoc <= this.prev) {
              var Z = i.call(te, "catchLoc"), ye = i.call(te, "finallyLoc");
              if (Z && ye) {
                if (this.prev < te.catchLoc)
                  return I(te.catchLoc, !0);
                if (this.prev < te.finallyLoc)
                  return I(te.finallyLoc);
              } else if (Z) {
                if (this.prev < te.catchLoc)
                  return I(te.catchLoc, !0);
              } else if (ye) {
                if (this.prev < te.finallyLoc)
                  return I(te.finallyLoc);
              } else
                throw new Error("try statement without catch or finally");
            }
          }
        },
        abrupt: function(Q, P) {
          for (var I = this.tryEntries.length - 1; I >= 0; --I) {
            var G = this.tryEntries[I];
            if (G.tryLoc <= this.prev && i.call(G, "finallyLoc") && this.prev < G.finallyLoc) {
              var te = G;
              break;
            }
          }
          te && (Q === "break" || Q === "continue") && te.tryLoc <= P && P <= te.finallyLoc && (te = null);
          var ee = te ? te.completion : {};
          return ee.type = Q, ee.arg = P, te ? (this.method = "next", this.next = te.finallyLoc, E) : this.complete(ee);
        },
        complete: function(Q, P) {
          if (Q.type === "throw")
            throw Q.arg;
          return Q.type === "break" || Q.type === "continue" ? this.next = Q.arg : Q.type === "return" ? (this.rval = this.arg = Q.arg, this.method = "return", this.next = "end") : Q.type === "normal" && P && (this.next = P), E;
        },
        finish: function(Q) {
          for (var P = this.tryEntries.length - 1; P >= 0; --P) {
            var I = this.tryEntries[P];
            if (I.finallyLoc === Q)
              return this.complete(I.completion, I.afterLoc), V(I), E;
          }
        },
        catch: function(Q) {
          for (var P = this.tryEntries.length - 1; P >= 0; --P) {
            var I = this.tryEntries[P];
            if (I.tryLoc === Q) {
              var G = I.completion;
              if (G.type === "throw") {
                var te = G.arg;
                V(I);
              }
              return te;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(Q, P, I) {
          return this.delegate = {
            iterator: R(Q),
            resultName: P,
            nextLoc: I
          }, this.method === "next" && (this.arg = a), E;
        }
      }, n;
    }(
      // If this script is executing as a CommonJS module, use module.exports
      // as the regeneratorRuntime namespace. Otherwise create a new empty
      // object. Either way, the resulting object will be used to initialize
      // the regeneratorRuntime variable at the top of this file.
      t.exports
    );
    try {
      regeneratorRuntime = e;
    } catch {
      typeof globalThis == "object" ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e);
    }
  }(B2)), B2.exports;
}
var F2, tS;
function uPe() {
  return tS || (tS = 1, F2 = oPe()), F2;
}
var U2, nS;
function lPe() {
  if (nS) return U2;
  nS = 1;
  function t(n, r, i, s, a, o, u) {
    try {
      var c = n[o](u), d = c.value;
    } catch (l) {
      i(l);
      return;
    }
    c.done ? r(d) : Promise.resolve(d).then(s, a);
  }
  function e(n) {
    return function() {
      var r = this, i = arguments;
      return new Promise(function(s, a) {
        var o = n.apply(r, i);
        function u(d) {
          t(o, s, a, u, c, "next", d);
        }
        function c(d) {
          t(o, s, a, u, c, "throw", d);
        }
        u(void 0);
      });
    };
  }
  return U2 = e, U2;
}
var rS;
function cPe() {
  return rS || (rS = 1, function(t) {
    var e = aPe();
    Object.defineProperty(t, "__esModule", { value: !0 }), t.default = i;
    var n = e(uPe()), r = e(lPe());
    function i(a) {
      return s.apply(this, arguments);
    }
    function s() {
      return (s = (0, r.default)(n.default.mark(function a(o) {
        var u, c;
        return n.default.wrap(function(d) {
          for (; ; ) switch (d.prev = d.next) {
            case 0:
              return u = document.createElement("video"), c = new Promise(function(l, f) {
                u.addEventListener("loadedmetadata", function() {
                  u.duration === 1 / 0 ? (u.currentTime = Number.MAX_SAFE_INTEGER, u.ontimeupdate = function() {
                    u.ontimeupdate = null, l(u.duration), u.currentTime = 0;
                  }) : l(u.duration);
                }), u.onerror = function(p) {
                  return f(p.target.error);
                };
              }), u.src = typeof o == "string" || o instanceof String ? o : window.URL.createObjectURL(o), d.abrupt("return", c);
            case 4:
            case "end":
              return d.stop();
          }
        }, a);
      }))).apply(this, arguments);
    }
  }(P2)), P2;
}
var dPe = cPe();
const fPe = /* @__PURE__ */ Fr(dPe), hPe = {}, pPe = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "128",
  height: "128",
  version: "1.0",
  viewBox: "0 0 96 96"
};
function mPe(t, e) {
  return X(), se("svg", pPe, e[0] || (e[0] = [
    W("path", { d: "M9.2 13.2C8.4 14 8 18.6 8 27.1 8 37.3 8.3 40 9.6 41c.9.9 11.2 2.3 27.5 3.9C51.3 46.3 63 47.7 63 48c0 .3-11.7 1.7-25.9 3.1-16.3 1.6-26.6 3-27.5 3.9C8.3 56 8 58.7 8 69c0 13.8.7 15.8 5.2 14.6 5.7-1.6 73.3-32.5 74.2-33.9.8-1.2.8-2.2 0-3.4-1-1.6-72.6-34.1-75.4-34.2-.9-.1-2.1.4-2.8 1.1z" }, null, -1)
  ]));
}
const D0 = /* @__PURE__ */ mn(hPe, [["render", mPe]]), gPe = { class: "flex grow items-center gap-1" }, APe = { class: "relative flex h-12 w-0 min-w-0 grow items-center gap-3 rounded-xl bg-gray-100 px-3 dark:bg-zinc-700" }, bPe = {
  key: 0,
  class: "flex items-center gap-1 rounded-xl bg-white p-2 text-xs text-gray-600 transition duration-150 ease-in-out dark:bg-zinc-800"
}, yPe = { class: "volumes" }, vPe = { class: "ml-auto rounded-full bg-black/30 px-2 py-1 text-xs font-bold text-white" }, iS = "audio/webm", TPe = 180, _Pe = /* @__PURE__ */ Ze({
  __name: "AudioInput",
  setup(t) {
    const { t: e } = Ri(), n = Yt(), r = de(() => n.state.imkit.config.styles), i = Se(
      3
      /* DidStop */
    ), s = Se(), a = Se(), o = Se(0), u = Se(0), c = Se(), d = Se(), l = ja([]), f = Se(""), p = de(() => o.value > 1), m = async () => {
      var y, b;
      try {
        switch (i.value) {
          case 3: {
            i.value = 0, l.splice(0), o.value = 0, u.value = 0, s.value = await navigator.mediaDevices.getUserMedia({
              video: !1,
              audio: !0
            }), a.value = new sPe.RecordRTCPromisesHandler(s.value, {
              type: "audio",
              mimeType: iS
            });
            let E = new AudioContext(), v = E.createAnalyser();
            v.fftSize = 64, v.smoothingTimeConstant = 0, E.createMediaStreamSource(s.value).connect(v), d.value = window.setInterval(() => {
              let D = new Uint8Array(v.frequencyBinCount);
              v.getByteFrequencyData(D);
              let S = D.reduce((O, T) => O + T) / D.length;
              const M = Math.min(1, S / 128);
              l.unshift(M);
            }, 100), await a.value.startRecording(), u.value = Date.now(), c.value = window.setInterval(() => {
              o.value = (Date.now() - u.value) / 1e3, o.value >= TPe && m();
            }, 1e3), i.value = 1;
            break;
          }
          case 1:
            i.value = 2, await ((y = a.value) == null ? void 0 : y.stopRecording()), (b = s.value) == null || b.getTracks().forEach((E) => E.stop()), clearInterval(c.value), clearInterval(d.value), i.value = 3;
            break;
          default:
            break;
        }
      } catch (E) {
        console.error(E), f.value = e("noAccessMicrophonePermission");
      }
    }, g = async () => {
      var b;
      i.value !== 3 && await m(), l.splice(0), o.value = 0, u.value = 0;
      let y = await ((b = a.value) == null ? void 0 : b.getBlob());
      if (y) {
        const E = await fPe(y), v = new File([y], `${n0()}.webm`), _ = {
          roomId: n.state.imkit.selectedRoomId,
          messageType: "audio",
          file: v,
          duration: E,
          originalUrl: "",
          extra: {
            mimeType: iS,
            fileName: v.name.split(".").slice(0, -1).join("."),
            bytes: v.size,
            fileExtension: v.name.split(".").pop()
          }
        };
        await n.dispatch("imkit/sendMessage", _);
      }
    };
    return Dc(() => {
      clearInterval(c.value), clearInterval(d.value);
    }), (y, b) => (X(), se("div", gPe, [
      W("div", APe, [
        W("div", {
          class: "flex h-8 w-8 shrink-0 items-center justify-center rounded-full border-2 border-gray-300",
          onClick: m
        }, [
          W("div", {
            class: vt(["h-6 w-6 rounded-full bg-red-500 transition-all duration-200 ease-in", {
              "h-3! w-3! rounded-xs": i.value != 1,
              "cursor-not-allowed bg-red-300": f.value
            }])
          }, null, 2)
        ]),
        et(Lu, null, {
          default: Zt(() => [
            f.value ? (X(), se("div", bPe, [
              b[0] || (b[0] = W("img", {
                class: "h-4 w-4",
                src: HN
              }, null, -1)),
              An(" " + _e(f.value), 1)
            ])) : Fe("", !0)
          ]),
          _: 1
        }),
        W("div", yPe, [
          (X(!0), se(wt, null, on(l, (E, v) => (X(), se("div", {
            key: v,
            class: "min-h-0.5! w-0.5 shrink-0 rounded-sm bg-gray-400",
            style: Qt({ height: `${E * 28}px` })
          }, null, 4))), 128))
        ]),
        W("div", vPe, _e(Math.floor(o.value / 60)) + ":" + _e(`${Math.floor(o.value % 60)}`.padStart(2, "0")), 1)
      ]),
      p.value ? (X(), gt(D0, {
        key: 0,
        class: "mr-1 ml-2 h-6 w-6 cursor-pointer fill-blue-500",
        style: Qt(r.value.sendButtonEnabled),
        onClick: g
      }, null, 8, ["style"])) : (X(), gt(D0, {
        key: 1,
        disabled: !p.value,
        class: "mr-1 ml-2 h-6 w-6 cursor-not-allowed fill-gray-200 dark:fill-gray-700",
        style: Qt(r.value.sendButtonDisabled)
      }, null, 8, ["disabled", "style"]))
    ]));
  }
}), EPe = /* @__PURE__ */ mn(_Pe, [["__scopeId", "data-v-3b1a855f"]]), zN = () => {
  const t = window.location.href, e = t.substring(t.indexOf("?"));
  return new URLSearchParams(
    e.lastIndexOf("#/") == -1 ? e : e.substring(0, e.lastIndexOf("#/"))
  );
}, xPe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHElEQVR4nO3UMU7DQBCF4ZEo4Aq0nICCKg03oMJpOIOVN1Nlx4UPAJcDypwgdInoiAJaCB3YG7IQ1nmftJJlWWP9XnlFiIiIiIiIiIhoR8D0DPA71XAbr2XIzJqRalio+uvHCot4Tw4j1t8X4M+q4VIOIVaHGG09sYOKtsTYQUSbNSPAl1+HhZe4voleFneQWffOroDmBgjXHdHl7LQlxH4+W3y0bRFbfLT9ILbYaNshtrhowC96TuNx+qww7jq947t+tyYB4I85YtOiw4PsU9u2JzljE6LXdV0f563YUvzqOWN7ou9l3yYTPwd8tomdm02vcs2Os1T9afMPz+K75L8A/LSqqqPcc+PMODv3XCIiIiIiIiIiIiIi+QNvk5r+mltEG0oAAAAASUVORK5CYII=", wPe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAABG0lEQVR4nO3UMU7DMBiGYUsMcAVWTsDA1IUbdEIsHIlejrKlQ5r8H07SjYqtiCCrRUxNU2ooTt9HsmQp0W+9iWTnAAAAAAAAcKCiqK/MqolZ9Rj2bsikZmTmX6WqDWu9b0buFGL1Hf1Wlv7WnUKshhitHbGDilbP2EFEax273BK2CmvLs2VyF5k6/qyZfy/Llwczf9cRnc6fVo/Yr3eTj9YesclH6wexyUbrgNjkoovC33TdxlJ133dWeLfr9g5n/W5ND5J/jhHbJ1ryU3dMeZ5fxIzdFW3mP7IsO49bsafw1WPGdkf7J3dskq4lP9vENlI9jje7HptVi03sLJzl/ov5fHHZtu1Z7LlhZpgdey4AAAAAAAAAAO4PfAKuTjfhZH9KRQAAAABJRU5ErkJggg==", CPe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLElEQVR4nO3UMU7DMBTGcSMGOAMbnICBBRZuwES6cIbIn1NFynOG7NwOWOECMBWxgQA91EqA2iRtLCW2vp/k0c/5x5KNISIiIiIiIiIiIiKKz15ZlkdZlu2HHqwzdbaeYabAWn/qnH9yzn8555+LoroKNVtnAfKiswF51LPM2AD/sIz9WYC8AzIbPldmOuvf7HszpqZpDn9/UKjodbHL9Znn+UHYii3pXw8Z3RKr686MDfBngH8NEd0Wq2foWWYKrK3OnZPFhlv5AOqbrhmAXLfEvjknl2ZK7IDo6GKHREcbu0t09LHbRCcTu1IU9UXH673xNda9Jka2/abTuNldo5OI7RudVGxXdJKxK/oY/Y2WRbQPVF9AdQLIra75vD7uvZGIiIiIiIiIiMx632C5/lbO/M2+AAAAAElFTkSuQmCC", SPe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLklEQVR4nO3UMU7DMBTGcVcd4AxscAIGFli4QSfUhRtxO2CLQJHzPp5TOoHYQBiZhEqgNk0To8bR95MiZcmz/7FkY4iIiIiIiIiIiIiIEuO9n1i7PPLeT/9h9rSePTFDAOAU0EfAeRH3DJSzeLPLmYhbhtmAPoS1Ys3uDND7akPVI6LvgJv3n+vm9azVbEDvzD7leX74e0NxotfHfs/9zLLsIG7FjsJfjxm9KbY+4Vuzb9bqmYi+xohuig1rhLXMEADluYi+bNjoR1E8XW+bIaJXDbFvRaGXZkjQIzq52D7RycZ2iU4+dpfo0cT+ABYXTbd3020cvjUpQsNJj+Zku0aPIrZt9Khit0WPMvbPRbaKrt4TvaDasrY8EdGb8Djnjlt/SEREREREREREZr0vWIQ93o81LZQAAAAASUVORK5CYII=", IPe = { class: "relative flex grow items-center rounded-lg bg-gray-100 px-4 py-3 dark:bg-zinc-700" }, kPe = {
  key: 0,
  class: "flex h-5 w-5 items-center justify-center"
}, DPe = {
  key: 1,
  class: "h-5 w-5 cursor-pointer",
  src: H0,
  alt: "Search Icon"
}, MPe = ["placeholder"], OPe = { class: "absolute top-1/2 right-2 flex -translate-y-1/2 items-center justify-center" }, NPe = { class: "pb-0.5 text-sm font-medium text-gray-500 dark:text-gray-300" }, LPe = {
  key: 1,
  width: "20",
  height: "20",
  src: wPe,
  alt: "collapse-arrow"
}, PPe = {
  key: 3,
  width: "20",
  height: "20",
  src: SPe,
  alt: "expand-arrow"
}, RPe = /* @__PURE__ */ Ze({
  __name: "SearchPanel",
  setup(t) {
    const e = Yt(), n = Se(""), r = Se(0), i = Se([]), s = Se(!1), a = Se(!1), o = async () => {
      var p;
      if (!s.value && n.value) {
        a.value = !0;
        const {
          data: { result: m }
        } = await e.state.imkit.axios.post(Da.Search, {
          type: ["messages"],
          room: e.state.imkit.selectedRoomId,
          keyword: n.value
        });
        i.value = ((p = m.messages[0]) == null ? void 0 : p.messages) ?? [], a.value = !1, i.value.length > 0 ? (r.value = i.value.length, await e.commit("imkit/setState", {
          messageSearchKeyword: n.value
        }), await e.dispatch(
          "imkit/navigateToMessage",
          i.value[r.value - 1]
        )) : r.value = 0;
      }
    }, u = (p) => {
      p > 0 && p <= i.value.length && (r.value = p, e.dispatch("imkit/navigateToMessage", i.value[p - 1]));
    }, c = Lh(1e3, o), d = x_(500, c, {
      atBegin: !1
    }), l = de(() => e.state.imkit.config.styles);
    Ct(n, d), Tr(() => {
      n.value = e.state.imkit.messageSearchKeyword, i.value = e.state.imkit.searchedMessageIds.get(
        e.state.imkit.selectedRoomId
      ) ?? [];
    });
    const f = () => {
      e.commit("imkit/setState", {
        isSearchInRoomMode: !1,
        messageSearchKeyword: ""
      });
    };
    return (p, m) => (X(), se("div", {
      class: "flex h-15 items-center justify-center border-b border-solid border-gray-200 p-2 dark:border-zinc-700",
      style: Qt(l.value.chatRoomHeader)
    }, [
      W("div", IPe, [
        W("div", null, [
          a.value ? (X(), se("div", kPe, [
            et(_c)
          ])) : (X(), se("img", DPe))
        ]),
        Gt(W("input", {
          "onUpdate:modelValue": m[0] || (m[0] = (g) => n.value = g),
          class: "-mr-4 ml-2 h-5 grow bg-gray-100 placeholder-gray-400 outline-none dark:bg-zinc-700",
          placeholder: p.$t("searchInConversation"),
          onCompositionstart: m[1] || (m[1] = (g) => s.value = !0),
          onCompositionend: m[2] || (m[2] = (g) => s.value = !1)
        }, null, 40, MPe), [
          [ds, n.value]
        ]),
        W("div", OPe, [
          !a.value && n.value.length > 0 ? (X(), se(wt, { key: 0 }, [
            W("div", NPe, _e(r.value) + "/" + _e(i.value.length), 1),
            r.value > 1 ? (X(), se("img", {
              key: 0,
              class: "cursor-pointer",
              width: "20",
              height: "20",
              src: xPe,
              alt: "collapse-arrow",
              onClick: m[3] || (m[3] = (g) => u(r.value - 1))
            })) : (X(), se("img", LPe)),
            r.value < i.value.length ? (X(), se("img", {
              key: 2,
              class: "cursor-pointer",
              width: "20",
              height: "20",
              src: CPe,
              alt: "expand-arrow",
              onClick: m[4] || (m[4] = (g) => u(r.value + 1))
            })) : (X(), se("img", PPe))
          ], 64)) : Fe("", !0),
          W("img", {
            src: Kg,
            class: "h-5 w-5 cursor-pointer",
            alt: "Clear Icon",
            onClick: m[5] || (m[5] = () => {
              ke(d).cancel({ upcomingOnly: !0 }), n.value = "", ke(c)(), f();
            })
          })
        ])
      ])
    ], 4));
  }
});
function Ca(t) {
  return typeof t == "string" ? t.endsWith("px") ? Number(t.slice(0, t.length - 2)) : Number(t) : t;
}
function $2(t) {
  if (t != null)
    return typeof t == "number" ? `${t}px` : t.endsWith("px") ? t : `${t}px`;
}
const sS = {
  black: "#000",
  silver: "#C0C0C0",
  gray: "#808080",
  white: "#FFF",
  maroon: "#800000",
  red: "#F00",
  purple: "#800080",
  fuchsia: "#F0F",
  green: "#008000",
  lime: "#0F0",
  olive: "#808000",
  yellow: "#FF0",
  navy: "#000080",
  blue: "#00F",
  teal: "#008080",
  aqua: "#0FF",
  transparent: "#0000"
}, Zc = "^\\s*", Jc = "\\s*$", yu = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*", vu = "([0-9A-Fa-f])", Tu = "([0-9A-Fa-f]{2})", BPe = new RegExp(`${Zc}rgb\\s*\\(${yu},${yu},${yu}\\)${Jc}`), FPe = new RegExp(`${Zc}rgba\\s*\\(${yu},${yu},${yu},${yu}\\)${Jc}`), UPe = new RegExp(`${Zc}#${vu}${vu}${vu}${Jc}`), $Pe = new RegExp(`${Zc}#${Tu}${Tu}${Tu}${Jc}`), HPe = new RegExp(`${Zc}#${vu}${vu}${vu}${vu}${Jc}`), jPe = new RegExp(`${Zc}#${Tu}${Tu}${Tu}${Tu}${Jc}`);
function vi(t) {
  return parseInt(t, 16);
}
function Ga(t) {
  try {
    let e;
    if (e = $Pe.exec(t))
      return [vi(e[1]), vi(e[2]), vi(e[3]), 1];
    if (e = BPe.exec(t))
      return [Gr(e[1]), Gr(e[5]), Gr(e[9]), 1];
    if (e = FPe.exec(t))
      return [
        Gr(e[1]),
        Gr(e[5]),
        Gr(e[9]),
        Cf(e[13])
      ];
    if (e = UPe.exec(t))
      return [
        vi(e[1] + e[1]),
        vi(e[2] + e[2]),
        vi(e[3] + e[3]),
        1
      ];
    if (e = jPe.exec(t))
      return [
        vi(e[1]),
        vi(e[2]),
        vi(e[3]),
        Cf(vi(e[4]) / 255)
      ];
    if (e = HPe.exec(t))
      return [
        vi(e[1] + e[1]),
        vi(e[2] + e[2]),
        vi(e[3] + e[3]),
        Cf(vi(e[4] + e[4]) / 255)
      ];
    if (t in sS)
      return Ga(sS[t]);
    throw new Error(`[seemly/rgba]: Invalid color value ${t}.`);
  } catch (e) {
    throw e;
  }
}
function zPe(t) {
  return t > 1 ? 1 : t < 0 ? 0 : t;
}
function Py(t, e, n, r) {
  return `rgba(${Gr(t)}, ${Gr(e)}, ${Gr(n)}, ${zPe(r)})`;
}
function H2(t, e, n, r, i) {
  return Gr((t * e * (1 - r) + n * r) / i);
}
function Dt(t, e) {
  Array.isArray(t) || (t = Ga(t)), Array.isArray(e) || (e = Ga(e));
  const n = t[3], r = e[3], i = Cf(n + r - n * r);
  return Py(H2(t[0], n, e[0], r, i), H2(t[1], n, e[1], r, i), H2(t[2], n, e[2], r, i), i);
}
function Et(t, e) {
  const [n, r, i, s = 1] = Array.isArray(t) ? t : Ga(t);
  return e.alpha ? Py(n, r, i, e.alpha) : Py(n, r, i, s);
}
function dr(t, e) {
  const [n, r, i, s = 1] = Array.isArray(t) ? t : Ga(t), { lightness: a = 1, alpha: o = 1 } = e;
  return qPe([n * a, r * a, i * a, s * o]);
}
function Cf(t) {
  const e = Math.round(Number(t) * 100) / 100;
  return e > 1 ? 1 : e < 0 ? 0 : e;
}
function Gr(t) {
  const e = Math.round(Number(t));
  return e > 255 ? 255 : e < 0 ? 0 : e;
}
function qPe(t) {
  const [e, n, r] = t;
  return 3 in t ? `rgba(${Gr(e)}, ${Gr(n)}, ${Gr(r)}, ${Cf(t[3])})` : `rgba(${Gr(e)}, ${Gr(n)}, ${Gr(r)}, 1)`;
}
function Cm(t, ...e) {
  if (Array.isArray(t))
    t.forEach((n) => Cm(n, ...e));
  else
    return t(...e);
}
const aS = /* @__PURE__ */ new Set();
function VPe(t, e) {
  const n = `[naive/${t}]: ${e}`;
  aS.has(n) || (aS.add(n), console.error(n));
}
function WPe(t, e) {
  console.error(`[naive/${t}]: ${e}`);
}
function qN(t, e) {
  throw new Error(`[naive/${t}]: ${e}`);
}
function w_(t) {
  return t.some((e) => m7(e) ? !(e.type === U0 || e.type === wt && !w_(e.children)) : !0) ? t : null;
}
function ru(t, e) {
  const n = t && w_(t());
  return e(n || null);
}
function j2(t) {
  return !(t && w_(t()));
}
const QPe = /^(\d|\.)+$/, oS = /(\d|\.)+/;
function GPe(t, { c: e = 1, offset: n = 0, attachPx: r = !0 } = {}) {
  if (typeof t == "number") {
    const i = (t + n) * e;
    return i === 0 ? "0" : `${i}px`;
  } else if (typeof t == "string")
    if (QPe.test(t)) {
      const i = (Number(t) + n) * e;
      return r ? i === 0 ? "0" : `${i}px` : `${i}`;
    } else {
      const i = oS.exec(t);
      return i ? t.replace(oS, String((Number(i[0]) + n) * e)) : t;
    }
  return t;
}
function YPe(t) {
  let e = 0;
  for (let n = 0; n < t.length; ++n)
    t[n] === "&" && ++e;
  return e;
}
const VN = /\s*,(?![^(]*\))\s*/g, XPe = /\s+/g;
function KPe(t, e) {
  const n = [];
  return e.split(VN).forEach((r) => {
    let i = YPe(r);
    if (i) {
      if (i === 1) {
        t.forEach((a) => {
          n.push(r.replace("&", a));
        });
        return;
      }
    } else {
      t.forEach((a) => {
        n.push(
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          (a && a + " ") + r
        );
      });
      return;
    }
    let s = [
      r
    ];
    for (; i--; ) {
      const a = [];
      s.forEach((o) => {
        t.forEach((u) => {
          a.push(o.replace("&", u));
        });
      }), s = a;
    }
    s.forEach((a) => n.push(a));
  }), n;
}
function ZPe(t, e) {
  const n = [];
  return e.split(VN).forEach((r) => {
    t.forEach((i) => {
      n.push((i && i + " ") + r);
    });
  }), n;
}
function JPe(t) {
  let e = [""];
  return t.forEach((n) => {
    n = n && n.trim(), // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    n && (n.includes("&") ? e = KPe(e, n) : e = ZPe(e, n));
  }), e.join(", ").replace(XPe, " ");
}
function uS(t) {
  if (!t)
    return;
  const e = t.parentElement;
  e && e.removeChild(t);
}
function C_(t) {
  return document.querySelector(`style[cssr-id="${t}"]`);
}
function eRe(t) {
  const e = document.createElement("style");
  return e.setAttribute("cssr-id", t), e;
}
function Xp(t) {
  return t ? /^\s*@(s|m)/.test(t) : !1;
}
const tRe = /[A-Z]/g;
function WN(t) {
  return t.replace(tRe, (e) => "-" + e.toLowerCase());
}
function nRe(t, e = "  ") {
  return typeof t == "object" && t !== null ? ` {
` + Object.entries(t).map((n) => e + `  ${WN(n[0])}: ${n[1]};`).join(`
`) + `
` + e + "}" : `: ${t};`;
}
function rRe(t, e, n) {
  return typeof t == "function" ? t({
    context: e.context,
    props: n
  }) : t;
}
function lS(t, e, n, r) {
  if (!e)
    return "";
  const i = rRe(e, n, r);
  if (!i)
    return "";
  if (typeof i == "string")
    return `${t} {
${i}
}`;
  const s = Object.keys(i);
  if (s.length === 0)
    return n.config.keepEmptyBlock ? t + ` {
}` : "";
  const a = t ? [
    t + " {"
  ] : [];
  return s.forEach((o) => {
    const u = i[o];
    if (o === "raw") {
      a.push(`
` + u + `
`);
      return;
    }
    o = WN(o), u != null && a.push(`  ${o}${nRe(u)}`);
  }), t && a.push("}"), a.join(`
`);
}
function Ry(t, e, n) {
  t && t.forEach((r) => {
    if (Array.isArray(r))
      Ry(r, e, n);
    else if (typeof r == "function") {
      const i = r(e);
      Array.isArray(i) ? Ry(i, e, n) : i && n(i);
    } else
      r && n(r);
  });
}
function QN(t, e, n, r, i, s) {
  const a = t.$;
  let o = "";
  if (!a || typeof a == "string")
    Xp(a) ? o = a : e.push(a);
  else if (typeof a == "function") {
    const d = a({
      context: r.context,
      props: i
    });
    Xp(d) ? o = d : e.push(d);
  } else if (a.before && a.before(r.context), !a.$ || typeof a.$ == "string")
    Xp(a.$) ? o = a.$ : e.push(a.$);
  else if (a.$) {
    const d = a.$({
      context: r.context,
      props: i
    });
    Xp(d) ? o = d : e.push(d);
  }
  const u = JPe(e), c = lS(u, t.props, r, i);
  o ? (n.push(`${o} {`), s && c && s.insertRule(`${o} {
${c}
}
`)) : (s && c && s.insertRule(c), !s && c.length && n.push(c)), t.children && Ry(t.children, {
    context: r.context,
    props: i
  }, (d) => {
    if (typeof d == "string") {
      const l = lS(u, { raw: d }, r, i);
      s ? s.insertRule(l) : n.push(l);
    } else
      QN(d, e, n, r, i, s);
  }), e.pop(), o && n.push("}"), a && a.after && a.after(r.context);
}
function GN(t, e, n, r = !1) {
  const i = [];
  return QN(t, [], i, e, n, r ? t.instance.__styleSheet : void 0), r ? "" : i.join(`

`);
}
function By(t) {
  for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
    n = t.charCodeAt(r) & 255 | (t.charCodeAt(++r) & 255) << 8 | (t.charCodeAt(++r) & 255) << 16 | (t.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, e = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      e ^= (t.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(r + 1) & 255) << 8;
    case 1:
      e ^= t.charCodeAt(r) & 255, e = /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = /* Math.imul(h, m): */
  (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
typeof window < "u" && (window.__cssrContext = {});
function iRe(t, e, n) {
  const { els: r } = e;
  if (n === void 0)
    r.forEach(uS), e.els = [];
  else {
    const i = C_(n);
    i && r.includes(i) && (uS(i), e.els = r.filter((s) => s !== i));
  }
}
function cS(t, e) {
  t.push(e);
}
function sRe(t, e, n, r, i, s, a, o, u) {
  if (s && !u) {
    if (n === void 0) {
      console.error("[css-render/mount]: `id` is required in `silent` mode.");
      return;
    }
    const f = window.__cssrContext;
    f[n] || (f[n] = !0, GN(e, t, r, s));
    return;
  }
  let c;
  if (n === void 0 && (c = e.render(r), n = By(c)), u) {
    u.adapter(n, c ?? e.render(r));
    return;
  }
  const d = C_(n);
  if (d !== null && !a)
    return d;
  const l = d ?? eRe(n);
  if (c === void 0 && (c = e.render(r)), l.textContent = c, d !== null)
    return d;
  if (o) {
    const f = document.head.querySelector(`meta[name="${o}"]`);
    if (f)
      return document.head.insertBefore(l, f), cS(e.els, l), l;
  }
  return i ? document.head.insertBefore(l, document.head.querySelector("style, link")) : document.head.appendChild(l), cS(e.els, l), l;
}
function aRe(t) {
  return GN(this, this.instance, t);
}
function oRe(t = {}) {
  const { id: e, ssr: n, props: r, head: i = !1, silent: s = !1, force: a = !1, anchorMetaName: o } = t;
  return sRe(this.instance, this, e, r, i, s, a, o, n);
}
function uRe(t = {}) {
  const { id: e } = t;
  iRe(this.instance, this, e);
}
const Kp = function(t, e, n, r) {
  return {
    instance: t,
    $: e,
    props: n,
    children: r,
    els: [],
    render: aRe,
    mount: oRe,
    unmount: uRe
  };
}, lRe = function(t, e, n, r) {
  return Array.isArray(e) ? Kp(t, { $: null }, null, e) : Array.isArray(n) ? Kp(t, e, null, n) : Array.isArray(r) ? Kp(t, e, n, r) : Kp(t, e, n, null);
};
function cRe(t = {}) {
  let e = null;
  const n = {
    c: (...r) => lRe(n, ...r),
    use: (r, ...i) => r.install(n, ...i),
    find: C_,
    context: {},
    config: t,
    get __styleSheet() {
      if (!e) {
        const r = document.createElement("style");
        return document.head.appendChild(r), e = document.styleSheets[document.styleSheets.length - 1], e;
      }
      return e;
    }
  };
  return n;
}
function dRe(t) {
  let e = ".", n = "__", r = "--", i;
  if (t) {
    let d = t.blockPrefix;
    d && (e = d), d = t.elementPrefix, d && (n = d), d = t.modifierPrefix, d && (r = d);
  }
  const s = {
    install(d) {
      i = d.c;
      const l = d.context;
      l.bem = {}, l.bem.b = null, l.bem.els = null;
    }
  };
  function a(d) {
    let l, f;
    return {
      before(p) {
        l = p.bem.b, f = p.bem.els, p.bem.els = null;
      },
      after(p) {
        p.bem.b = l, p.bem.els = f;
      },
      $({ context: p, props: m }) {
        return d = typeof d == "string" ? d : d({ context: p, props: m }), p.bem.b = d, `${(m == null ? void 0 : m.bPrefix) || e}${p.bem.b}`;
      }
    };
  }
  function o(d) {
    let l;
    return {
      before(f) {
        l = f.bem.els;
      },
      after(f) {
        f.bem.els = l;
      },
      $({ context: f, props: p }) {
        return d = typeof d == "string" ? d : d({ context: f, props: p }), f.bem.els = d.split(",").map((m) => m.trim()), f.bem.els.map((m) => `${(p == null ? void 0 : p.bPrefix) || e}${f.bem.b}${n}${m}`).join(", ");
      }
    };
  }
  function u(d) {
    return {
      $({ context: l, props: f }) {
        d = typeof d == "string" ? d : d({ context: l, props: f });
        const p = d.split(",").map((y) => y.trim());
        function m(y) {
          return p.map((b) => `&${(f == null ? void 0 : f.bPrefix) || e}${l.bem.b}${y !== void 0 ? `${n}${y}` : ""}${r}${b}`).join(", ");
        }
        const g = l.bem.els;
        if (g !== null) {
          if (process.env.NODE_ENV !== "production" && g.length >= 2)
            throw Error(`[css-render/plugin-bem]: m(${d}) is invalid, using modifier inside multiple elements is not allowed`);
          return m(g[0]);
        } else
          return m();
      }
    };
  }
  function c(d) {
    return {
      $({ context: l, props: f }) {
        d = typeof d == "string" ? d : d({ context: l, props: f });
        const p = l.bem.els;
        if (process.env.NODE_ENV !== "production" && p !== null && p.length >= 2)
          throw Error(`[css-render/plugin-bem]: notM(${d}) is invalid, using modifier inside multiple elements is not allowed`);
        return `&:not(${(f == null ? void 0 : f.bPrefix) || e}${l.bem.b}${p !== null && p.length > 0 ? `${n}${p[0]}` : ""}${r}${d})`;
      }
    };
  }
  return Object.assign(s, {
    cB: (...d) => i(a(d[0]), d[1], d[2]),
    cE: (...d) => i(o(d[0]), d[1], d[2]),
    cM: (...d) => i(u(d[0]), d[1], d[2]),
    cNotM: (...d) => i(c(d[0]), d[1], d[2])
  }), s;
}
function ho(t, e) {
  return t + (e === "default" ? "" : e.replace(/^[a-z]/, (n) => n.toUpperCase()));
}
ho("abc", "def");
const fRe = "n", hRe = `.${fRe}-`, pRe = "__", mRe = "--", YN = cRe(), XN = dRe({
  blockPrefix: hRe,
  elementPrefix: pRe,
  modifierPrefix: mRe
});
YN.use(XN);
const { c: Kr, find: HXe } = YN, { cB: M0, cE: tn, cM: xs, cNotM: dS } = XN;
function gRe(t, e) {
  return Ct(t, (n) => {
    n !== void 0 && (e.value = n);
  }), de(() => t.value === void 0 ? e.value : t.value);
}
function ARe() {
  const t = Se(!1);
  return Tr(() => {
    t.value = !0;
  }), B0(t);
}
const KN = Symbol("@css-render/vue3-ssr");
function bRe(t, e) {
  return `<style cssr-id="${t}">
${e}
</style>`;
}
function yRe(t, e) {
  const n = pn(KN, null);
  if (n === null) {
    console.error("[css-render/vue3-ssr]: no ssr context found.");
    return;
  }
  const { styles: r, ids: i } = n;
  i.has(t) || r !== null && (i.add(t), r.push(bRe(t, e)));
}
const vRe = typeof document < "u";
function S_() {
  if (vRe)
    return;
  const t = pn(KN, null);
  if (t !== null)
    return {
      adapter: yRe,
      context: t
    };
}
const fS = "n-form-item";
function TRe(t, { defaultSize: e = "medium", mergedSize: n, mergedDisabled: r } = {}) {
  const i = pn(fS, null);
  Ba(fS, null);
  const s = de(n ? () => n(i) : () => {
    const { size: u } = t;
    if (u)
      return u;
    if (i) {
      const { mergedSize: c } = i;
      if (c.value !== void 0)
        return c.value;
    }
    return e;
  }), a = de(r ? () => r(i) : () => {
    const { disabled: u } = t;
    return u !== void 0 ? u : i ? i.disabled.value : !1;
  }), o = de(() => {
    const { status: u } = t;
    return u || (i == null ? void 0 : i.mergedValidationStatus.value);
  });
  return mi(() => {
    i && i.restoreValidation();
  }), {
    mergedSizeRef: s,
    mergedDisabledRef: a,
    mergedStatusRef: o,
    nTriggerFormBlur() {
      i && i.handleContentBlur();
    },
    nTriggerFormChange() {
      i && i.handleContentChange();
    },
    nTriggerFormFocus() {
      i && i.handleContentFocus();
    },
    nTriggerFormInput() {
      i && i.handleContentInput();
    }
  };
}
var _Re = typeof global == "object" && global && global.Object === Object && global;
const ZN = _Re;
var ERe = typeof self == "object" && self && self.Object === Object && self, xRe = ZN || ERe || Function("return this")();
const ed = xRe;
var wRe = ed.Symbol;
const O0 = wRe;
var JN = Object.prototype, CRe = JN.hasOwnProperty, SRe = JN.toString, jd = O0 ? O0.toStringTag : void 0;
function IRe(t) {
  var e = CRe.call(t, jd), n = t[jd];
  try {
    t[jd] = void 0;
    var r = !0;
  } catch {
  }
  var i = SRe.call(t);
  return r && (e ? t[jd] = n : delete t[jd]), i;
}
var kRe = Object.prototype, DRe = kRe.toString;
function MRe(t) {
  return DRe.call(t);
}
var ORe = "[object Null]", NRe = "[object Undefined]", hS = O0 ? O0.toStringTag : void 0;
function Zg(t) {
  return t == null ? t === void 0 ? NRe : ORe : hS && hS in Object(t) ? IRe(t) : MRe(t);
}
function Ph(t) {
  return t != null && typeof t == "object";
}
var LRe = Array.isArray;
const Fy = LRe;
function tl(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
function e9(t) {
  return t;
}
var PRe = "[object AsyncFunction]", RRe = "[object Function]", BRe = "[object GeneratorFunction]", FRe = "[object Proxy]";
function I_(t) {
  if (!tl(t))
    return !1;
  var e = Zg(t);
  return e == RRe || e == BRe || e == PRe || e == FRe;
}
var URe = ed["__core-js_shared__"];
const z2 = URe;
var pS = function() {
  var t = /[^.]+$/.exec(z2 && z2.keys && z2.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function $Re(t) {
  return !!pS && pS in t;
}
var HRe = Function.prototype, jRe = HRe.toString;
function zRe(t) {
  if (t != null) {
    try {
      return jRe.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var qRe = /[\\^$.*+?()[\]{}|]/g, VRe = /^\[object .+?Constructor\]$/, WRe = Function.prototype, QRe = Object.prototype, GRe = WRe.toString, YRe = QRe.hasOwnProperty, XRe = RegExp(
  "^" + GRe.call(YRe).replace(qRe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function KRe(t) {
  if (!tl(t) || $Re(t))
    return !1;
  var e = I_(t) ? XRe : VRe;
  return e.test(zRe(t));
}
function ZRe(t, e) {
  return t == null ? void 0 : t[e];
}
function k_(t, e) {
  var n = ZRe(t, e);
  return KRe(n) ? n : void 0;
}
var mS = Object.create, JRe = /* @__PURE__ */ function() {
  function t() {
  }
  return function(e) {
    if (!tl(e))
      return {};
    if (mS)
      return mS(e);
    t.prototype = e;
    var n = new t();
    return t.prototype = void 0, n;
  };
}();
const eBe = JRe;
function tBe(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function nBe(t, e) {
  var n = -1, r = t.length;
  for (e || (e = Array(r)); ++n < r; )
    e[n] = t[n];
  return e;
}
var rBe = 800, iBe = 16, sBe = Date.now;
function aBe(t) {
  var e = 0, n = 0;
  return function() {
    var r = sBe(), i = iBe - (r - n);
    if (n = r, i > 0) {
      if (++e >= rBe)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function oBe(t) {
  return function() {
    return t;
  };
}
var uBe = function() {
  try {
    var t = k_(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}();
const N0 = uBe;
var lBe = N0 ? function(t, e) {
  return N0(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: oBe(e),
    writable: !0
  });
} : e9;
const cBe = lBe;
var dBe = aBe(cBe);
const fBe = dBe;
var hBe = 9007199254740991, pBe = /^(?:0|[1-9]\d*)$/;
function t9(t, e) {
  var n = typeof t;
  return e = e ?? hBe, !!e && (n == "number" || n != "symbol" && pBe.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function D_(t, e, n) {
  e == "__proto__" && N0 ? N0(t, e, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : t[e] = n;
}
function Jg(t, e) {
  return t === e || t !== t && e !== e;
}
var mBe = Object.prototype, gBe = mBe.hasOwnProperty;
function ABe(t, e, n) {
  var r = t[e];
  (!(gBe.call(t, e) && Jg(r, n)) || n === void 0 && !(e in t)) && D_(t, e, n);
}
function bBe(t, e, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, a = e.length; ++s < a; ) {
    var o = e[s], u = void 0;
    u === void 0 && (u = t[o]), i ? D_(n, o, u) : ABe(n, o, u);
  }
  return n;
}
var gS = Math.max;
function yBe(t, e, n) {
  return e = gS(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = gS(r.length - e, 0), a = Array(s); ++i < s; )
      a[i] = r[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = r[i];
    return o[e] = n(a), tBe(t, this, o);
  };
}
function vBe(t, e) {
  return fBe(yBe(t, e, e9), t + "");
}
var TBe = 9007199254740991;
function n9(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= TBe;
}
function M_(t) {
  return t != null && n9(t.length) && !I_(t);
}
function _Be(t, e, n) {
  if (!tl(n))
    return !1;
  var r = typeof e;
  return (r == "number" ? M_(n) && t9(e, n.length) : r == "string" && e in n) ? Jg(n[e], t) : !1;
}
function EBe(t) {
  return vBe(function(e, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, a = i > 2 ? n[2] : void 0;
    for (s = t.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && _Be(n[0], n[1], a) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var o = n[r];
      o && t(e, o, r, s);
    }
    return e;
  });
}
var xBe = Object.prototype;
function r9(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || xBe;
  return t === n;
}
function wBe(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var CBe = "[object Arguments]";
function AS(t) {
  return Ph(t) && Zg(t) == CBe;
}
var i9 = Object.prototype, SBe = i9.hasOwnProperty, IBe = i9.propertyIsEnumerable, kBe = AS(/* @__PURE__ */ function() {
  return arguments;
}()) ? AS : function(t) {
  return Ph(t) && SBe.call(t, "callee") && !IBe.call(t, "callee");
};
const Uy = kBe;
function DBe() {
  return !1;
}
var s9 = typeof exports == "object" && exports && !exports.nodeType && exports, bS = s9 && typeof module == "object" && module && !module.nodeType && module, MBe = bS && bS.exports === s9, yS = MBe ? ed.Buffer : void 0, OBe = yS ? yS.isBuffer : void 0, NBe = OBe || DBe;
const a9 = NBe;
var LBe = "[object Arguments]", PBe = "[object Array]", RBe = "[object Boolean]", BBe = "[object Date]", FBe = "[object Error]", UBe = "[object Function]", $Be = "[object Map]", HBe = "[object Number]", jBe = "[object Object]", zBe = "[object RegExp]", qBe = "[object Set]", VBe = "[object String]", WBe = "[object WeakMap]", QBe = "[object ArrayBuffer]", GBe = "[object DataView]", YBe = "[object Float32Array]", XBe = "[object Float64Array]", KBe = "[object Int8Array]", ZBe = "[object Int16Array]", JBe = "[object Int32Array]", eFe = "[object Uint8Array]", tFe = "[object Uint8ClampedArray]", nFe = "[object Uint16Array]", rFe = "[object Uint32Array]", qn = {};
qn[YBe] = qn[XBe] = qn[KBe] = qn[ZBe] = qn[JBe] = qn[eFe] = qn[tFe] = qn[nFe] = qn[rFe] = !0;
qn[LBe] = qn[PBe] = qn[QBe] = qn[RBe] = qn[GBe] = qn[BBe] = qn[FBe] = qn[UBe] = qn[$Be] = qn[HBe] = qn[jBe] = qn[zBe] = qn[qBe] = qn[VBe] = qn[WBe] = !1;
function iFe(t) {
  return Ph(t) && n9(t.length) && !!qn[Zg(t)];
}
function sFe(t) {
  return function(e) {
    return t(e);
  };
}
var o9 = typeof exports == "object" && exports && !exports.nodeType && exports, Sf = o9 && typeof module == "object" && module && !module.nodeType && module, aFe = Sf && Sf.exports === o9, q2 = aFe && ZN.process, oFe = function() {
  try {
    var t = Sf && Sf.require && Sf.require("util").types;
    return t || q2 && q2.binding && q2.binding("util");
  } catch {
  }
}();
const vS = oFe;
var TS = vS && vS.isTypedArray, uFe = TS ? sFe(TS) : iFe;
const u9 = uFe;
function lFe(t, e) {
  var n = Fy(t), r = !n && Uy(t), i = !n && !r && a9(t), s = !n && !r && !i && u9(t), a = n || r || i || s, o = a ? wBe(t.length, String) : [], u = o.length;
  for (var c in t)
    !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    t9(c, u))) && o.push(c);
  return o;
}
function cFe(t, e) {
  return function(n) {
    return t(e(n));
  };
}
function dFe(t) {
  var e = [];
  if (t != null)
    for (var n in Object(t))
      e.push(n);
  return e;
}
var fFe = Object.prototype, hFe = fFe.hasOwnProperty;
function pFe(t) {
  if (!tl(t))
    return dFe(t);
  var e = r9(t), n = [];
  for (var r in t)
    r == "constructor" && (e || !hFe.call(t, r)) || n.push(r);
  return n;
}
function l9(t) {
  return M_(t) ? lFe(t) : pFe(t);
}
var mFe = k_(Object, "create");
const oh = mFe;
function gFe() {
  this.__data__ = oh ? oh(null) : {}, this.size = 0;
}
function AFe(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var bFe = "__lodash_hash_undefined__", yFe = Object.prototype, vFe = yFe.hasOwnProperty;
function TFe(t) {
  var e = this.__data__;
  if (oh) {
    var n = e[t];
    return n === bFe ? void 0 : n;
  }
  return vFe.call(e, t) ? e[t] : void 0;
}
var _Fe = Object.prototype, EFe = _Fe.hasOwnProperty;
function xFe(t) {
  var e = this.__data__;
  return oh ? e[t] !== void 0 : EFe.call(e, t);
}
var wFe = "__lodash_hash_undefined__";
function CFe(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = oh && e === void 0 ? wFe : e, this;
}
function Qu(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Qu.prototype.clear = gFe;
Qu.prototype.delete = AFe;
Qu.prototype.get = TFe;
Qu.prototype.has = xFe;
Qu.prototype.set = CFe;
function SFe() {
  this.__data__ = [], this.size = 0;
}
function e1(t, e) {
  for (var n = t.length; n--; )
    if (Jg(t[n][0], e))
      return n;
  return -1;
}
var IFe = Array.prototype, kFe = IFe.splice;
function DFe(t) {
  var e = this.__data__, n = e1(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : kFe.call(e, n, 1), --this.size, !0;
}
function MFe(t) {
  var e = this.__data__, n = e1(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function OFe(t) {
  return e1(this.__data__, t) > -1;
}
function NFe(t, e) {
  var n = this.__data__, r = e1(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
function Ya(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Ya.prototype.clear = SFe;
Ya.prototype.delete = DFe;
Ya.prototype.get = MFe;
Ya.prototype.has = OFe;
Ya.prototype.set = NFe;
var LFe = k_(ed, "Map");
const c9 = LFe;
function PFe() {
  this.size = 0, this.__data__ = {
    hash: new Qu(),
    map: new (c9 || Ya)(),
    string: new Qu()
  };
}
function RFe(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function t1(t, e) {
  var n = t.__data__;
  return RFe(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function BFe(t) {
  var e = t1(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function FFe(t) {
  return t1(this, t).get(t);
}
function UFe(t) {
  return t1(this, t).has(t);
}
function $Fe(t, e) {
  var n = t1(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
function td(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
td.prototype.clear = PFe;
td.prototype.delete = BFe;
td.prototype.get = FFe;
td.prototype.has = UFe;
td.prototype.set = $Fe;
var HFe = cFe(Object.getPrototypeOf, Object);
const d9 = HFe;
var jFe = "[object Object]", zFe = Function.prototype, qFe = Object.prototype, f9 = zFe.toString, VFe = qFe.hasOwnProperty, WFe = f9.call(Object);
function QFe(t) {
  if (!Ph(t) || Zg(t) != jFe)
    return !1;
  var e = d9(t);
  if (e === null)
    return !0;
  var n = VFe.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && f9.call(n) == WFe;
}
function GFe() {
  this.__data__ = new Ya(), this.size = 0;
}
function YFe(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function XFe(t) {
  return this.__data__.get(t);
}
function KFe(t) {
  return this.__data__.has(t);
}
var ZFe = 200;
function JFe(t, e) {
  var n = this.__data__;
  if (n instanceof Ya) {
    var r = n.__data__;
    if (!c9 || r.length < ZFe - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new td(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
function nd(t) {
  var e = this.__data__ = new Ya(t);
  this.size = e.size;
}
nd.prototype.clear = GFe;
nd.prototype.delete = YFe;
nd.prototype.get = XFe;
nd.prototype.has = KFe;
nd.prototype.set = JFe;
var h9 = typeof exports == "object" && exports && !exports.nodeType && exports, _S = h9 && typeof module == "object" && module && !module.nodeType && module, eUe = _S && _S.exports === h9, ES = eUe ? ed.Buffer : void 0;
ES && ES.allocUnsafe;
function tUe(t, e) {
  return t.slice();
}
var nUe = ed.Uint8Array;
const xS = nUe;
function rUe(t) {
  var e = new t.constructor(t.byteLength);
  return new xS(e).set(new xS(t)), e;
}
function iUe(t, e) {
  var n = rUe(t.buffer);
  return new t.constructor(n, t.byteOffset, t.length);
}
function sUe(t) {
  return typeof t.constructor == "function" && !r9(t) ? eBe(d9(t)) : {};
}
function aUe(t) {
  return function(e, n, r) {
    for (var i = -1, s = Object(e), a = r(e), o = a.length; o--; ) {
      var u = a[++i];
      if (n(s[u], u, s) === !1)
        break;
    }
    return e;
  };
}
var oUe = aUe();
const uUe = oUe;
function $y(t, e, n) {
  (n !== void 0 && !Jg(t[e], n) || n === void 0 && !(e in t)) && D_(t, e, n);
}
function lUe(t) {
  return Ph(t) && M_(t);
}
function Hy(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
function cUe(t) {
  return bBe(t, l9(t));
}
function dUe(t, e, n, r, i, s, a) {
  var o = Hy(t, n), u = Hy(e, n), c = a.get(u);
  if (c) {
    $y(t, n, c);
    return;
  }
  var d = s ? s(o, u, n + "", t, e, a) : void 0, l = d === void 0;
  if (l) {
    var f = Fy(u), p = !f && a9(u), m = !f && !p && u9(u);
    d = u, f || p || m ? Fy(o) ? d = o : lUe(o) ? d = nBe(o) : p ? (l = !1, d = tUe(u)) : m ? (l = !1, d = iUe(u)) : d = [] : QFe(u) || Uy(u) ? (d = o, Uy(o) ? d = cUe(o) : (!tl(o) || I_(o)) && (d = sUe(u))) : l = !1;
  }
  l && (a.set(u, d), i(d, u, r, s, a), a.delete(u)), $y(t, n, d);
}
function p9(t, e, n, r, i) {
  t !== e && uUe(e, function(s, a) {
    if (i || (i = new nd()), tl(s))
      dUe(t, e, a, n, p9, r, i);
    else {
      var o = r ? r(Hy(t, a), s, a + "", t, e, i) : void 0;
      o === void 0 && (o = s), $y(t, a, o);
    }
  }, l9);
}
var fUe = EBe(function(t, e, n) {
  p9(t, e, n);
});
const Zp = fUe, n1 = {
  fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
  fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
  fontWeight: "400",
  fontWeightStrong: "500",
  cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
  cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
  cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
  borderRadius: "3px",
  borderRadiusSmall: "2px",
  fontSize: "14px",
  fontSizeMini: "12px",
  fontSizeTiny: "12px",
  fontSizeSmall: "14px",
  fontSizeMedium: "14px",
  fontSizeLarge: "15px",
  fontSizeHuge: "16px",
  lineHeight: "1.6",
  heightMini: "16px",
  heightTiny: "22px",
  heightSmall: "28px",
  heightMedium: "34px",
  heightLarge: "40px",
  heightHuge: "46px"
}, {
  fontSize: hUe,
  fontFamily: pUe,
  lineHeight: mUe
} = n1, m9 = Kr("body", `
 margin: 0;
 font-size: ${hUe};
 font-family: ${pUe};
 line-height: ${mUe};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [Kr("input", `
 font-family: inherit;
 font-size: inherit;
 `)]), r1 = "n-config-provider", L0 = "naive-ui-style";
function Rh(t, e, n, r, i, s) {
  const a = S_(), o = pn(r1, null);
  if (n) {
    const u = () => {
      const c = s == null ? void 0 : s.value;
      n.mount({
        id: c === void 0 ? e : c + e,
        head: !0,
        props: {
          bPrefix: c ? `.${c}-` : void 0
        },
        anchorMetaName: L0,
        ssr: a
      }), o != null && o.preflightStyleDisabled || m9.mount({
        id: "n-global",
        head: !0,
        anchorMetaName: L0,
        ssr: a
      });
    };
    a ? u() : Xy(u);
  }
  return de(() => {
    var u;
    const { theme: { common: c, self: d, peers: l = {} } = {}, themeOverrides: f = {}, builtinThemeOverrides: p = {} } = i, { common: m, peers: g } = f, { common: y = void 0, [t]: { common: b = void 0, self: E = void 0, peers: v = {} } = {} } = (o == null ? void 0 : o.mergedThemeRef.value) || {}, { common: _ = void 0, [t]: D = {} } = (o == null ? void 0 : o.mergedThemeOverridesRef.value) || {}, { common: S, peers: M = {} } = D, O = Zp({}, c || b || y || r.common, _, S, m), T = Zp(
      // {}, executed every time, no need for empty obj
      (u = d || E || r.self) === null || u === void 0 ? void 0 : u(O),
      p,
      D,
      f
    );
    return {
      common: O,
      self: T,
      peers: Zp({}, r.peers, v, l),
      peerOverrides: Zp({}, p.peers, M, g)
    };
  });
}
Rh.props = {
  theme: Object,
  themeOverrides: Object,
  builtinThemeOverrides: Object
};
const gUe = "n";
function g9(t = {}, e = {
  defaultBordered: !0
}) {
  const n = pn(r1, null);
  return {
    // NConfigProvider,
    inlineThemeDisabled: n == null ? void 0 : n.inlineThemeDisabled,
    mergedRtlRef: n == null ? void 0 : n.mergedRtlRef,
    mergedComponentPropsRef: n == null ? void 0 : n.mergedComponentPropsRef,
    mergedBreakpointsRef: n == null ? void 0 : n.mergedBreakpointsRef,
    mergedBorderedRef: de(() => {
      var r, i;
      const { bordered: s } = t;
      return s !== void 0 ? s : (i = (r = n == null ? void 0 : n.mergedBorderedRef.value) !== null && r !== void 0 ? r : e.defaultBordered) !== null && i !== void 0 ? i : !0;
    }),
    mergedClsPrefixRef: n ? n.mergedClsPrefixRef : ch(gUe),
    namespaceRef: de(() => n == null ? void 0 : n.mergedNamespaceRef.value)
  };
}
function AUe(t, e, n) {
  if (!e) {
    process.env.NODE_ENV !== "production" && qN("use-style", "No style is specified.");
    return;
  }
  const r = S_(), i = pn(r1, null), s = () => {
    const a = n.value;
    e.mount({
      id: a === void 0 ? t : a + t,
      head: !0,
      anchorMetaName: L0,
      props: {
        bPrefix: a ? `.${a}-` : void 0
      },
      ssr: r
    }), i != null && i.preflightStyleDisabled || m9.mount({
      id: "n-global",
      head: !0,
      anchorMetaName: L0,
      ssr: r
    });
  };
  r ? s() : Xy(s);
}
function A9(t, e, n, r) {
  var i;
  n || qN("useThemeClass", "cssVarsRef is not passed");
  const s = (i = pn(r1, null)) === null || i === void 0 ? void 0 : i.mergedThemeHashRef, a = Se(""), o = S_();
  let u;
  const c = `__${t}`, d = () => {
    let l = c;
    const f = e ? e.value : void 0, p = s == null ? void 0 : s.value;
    p && (l += "-" + p), f && (l += "-" + f);
    const { themeOverrides: m, builtinThemeOverrides: g } = r;
    m && (l += "-" + By(JSON.stringify(m))), g && (l += "-" + By(JSON.stringify(g))), a.value = l, u = () => {
      const y = n.value;
      let b = "";
      for (const E in y)
        b += `${E}: ${y[E]};`;
      Kr(`.${l}`, b).mount({
        id: l,
        ssr: o
      }), u = void 0;
    };
  };
  return If(() => {
    d();
  }), {
    themeClass: a,
    onRender: () => {
      u == null || u();
    }
  };
}
const b9 = Ze({
  name: "BaseIconSwitchTransition",
  setup(t, { slots: e }) {
    const n = ARe();
    return () => sn(Lu, { name: "icon-switch-transition", appear: n.value }, e);
  }
}), {
  cubicBezierEaseInOut: bUe
} = n1;
function P0({
  originalTransform: t = "",
  left: e = 0,
  top: n = 0,
  transition: r = `all .3s ${bUe} !important`
} = {}) {
  return [Kr("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
    transform: t + " scale(0.75)",
    left: e,
    top: n,
    opacity: 0
  }), Kr("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
    transform: `scale(1) ${t}`,
    left: e,
    top: n,
    opacity: 1
  }), Kr("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
    transformOrigin: "center",
    position: "absolute",
    left: e,
    top: n,
    transition: r
  })];
}
const yUe = Kr([Kr("@keyframes loading-container-rotate", `
 to {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }
 `), Kr("@keyframes loading-layer-rotate", `
 12.5% {
 -webkit-transform: rotate(135deg);
 transform: rotate(135deg);
 }
 25% {
 -webkit-transform: rotate(270deg);
 transform: rotate(270deg);
 }
 37.5% {
 -webkit-transform: rotate(405deg);
 transform: rotate(405deg);
 }
 50% {
 -webkit-transform: rotate(540deg);
 transform: rotate(540deg);
 }
 62.5% {
 -webkit-transform: rotate(675deg);
 transform: rotate(675deg);
 }
 75% {
 -webkit-transform: rotate(810deg);
 transform: rotate(810deg);
 }
 87.5% {
 -webkit-transform: rotate(945deg);
 transform: rotate(945deg);
 }
 100% {
 -webkit-transform: rotate(1080deg);
 transform: rotate(1080deg);
 } 
 `), Kr("@keyframes loading-left-spin", `
 from {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 50% {
 -webkit-transform: rotate(130deg);
 transform: rotate(130deg);
 }
 to {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 `), Kr("@keyframes loading-right-spin", `
 from {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 50% {
 -webkit-transform: rotate(-130deg);
 transform: rotate(-130deg);
 }
 to {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 `), M0("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [tn("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [P0()]), tn("container", `
 display: inline-flex;
 position: relative;
 direction: ltr;
 line-height: 0;
 animation: loading-container-rotate 1568.2352941176ms linear infinite;
 font-size: 0;
 letter-spacing: 0;
 white-space: nowrap;
 opacity: 1;
 width: 100%;
 height: 100%;
 `, [tn("svg", `
 stroke: var(--n-text-color);
 fill: transparent;
 position: absolute;
 height: 100%;
 overflow: hidden;
 `), tn("container-layer", `
 position: absolute;
 width: 100%;
 height: 100%;
 animation: loading-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 `, [tn("container-layer-left", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [tn("svg", `
 animation: loading-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 width: 200%;
 `)]), tn("container-layer-patch", `
 position: absolute;
 top: 0;
 left: 47.5%;
 box-sizing: border-box;
 width: 5%;
 height: 100%;
 overflow: hidden;
 `, [tn("svg", `
 left: -900%;
 width: 2000%;
 transform: rotate(180deg);
 `)]), tn("container-layer-right", `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [tn("svg", `
 animation: loading-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 left: -100%;
 width: 200%;
 `)])])]), tn("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [P0({
  left: "50%",
  top: "50%",
  originalTransform: "translateX(-50%) translateY(-50%)"
})])])]), vUe = {
  strokeWidth: {
    type: Number,
    default: 28
  },
  stroke: {
    type: String,
    default: void 0
  }
}, TUe = Ze({
  name: "BaseLoading",
  props: Object.assign({ clsPrefix: {
    type: String,
    required: !0
  }, show: {
    type: Boolean,
    default: !0
  }, scale: {
    type: Number,
    default: 1
  }, radius: {
    type: Number,
    default: 100
  } }, vUe),
  setup(t) {
    AUe("-base-loading", yUe, Ii(t, "clsPrefix"));
  },
  render() {
    const { clsPrefix: t, radius: e, strokeWidth: n, stroke: r, scale: i } = this, s = e / i;
    return sn(
      "div",
      { class: `${t}-base-loading`, role: "img", "aria-label": "loading" },
      sn(b9, null, {
        default: () => this.show ? sn(
          "div",
          { key: "icon", class: `${t}-base-loading__transition-wrapper` },
          sn(
            "div",
            { class: `${t}-base-loading__container` },
            sn(
              "div",
              { class: `${t}-base-loading__container-layer` },
              sn(
                "div",
                { class: `${t}-base-loading__container-layer-left` },
                sn(
                  "svg",
                  { class: `${t}-base-loading__svg`, viewBox: `0 0 ${2 * s} ${2 * s}`, xmlns: "http://www.w3.org/2000/svg", style: { color: r } },
                  sn("circle", { fill: "none", stroke: "currentColor", "stroke-width": n, "stroke-linecap": "round", cx: s, cy: s, r: e - n / 2, "stroke-dasharray": 4.91 * e, "stroke-dashoffset": 2.46 * e })
                )
              ),
              sn(
                "div",
                { class: `${t}-base-loading__container-layer-patch` },
                sn(
                  "svg",
                  { class: `${t}-base-loading__svg`, viewBox: `0 0 ${2 * s} ${2 * s}`, xmlns: "http://www.w3.org/2000/svg", style: { color: r } },
                  sn("circle", { fill: "none", stroke: "currentColor", "stroke-width": n, "stroke-linecap": "round", cx: s, cy: s, r: e - n / 2, "stroke-dasharray": 4.91 * e, "stroke-dashoffset": 2.46 * e })
                )
              ),
              sn(
                "div",
                { class: `${t}-base-loading__container-layer-right` },
                sn(
                  "svg",
                  { class: `${t}-base-loading__svg`, viewBox: `0 0 ${2 * s} ${2 * s}`, xmlns: "http://www.w3.org/2000/svg", style: { color: r } },
                  sn("circle", { fill: "none", stroke: "currentColor", "stroke-width": n, "stroke-linecap": "round", cx: s, cy: s, r: e - n / 2, "stroke-dasharray": 4.91 * e, "stroke-dashoffset": 2.46 * e })
                )
              )
            )
          )
        ) : sn("div", { key: "placeholder", class: `${t}-base-loading__placeholder` }, this.$slots)
      })
    );
  }
}), yt = {
  neutralBase: "#000",
  neutralInvertBase: "#fff",
  neutralTextBase: "#fff",
  neutralPopover: "rgb(72, 72, 78)",
  neutralCard: "rgb(24, 24, 28)",
  neutralModal: "rgb(44, 44, 50)",
  neutralBody: "rgb(16, 16, 20)",
  alpha1: "0.9",
  alpha2: "0.82",
  alpha3: "0.52",
  alpha4: "0.38",
  alpha5: "0.28",
  alphaClose: "0.52",
  alphaDisabled: "0.38",
  alphaDisabledInput: "0.06",
  alphaPending: "0.09",
  alphaTablePending: "0.06",
  alphaTableStriped: "0.05",
  alphaPressed: "0.05",
  alphaAvatar: "0.18",
  alphaRail: "0.2",
  alphaProgressRail: "0.12",
  alphaBorder: "0.24",
  alphaDivider: "0.09",
  alphaInput: "0.1",
  alphaAction: "0.06",
  alphaTab: "0.04",
  alphaScrollbar: "0.2",
  alphaScrollbarHover: "0.3",
  alphaCode: "0.12",
  alphaTag: "0.2",
  // primary
  primaryHover: "#7fe7c4",
  primaryDefault: "#63e2b7",
  primaryActive: "#5acea7",
  primarySuppl: "rgb(42, 148, 125)",
  // info
  infoHover: "#8acbec",
  infoDefault: "#70c0e8",
  infoActive: "#66afd3",
  infoSuppl: "rgb(56, 137, 197)",
  // error
  errorHover: "#e98b8b",
  errorDefault: "#e88080",
  errorActive: "#e57272",
  errorSuppl: "rgb(208, 58, 82)",
  // warning
  warningHover: "#f5d599",
  warningDefault: "#f2c97d",
  warningActive: "#e6c260",
  warningSuppl: "rgb(240, 138, 0)",
  // success
  successHover: "#7fe7c4",
  successDefault: "#63e2b7",
  successActive: "#5acea7",
  successSuppl: "rgb(42, 148, 125)"
}, _Ue = Ga(yt.neutralBase), y9 = Ga(yt.neutralInvertBase), EUe = "rgba(" + y9.slice(0, 3).join(", ") + ", ";
function ln(t) {
  return EUe + String(t) + ")";
}
function xUe(t) {
  const e = Array.from(y9);
  return e[3] = Number(t), Dt(_Ue, e);
}
const wUe = Object.assign(Object.assign({ name: "common" }, n1), {
  baseColor: yt.neutralBase,
  // primary color
  primaryColor: yt.primaryDefault,
  primaryColorHover: yt.primaryHover,
  primaryColorPressed: yt.primaryActive,
  primaryColorSuppl: yt.primarySuppl,
  // info color
  infoColor: yt.infoDefault,
  infoColorHover: yt.infoHover,
  infoColorPressed: yt.infoActive,
  infoColorSuppl: yt.infoSuppl,
  // success color
  successColor: yt.successDefault,
  successColorHover: yt.successHover,
  successColorPressed: yt.successActive,
  successColorSuppl: yt.successSuppl,
  // warning color
  warningColor: yt.warningDefault,
  warningColorHover: yt.warningHover,
  warningColorPressed: yt.warningActive,
  warningColorSuppl: yt.warningSuppl,
  // error color
  errorColor: yt.errorDefault,
  errorColorHover: yt.errorHover,
  errorColorPressed: yt.errorActive,
  errorColorSuppl: yt.errorSuppl,
  // text color
  textColorBase: yt.neutralTextBase,
  textColor1: ln(yt.alpha1),
  textColor2: ln(yt.alpha2),
  textColor3: ln(yt.alpha3),
  // textColor4: overlay(base.alpha4), // disabled, placeholder, icon
  // textColor5: overlay(base.alpha5),
  textColorDisabled: ln(yt.alpha4),
  placeholderColor: ln(yt.alpha4),
  placeholderColorDisabled: ln(yt.alpha5),
  iconColor: ln(yt.alpha4),
  iconColorDisabled: ln(yt.alpha5),
  iconColorHover: ln(Number(yt.alpha4) * 1.25),
  iconColorPressed: ln(Number(yt.alpha4) * 0.8),
  opacity1: yt.alpha1,
  opacity2: yt.alpha2,
  opacity3: yt.alpha3,
  opacity4: yt.alpha4,
  opacity5: yt.alpha5,
  dividerColor: ln(yt.alphaDivider),
  borderColor: ln(yt.alphaBorder),
  // close
  closeIconColorHover: ln(Number(yt.alphaClose)),
  closeIconColor: ln(Number(yt.alphaClose)),
  closeIconColorPressed: ln(Number(yt.alphaClose)),
  closeColorHover: "rgba(255, 255, 255, .12)",
  closeColorPressed: "rgba(255, 255, 255, .08)",
  // clear
  clearColor: ln(yt.alpha4),
  clearColorHover: dr(ln(yt.alpha4), { alpha: 1.25 }),
  clearColorPressed: dr(ln(yt.alpha4), { alpha: 0.8 }),
  scrollbarColor: ln(yt.alphaScrollbar),
  scrollbarColorHover: ln(yt.alphaScrollbarHover),
  scrollbarWidth: "5px",
  scrollbarHeight: "5px",
  scrollbarBorderRadius: "5px",
  progressRailColor: ln(yt.alphaProgressRail),
  railColor: ln(yt.alphaRail),
  popoverColor: yt.neutralPopover,
  tableColor: yt.neutralCard,
  cardColor: yt.neutralCard,
  modalColor: yt.neutralModal,
  bodyColor: yt.neutralBody,
  tagColor: xUe(yt.alphaTag),
  avatarColor: ln(yt.alphaAvatar),
  invertedColor: yt.neutralBase,
  inputColor: ln(yt.alphaInput),
  codeColor: ln(yt.alphaCode),
  tabColor: ln(yt.alphaTab),
  actionColor: ln(yt.alphaAction),
  tableHeaderColor: ln(yt.alphaAction),
  hoverColor: ln(yt.alphaPending),
  tableColorHover: ln(yt.alphaTablePending),
  tableColorStriped: ln(yt.alphaTableStriped),
  pressedColor: ln(yt.alphaPressed),
  opacityDisabled: yt.alphaDisabled,
  inputColorDisabled: ln(yt.alphaDisabledInput),
  buttonColor2: "rgba(255, 255, 255, .08)",
  buttonColor2Hover: "rgba(255, 255, 255, .12)",
  buttonColor2Pressed: "rgba(255, 255, 255, .08)",
  boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .24), 0 3px 6px 0 rgba(0, 0, 0, .18), 0 5px 12px 4px rgba(0, 0, 0, .12)",
  boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .24), 0 6px 12px 0 rgba(0, 0, 0, .16), 0 9px 18px 8px rgba(0, 0, 0, .10)",
  boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
}), ct = wUe, It = {
  neutralBase: "#FFF",
  neutralInvertBase: "#000",
  neutralTextBase: "#000",
  neutralPopover: "#fff",
  neutralCard: "#fff",
  neutralModal: "#fff",
  neutralBody: "#fff",
  alpha1: "0.82",
  alpha2: "0.72",
  alpha3: "0.38",
  alpha4: "0.24",
  alpha5: "0.18",
  alphaClose: "0.6",
  alphaDisabled: "0.5",
  alphaAvatar: "0.2",
  alphaProgressRail: ".08",
  alphaInput: "0",
  alphaScrollbar: "0.25",
  alphaScrollbarHover: "0.4",
  // primary
  primaryHover: "#36ad6a",
  primaryDefault: "#18a058",
  primaryActive: "#0c7a43",
  primarySuppl: "#36ad6a",
  // info
  infoHover: "#4098fc",
  infoDefault: "#2080f0",
  infoActive: "#1060c9",
  infoSuppl: "#4098fc",
  // error
  errorHover: "#de576d",
  errorDefault: "#d03050",
  errorActive: "#ab1f3f",
  errorSuppl: "#de576d",
  // warning
  warningHover: "#fcb040",
  warningDefault: "#f0a020",
  warningActive: "#c97c10",
  warningSuppl: "#fcb040",
  // success
  successHover: "#36ad6a",
  successDefault: "#18a058",
  successActive: "#0c7a43",
  successSuppl: "#36ad6a"
}, CUe = Ga(It.neutralBase), v9 = Ga(It.neutralInvertBase), SUe = "rgba(" + v9.slice(0, 3).join(", ") + ", ";
function wS(t) {
  return SUe + String(t) + ")";
}
function Hr(t) {
  const e = Array.from(v9);
  return e[3] = Number(t), Dt(CUe, e);
}
const IUe = Object.assign(Object.assign({ name: "common" }, n1), {
  baseColor: It.neutralBase,
  // primary color
  primaryColor: It.primaryDefault,
  primaryColorHover: It.primaryHover,
  primaryColorPressed: It.primaryActive,
  primaryColorSuppl: It.primarySuppl,
  // info color
  infoColor: It.infoDefault,
  infoColorHover: It.infoHover,
  infoColorPressed: It.infoActive,
  infoColorSuppl: It.infoSuppl,
  // success color
  successColor: It.successDefault,
  successColorHover: It.successHover,
  successColorPressed: It.successActive,
  successColorSuppl: It.successSuppl,
  // warning color
  warningColor: It.warningDefault,
  warningColorHover: It.warningHover,
  warningColorPressed: It.warningActive,
  warningColorSuppl: It.warningSuppl,
  // error color
  errorColor: It.errorDefault,
  errorColorHover: It.errorHover,
  errorColorPressed: It.errorActive,
  errorColorSuppl: It.errorSuppl,
  // text color
  textColorBase: It.neutralTextBase,
  textColor1: "rgb(31, 34, 37)",
  textColor2: "rgb(51, 54, 57)",
  textColor3: "rgb(118, 124, 130)",
  // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
  // textColor5: neutral(base.alpha5),
  textColorDisabled: Hr(It.alpha4),
  placeholderColor: Hr(It.alpha4),
  placeholderColorDisabled: Hr(It.alpha5),
  iconColor: Hr(It.alpha4),
  iconColorHover: dr(Hr(It.alpha4), { lightness: 0.75 }),
  iconColorPressed: dr(Hr(It.alpha4), { lightness: 0.9 }),
  iconColorDisabled: Hr(It.alpha5),
  opacity1: It.alpha1,
  opacity2: It.alpha2,
  opacity3: It.alpha3,
  opacity4: It.alpha4,
  opacity5: It.alpha5,
  dividerColor: "rgb(239, 239, 245)",
  borderColor: "rgb(224, 224, 230)",
  // close
  closeIconColor: Hr(Number(It.alphaClose)),
  closeIconColorHover: Hr(Number(It.alphaClose)),
  closeIconColorPressed: Hr(Number(It.alphaClose)),
  closeColorHover: "rgba(0, 0, 0, .09)",
  closeColorPressed: "rgba(0, 0, 0, .13)",
  // clear
  clearColor: Hr(It.alpha4),
  clearColorHover: dr(Hr(It.alpha4), { lightness: 0.75 }),
  clearColorPressed: dr(Hr(It.alpha4), { lightness: 0.9 }),
  scrollbarColor: wS(It.alphaScrollbar),
  scrollbarColorHover: wS(It.alphaScrollbarHover),
  scrollbarWidth: "5px",
  scrollbarHeight: "5px",
  scrollbarBorderRadius: "5px",
  progressRailColor: Hr(It.alphaProgressRail),
  railColor: "rgb(219, 219, 223)",
  popoverColor: It.neutralPopover,
  tableColor: It.neutralCard,
  cardColor: It.neutralCard,
  modalColor: It.neutralModal,
  bodyColor: It.neutralBody,
  tagColor: "#eee",
  avatarColor: Hr(It.alphaAvatar),
  invertedColor: "rgb(0, 20, 40)",
  inputColor: Hr(It.alphaInput),
  codeColor: "rgb(244, 244, 248)",
  tabColor: "rgb(247, 247, 250)",
  actionColor: "rgb(250, 250, 252)",
  tableHeaderColor: "rgb(250, 250, 252)",
  hoverColor: "rgb(243, 243, 245)",
  // use color with alpha since it can be nested with header filter & sorter effect
  tableColorHover: "rgba(0, 0, 100, 0.03)",
  tableColorStriped: "rgba(0, 0, 100, 0.02)",
  pressedColor: "rgb(237, 237, 239)",
  opacityDisabled: It.alphaDisabled,
  inputColorDisabled: "rgb(250, 250, 252)",
  // secondary button color
  // can also be used in tertiary button & quaternary button
  buttonColor2: "rgba(46, 51, 56, .05)",
  buttonColor2Hover: "rgba(46, 51, 56, .09)",
  buttonColor2Pressed: "rgba(46, 51, 56, .13)",
  boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
  boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
  boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
}), O_ = IUe, kUe = {
  iconSizeSmall: "34px",
  iconSizeMedium: "40px",
  iconSizeLarge: "46px",
  iconSizeHuge: "52px"
}, T9 = (t) => {
  const { textColorDisabled: e, iconColor: n, textColor2: r, fontSizeSmall: i, fontSizeMedium: s, fontSizeLarge: a, fontSizeHuge: o } = t;
  return Object.assign(Object.assign({}, kUe), {
    fontSizeSmall: i,
    fontSizeMedium: s,
    fontSizeLarge: a,
    fontSizeHuge: o,
    textColor: e,
    iconColor: n,
    extraTextColor: r
  });
}, DUe = {
  name: "Empty",
  common: O_,
  self: T9
}, MUe = DUe, OUe = {
  name: "Empty",
  common: ct,
  self: T9
}, nl = OUe, NUe = (t) => {
  const { scrollbarColor: e, scrollbarColorHover: n } = t;
  return {
    color: e,
    colorHover: n
  };
}, LUe = {
  name: "Scrollbar",
  common: ct,
  self: NUe
}, Bi = LUe, PUe = {
  height: "calc(var(--n-option-height) * 7.6)",
  paddingSmall: "4px 0",
  paddingMedium: "4px 0",
  paddingLarge: "4px 0",
  paddingHuge: "4px 0",
  optionPaddingSmall: "0 12px",
  optionPaddingMedium: "0 12px",
  optionPaddingLarge: "0 12px",
  optionPaddingHuge: "0 12px",
  loadingSize: "18px"
}, RUe = (t) => {
  const { borderRadius: e, popoverColor: n, textColor3: r, dividerColor: i, textColor2: s, primaryColorPressed: a, textColorDisabled: o, primaryColor: u, opacityDisabled: c, hoverColor: d, fontSizeSmall: l, fontSizeMedium: f, fontSizeLarge: p, fontSizeHuge: m, heightSmall: g, heightMedium: y, heightLarge: b, heightHuge: E } = t;
  return Object.assign(Object.assign({}, PUe), { optionFontSizeSmall: l, optionFontSizeMedium: f, optionFontSizeLarge: p, optionFontSizeHuge: m, optionHeightSmall: g, optionHeightMedium: y, optionHeightLarge: b, optionHeightHuge: E, borderRadius: e, color: n, groupHeaderTextColor: r, actionDividerColor: i, optionTextColor: s, optionTextColorPressed: a, optionTextColorDisabled: o, optionTextColorActive: u, optionOpacityDisabled: c, optionCheckColor: u, optionColorPending: d, optionColorActive: "rgba(0, 0, 0, 0)", optionColorActivePending: d, actionTextColor: s, loadingColor: u });
}, BUe = {
  name: "InternalSelectMenu",
  common: ct,
  peers: {
    Scrollbar: Bi,
    Empty: nl
  },
  self: RUe
}, Bh = BUe, FUe = {
  space: "6px",
  spaceArrow: "10px",
  arrowOffset: "10px",
  arrowOffsetVertical: "10px",
  arrowHeight: "6px",
  padding: "8px 14px"
}, UUe = (t) => {
  const { boxShadow2: e, popoverColor: n, textColor2: r, borderRadius: i, fontSize: s, dividerColor: a } = t;
  return Object.assign(Object.assign({}, FUe), {
    fontSize: s,
    borderRadius: i,
    color: n,
    dividerColor: a,
    textColor: r,
    boxShadow: e
  });
}, $Ue = {
  name: "Popover",
  common: ct,
  self: UUe
}, rl = $Ue, HUe = {
  closeIconSizeTiny: "12px",
  closeIconSizeSmall: "12px",
  closeIconSizeMedium: "14px",
  closeIconSizeLarge: "14px",
  closeSizeTiny: "16px",
  closeSizeSmall: "16px",
  closeSizeMedium: "18px",
  closeSizeLarge: "18px",
  padding: "0 7px",
  closeMargin: "0 0 0 4px",
  closeMarginRtl: "0 4px 0 0"
}, jUe = {
  name: "Tag",
  common: ct,
  self(t) {
    const { textColor2: e, primaryColorHover: n, primaryColorPressed: r, primaryColor: i, infoColor: s, successColor: a, warningColor: o, errorColor: u, baseColor: c, borderColor: d, tagColor: l, opacityDisabled: f, closeIconColor: p, closeIconColorHover: m, closeIconColorPressed: g, closeColorHover: y, closeColorPressed: b, borderRadiusSmall: E, fontSizeMini: v, fontSizeTiny: _, fontSizeSmall: D, fontSizeMedium: S, heightMini: M, heightTiny: O, heightSmall: T, heightMedium: N, buttonColor2Hover: H, buttonColor2Pressed: $, fontWeightStrong: j } = t;
    return Object.assign(Object.assign({}, HUe), {
      closeBorderRadius: E,
      heightTiny: M,
      heightSmall: O,
      heightMedium: T,
      heightLarge: N,
      borderRadius: E,
      opacityDisabled: f,
      fontSizeTiny: v,
      fontSizeSmall: _,
      fontSizeMedium: D,
      fontSizeLarge: S,
      fontWeightStrong: j,
      // checked
      textColorCheckable: e,
      textColorHoverCheckable: e,
      textColorPressedCheckable: e,
      textColorChecked: c,
      colorCheckable: "#0000",
      colorHoverCheckable: H,
      colorPressedCheckable: $,
      colorChecked: i,
      colorCheckedHover: n,
      colorCheckedPressed: r,
      // default
      border: `1px solid ${d}`,
      textColor: e,
      color: l,
      colorBordered: "#0000",
      closeIconColor: p,
      closeIconColorHover: m,
      closeIconColorPressed: g,
      closeColorHover: y,
      closeColorPressed: b,
      borderPrimary: `1px solid ${Et(i, { alpha: 0.3 })}`,
      textColorPrimary: i,
      colorPrimary: Et(i, { alpha: 0.16 }),
      colorBorderedPrimary: "#0000",
      closeIconColorPrimary: dr(i, { lightness: 0.7 }),
      closeIconColorHoverPrimary: dr(i, { lightness: 0.7 }),
      closeIconColorPressedPrimary: dr(i, {
        lightness: 0.7
      }),
      closeColorHoverPrimary: Et(i, { alpha: 0.16 }),
      closeColorPressedPrimary: Et(i, { alpha: 0.12 }),
      borderInfo: `1px solid ${Et(s, { alpha: 0.3 })}`,
      textColorInfo: s,
      colorInfo: Et(s, { alpha: 0.16 }),
      colorBorderedInfo: "#0000",
      closeIconColorInfo: dr(s, { alpha: 0.7 }),
      closeIconColorHoverInfo: dr(s, { alpha: 0.7 }),
      closeIconColorPressedInfo: dr(s, { alpha: 0.7 }),
      closeColorHoverInfo: Et(s, { alpha: 0.16 }),
      closeColorPressedInfo: Et(s, { alpha: 0.12 }),
      borderSuccess: `1px solid ${Et(a, { alpha: 0.3 })}`,
      textColorSuccess: a,
      colorSuccess: Et(a, { alpha: 0.16 }),
      colorBorderedSuccess: "#0000",
      closeIconColorSuccess: dr(a, { alpha: 0.7 }),
      closeIconColorHoverSuccess: dr(a, { alpha: 0.7 }),
      closeIconColorPressedSuccess: dr(a, { alpha: 0.7 }),
      closeColorHoverSuccess: Et(a, { alpha: 0.16 }),
      closeColorPressedSuccess: Et(a, { alpha: 0.12 }),
      borderWarning: `1px solid ${Et(o, { alpha: 0.3 })}`,
      textColorWarning: o,
      colorWarning: Et(o, { alpha: 0.16 }),
      colorBorderedWarning: "#0000",
      closeIconColorWarning: dr(o, { alpha: 0.7 }),
      closeIconColorHoverWarning: dr(o, { alpha: 0.7 }),
      closeIconColorPressedWarning: dr(o, { alpha: 0.7 }),
      closeColorHoverWarning: Et(o, { alpha: 0.16 }),
      closeColorPressedWarning: Et(o, { alpha: 0.11 }),
      borderError: `1px solid ${Et(u, { alpha: 0.3 })}`,
      textColorError: u,
      colorError: Et(u, { alpha: 0.16 }),
      colorBorderedError: "#0000",
      closeIconColorError: dr(u, { alpha: 0.7 }),
      closeIconColorHoverError: dr(u, { alpha: 0.7 }),
      closeIconColorPressedError: dr(u, { alpha: 0.7 }),
      closeColorHoverError: Et(u, { alpha: 0.16 }),
      closeColorPressedError: Et(u, { alpha: 0.12 })
    });
  }
}, _9 = jUe, zUe = {
  paddingSingle: "0 26px 0 12px",
  paddingMultiple: "3px 26px 0 12px",
  clearSize: "16px",
  arrowSize: "16px"
}, qUe = {
  name: "InternalSelection",
  common: ct,
  peers: {
    Popover: rl
  },
  self(t) {
    const { borderRadius: e, textColor2: n, textColorDisabled: r, inputColor: i, inputColorDisabled: s, primaryColor: a, primaryColorHover: o, warningColor: u, warningColorHover: c, errorColor: d, errorColorHover: l, iconColor: f, iconColorDisabled: p, clearColor: m, clearColorHover: g, clearColorPressed: y, placeholderColor: b, placeholderColorDisabled: E, fontSizeTiny: v, fontSizeSmall: _, fontSizeMedium: D, fontSizeLarge: S, heightTiny: M, heightSmall: O, heightMedium: T, heightLarge: N } = t;
    return Object.assign(Object.assign({}, zUe), {
      fontSizeTiny: v,
      fontSizeSmall: _,
      fontSizeMedium: D,
      fontSizeLarge: S,
      heightTiny: M,
      heightSmall: O,
      heightMedium: T,
      heightLarge: N,
      borderRadius: e,
      // default
      textColor: n,
      textColorDisabled: r,
      placeholderColor: b,
      placeholderColorDisabled: E,
      color: i,
      colorDisabled: s,
      colorActive: Et(a, { alpha: 0.1 }),
      border: "1px solid #0000",
      borderHover: `1px solid ${o}`,
      borderActive: `1px solid ${a}`,
      borderFocus: `1px solid ${o}`,
      boxShadowHover: "none",
      boxShadowActive: `0 0 8px 0 ${Et(a, {
        alpha: 0.4
      })}`,
      boxShadowFocus: `0 0 8px 0 ${Et(a, {
        alpha: 0.4
      })}`,
      caretColor: a,
      arrowColor: f,
      arrowColorDisabled: p,
      loadingColor: a,
      // warning
      borderWarning: `1px solid ${u}`,
      borderHoverWarning: `1px solid ${c}`,
      borderActiveWarning: `1px solid ${u}`,
      borderFocusWarning: `1px solid ${c}`,
      boxShadowHoverWarning: "none",
      boxShadowActiveWarning: `0 0 8px 0 ${Et(u, {
        alpha: 0.4
      })}`,
      boxShadowFocusWarning: `0 0 8px 0 ${Et(u, {
        alpha: 0.4
      })}`,
      colorActiveWarning: Et(u, { alpha: 0.1 }),
      caretColorWarning: u,
      // error
      borderError: `1px solid ${d}`,
      borderHoverError: `1px solid ${l}`,
      borderActiveError: `1px solid ${d}`,
      borderFocusError: `1px solid ${l}`,
      boxShadowHoverError: "none",
      boxShadowActiveError: `0 0 8px 0 ${Et(d, {
        alpha: 0.4
      })}`,
      boxShadowFocusError: `0 0 8px 0 ${Et(d, {
        alpha: 0.4
      })}`,
      colorActiveError: Et(d, { alpha: 0.1 }),
      caretColorError: d,
      clearColor: m,
      clearColorHover: g,
      clearColorPressed: y
    });
  }
}, N_ = qUe, VUe = {
  iconMargin: "11px 8px 0 12px",
  iconMarginRtl: "11px 12px 0 8px",
  iconSize: "24px",
  closeIconSize: "16px",
  closeSize: "20px",
  closeMargin: "13px 14px 0 0",
  closeMarginRtl: "13px 0 0 14px",
  padding: "13px"
}, WUe = {
  name: "Alert",
  common: ct,
  self(t) {
    const { lineHeight: e, borderRadius: n, fontWeightStrong: r, dividerColor: i, inputColor: s, textColor1: a, textColor2: o, closeColorHover: u, closeColorPressed: c, closeIconColor: d, closeIconColorHover: l, closeIconColorPressed: f, infoColorSuppl: p, successColorSuppl: m, warningColorSuppl: g, errorColorSuppl: y, fontSize: b } = t;
    return Object.assign(Object.assign({}, VUe), {
      fontSize: b,
      lineHeight: e,
      titleFontWeight: r,
      borderRadius: n,
      border: `1px solid ${i}`,
      color: s,
      titleTextColor: a,
      iconColor: o,
      contentTextColor: o,
      closeBorderRadius: n,
      closeColorHover: u,
      closeColorPressed: c,
      closeIconColor: d,
      closeIconColorHover: l,
      closeIconColorPressed: f,
      borderInfo: `1px solid ${Et(p, { alpha: 0.35 })}`,
      colorInfo: Et(p, { alpha: 0.25 }),
      titleTextColorInfo: a,
      iconColorInfo: p,
      contentTextColorInfo: o,
      closeColorHoverInfo: u,
      closeColorPressedInfo: c,
      closeIconColorInfo: d,
      closeIconColorHoverInfo: l,
      closeIconColorPressedInfo: f,
      borderSuccess: `1px solid ${Et(m, {
        alpha: 0.35
      })}`,
      colorSuccess: Et(m, { alpha: 0.25 }),
      titleTextColorSuccess: a,
      iconColorSuccess: m,
      contentTextColorSuccess: o,
      closeColorHoverSuccess: u,
      closeColorPressedSuccess: c,
      closeIconColorSuccess: d,
      closeIconColorHoverSuccess: l,
      closeIconColorPressedSuccess: f,
      borderWarning: `1px solid ${Et(g, {
        alpha: 0.35
      })}`,
      colorWarning: Et(g, { alpha: 0.25 }),
      titleTextColorWarning: a,
      iconColorWarning: g,
      contentTextColorWarning: o,
      closeColorHoverWarning: u,
      closeColorPressedWarning: c,
      closeIconColorWarning: d,
      closeIconColorHoverWarning: l,
      closeIconColorPressedWarning: f,
      borderError: `1px solid ${Et(y, { alpha: 0.35 })}`,
      colorError: Et(y, { alpha: 0.25 }),
      titleTextColorError: a,
      iconColorError: y,
      contentTextColorError: o,
      closeColorHoverError: u,
      closeColorPressedError: c,
      closeIconColorError: d,
      closeIconColorHoverError: l,
      closeIconColorPressedError: f
    });
  }
}, QUe = WUe, GUe = {
  linkFontSize: "13px",
  linkPadding: "0 0 0 16px",
  railWidth: "4px"
}, YUe = (t) => {
  const { borderRadius: e, railColor: n, primaryColor: r, primaryColorHover: i, primaryColorPressed: s, textColor2: a } = t;
  return Object.assign(Object.assign({}, GUe), {
    borderRadius: e,
    railColor: n,
    railColorActive: r,
    linkColor: Et(r, { alpha: 0.15 }),
    linkTextColor: a,
    linkTextColorHover: i,
    linkTextColorPressed: s,
    linkTextColorActive: r
  });
}, XUe = {
  name: "Anchor",
  common: ct,
  self: YUe
}, KUe = XUe, ZUe = {
  paddingTiny: "0 8px",
  paddingSmall: "0 10px",
  paddingMedium: "0 12px",
  paddingLarge: "0 14px",
  clearSize: "16px"
}, JUe = {
  name: "Input",
  common: ct,
  self(t) {
    const { textColor2: e, textColor3: n, textColorDisabled: r, primaryColor: i, primaryColorHover: s, inputColor: a, inputColorDisabled: o, warningColor: u, warningColorHover: c, errorColor: d, errorColorHover: l, borderRadius: f, lineHeight: p, fontSizeTiny: m, fontSizeSmall: g, fontSizeMedium: y, fontSizeLarge: b, heightTiny: E, heightSmall: v, heightMedium: _, heightLarge: D, clearColor: S, clearColorHover: M, clearColorPressed: O, placeholderColor: T, placeholderColorDisabled: N, iconColor: H, iconColorDisabled: $, iconColorHover: j, iconColorPressed: U } = t;
    return Object.assign(Object.assign({}, ZUe), {
      countTextColorDisabled: r,
      countTextColor: n,
      heightTiny: E,
      heightSmall: v,
      heightMedium: _,
      heightLarge: D,
      fontSizeTiny: m,
      fontSizeSmall: g,
      fontSizeMedium: y,
      fontSizeLarge: b,
      lineHeight: p,
      lineHeightTextarea: p,
      borderRadius: f,
      iconSize: "16px",
      groupLabelColor: a,
      textColor: e,
      textColorDisabled: r,
      textDecorationColor: e,
      groupLabelTextColor: e,
      caretColor: i,
      placeholderColor: T,
      placeholderColorDisabled: N,
      color: a,
      colorDisabled: o,
      colorFocus: Et(i, { alpha: 0.1 }),
      groupLabelBorder: "1px solid #0000",
      border: "1px solid #0000",
      borderHover: `1px solid ${s}`,
      borderDisabled: "1px solid #0000",
      borderFocus: `1px solid ${s}`,
      boxShadowFocus: `0 0 8px 0 ${Et(i, { alpha: 0.3 })}`,
      loadingColor: i,
      // warning
      loadingColorWarning: u,
      borderWarning: `1px solid ${u}`,
      borderHoverWarning: `1px solid ${c}`,
      colorFocusWarning: Et(u, { alpha: 0.1 }),
      borderFocusWarning: `1px solid ${c}`,
      boxShadowFocusWarning: `0 0 8px 0 ${Et(u, {
        alpha: 0.3
      })}`,
      caretColorWarning: u,
      // error
      loadingColorError: d,
      borderError: `1px solid ${d}`,
      borderHoverError: `1px solid ${l}`,
      colorFocusError: Et(d, { alpha: 0.1 }),
      borderFocusError: `1px solid ${l}`,
      boxShadowFocusError: `0 0 8px 0 ${Et(d, {
        alpha: 0.3
      })}`,
      caretColorError: d,
      clearColor: S,
      clearColorHover: M,
      clearColorPressed: O,
      iconColor: H,
      iconColorDisabled: $,
      iconColorHover: j,
      iconColorPressed: U,
      suffixTextColor: e
    });
  }
}, As = JUe;
function e$e(t) {
  const { boxShadow2: e } = t;
  return {
    menuBoxShadow: e
  };
}
const t$e = {
  name: "AutoComplete",
  common: ct,
  peers: {
    InternalSelectMenu: Bh,
    Input: As
  },
  self: e$e
}, n$e = t$e, r$e = (t) => {
  const { borderRadius: e, avatarColor: n, cardColor: r, fontSize: i, heightTiny: s, heightSmall: a, heightMedium: o, heightLarge: u, heightHuge: c, modalColor: d, popoverColor: l } = t;
  return {
    borderRadius: e,
    fontSize: i,
    border: `2px solid ${r}`,
    heightTiny: s,
    heightSmall: a,
    heightMedium: o,
    heightLarge: u,
    heightHuge: c,
    color: Dt(r, n),
    colorModal: Dt(d, n),
    colorPopover: Dt(l, n)
  };
}, i$e = {
  name: "Avatar",
  common: ct,
  self: r$e
}, E9 = i$e, s$e = () => ({
  gap: "-12px"
}), a$e = {
  name: "AvatarGroup",
  common: ct,
  peers: {
    Avatar: E9
  },
  self: s$e
}, o$e = a$e, u$e = {
  width: "44px",
  height: "44px",
  borderRadius: "22px",
  iconSize: "26px"
}, l$e = {
  name: "BackTop",
  common: ct,
  self(t) {
    const { popoverColor: e, textColor2: n, primaryColorHover: r, primaryColorPressed: i } = t;
    return Object.assign(Object.assign({}, u$e), { color: e, textColor: n, iconColor: n, iconColorHover: r, iconColorPressed: i, boxShadow: "0 2px 8px 0px rgba(0, 0, 0, .12)", boxShadowHover: "0 2px 12px 0px rgba(0, 0, 0, .18)", boxShadowPressed: "0 2px 12px 0px rgba(0, 0, 0, .18)" });
  }
}, c$e = l$e, d$e = {
  name: "Badge",
  common: ct,
  self(t) {
    const { errorColorSuppl: e, infoColorSuppl: n, successColorSuppl: r, warningColorSuppl: i, fontFamily: s } = t;
    return {
      color: e,
      colorInfo: n,
      colorSuccess: r,
      colorError: e,
      colorWarning: i,
      fontSize: "12px",
      fontFamily: s
    };
  }
}, f$e = d$e, h$e = {
  fontWeightActive: "400"
}, p$e = (t) => {
  const { fontSize: e, textColor3: n, textColor2: r, borderRadius: i, buttonColor2Hover: s, buttonColor2Pressed: a } = t;
  return Object.assign(Object.assign({}, h$e), { fontSize: e, itemLineHeight: "1.25", itemTextColor: n, itemTextColorHover: r, itemTextColorPressed: r, itemTextColorActive: r, itemBorderRadius: i, itemColorHover: s, itemColorPressed: a, separatorColor: n });
}, m$e = {
  name: "Breadcrumb",
  common: ct,
  self: p$e
}, g$e = m$e, A$e = {
  paddingTiny: "0 6px",
  paddingSmall: "0 10px",
  paddingMedium: "0 14px",
  paddingLarge: "0 18px",
  paddingRoundTiny: "0 10px",
  paddingRoundSmall: "0 14px",
  paddingRoundMedium: "0 18px",
  paddingRoundLarge: "0 22px",
  iconMarginTiny: "6px",
  iconMarginSmall: "6px",
  iconMarginMedium: "6px",
  iconMarginLarge: "6px",
  iconSizeTiny: "14px",
  iconSizeSmall: "18px",
  iconSizeMedium: "18px",
  iconSizeLarge: "20px",
  rippleDuration: ".6s"
}, b$e = (t) => {
  const { heightTiny: e, heightSmall: n, heightMedium: r, heightLarge: i, borderRadius: s, fontSizeTiny: a, fontSizeSmall: o, fontSizeMedium: u, fontSizeLarge: c, opacityDisabled: d, textColor2: l, textColor3: f, primaryColorHover: p, primaryColorPressed: m, borderColor: g, primaryColor: y, baseColor: b, infoColor: E, infoColorHover: v, infoColorPressed: _, successColor: D, successColorHover: S, successColorPressed: M, warningColor: O, warningColorHover: T, warningColorPressed: N, errorColor: H, errorColorHover: $, errorColorPressed: j, fontWeight: U, buttonColor2: V, buttonColor2Hover: B, buttonColor2Pressed: R, fontWeightStrong: K } = t;
  return Object.assign(Object.assign({}, A$e), {
    heightTiny: e,
    heightSmall: n,
    heightMedium: r,
    heightLarge: i,
    borderRadiusTiny: s,
    borderRadiusSmall: s,
    borderRadiusMedium: s,
    borderRadiusLarge: s,
    fontSizeTiny: a,
    fontSizeSmall: o,
    fontSizeMedium: u,
    fontSizeLarge: c,
    opacityDisabled: d,
    // secondary
    colorOpacitySecondary: "0.16",
    colorOpacitySecondaryHover: "0.22",
    colorOpacitySecondaryPressed: "0.28",
    colorSecondary: V,
    colorSecondaryHover: B,
    colorSecondaryPressed: R,
    // tertiary
    colorTertiary: V,
    colorTertiaryHover: B,
    colorTertiaryPressed: R,
    // quaternary
    colorQuaternary: "#0000",
    colorQuaternaryHover: B,
    colorQuaternaryPressed: R,
    // default type
    color: "#0000",
    colorHover: "#0000",
    colorPressed: "#0000",
    colorFocus: "#0000",
    colorDisabled: "#0000",
    textColor: l,
    textColorTertiary: f,
    textColorHover: p,
    textColorPressed: m,
    textColorFocus: p,
    textColorDisabled: l,
    textColorText: l,
    textColorTextHover: p,
    textColorTextPressed: m,
    textColorTextFocus: p,
    textColorTextDisabled: l,
    textColorGhost: l,
    textColorGhostHover: p,
    textColorGhostPressed: m,
    textColorGhostFocus: p,
    textColorGhostDisabled: l,
    border: `1px solid ${g}`,
    borderHover: `1px solid ${p}`,
    borderPressed: `1px solid ${m}`,
    borderFocus: `1px solid ${p}`,
    borderDisabled: `1px solid ${g}`,
    rippleColor: y,
    // primary
    colorPrimary: y,
    colorHoverPrimary: p,
    colorPressedPrimary: m,
    colorFocusPrimary: p,
    colorDisabledPrimary: y,
    textColorPrimary: b,
    textColorHoverPrimary: b,
    textColorPressedPrimary: b,
    textColorFocusPrimary: b,
    textColorDisabledPrimary: b,
    textColorTextPrimary: y,
    textColorTextHoverPrimary: p,
    textColorTextPressedPrimary: m,
    textColorTextFocusPrimary: p,
    textColorTextDisabledPrimary: l,
    textColorGhostPrimary: y,
    textColorGhostHoverPrimary: p,
    textColorGhostPressedPrimary: m,
    textColorGhostFocusPrimary: p,
    textColorGhostDisabledPrimary: y,
    borderPrimary: `1px solid ${y}`,
    borderHoverPrimary: `1px solid ${p}`,
    borderPressedPrimary: `1px solid ${m}`,
    borderFocusPrimary: `1px solid ${p}`,
    borderDisabledPrimary: `1px solid ${y}`,
    rippleColorPrimary: y,
    // info
    colorInfo: E,
    colorHoverInfo: v,
    colorPressedInfo: _,
    colorFocusInfo: v,
    colorDisabledInfo: E,
    textColorInfo: b,
    textColorHoverInfo: b,
    textColorPressedInfo: b,
    textColorFocusInfo: b,
    textColorDisabledInfo: b,
    textColorTextInfo: E,
    textColorTextHoverInfo: v,
    textColorTextPressedInfo: _,
    textColorTextFocusInfo: v,
    textColorTextDisabledInfo: l,
    textColorGhostInfo: E,
    textColorGhostHoverInfo: v,
    textColorGhostPressedInfo: _,
    textColorGhostFocusInfo: v,
    textColorGhostDisabledInfo: E,
    borderInfo: `1px solid ${E}`,
    borderHoverInfo: `1px solid ${v}`,
    borderPressedInfo: `1px solid ${_}`,
    borderFocusInfo: `1px solid ${v}`,
    borderDisabledInfo: `1px solid ${E}`,
    rippleColorInfo: E,
    // success
    colorSuccess: D,
    colorHoverSuccess: S,
    colorPressedSuccess: M,
    colorFocusSuccess: S,
    colorDisabledSuccess: D,
    textColorSuccess: b,
    textColorHoverSuccess: b,
    textColorPressedSuccess: b,
    textColorFocusSuccess: b,
    textColorDisabledSuccess: b,
    textColorTextSuccess: D,
    textColorTextHoverSuccess: S,
    textColorTextPressedSuccess: M,
    textColorTextFocusSuccess: S,
    textColorTextDisabledSuccess: l,
    textColorGhostSuccess: D,
    textColorGhostHoverSuccess: S,
    textColorGhostPressedSuccess: M,
    textColorGhostFocusSuccess: S,
    textColorGhostDisabledSuccess: D,
    borderSuccess: `1px solid ${D}`,
    borderHoverSuccess: `1px solid ${S}`,
    borderPressedSuccess: `1px solid ${M}`,
    borderFocusSuccess: `1px solid ${S}`,
    borderDisabledSuccess: `1px solid ${D}`,
    rippleColorSuccess: D,
    // warning
    colorWarning: O,
    colorHoverWarning: T,
    colorPressedWarning: N,
    colorFocusWarning: T,
    colorDisabledWarning: O,
    textColorWarning: b,
    textColorHoverWarning: b,
    textColorPressedWarning: b,
    textColorFocusWarning: b,
    textColorDisabledWarning: b,
    textColorTextWarning: O,
    textColorTextHoverWarning: T,
    textColorTextPressedWarning: N,
    textColorTextFocusWarning: T,
    textColorTextDisabledWarning: l,
    textColorGhostWarning: O,
    textColorGhostHoverWarning: T,
    textColorGhostPressedWarning: N,
    textColorGhostFocusWarning: T,
    textColorGhostDisabledWarning: O,
    borderWarning: `1px solid ${O}`,
    borderHoverWarning: `1px solid ${T}`,
    borderPressedWarning: `1px solid ${N}`,
    borderFocusWarning: `1px solid ${T}`,
    borderDisabledWarning: `1px solid ${O}`,
    rippleColorWarning: O,
    // error
    colorError: H,
    colorHoverError: $,
    colorPressedError: j,
    colorFocusError: $,
    colorDisabledError: H,
    textColorError: b,
    textColorHoverError: b,
    textColorPressedError: b,
    textColorFocusError: b,
    textColorDisabledError: b,
    textColorTextError: H,
    textColorTextHoverError: $,
    textColorTextPressedError: j,
    textColorTextFocusError: $,
    textColorTextDisabledError: l,
    textColorGhostError: H,
    textColorGhostHoverError: $,
    textColorGhostPressedError: j,
    textColorGhostFocusError: $,
    textColorGhostDisabledError: H,
    borderError: `1px solid ${H}`,
    borderHoverError: `1px solid ${$}`,
    borderPressedError: `1px solid ${j}`,
    borderFocusError: `1px solid ${$}`,
    borderDisabledError: `1px solid ${H}`,
    rippleColorError: H,
    waveOpacity: "0.6",
    fontWeight: U,
    fontWeightStrong: K
  });
}, y$e = {
  name: "Button",
  common: ct,
  self(t) {
    const e = b$e(t);
    return e.waveOpacity = "0.8", e.colorOpacitySecondary = "0.16", e.colorOpacitySecondaryHover = "0.2", e.colorOpacitySecondaryPressed = "0.12", e;
  }
}, Fi = y$e, v$e = {
  titleFontSize: "22px"
}, T$e = (t) => {
  const { borderRadius: e, fontSize: n, lineHeight: r, textColor2: i, textColor1: s, textColorDisabled: a, dividerColor: o, fontWeightStrong: u, primaryColor: c, baseColor: d, hoverColor: l, cardColor: f, modalColor: p, popoverColor: m } = t;
  return Object.assign(Object.assign({}, v$e), {
    borderRadius: e,
    borderColor: Dt(f, o),
    borderColorModal: Dt(p, o),
    borderColorPopover: Dt(m, o),
    textColor: i,
    titleFontWeight: u,
    titleTextColor: s,
    dayTextColor: a,
    fontSize: n,
    lineHeight: r,
    dateColorCurrent: c,
    dateTextColorCurrent: d,
    cellColorHover: Dt(f, l),
    cellColorHoverModal: Dt(p, l),
    cellColorHoverPopover: Dt(m, l),
    cellColor: f,
    cellColorModal: p,
    cellColorPopover: m,
    barColor: c
  });
}, _$e = {
  name: "Calendar",
  common: ct,
  peers: {
    Button: Fi
  },
  self: T$e
}, E$e = _$e, x$e = (t) => {
  const { fontSize: e, boxShadow2: n, popoverColor: r, textColor2: i, borderRadius: s, borderColor: a, heightSmall: o, heightMedium: u, heightLarge: c, fontSizeSmall: d, fontSizeMedium: l, fontSizeLarge: f, dividerColor: p } = t;
  return {
    panelFontSize: e,
    boxShadow: n,
    color: r,
    textColor: i,
    borderRadius: s,
    border: `1px solid ${a}`,
    heightSmall: o,
    heightMedium: u,
    heightLarge: c,
    fontSizeSmall: d,
    fontSizeMedium: l,
    fontSizeLarge: f,
    dividerColor: p
  };
}, w$e = {
  name: "ColorPicker",
  common: ct,
  peers: {
    Input: As,
    Button: Fi
  },
  self: x$e
}, C$e = w$e, S$e = {
  paddingSmall: "12px 16px 12px",
  paddingMedium: "19px 24px 20px",
  paddingLarge: "23px 32px 24px",
  paddingHuge: "27px 40px 28px",
  titleFontSizeSmall: "16px",
  titleFontSizeMedium: "18px",
  titleFontSizeLarge: "18px",
  titleFontSizeHuge: "18px",
  closeIconSize: "18px",
  closeSize: "22px"
}, I$e = (t) => {
  const { primaryColor: e, borderRadius: n, lineHeight: r, fontSize: i, cardColor: s, textColor2: a, textColor1: o, dividerColor: u, fontWeightStrong: c, closeIconColor: d, closeIconColorHover: l, closeIconColorPressed: f, closeColorHover: p, closeColorPressed: m, modalColor: g, boxShadow1: y, popoverColor: b, actionColor: E } = t;
  return Object.assign(Object.assign({}, S$e), {
    lineHeight: r,
    color: s,
    colorModal: g,
    colorPopover: b,
    colorTarget: e,
    colorEmbedded: E,
    colorEmbeddedModal: E,
    colorEmbeddedPopover: E,
    textColor: a,
    titleTextColor: o,
    borderColor: u,
    actionColor: E,
    titleFontWeight: c,
    closeColorHover: p,
    closeColorPressed: m,
    closeBorderRadius: n,
    closeIconColor: d,
    closeIconColorHover: l,
    closeIconColorPressed: f,
    fontSizeSmall: i,
    fontSizeMedium: i,
    fontSizeLarge: i,
    fontSizeHuge: i,
    boxShadow: y,
    borderRadius: n
  });
}, k$e = {
  name: "Card",
  common: ct,
  self(t) {
    const e = I$e(t), { cardColor: n, modalColor: r, popoverColor: i } = t;
    return e.colorEmbedded = n, e.colorEmbeddedModal = r, e.colorEmbeddedPopover = i, e;
  }
}, x9 = k$e, D$e = (t) => ({
  dotSize: "8px",
  dotColor: "rgba(255, 255, 255, .3)",
  dotColorActive: "rgba(255, 255, 255, 1)",
  dotColorFocus: "rgba(255, 255, 255, .5)",
  dotLineWidth: "16px",
  dotLineWidthActive: "24px",
  arrowColor: "#eee"
}), M$e = {
  name: "Carousel",
  common: ct,
  self: D$e
}, O$e = M$e, N$e = {
  sizeSmall: "14px",
  sizeMedium: "16px",
  sizeLarge: "18px",
  labelPadding: "0 8px",
  labelFontWeight: "400"
}, L$e = (t) => {
  const { baseColor: e, inputColorDisabled: n, cardColor: r, modalColor: i, popoverColor: s, textColorDisabled: a, borderColor: o, primaryColor: u, textColor2: c, fontSizeSmall: d, fontSizeMedium: l, fontSizeLarge: f, borderRadiusSmall: p, lineHeight: m } = t;
  return Object.assign(Object.assign({}, N$e), {
    labelLineHeight: m,
    fontSizeSmall: d,
    fontSizeMedium: l,
    fontSizeLarge: f,
    borderRadius: p,
    color: e,
    colorChecked: u,
    colorDisabled: n,
    colorDisabledChecked: n,
    colorTableHeader: r,
    colorTableHeaderModal: i,
    colorTableHeaderPopover: s,
    checkMarkColor: e,
    checkMarkColorDisabled: a,
    checkMarkColorDisabledChecked: a,
    border: `1px solid ${o}`,
    borderDisabled: `1px solid ${o}`,
    borderDisabledChecked: `1px solid ${o}`,
    borderChecked: `1px solid ${u}`,
    borderFocus: `1px solid ${u}`,
    boxShadowFocus: `0 0 0 2px ${Et(u, { alpha: 0.3 })}`,
    textColor: c,
    textColorDisabled: a
  });
}, P$e = {
  name: "Checkbox",
  common: ct,
  self(t) {
    const { cardColor: e } = t, n = L$e(t);
    return n.color = "#0000", n.checkMarkColor = e, n;
  }
}, rd = P$e, R$e = (t) => {
  const { borderRadius: e, boxShadow2: n, popoverColor: r, textColor2: i, textColor3: s, primaryColor: a, textColorDisabled: o, dividerColor: u, hoverColor: c, fontSizeMedium: d, heightMedium: l } = t;
  return {
    menuBorderRadius: e,
    menuColor: r,
    menuBoxShadow: n,
    menuDividerColor: u,
    menuHeight: "calc(var(--n-option-height) * 6.6)",
    optionArrowColor: s,
    optionHeight: l,
    optionFontSize: d,
    optionColorHover: c,
    optionTextColor: i,
    optionTextColorActive: a,
    optionTextColorDisabled: o,
    optionCheckMarkColor: a,
    loadingColor: a,
    columnWidth: "180px"
  };
}, B$e = {
  name: "Cascader",
  common: ct,
  peers: {
    InternalSelectMenu: Bh,
    InternalSelection: N_,
    Scrollbar: Bi,
    Checkbox: rd,
    Empty: MUe
  },
  self: R$e
}, F$e = B$e, U$e = {
  name: "Code",
  common: ct,
  self(t) {
    const { textColor2: e, fontSize: n, fontWeightStrong: r, textColor3: i } = t;
    return {
      textColor: e,
      fontSize: n,
      fontWeightStrong: r,
      // extracted from hljs atom-one-dark.scss
      "mono-3": "#5c6370",
      "hue-1": "#56b6c2",
      "hue-2": "#61aeee",
      "hue-3": "#c678dd",
      "hue-4": "#98c379",
      "hue-5": "#e06c75",
      "hue-5-2": "#be5046",
      "hue-6": "#d19a66",
      "hue-6-2": "#e6c07b",
      // line-number styles
      lineNumberTextColor: i
    };
  }
}, w9 = U$e, $$e = (t) => {
  const { fontWeight: e, textColor1: n, textColor2: r, textColorDisabled: i, dividerColor: s, fontSize: a } = t;
  return {
    titleFontSize: a,
    titleFontWeight: e,
    dividerColor: s,
    titleTextColor: n,
    titleTextColorDisabled: i,
    fontSize: a,
    textColor: r,
    arrowColor: r,
    arrowColorDisabled: i,
    itemMargin: "16px 0 0 0",
    titlePadding: "16px 0 0 0"
  };
}, H$e = {
  name: "Collapse",
  common: ct,
  self: $$e
}, j$e = H$e, z$e = (t) => {
  const { cubicBezierEaseInOut: e } = t;
  return {
    bezier: e
  };
}, q$e = {
  name: "CollapseTransition",
  common: ct,
  self: z$e
}, V$e = q$e, W$e = {
  name: "Popselect",
  common: ct,
  peers: {
    Popover: rl,
    InternalSelectMenu: Bh
  }
}, C9 = W$e;
function Q$e(t) {
  const { boxShadow2: e } = t;
  return {
    menuBoxShadow: e
  };
}
const G$e = {
  name: "Select",
  common: ct,
  peers: {
    InternalSelection: N_,
    InternalSelectMenu: Bh
  },
  self: Q$e
}, S9 = G$e, Y$e = {
  itemPaddingSmall: "0 4px",
  itemMarginSmall: "0 0 0 8px",
  itemMarginSmallRtl: "0 8px 0 0",
  itemPaddingMedium: "0 4px",
  itemMarginMedium: "0 0 0 8px",
  itemMarginMediumRtl: "0 8px 0 0",
  itemPaddingLarge: "0 4px",
  itemMarginLarge: "0 0 0 8px",
  itemMarginLargeRtl: "0 8px 0 0",
  buttonIconSizeSmall: "14px",
  buttonIconSizeMedium: "16px",
  buttonIconSizeLarge: "18px",
  inputWidthSmall: "60px",
  selectWidthSmall: "unset",
  inputMarginSmall: "0 0 0 8px",
  inputMarginSmallRtl: "0 8px 0 0",
  selectMarginSmall: "0 0 0 8px",
  prefixMarginSmall: "0 8px 0 0",
  suffixMarginSmall: "0 0 0 8px",
  inputWidthMedium: "60px",
  selectWidthMedium: "unset",
  inputMarginMedium: "0 0 0 8px",
  inputMarginMediumRtl: "0 8px 0 0",
  selectMarginMedium: "0 0 0 8px",
  prefixMarginMedium: "0 8px 0 0",
  suffixMarginMedium: "0 0 0 8px",
  inputWidthLarge: "60px",
  selectWidthLarge: "unset",
  inputMarginLarge: "0 0 0 8px",
  inputMarginLargeRtl: "0 8px 0 0",
  selectMarginLarge: "0 0 0 8px",
  prefixMarginLarge: "0 8px 0 0",
  suffixMarginLarge: "0 0 0 8px"
}, X$e = (t) => {
  const {
    textColor2: e,
    primaryColor: n,
    primaryColorHover: r,
    primaryColorPressed: i,
    inputColorDisabled: s,
    textColorDisabled: a,
    borderColor: o,
    borderRadius: u,
    // item font size
    fontSizeTiny: c,
    fontSizeSmall: d,
    fontSizeMedium: l,
    // item size
    heightTiny: f,
    heightSmall: p,
    heightMedium: m
  } = t;
  return Object.assign(Object.assign({}, Y$e), { buttonColor: "#0000", buttonColorHover: "#0000", buttonColorPressed: "#0000", buttonBorder: `1px solid ${o}`, buttonBorderHover: `1px solid ${o}`, buttonBorderPressed: `1px solid ${o}`, buttonIconColor: e, buttonIconColorHover: e, buttonIconColorPressed: e, itemTextColor: e, itemTextColorHover: r, itemTextColorPressed: i, itemTextColorActive: n, itemTextColorDisabled: a, itemColor: "#0000", itemColorHover: "#0000", itemColorPressed: "#0000", itemColorActive: "#0000", itemColorActiveHover: "#0000", itemColorDisabled: s, itemBorder: "1px solid #0000", itemBorderHover: "1px solid #0000", itemBorderPressed: "1px solid #0000", itemBorderActive: `1px solid ${n}`, itemBorderDisabled: `1px solid ${o}`, itemBorderRadius: u, itemSizeSmall: f, itemSizeMedium: p, itemSizeLarge: m, itemFontSizeSmall: c, itemFontSizeMedium: d, itemFontSizeLarge: l, jumperFontSizeSmall: c, jumperFontSizeMedium: d, jumperFontSizeLarge: l, jumperTextColor: e, jumperTextColorDisabled: a });
}, K$e = {
  name: "Pagination",
  common: ct,
  peers: {
    Select: S9,
    Input: As,
    Popselect: C9
  },
  self(t) {
    const { primaryColor: e, opacity3: n } = t, r = Et(e, {
      alpha: Number(n)
    }), i = X$e(t);
    return i.itemBorderActive = `1px solid ${r}`, i.itemBorderDisabled = "1px solid #0000", i;
  }
}, I9 = K$e, Z$e = {
  padding: "8px 14px"
}, J$e = {
  name: "Tooltip",
  common: ct,
  peers: {
    Popover: rl
  },
  self(t) {
    const { borderRadius: e, boxShadow2: n, popoverColor: r, textColor2: i } = t;
    return Object.assign(Object.assign({}, Z$e), { borderRadius: e, boxShadow: n, color: r, textColor: i });
  }
}, i1 = J$e, eHe = {
  name: "Ellipsis",
  common: ct,
  peers: {
    Tooltip: i1
  }
}, k9 = eHe, tHe = {
  radioSizeSmall: "14px",
  radioSizeMedium: "16px",
  radioSizeLarge: "18px",
  labelPadding: "0 8px",
  labelFontWeight: "400"
}, nHe = {
  name: "Radio",
  common: ct,
  self(t) {
    const { borderColor: e, primaryColor: n, baseColor: r, textColorDisabled: i, inputColorDisabled: s, textColor2: a, opacityDisabled: o, borderRadius: u, fontSizeSmall: c, fontSizeMedium: d, fontSizeLarge: l, heightSmall: f, heightMedium: p, heightLarge: m, lineHeight: g } = t;
    return Object.assign(Object.assign({}, tHe), {
      labelLineHeight: g,
      buttonHeightSmall: f,
      buttonHeightMedium: p,
      buttonHeightLarge: m,
      fontSizeSmall: c,
      fontSizeMedium: d,
      fontSizeLarge: l,
      boxShadow: `inset 0 0 0 1px ${e}`,
      boxShadowActive: `inset 0 0 0 1px ${n}`,
      boxShadowFocus: `inset 0 0 0 1px ${n}, 0 0 0 2px ${Et(n, { alpha: 0.3 })}`,
      boxShadowHover: `inset 0 0 0 1px ${n}`,
      boxShadowDisabled: `inset 0 0 0 1px ${e}`,
      color: "#0000",
      colorDisabled: s,
      colorActive: "#0000",
      textColor: a,
      textColorDisabled: i,
      dotColorActive: n,
      dotColorDisabled: e,
      buttonBorderColor: e,
      buttonBorderColorActive: n,
      buttonBorderColorHover: n,
      buttonColor: "#0000",
      buttonColorActive: n,
      buttonTextColor: a,
      buttonTextColorActive: r,
      buttonTextColorHover: n,
      opacityDisabled: o,
      buttonBoxShadowFocus: `inset 0 0 0 1px ${n}, 0 0 0 2px ${Et(n, { alpha: 0.3 })}`,
      buttonBoxShadowHover: `inset 0 0 0 1px ${n}`,
      buttonBoxShadow: "inset 0 0 0 1px #0000",
      buttonBorderRadius: u
    });
  }
}, D9 = nHe, rHe = {
  padding: "4px 0",
  optionIconSizeSmall: "14px",
  optionIconSizeMedium: "16px",
  optionIconSizeLarge: "16px",
  optionIconSizeHuge: "18px",
  optionSuffixWidthSmall: "14px",
  optionSuffixWidthMedium: "14px",
  optionSuffixWidthLarge: "16px",
  optionSuffixWidthHuge: "16px",
  optionIconSuffixWidthSmall: "32px",
  optionIconSuffixWidthMedium: "32px",
  optionIconSuffixWidthLarge: "36px",
  optionIconSuffixWidthHuge: "36px",
  optionPrefixWidthSmall: "14px",
  optionPrefixWidthMedium: "14px",
  optionPrefixWidthLarge: "16px",
  optionPrefixWidthHuge: "16px",
  optionIconPrefixWidthSmall: "36px",
  optionIconPrefixWidthMedium: "36px",
  optionIconPrefixWidthLarge: "40px",
  optionIconPrefixWidthHuge: "40px"
}, iHe = (t) => {
  const { primaryColor: e, textColor2: n, dividerColor: r, hoverColor: i, popoverColor: s, invertedColor: a, borderRadius: o, fontSizeSmall: u, fontSizeMedium: c, fontSizeLarge: d, fontSizeHuge: l, heightSmall: f, heightMedium: p, heightLarge: m, heightHuge: g, textColor3: y, opacityDisabled: b } = t;
  return Object.assign(Object.assign({}, rHe), {
    optionHeightSmall: f,
    optionHeightMedium: p,
    optionHeightLarge: m,
    optionHeightHuge: g,
    borderRadius: o,
    fontSizeSmall: u,
    fontSizeMedium: c,
    fontSizeLarge: d,
    fontSizeHuge: l,
    // non-inverted
    optionTextColor: n,
    optionTextColorHover: n,
    optionTextColorActive: e,
    optionTextColorChildActive: e,
    color: s,
    dividerColor: r,
    suffixColor: n,
    prefixColor: n,
    optionColorHover: i,
    optionColorActive: Et(e, { alpha: 0.1 }),
    groupHeaderTextColor: y,
    // inverted
    optionTextColorInverted: "#BBB",
    optionTextColorHoverInverted: "#FFF",
    optionTextColorActiveInverted: "#FFF",
    optionTextColorChildActiveInverted: "#FFF",
    colorInverted: a,
    dividerColorInverted: "#BBB",
    suffixColorInverted: "#BBB",
    prefixColorInverted: "#BBB",
    optionColorHoverInverted: e,
    optionColorActiveInverted: e,
    groupHeaderTextColorInverted: "#AAA",
    optionOpacityDisabled: b
  });
}, sHe = {
  name: "Dropdown",
  common: ct,
  peers: {
    Popover: rl
  },
  self(t) {
    const { primaryColorSuppl: e, primaryColor: n, popoverColor: r } = t, i = iHe(t);
    return i.colorInverted = r, i.optionColorActive = Et(n, { alpha: 0.15 }), i.optionColorActiveInverted = e, i.optionColorHoverInverted = e, i;
  }
}, L_ = sHe, aHe = {
  thPaddingSmall: "8px",
  thPaddingMedium: "12px",
  thPaddingLarge: "12px",
  tdPaddingSmall: "8px",
  tdPaddingMedium: "12px",
  tdPaddingLarge: "12px",
  sorterSize: "15px",
  resizableContainerSize: "8px",
  resizableSize: "2px",
  filterSize: "15px",
  paginationMargin: "12px 0 0 0",
  emptyPadding: "48px 0",
  actionPadding: "8px 12px",
  actionButtonMargin: "0 8px 0 0"
}, oHe = (t) => {
  const { cardColor: e, modalColor: n, popoverColor: r, textColor2: i, textColor1: s, tableHeaderColor: a, tableColorHover: o, iconColor: u, primaryColor: c, fontWeightStrong: d, borderRadius: l, lineHeight: f, fontSizeSmall: p, fontSizeMedium: m, fontSizeLarge: g, dividerColor: y, heightSmall: b, opacityDisabled: E, tableColorStriped: v } = t;
  return Object.assign(Object.assign({}, aHe), {
    actionDividerColor: y,
    lineHeight: f,
    borderRadius: l,
    fontSizeSmall: p,
    fontSizeMedium: m,
    fontSizeLarge: g,
    borderColor: Dt(e, y),
    tdColorHover: Dt(e, o),
    tdColorStriped: Dt(e, v),
    thColor: Dt(e, a),
    thColorHover: Dt(Dt(e, a), o),
    tdColor: e,
    tdTextColor: i,
    thTextColor: s,
    thFontWeight: d,
    thButtonColorHover: o,
    thIconColor: u,
    thIconColorActive: c,
    // modal
    borderColorModal: Dt(n, y),
    tdColorHoverModal: Dt(n, o),
    tdColorStripedModal: Dt(n, v),
    thColorModal: Dt(n, a),
    thColorHoverModal: Dt(Dt(n, a), o),
    tdColorModal: n,
    // popover
    borderColorPopover: Dt(r, y),
    tdColorHoverPopover: Dt(r, o),
    tdColorStripedPopover: Dt(r, v),
    thColorPopover: Dt(r, a),
    thColorHoverPopover: Dt(Dt(r, a), o),
    tdColorPopover: r,
    boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
    boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
    // loading
    loadingColor: c,
    loadingSize: b,
    opacityLoading: E
  });
}, uHe = {
  name: "DataTable",
  common: ct,
  peers: {
    Button: Fi,
    Checkbox: rd,
    Radio: D9,
    Pagination: I9,
    Scrollbar: Bi,
    Empty: nl,
    Popover: rl,
    Ellipsis: k9,
    Dropdown: L_
  },
  self(t) {
    const e = oHe(t);
    return e.boxShadowAfter = "inset 12px 0 8px -12px rgba(0, 0, 0, .36)", e.boxShadowBefore = "inset -12px 0 8px -12px rgba(0, 0, 0, .36)", e;
  }
}, lHe = uHe, M9 = (t) => {
  const { textColorBase: e, opacity1: n, opacity2: r, opacity3: i, opacity4: s, opacity5: a } = t;
  return {
    color: e,
    opacity1Depth: n,
    opacity2Depth: r,
    opacity3Depth: i,
    opacity4Depth: s,
    opacity5Depth: a
  };
}, cHe = {
  common: O_,
  self: M9
}, dHe = cHe, fHe = {
  name: "Icon",
  common: ct,
  self: M9
}, hHe = fHe, pHe = M0("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [xs("color-transition", {
  transition: "color .3s var(--n-bezier)"
}), xs("depth", {
  color: "var(--n-color)"
}, [Kr("svg", {
  opacity: "var(--n-opacity)",
  transition: "opacity .3s var(--n-bezier)"
})]), Kr("svg", {
  height: "1em",
  width: "1em"
})]), mHe = Object.assign(Object.assign({}, Rh.props), { depth: [String, Number], size: [Number, String], color: String, component: Object }), CS = Ze({
  _n_icon__: !0,
  name: "Icon",
  inheritAttrs: !1,
  props: mHe,
  setup(t) {
    const { mergedClsPrefixRef: e, inlineThemeDisabled: n } = g9(t), r = Rh("Icon", "-icon", pHe, dHe, t, e), i = de(() => {
      const { depth: a } = t, { common: { cubicBezierEaseInOut: o }, self: u } = r.value;
      if (a !== void 0) {
        const { color: c, [`opacity${a}Depth`]: d } = u;
        return {
          "--n-bezier": o,
          "--n-color": c,
          "--n-opacity": d
        };
      }
      return {
        "--n-bezier": o,
        "--n-color": "",
        "--n-opacity": ""
      };
    }), s = n ? A9("icon", de(() => `${t.depth || "d"}`), i, t) : void 0;
    return {
      mergedClsPrefix: e,
      mergedStyle: de(() => {
        const { size: a, color: o } = t;
        return {
          fontSize: GPe(a),
          color: o
        };
      }),
      cssVars: n ? void 0 : i,
      themeClass: s == null ? void 0 : s.themeClass,
      onRender: s == null ? void 0 : s.onRender
    };
  },
  render() {
    var t;
    const { $parent: e, depth: n, mergedClsPrefix: r, component: i, onRender: s, themeClass: a } = this;
    return !((t = e == null ? void 0 : e.$options) === null || t === void 0) && t._n_icon__ && WPe("icon", "don't wrap `n-icon` inside `n-icon`"), s == null || s(), sn("i", ea(this.$attrs, {
      role: "img",
      class: [
        `${r}-icon`,
        a,
        {
          [`${r}-icon--depth`]: n,
          [`${r}-icon--color-transition`]: n !== void 0
        }
      ],
      style: [this.cssVars, this.mergedStyle]
    }), i ? sn(i) : this.$slots);
  }
}), gHe = {
  itemFontSize: "12px",
  itemHeight: "36px",
  itemWidth: "52px",
  panelActionPadding: "8px 0"
}, AHe = (t) => {
  const { popoverColor: e, textColor2: n, primaryColor: r, hoverColor: i, dividerColor: s, opacityDisabled: a, boxShadow2: o, borderRadius: u, iconColor: c, iconColorDisabled: d } = t;
  return Object.assign(Object.assign({}, gHe), {
    panelColor: e,
    panelBoxShadow: o,
    panelDividerColor: s,
    itemTextColor: n,
    itemTextColorActive: r,
    itemColorHover: i,
    itemOpacityDisabled: a,
    itemBorderRadius: u,
    borderRadius: u,
    iconColor: c,
    iconColorDisabled: d
  });
}, bHe = {
  name: "TimePicker",
  common: ct,
  peers: {
    Scrollbar: Bi,
    Button: Fi,
    Input: As
  },
  self: AHe
}, O9 = bHe, yHe = {
  itemSize: "24px",
  itemCellWidth: "38px",
  itemCellHeight: "32px",
  scrollItemWidth: "80px",
  scrollItemHeight: "40px",
  panelExtraFooterPadding: "8px 12px",
  panelActionPadding: "8px 12px",
  calendarTitlePadding: "0",
  calendarTitleHeight: "28px",
  arrowSize: "14px",
  panelHeaderPadding: "8px 12px",
  calendarDaysHeight: "32px",
  calendarTitleGridTempateColumns: "28px 28px 1fr 28px 28px",
  // type
  calendarLeftPaddingDate: "6px 12px 4px 12px",
  calendarLeftPaddingDatetime: "4px 12px",
  calendarLeftPaddingDaterange: "6px 12px 4px 12px",
  calendarLeftPaddingDatetimerange: "4px 12px",
  calendarLeftPaddingMonth: "0",
  calendarLeftPaddingYear: "0",
  calendarLeftPaddingQuarter: "0",
  calendarLeftPaddingMonthrange: "0",
  calendarLeftPaddingQuarterrange: "0",
  calendarLeftPaddingYearrange: "0",
  calendarRightPaddingDate: "6px 12px 4px 12px",
  calendarRightPaddingDatetime: "4px 12px",
  calendarRightPaddingDaterange: "6px 12px 4px 12px",
  calendarRightPaddingDatetimerange: "4px 12px",
  calendarRightPaddingMonth: "0",
  calendarRightPaddingYear: "0",
  calendarRightPaddingQuarter: "0",
  calendarRightPaddingMonthrange: "0",
  calendarRightPaddingQuarterrange: "0",
  calendarRightPaddingYearrange: "0"
}, vHe = (t) => {
  const { hoverColor: e, fontSize: n, textColor2: r, textColorDisabled: i, popoverColor: s, primaryColor: a, borderRadiusSmall: o, iconColor: u, iconColorDisabled: c, textColor1: d, dividerColor: l, boxShadow2: f, borderRadius: p, fontWeightStrong: m } = t;
  return Object.assign(Object.assign({}, yHe), {
    itemFontSize: n,
    calendarDaysFontSize: n,
    calendarTitleFontSize: n,
    itemTextColor: r,
    itemTextColorDisabled: i,
    itemTextColorActive: s,
    itemTextColorCurrent: a,
    itemColorIncluded: Et(a, { alpha: 0.1 }),
    itemColorHover: e,
    itemColorDisabled: e,
    itemColorActive: a,
    itemBorderRadius: o,
    panelColor: s,
    panelTextColor: r,
    arrowColor: u,
    calendarTitleTextColor: d,
    calendarTitleColorHover: e,
    calendarDaysTextColor: r,
    panelHeaderDividerColor: l,
    calendarDaysDividerColor: l,
    calendarDividerColor: l,
    panelActionDividerColor: l,
    panelBoxShadow: f,
    panelBorderRadius: p,
    calendarTitleFontWeight: m,
    scrollItemBorderRadius: p,
    iconColor: u,
    iconColorDisabled: c
  });
}, THe = {
  name: "DatePicker",
  common: ct,
  peers: {
    Input: As,
    Button: Fi,
    TimePicker: O9,
    Scrollbar: Bi
  },
  self(t) {
    const { popoverColor: e, hoverColor: n, primaryColor: r } = t, i = vHe(t);
    return i.itemColorDisabled = Dt(e, n), i.itemColorIncluded = Et(r, { alpha: 0.15 }), i.itemColorHover = Dt(e, n), i;
  }
}, _He = THe, EHe = {
  thPaddingBorderedSmall: "8px 12px",
  thPaddingBorderedMedium: "12px 16px",
  thPaddingBorderedLarge: "16px 24px",
  thPaddingSmall: "0",
  thPaddingMedium: "0",
  thPaddingLarge: "0",
  tdPaddingBorderedSmall: "8px 12px",
  tdPaddingBorderedMedium: "12px 16px",
  tdPaddingBorderedLarge: "16px 24px",
  tdPaddingSmall: "0 0 8px 0",
  tdPaddingMedium: "0 0 12px 0",
  tdPaddingLarge: "0 0 16px 0"
}, xHe = (t) => {
  const { tableHeaderColor: e, textColor2: n, textColor1: r, cardColor: i, modalColor: s, popoverColor: a, dividerColor: o, borderRadius: u, fontWeightStrong: c, lineHeight: d, fontSizeSmall: l, fontSizeMedium: f, fontSizeLarge: p } = t;
  return Object.assign(Object.assign({}, EHe), {
    lineHeight: d,
    fontSizeSmall: l,
    fontSizeMedium: f,
    fontSizeLarge: p,
    titleTextColor: r,
    thColor: Dt(i, e),
    thColorModal: Dt(s, e),
    thColorPopover: Dt(a, e),
    thTextColor: r,
    thFontWeight: c,
    tdTextColor: n,
    tdColor: i,
    tdColorModal: s,
    tdColorPopover: a,
    borderColor: Dt(i, o),
    borderColorModal: Dt(s, o),
    borderColorPopover: Dt(a, o),
    borderRadius: u
  });
}, wHe = {
  name: "Descriptions",
  common: ct,
  self: xHe
}, CHe = wHe, SHe = {
  titleFontSize: "18px",
  padding: "16px 28px 20px 28px",
  iconSize: "28px",
  actionSpace: "12px",
  contentMargin: "8px 0 16px 0",
  iconMargin: "0 4px 0 0",
  iconMarginIconTop: "4px 0 8px 0",
  closeSize: "22px",
  closeIconSize: "18px",
  closeMargin: "20px 26px 0 0",
  closeMarginIconTop: "10px 16px 0 0"
}, IHe = (t) => {
  const { textColor1: e, textColor2: n, modalColor: r, closeIconColor: i, closeIconColorHover: s, closeIconColorPressed: a, closeColorHover: o, closeColorPressed: u, infoColor: c, successColor: d, warningColor: l, errorColor: f, primaryColor: p, dividerColor: m, borderRadius: g, fontWeightStrong: y, lineHeight: b, fontSize: E } = t;
  return Object.assign(Object.assign({}, SHe), {
    fontSize: E,
    lineHeight: b,
    border: `1px solid ${m}`,
    titleTextColor: e,
    textColor: n,
    color: r,
    closeColorHover: o,
    closeColorPressed: u,
    closeIconColor: i,
    closeIconColorHover: s,
    closeIconColorPressed: a,
    closeBorderRadius: g,
    iconColor: p,
    iconColorInfo: c,
    iconColorSuccess: d,
    iconColorWarning: l,
    iconColorError: f,
    borderRadius: g,
    titleFontWeight: y
  });
}, kHe = {
  name: "Dialog",
  common: ct,
  peers: {
    Button: Fi
  },
  self: IHe
}, N9 = kHe, DHe = (t) => {
  const { modalColor: e, textColor2: n, boxShadow3: r } = t;
  return {
    color: e,
    textColor: n,
    boxShadow: r
  };
}, MHe = {
  name: "Modal",
  common: ct,
  peers: {
    Scrollbar: Bi,
    Dialog: N9,
    Card: x9
  },
  self: DHe
}, OHe = MHe, NHe = (t) => {
  const { textColor1: e, dividerColor: n, fontWeightStrong: r } = t;
  return {
    textColor: e,
    color: n,
    fontWeight: r
  };
}, LHe = {
  name: "Divider",
  common: ct,
  self: NHe
}, PHe = LHe, RHe = (t) => {
  const { modalColor: e, textColor1: n, textColor2: r, boxShadow3: i, lineHeight: s, fontWeightStrong: a, dividerColor: o, closeColorHover: u, closeColorPressed: c, closeIconColor: d, closeIconColorHover: l, closeIconColorPressed: f, borderRadius: p, primaryColorHover: m } = t;
  return {
    bodyPadding: "16px 24px",
    headerPadding: "16px 24px",
    footerPadding: "16px 24px",
    color: e,
    textColor: r,
    titleTextColor: n,
    titleFontSize: "18px",
    titleFontWeight: a,
    boxShadow: i,
    lineHeight: s,
    headerBorderBottom: `1px solid ${o}`,
    footerBorderTop: `1px solid ${o}`,
    closeIconColor: d,
    closeIconColorHover: l,
    closeIconColorPressed: f,
    closeSize: "22px",
    closeIconSize: "18px",
    closeColorHover: u,
    closeColorPressed: c,
    closeBorderRadius: p,
    resizableTriggerColorHover: m
  };
}, BHe = {
  name: "Drawer",
  common: ct,
  peers: {
    Scrollbar: Bi
  },
  self: RHe
}, FHe = BHe, UHe = {
  actionMargin: "0 0 0 20px",
  actionMarginRtl: "0 20px 0 0"
}, $He = {
  name: "DynamicInput",
  common: ct,
  peers: {
    Input: As,
    Button: Fi
  },
  self() {
    return UHe;
  }
}, HHe = $He, jHe = {
  gapSmall: "4px 8px",
  gapMedium: "8px 12px",
  gapLarge: "12px 16px"
}, zHe = {
  name: "Space",
  self() {
    return jHe;
  }
}, L9 = zHe, qHe = {
  name: "DynamicTags",
  common: ct,
  peers: {
    Input: As,
    Button: Fi,
    Tag: _9,
    Space: L9
  },
  self() {
    return {
      inputWidth: "64px"
    };
  }
}, VHe = qHe, WHe = {
  name: "Element",
  common: ct
}, QHe = WHe, GHe = {
  feedbackPadding: "4px 0 0 2px",
  feedbackHeightSmall: "24px",
  feedbackHeightMedium: "24px",
  feedbackHeightLarge: "26px",
  feedbackFontSizeSmall: "13px",
  feedbackFontSizeMedium: "14px",
  feedbackFontSizeLarge: "14px",
  labelFontSizeLeftSmall: "14px",
  labelFontSizeLeftMedium: "14px",
  labelFontSizeLeftLarge: "15px",
  labelFontSizeTopSmall: "13px",
  labelFontSizeTopMedium: "14px",
  labelFontSizeTopLarge: "14px",
  labelHeightSmall: "24px",
  labelHeightMedium: "26px",
  labelHeightLarge: "28px",
  labelPaddingVertical: "0 0 6px 2px",
  labelPaddingHorizontal: "0 12px 0 0",
  labelTextAlignVertical: "left",
  labelTextAlignHorizontal: "right",
  labelFontWeight: "400"
}, YHe = (t) => {
  const { heightSmall: e, heightMedium: n, heightLarge: r, textColor1: i, errorColor: s, warningColor: a, lineHeight: o, textColor3: u } = t;
  return Object.assign(Object.assign({}, GHe), { blankHeightSmall: e, blankHeightMedium: n, blankHeightLarge: r, lineHeight: o, labelTextColor: i, asteriskColor: s, feedbackTextColorError: s, feedbackTextColorWarning: a, feedbackTextColor: u });
}, XHe = {
  name: "Form",
  common: ct,
  self: YHe
}, KHe = XHe, ZHe = {
  name: "GradientText",
  common: ct,
  self(t) {
    const { primaryColor: e, successColor: n, warningColor: r, errorColor: i, infoColor: s, primaryColorSuppl: a, successColorSuppl: o, warningColorSuppl: u, errorColorSuppl: c, infoColorSuppl: d, fontWeightStrong: l } = t;
    return {
      fontWeight: l,
      rotate: "252deg",
      colorStartPrimary: e,
      colorEndPrimary: a,
      colorStartInfo: s,
      colorEndInfo: d,
      colorStartWarning: r,
      colorEndWarning: u,
      colorStartError: i,
      colorEndError: c,
      colorStartSuccess: n,
      colorEndSuccess: o
    };
  }
}, JHe = ZHe, eje = (t) => {
  const { primaryColor: e, baseColor: n } = t;
  return {
    color: e,
    iconColor: n
  };
}, tje = {
  name: "IconWrapper",
  common: ct,
  self: eje
}, nje = tje, rje = {
  closeMargin: "16px 12px",
  closeSize: "20px",
  closeIconSize: "16px",
  width: "365px",
  padding: "16px",
  titleFontSize: "16px",
  metaFontSize: "12px",
  descriptionFontSize: "12px"
}, ije = (t) => {
  const { textColor2: e, successColor: n, infoColor: r, warningColor: i, errorColor: s, popoverColor: a, closeIconColor: o, closeIconColorHover: u, closeIconColorPressed: c, closeColorHover: d, closeColorPressed: l, textColor1: f, textColor3: p, borderRadius: m, fontWeightStrong: g, boxShadow2: y, lineHeight: b, fontSize: E } = t;
  return Object.assign(Object.assign({}, rje), {
    borderRadius: m,
    lineHeight: b,
    fontSize: E,
    headerFontWeight: g,
    iconColor: e,
    iconColorSuccess: n,
    iconColorInfo: r,
    iconColorWarning: i,
    iconColorError: s,
    color: a,
    textColor: e,
    closeIconColor: o,
    closeIconColorHover: u,
    closeIconColorPressed: c,
    closeBorderRadius: m,
    closeColorHover: d,
    closeColorPressed: l,
    headerTextColor: f,
    descriptionTextColor: p,
    actionTextColor: e,
    boxShadow: y
  });
}, sje = {
  name: "Notification",
  common: ct,
  peers: {
    Scrollbar: Bi
  },
  self: ije
}, aje = sje, oje = {
  margin: "0 0 8px 0",
  padding: "10px 20px",
  maxWidth: "720px",
  minWidth: "420px",
  iconMargin: "0 10px 0 0",
  closeMargin: "0 0 0 10px",
  closeSize: "20px",
  closeIconSize: "16px",
  iconSize: "20px",
  fontSize: "14px"
}, uje = (t) => {
  const { textColor2: e, closeIconColor: n, closeIconColorHover: r, closeIconColorPressed: i, infoColor: s, successColor: a, errorColor: o, warningColor: u, popoverColor: c, boxShadow2: d, primaryColor: l, lineHeight: f, borderRadius: p, closeColorHover: m, closeColorPressed: g } = t;
  return Object.assign(Object.assign({}, oje), {
    closeBorderRadius: p,
    textColor: e,
    textColorInfo: e,
    textColorSuccess: e,
    textColorError: e,
    textColorWarning: e,
    textColorLoading: e,
    color: c,
    colorInfo: c,
    colorSuccess: c,
    colorError: c,
    colorWarning: c,
    colorLoading: c,
    boxShadow: d,
    boxShadowInfo: d,
    boxShadowSuccess: d,
    boxShadowError: d,
    boxShadowWarning: d,
    boxShadowLoading: d,
    iconColor: e,
    iconColorInfo: s,
    iconColorSuccess: a,
    iconColorWarning: u,
    iconColorError: o,
    iconColorLoading: l,
    closeColorHover: m,
    closeColorPressed: g,
    closeIconColor: n,
    closeIconColorHover: r,
    closeIconColorPressed: i,
    closeColorHoverInfo: m,
    closeColorPressedInfo: g,
    closeIconColorInfo: n,
    closeIconColorHoverInfo: r,
    closeIconColorPressedInfo: i,
    closeColorHoverSuccess: m,
    closeColorPressedSuccess: g,
    closeIconColorSuccess: n,
    closeIconColorHoverSuccess: r,
    closeIconColorPressedSuccess: i,
    closeColorHoverError: m,
    closeColorPressedError: g,
    closeIconColorError: n,
    closeIconColorHoverError: r,
    closeIconColorPressedError: i,
    closeColorHoverWarning: m,
    closeColorPressedWarning: g,
    closeIconColorWarning: n,
    closeIconColorHoverWarning: r,
    closeIconColorPressedWarning: i,
    closeColorHoverLoading: m,
    closeColorPressedLoading: g,
    closeIconColorLoading: n,
    closeIconColorHoverLoading: r,
    closeIconColorPressedLoading: i,
    loadingColor: l,
    lineHeight: f,
    borderRadius: p
  });
}, lje = {
  name: "Message",
  common: ct,
  self: uje
}, cje = lje, dje = {
  name: "ButtonGroup",
  common: ct
}, fje = dje, hje = {
  name: "InputNumber",
  common: ct,
  peers: {
    Button: Fi,
    Input: As
  },
  self(t) {
    const { textColorDisabled: e } = t;
    return {
      iconColorDisabled: e
    };
  }
}, pje = hje, mje = {
  name: "Layout",
  common: ct,
  peers: {
    Scrollbar: Bi
  },
  self(t) {
    const { textColor2: e, bodyColor: n, popoverColor: r, cardColor: i, dividerColor: s, scrollbarColor: a, scrollbarColorHover: o } = t;
    return {
      textColor: e,
      textColorInverted: e,
      color: n,
      colorEmbedded: n,
      headerColor: i,
      headerColorInverted: i,
      footerColor: i,
      footerColorInverted: i,
      headerBorderColor: s,
      headerBorderColorInverted: s,
      footerBorderColor: s,
      footerBorderColorInverted: s,
      siderBorderColor: s,
      siderBorderColorInverted: s,
      siderColor: i,
      siderColorInverted: i,
      siderToggleButtonBorder: "1px solid transparent",
      siderToggleButtonColor: r,
      siderToggleButtonIconColor: e,
      siderToggleButtonIconColorInverted: e,
      siderToggleBarColor: Dt(n, a),
      siderToggleBarColorHover: Dt(n, o),
      __invertScrollbar: "false"
    };
  }
}, gje = mje, Aje = (t) => {
  const { textColor2: e, cardColor: n, modalColor: r, popoverColor: i, dividerColor: s, borderRadius: a, fontSize: o, hoverColor: u } = t;
  return {
    textColor: e,
    color: n,
    colorHover: u,
    colorModal: r,
    colorHoverModal: Dt(r, u),
    colorPopover: i,
    colorHoverPopover: Dt(i, u),
    borderColor: s,
    borderColorModal: Dt(r, s),
    borderColorPopover: Dt(i, s),
    borderRadius: a,
    fontSize: o
  };
}, bje = {
  name: "List",
  common: ct,
  self: Aje
}, yje = bje, vje = {
  name: "LoadingBar",
  common: ct,
  self(t) {
    const { primaryColor: e } = t;
    return {
      colorError: "red",
      colorLoading: e,
      height: "2px"
    };
  }
}, Tje = vje, _je = {
  name: "Log",
  common: ct,
  peers: {
    Scrollbar: Bi,
    Code: w9
  },
  self(t) {
    const { textColor2: e, inputColor: n, fontSize: r, primaryColor: i } = t;
    return {
      loaderFontSize: r,
      loaderTextColor: e,
      loaderColor: n,
      loaderBorder: "1px solid #0000",
      loadingColor: i
    };
  }
}, Eje = _je, xje = {
  name: "Mention",
  common: ct,
  peers: {
    InternalSelectMenu: Bh,
    Input: As
  },
  self(t) {
    const { boxShadow2: e } = t;
    return {
      menuBoxShadow: e
    };
  }
}, wje = xje;
function Cje(t, e, n, r) {
  return {
    itemColorHoverInverted: "#0000",
    itemColorActiveInverted: e,
    itemColorActiveHoverInverted: e,
    itemColorActiveCollapsedInverted: e,
    itemTextColorInverted: t,
    itemTextColorHoverInverted: n,
    itemTextColorChildActiveInverted: n,
    itemTextColorChildActiveHoverInverted: n,
    itemTextColorActiveInverted: n,
    itemTextColorActiveHoverInverted: n,
    itemTextColorHorizontalInverted: t,
    itemTextColorHoverHorizontalInverted: n,
    itemTextColorChildActiveHorizontalInverted: n,
    itemTextColorChildActiveHoverHorizontalInverted: n,
    itemTextColorActiveHorizontalInverted: n,
    itemTextColorActiveHoverHorizontalInverted: n,
    itemIconColorInverted: t,
    itemIconColorHoverInverted: n,
    itemIconColorActiveInverted: n,
    itemIconColorActiveHoverInverted: n,
    itemIconColorChildActiveInverted: n,
    itemIconColorChildActiveHoverInverted: n,
    itemIconColorCollapsedInverted: t,
    itemIconColorHorizontalInverted: t,
    itemIconColorHoverHorizontalInverted: n,
    itemIconColorActiveHorizontalInverted: n,
    itemIconColorActiveHoverHorizontalInverted: n,
    itemIconColorChildActiveHorizontalInverted: n,
    itemIconColorChildActiveHoverHorizontalInverted: n,
    arrowColorInverted: t,
    arrowColorHoverInverted: n,
    arrowColorActiveInverted: n,
    arrowColorActiveHoverInverted: n,
    arrowColorChildActiveInverted: n,
    arrowColorChildActiveHoverInverted: n,
    groupTextColorInverted: r
  };
}
const Sje = (t) => {
  const { borderRadius: e, textColor3: n, primaryColor: r, textColor2: i, textColor1: s, fontSize: a, dividerColor: o, hoverColor: u, primaryColorHover: c } = t;
  return Object.assign({
    borderRadius: e,
    color: "#0000",
    groupTextColor: n,
    itemColorHover: u,
    itemColorActive: Et(r, { alpha: 0.1 }),
    itemColorActiveHover: Et(r, { alpha: 0.1 }),
    itemColorActiveCollapsed: Et(r, { alpha: 0.1 }),
    itemTextColor: i,
    itemTextColorHover: i,
    itemTextColorActive: r,
    itemTextColorActiveHover: r,
    itemTextColorChildActive: r,
    itemTextColorChildActiveHover: r,
    itemTextColorHorizontal: i,
    itemTextColorHoverHorizontal: c,
    itemTextColorActiveHorizontal: r,
    itemTextColorActiveHoverHorizontal: r,
    itemTextColorChildActiveHorizontal: r,
    itemTextColorChildActiveHoverHorizontal: r,
    itemIconColor: s,
    itemIconColorHover: s,
    itemIconColorActive: r,
    itemIconColorActiveHover: r,
    itemIconColorChildActive: r,
    itemIconColorChildActiveHover: r,
    itemIconColorCollapsed: s,
    itemIconColorHorizontal: s,
    itemIconColorHoverHorizontal: c,
    itemIconColorActiveHorizontal: r,
    itemIconColorActiveHoverHorizontal: r,
    itemIconColorChildActiveHorizontal: r,
    itemIconColorChildActiveHoverHorizontal: r,
    itemHeight: "42px",
    arrowColor: i,
    arrowColorHover: i,
    arrowColorActive: r,
    arrowColorActiveHover: r,
    arrowColorChildActive: r,
    arrowColorChildActiveHover: r,
    colorInverted: "#0000",
    borderColorHorizontal: "#0000",
    fontSize: a,
    dividerColor: o
  }, Cje("#BBB", r, "#FFF", "#AAA"));
}, Ije = {
  name: "Menu",
  common: ct,
  peers: {
    Tooltip: i1,
    Dropdown: L_
  },
  self(t) {
    const { primaryColor: e, primaryColorSuppl: n } = t, r = Sje(t);
    return r.itemColorActive = Et(e, { alpha: 0.15 }), r.itemColorActiveHover = Et(e, { alpha: 0.15 }), r.itemColorActiveCollapsed = Et(e, {
      alpha: 0.15
    }), r.itemColorActiveInverted = n, r.itemColorActiveHoverInverted = n, r.itemColorActiveCollapsedInverted = n, r;
  }
}, kje = Ije, Dje = {
  titleFontSize: "18px",
  backSize: "22px"
};
function Mje(t) {
  const { textColor1: e, textColor2: n, textColor3: r, fontSize: i, fontWeightStrong: s, primaryColorHover: a, primaryColorPressed: o } = t;
  return Object.assign(Object.assign({}, Dje), { titleFontWeight: s, fontSize: i, titleTextColor: e, backColor: n, backColorHover: a, backColorPressed: o, subtitleTextColor: r });
}
const Oje = {
  name: "PageHeader",
  common: ct,
  self: Mje
}, Nje = {
  iconSize: "22px"
}, Lje = (t) => {
  const { fontSize: e, warningColor: n } = t;
  return Object.assign(Object.assign({}, Nje), { fontSize: e, iconColor: n });
}, Pje = {
  name: "Popconfirm",
  common: ct,
  peers: {
    Button: Fi,
    Popover: rl
  },
  self: Lje
}, Rje = Pje, Bje = (t) => {
  const { infoColor: e, successColor: n, warningColor: r, errorColor: i, textColor2: s, progressRailColor: a, fontSize: o, fontWeight: u } = t;
  return {
    fontSize: o,
    fontSizeCircle: "28px",
    fontWeightCircle: u,
    railColor: a,
    railHeight: "8px",
    iconSizeCircle: "36px",
    iconSizeLine: "18px",
    iconColor: e,
    iconColorInfo: e,
    iconColorSuccess: n,
    iconColorWarning: r,
    iconColorError: i,
    textColorCircle: s,
    textColorLineInner: "rgb(255, 255, 255)",
    textColorLineOuter: s,
    fillColor: e,
    fillColorInfo: e,
    fillColorSuccess: n,
    fillColorWarning: r,
    fillColorError: i,
    lineBgProcessing: "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)"
  };
}, Fje = {
  name: "Progress",
  common: ct,
  self(t) {
    const e = Bje(t);
    return e.textColorLineInner = "rgb(0, 0, 0)", e.lineBgProcessing = "linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)", e;
  }
}, P9 = Fje, Uje = {
  name: "Rate",
  common: ct,
  self(t) {
    const { railColor: e } = t;
    return {
      itemColor: e,
      itemColorActive: "#CCAA33",
      itemSize: "20px",
      sizeSmall: "16px",
      sizeMedium: "20px",
      sizeLarge: "24px"
    };
  }
}, $je = Uje, Hje = {
  titleFontSizeSmall: "26px",
  titleFontSizeMedium: "32px",
  titleFontSizeLarge: "40px",
  titleFontSizeHuge: "48px",
  fontSizeSmall: "14px",
  fontSizeMedium: "14px",
  fontSizeLarge: "15px",
  fontSizeHuge: "16px",
  iconSizeSmall: "64px",
  iconSizeMedium: "80px",
  iconSizeLarge: "100px",
  iconSizeHuge: "125px",
  iconColor418: void 0,
  iconColor404: void 0,
  iconColor403: void 0,
  iconColor500: void 0
}, jje = (t) => {
  const { textColor2: e, textColor1: n, errorColor: r, successColor: i, infoColor: s, warningColor: a, lineHeight: o, fontWeightStrong: u } = t;
  return Object.assign(Object.assign({}, Hje), { lineHeight: o, titleFontWeight: u, titleTextColor: n, textColor: e, iconColorError: r, iconColorSuccess: i, iconColorInfo: s, iconColorWarning: a });
}, zje = {
  name: "Result",
  common: ct,
  self: jje
}, qje = zje, Vje = {
  railHeight: "4px",
  railWidthVertical: "4px",
  handleSize: "18px",
  dotHeight: "8px",
  dotWidth: "8px",
  dotBorderRadius: "4px"
}, Wje = {
  name: "Slider",
  common: ct,
  self(t) {
    const e = "0 2px 8px 0 rgba(0, 0, 0, 0.12)", { railColor: n, modalColor: r, primaryColorSuppl: i, popoverColor: s, textColor2: a, cardColor: o, borderRadius: u, fontSize: c, opacityDisabled: d } = t;
    return Object.assign(Object.assign({}, Vje), { fontSize: c, markFontSize: c, railColor: n, railColorHover: n, fillColor: i, fillColorHover: i, opacityDisabled: d, handleColor: "#FFF", dotColor: o, dotColorModal: r, dotColorPopover: s, handleBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowHover: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowActive: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", handleBoxShadowFocus: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", indicatorColor: s, indicatorBoxShadow: e, indicatorTextColor: a, indicatorBorderRadius: u, dotBorder: `2px solid ${n}`, dotBorderActive: `2px solid ${i}`, dotBoxShadow: "" });
  }
}, Qje = Wje, Gje = (t) => {
  const { opacityDisabled: e, heightTiny: n, heightSmall: r, heightMedium: i, heightLarge: s, heightHuge: a, primaryColor: o, fontSize: u } = t;
  return {
    fontSize: u,
    textColor: o,
    sizeTiny: n,
    sizeSmall: r,
    sizeMedium: i,
    sizeLarge: s,
    sizeHuge: a,
    color: o,
    opacitySpinning: e
  };
}, Yje = {
  name: "Spin",
  common: ct,
  self: Gje
}, Xje = Yje, Kje = (t) => {
  const { textColor2: e, textColor3: n, fontSize: r, fontWeight: i } = t;
  return {
    labelFontSize: r,
    labelFontWeight: i,
    valueFontWeight: i,
    valueFontSize: "24px",
    labelTextColor: n,
    valuePrefixTextColor: e,
    valueSuffixTextColor: e,
    valueTextColor: e
  };
}, Zje = {
  name: "Statistic",
  common: ct,
  self: Kje
}, Jje = Zje, eze = {
  stepHeaderFontSizeSmall: "14px",
  stepHeaderFontSizeMedium: "16px",
  indicatorIndexFontSizeSmall: "14px",
  indicatorIndexFontSizeMedium: "16px",
  indicatorSizeSmall: "22px",
  indicatorSizeMedium: "28px",
  indicatorIconSizeSmall: "14px",
  indicatorIconSizeMedium: "18px"
}, tze = (t) => {
  const { fontWeightStrong: e, baseColor: n, textColorDisabled: r, primaryColor: i, errorColor: s, textColor1: a, textColor2: o } = t;
  return Object.assign(Object.assign({}, eze), { stepHeaderFontWeight: e, indicatorTextColorProcess: n, indicatorTextColorWait: r, indicatorTextColorFinish: i, indicatorTextColorError: s, indicatorBorderColorProcess: i, indicatorBorderColorWait: r, indicatorBorderColorFinish: i, indicatorBorderColorError: s, indicatorColorProcess: i, indicatorColorWait: "#0000", indicatorColorFinish: "#0000", indicatorColorError: "#0000", splitorColorProcess: r, splitorColorWait: r, splitorColorFinish: i, splitorColorError: r, headerTextColorProcess: a, headerTextColorWait: r, headerTextColorFinish: r, headerTextColorError: s, descriptionTextColorProcess: o, descriptionTextColorWait: r, descriptionTextColorFinish: r, descriptionTextColorError: s });
}, nze = {
  name: "Steps",
  common: ct,
  self: tze
}, rze = nze, R9 = {
  buttonHeightSmall: "14px",
  buttonHeightMedium: "18px",
  buttonHeightLarge: "22px",
  buttonWidthSmall: "14px",
  buttonWidthMedium: "18px",
  buttonWidthLarge: "22px",
  buttonWidthPressedSmall: "20px",
  buttonWidthPressedMedium: "24px",
  buttonWidthPressedLarge: "28px",
  railHeightSmall: "18px",
  railHeightMedium: "22px",
  railHeightLarge: "26px",
  railWidthSmall: "32px",
  railWidthMedium: "40px",
  railWidthLarge: "48px"
}, ize = {
  name: "Switch",
  common: ct,
  self(t) {
    const { primaryColorSuppl: e, opacityDisabled: n, borderRadius: r, primaryColor: i, textColor2: s, baseColor: a } = t;
    return Object.assign(Object.assign({}, R9), { iconColor: a, textColor: s, loadingColor: e, opacityDisabled: n, railColor: "rgba(255, 255, 255, .20)", railColorActive: e, buttonBoxShadow: "0px 2px 4px 0 rgba(0, 0, 0, 0.4)", buttonColor: "#FFF", railBorderRadiusSmall: r, railBorderRadiusMedium: r, railBorderRadiusLarge: r, buttonBorderRadiusSmall: r, buttonBorderRadiusMedium: r, buttonBorderRadiusLarge: r, boxShadowFocus: `0 0 8px 0 ${Et(i, { alpha: 0.3 })}` });
  }
}, sze = ize, aze = (t) => {
  const { primaryColor: e, opacityDisabled: n, borderRadius: r, textColor3: i } = t;
  return Object.assign(Object.assign({}, R9), { iconColor: i, textColor: "white", loadingColor: e, opacityDisabled: n, railColor: "rgba(0, 0, 0, .14)", railColorActive: e, buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)", buttonColor: "#FFF", railBorderRadiusSmall: r, railBorderRadiusMedium: r, railBorderRadiusLarge: r, buttonBorderRadiusSmall: r, buttonBorderRadiusMedium: r, buttonBorderRadiusLarge: r, boxShadowFocus: `0 0 0 2px ${Et(e, { alpha: 0.2 })}` });
}, oze = {
  common: O_,
  self: aze
}, uze = oze, lze = {
  thPaddingSmall: "6px",
  thPaddingMedium: "12px",
  thPaddingLarge: "12px",
  tdPaddingSmall: "6px",
  tdPaddingMedium: "12px",
  tdPaddingLarge: "12px"
}, cze = (t) => {
  const { dividerColor: e, cardColor: n, modalColor: r, popoverColor: i, tableHeaderColor: s, tableColorStriped: a, textColor1: o, textColor2: u, borderRadius: c, fontWeightStrong: d, lineHeight: l, fontSizeSmall: f, fontSizeMedium: p, fontSizeLarge: m } = t;
  return Object.assign(Object.assign({}, lze), {
    fontSizeSmall: f,
    fontSizeMedium: p,
    fontSizeLarge: m,
    lineHeight: l,
    borderRadius: c,
    borderColor: Dt(n, e),
    borderColorModal: Dt(r, e),
    borderColorPopover: Dt(i, e),
    tdColor: n,
    tdColorModal: r,
    tdColorPopover: i,
    tdColorStriped: Dt(n, a),
    tdColorStripedModal: Dt(r, a),
    tdColorStripedPopover: Dt(i, a),
    thColor: Dt(n, s),
    thColorModal: Dt(r, s),
    thColorPopover: Dt(i, s),
    thTextColor: o,
    tdTextColor: u,
    thFontWeight: d
  });
}, dze = {
  name: "Table",
  common: ct,
  self: cze
}, fze = dze, hze = {
  tabFontSizeSmall: "14px",
  tabFontSizeMedium: "14px",
  tabFontSizeLarge: "16px",
  tabGapSmallLine: "36px",
  tabGapMediumLine: "36px",
  tabGapLargeLine: "36px",
  tabGapSmallLineVertical: "8px",
  tabGapMediumLineVertical: "8px",
  tabGapLargeLineVertical: "8px",
  tabPaddingSmallLine: "6px 0",
  tabPaddingMediumLine: "10px 0",
  tabPaddingLargeLine: "14px 0",
  tabPaddingVerticalSmallLine: "6px 12px",
  tabPaddingVerticalMediumLine: "8px 16px",
  tabPaddingVerticalLargeLine: "10px 20px",
  tabGapSmallBar: "36px",
  tabGapMediumBar: "36px",
  tabGapLargeBar: "36px",
  tabGapSmallBarVertical: "8px",
  tabGapMediumBarVertical: "8px",
  tabGapLargeBarVertical: "8px",
  tabPaddingSmallBar: "4px 0",
  tabPaddingMediumBar: "6px 0",
  tabPaddingLargeBar: "10px 0",
  tabPaddingVerticalSmallBar: "6px 12px",
  tabPaddingVerticalMediumBar: "8px 16px",
  tabPaddingVerticalLargeBar: "10px 20px",
  tabGapSmallCard: "4px",
  tabGapMediumCard: "4px",
  tabGapLargeCard: "4px",
  tabGapSmallCardVertical: "4px",
  tabGapMediumCardVertical: "4px",
  tabGapLargeCardVertical: "4px",
  tabPaddingSmallCard: "8px 16px",
  tabPaddingMediumCard: "10px 20px",
  tabPaddingLargeCard: "12px 24px",
  tabPaddingSmallSegment: "4px 0",
  tabPaddingMediumSegment: "6px 0",
  tabPaddingLargeSegment: "8px 0",
  tabPaddingVerticalLargeSegment: "0 8px",
  tabPaddingVerticalSmallCard: "8px 12px",
  tabPaddingVerticalMediumCard: "10px 16px",
  tabPaddingVerticalLargeCard: "12px 20px",
  tabPaddingVerticalSmallSegment: "0 4px",
  tabPaddingVerticalMediumSegment: "0 6px",
  tabGapSmallSegment: "0",
  tabGapMediumSegment: "0",
  tabGapLargeSegment: "0",
  tabGapSmallSegmentVertical: "0",
  tabGapMediumSegmentVertical: "0",
  tabGapLargeSegmentVertical: "0",
  panePaddingSmall: "8px 0 0 0",
  panePaddingMedium: "12px 0 0 0",
  panePaddingLarge: "16px 0 0 0",
  closeSize: "18px",
  closeIconSize: "14px"
}, pze = (t) => {
  const { textColor2: e, primaryColor: n, textColorDisabled: r, closeIconColor: i, closeIconColorHover: s, closeIconColorPressed: a, closeColorHover: o, closeColorPressed: u, tabColor: c, baseColor: d, dividerColor: l, fontWeight: f, textColor1: p, borderRadius: m, fontSize: g, fontWeightStrong: y } = t;
  return Object.assign(Object.assign({}, hze), {
    colorSegment: c,
    tabFontSizeCard: g,
    tabTextColorLine: p,
    tabTextColorActiveLine: n,
    tabTextColorHoverLine: n,
    tabTextColorDisabledLine: r,
    tabTextColorSegment: p,
    tabTextColorActiveSegment: e,
    tabTextColorHoverSegment: e,
    tabTextColorDisabledSegment: r,
    tabTextColorBar: p,
    tabTextColorActiveBar: n,
    tabTextColorHoverBar: n,
    tabTextColorDisabledBar: r,
    tabTextColorCard: p,
    tabTextColorHoverCard: p,
    tabTextColorActiveCard: n,
    tabTextColorDisabledCard: r,
    barColor: n,
    closeIconColor: i,
    closeIconColorHover: s,
    closeIconColorPressed: a,
    closeColorHover: o,
    closeColorPressed: u,
    closeBorderRadius: m,
    tabColor: c,
    tabColorSegment: d,
    tabBorderColor: l,
    tabFontWeightActive: f,
    tabFontWeight: f,
    tabBorderRadius: m,
    paneTextColor: e,
    fontWeightStrong: y
  });
}, mze = {
  name: "Tabs",
  common: ct,
  self(t) {
    const e = pze(t), { inputColor: n } = t;
    return e.colorSegment = n, e.tabColorSegment = n, e;
  }
}, gze = mze, Aze = (t) => {
  const { textColor1: e, textColor2: n, fontWeightStrong: r, fontSize: i } = t;
  return {
    fontSize: i,
    titleTextColor: e,
    textColor: n,
    titleFontWeight: r
  };
}, bze = {
  name: "Thing",
  common: ct,
  self: Aze
}, yze = bze, vze = {
  titleMarginMedium: "0 0 6px 0",
  titleMarginLarge: "-2px 0 6px 0",
  titleFontSizeMedium: "14px",
  titleFontSizeLarge: "16px",
  iconSizeMedium: "14px",
  iconSizeLarge: "14px"
}, Tze = {
  name: "Timeline",
  common: ct,
  self(t) {
    const { textColor3: e, infoColorSuppl: n, errorColorSuppl: r, successColorSuppl: i, warningColorSuppl: s, textColor1: a, textColor2: o, railColor: u, fontWeightStrong: c, fontSize: d } = t;
    return Object.assign(Object.assign({}, vze), { contentFontSize: d, titleFontWeight: c, circleBorder: `2px solid ${e}`, circleBorderInfo: `2px solid ${n}`, circleBorderError: `2px solid ${r}`, circleBorderSuccess: `2px solid ${i}`, circleBorderWarning: `2px solid ${s}`, iconColor: e, iconColorInfo: n, iconColorError: r, iconColorSuccess: i, iconColorWarning: s, titleTextColor: a, contentTextColor: o, metaTextColor: e, lineColor: u });
  }
}, _ze = Tze, Eze = {
  extraFontSizeSmall: "12px",
  extraFontSizeMedium: "12px",
  extraFontSizeLarge: "14px",
  titleFontSizeSmall: "14px",
  titleFontSizeMedium: "16px",
  titleFontSizeLarge: "16px",
  closeSize: "20px",
  closeIconSize: "16px",
  headerHeightSmall: "44px",
  headerHeightMedium: "44px",
  headerHeightLarge: "50px"
}, xze = {
  name: "Transfer",
  common: ct,
  peers: {
    Checkbox: rd,
    Scrollbar: Bi,
    Input: As,
    Empty: nl,
    Button: Fi
  },
  self(t) {
    const { fontWeight: e, fontSizeLarge: n, fontSizeMedium: r, fontSizeSmall: i, heightLarge: s, heightMedium: a, borderRadius: o, inputColor: u, tableHeaderColor: c, textColor1: d, textColorDisabled: l, textColor2: f, textColor3: p, hoverColor: m, closeColorHover: g, closeColorPressed: y, closeIconColor: b, closeIconColorHover: E, closeIconColorPressed: v, dividerColor: _ } = t;
    return Object.assign(Object.assign({}, Eze), {
      itemHeightSmall: a,
      itemHeightMedium: a,
      itemHeightLarge: s,
      fontSizeSmall: i,
      fontSizeMedium: r,
      fontSizeLarge: n,
      borderRadius: o,
      dividerColor: _,
      borderColor: "#0000",
      listColor: u,
      headerColor: c,
      titleTextColor: d,
      titleTextColorDisabled: l,
      extraTextColor: p,
      extraTextColorDisabled: l,
      itemTextColor: f,
      itemTextColorDisabled: l,
      itemColorPending: m,
      titleFontWeight: e,
      closeColorHover: g,
      closeColorPressed: y,
      closeIconColor: b,
      closeIconColorHover: E,
      closeIconColorPressed: v
    });
  }
}, wze = xze, Cze = (t) => {
  const { borderRadiusSmall: e, hoverColor: n, pressedColor: r, primaryColor: i, textColor3: s, textColor2: a, textColorDisabled: o, fontSize: u } = t;
  return {
    fontSize: u,
    lineHeight: "1.5",
    nodeHeight: "30px",
    nodeWrapperPadding: "3px 0",
    nodeBorderRadius: e,
    nodeColorHover: n,
    nodeColorPressed: r,
    nodeColorActive: Et(i, { alpha: 0.1 }),
    arrowColor: s,
    nodeTextColor: a,
    nodeTextColorDisabled: o,
    loadingColor: i,
    dropMarkColor: i
  };
}, Sze = {
  name: "Tree",
  common: ct,
  peers: {
    Checkbox: rd,
    Scrollbar: Bi,
    Empty: nl
  },
  self(t) {
    const { primaryColor: e } = t, n = Cze(t);
    return n.nodeColorActive = Et(e, { alpha: 0.15 }), n;
  }
}, B9 = Sze, Ize = {
  name: "TreeSelect",
  common: ct,
  peers: {
    Tree: B9,
    Empty: nl,
    InternalSelection: N_
  }
}, kze = Ize, Dze = {
  headerFontSize1: "30px",
  headerFontSize2: "22px",
  headerFontSize3: "18px",
  headerFontSize4: "16px",
  headerFontSize5: "16px",
  headerFontSize6: "16px",
  headerMargin1: "28px 0 20px 0",
  headerMargin2: "28px 0 20px 0",
  headerMargin3: "28px 0 20px 0",
  headerMargin4: "28px 0 18px 0",
  headerMargin5: "28px 0 18px 0",
  headerMargin6: "28px 0 18px 0",
  headerPrefixWidth1: "16px",
  headerPrefixWidth2: "16px",
  headerPrefixWidth3: "12px",
  headerPrefixWidth4: "12px",
  headerPrefixWidth5: "12px",
  headerPrefixWidth6: "12px",
  headerBarWidth1: "4px",
  headerBarWidth2: "4px",
  headerBarWidth3: "3px",
  headerBarWidth4: "3px",
  headerBarWidth5: "3px",
  headerBarWidth6: "3px",
  pMargin: "16px 0 16px 0",
  liMargin: ".25em 0 0 0",
  olPadding: "0 0 0 2em",
  ulPadding: "0 0 0 2em"
}, Mze = (t) => {
  const { primaryColor: e, textColor2: n, borderColor: r, lineHeight: i, fontSize: s, borderRadiusSmall: a, dividerColor: o, fontWeightStrong: u, textColor1: c, textColor3: d, infoColor: l, warningColor: f, errorColor: p, successColor: m, codeColor: g } = t;
  return Object.assign(Object.assign({}, Dze), { aTextColor: e, blockquoteTextColor: n, blockquotePrefixColor: r, blockquoteLineHeight: i, blockquoteFontSize: s, codeBorderRadius: a, liTextColor: n, liLineHeight: i, liFontSize: s, hrColor: o, headerFontWeight: u, headerTextColor: c, pTextColor: n, pTextColor1Depth: c, pTextColor2Depth: n, pTextColor3Depth: d, pLineHeight: i, pFontSize: s, headerBarColor: e, headerBarColorPrimary: e, headerBarColorInfo: l, headerBarColorError: p, headerBarColorWarning: f, headerBarColorSuccess: m, textColor: n, textColor1Depth: c, textColor2Depth: n, textColor3Depth: d, textColorPrimary: e, textColorInfo: l, textColorSuccess: m, textColorWarning: f, textColorError: p, codeTextColor: n, codeColor: g, codeBorder: "1px solid #0000" });
}, Oze = {
  name: "Typography",
  common: ct,
  self: Mze
}, Nze = Oze, Lze = (t) => {
  const { iconColor: e, primaryColor: n, errorColor: r, textColor2: i, successColor: s, opacityDisabled: a, actionColor: o, borderColor: u, hoverColor: c, lineHeight: d, borderRadius: l, fontSize: f } = t;
  return {
    fontSize: f,
    lineHeight: d,
    borderRadius: l,
    draggerColor: o,
    draggerBorder: `1px dashed ${u}`,
    draggerBorderHover: `1px dashed ${n}`,
    itemColorHover: c,
    itemColorHoverError: Et(r, {
      alpha: 0.06
    }),
    itemTextColor: i,
    itemTextColorError: r,
    itemTextColorSuccess: s,
    itemIconColor: e,
    itemDisabledOpacity: a,
    itemBorderImageCardError: `1px solid ${r}`,
    itemBorderImageCard: `1px solid ${u}`
  };
}, Pze = {
  name: "Upload",
  common: ct,
  peers: {
    Button: Fi,
    Progress: P9
  },
  self(t) {
    const { errorColor: e } = t, n = Lze(t);
    return n.itemColorHoverError = Et(e, {
      alpha: 0.09
    }), n;
  }
}, Rze = Pze, Bze = {
  name: "Watermark",
  common: ct,
  self(t) {
    const { fontFamily: e } = t;
    return {
      fontFamily: e
    };
  }
}, Fze = Bze, Uze = {
  name: "Row",
  common: ct
}, $ze = Uze, Hze = {
  name: "Image",
  common: ct,
  peers: {
    Tooltip: i1
  },
  self: (t) => {
    const { textColor2: e } = t;
    return {
      toolbarIconColor: e,
      toolbarColor: "rgba(0, 0, 0, .35)",
      toolbarBoxShadow: "none",
      toolbarBorderRadius: "24px"
    };
  }
}, jze = {
  extraFontSize: "12px",
  width: "440px"
}, zze = {
  name: "Transfer",
  common: ct,
  peers: {
    Checkbox: rd,
    Scrollbar: Bi,
    Input: As,
    Empty: nl,
    Button: Fi
  },
  self(t) {
    const { iconColorDisabled: e, iconColor: n, fontWeight: r, fontSizeLarge: i, fontSizeMedium: s, fontSizeSmall: a, heightLarge: o, heightMedium: u, heightSmall: c, borderRadius: d, inputColor: l, tableHeaderColor: f, textColor1: p, textColorDisabled: m, textColor2: g, hoverColor: y } = t;
    return Object.assign(Object.assign({}, jze), {
      itemHeightSmall: c,
      itemHeightMedium: u,
      itemHeightLarge: o,
      fontSizeSmall: a,
      fontSizeMedium: s,
      fontSizeLarge: i,
      borderRadius: d,
      borderColor: "#0000",
      listColor: l,
      headerColor: f,
      titleTextColor: p,
      titleTextColorDisabled: m,
      extraTextColor: g,
      filterDividerColor: "#0000",
      itemTextColor: g,
      itemTextColorDisabled: m,
      itemColorPending: y,
      titleFontWeight: r,
      iconColor: n,
      iconColorDisabled: e
    });
  }
}, qze = zze, Vze = {
  name: "Skeleton",
  common: ct,
  self(t) {
    const { heightSmall: e, heightMedium: n, heightLarge: r, borderRadius: i } = t;
    return {
      color: "rgba(255, 255, 255, 0.12)",
      colorEnd: "rgba(255, 255, 255, 0.18)",
      borderRadius: i,
      heightSmall: e,
      heightMedium: n,
      heightLarge: r
    };
  }
}, Wze = M0("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [tn("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), tn("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), tn("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), M0("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [P0({
  left: "50%",
  top: "50%",
  originalTransform: "translateX(-50%) translateY(-50%)"
})]), tn("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), tn("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), tn("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Kr("&:focus", [tn("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), xs("round", [tn("rail", "border-radius: calc(var(--n-rail-height) / 2);", [tn("button", "border-radius: calc(var(--n-button-height) / 2);")])]), dS("disabled", [dS("icon", [xs("rubber-band", [xs("pressed", [tn("rail", [tn("button", "max-width: var(--n-button-width-pressed);")])]), tn("rail", [Kr("&:active", [tn("button", "max-width: var(--n-button-width-pressed);")])]), xs("active", [xs("pressed", [tn("rail", [tn("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), tn("rail", [Kr("&:active", [tn("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), xs("active", [tn("rail", [tn("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), tn("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [tn("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [P0()]), tn("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), xs("active", [tn("rail", "background-color: var(--n-rail-color-active);")]), xs("loading", [tn("rail", `
 cursor: wait;
 `)]), xs("disabled", [tn("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]), Qze = Object.assign(Object.assign({}, Rh.props), {
  size: {
    type: String,
    default: "medium"
  },
  value: {
    type: [String, Number, Boolean],
    default: void 0
  },
  loading: Boolean,
  defaultValue: {
    type: [String, Number, Boolean],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  round: {
    type: Boolean,
    default: !0
  },
  "onUpdate:value": [Function, Array],
  onUpdateValue: [Function, Array],
  checkedValue: {
    type: [String, Number, Boolean],
    default: !0
  },
  uncheckedValue: {
    type: [String, Number, Boolean],
    default: !1
  },
  railStyle: Function,
  rubberBand: {
    type: Boolean,
    default: !0
  },
  /** @deprecated */
  onChange: [Function, Array]
});
let zd;
const Gze = Ze({
  name: "Switch",
  props: Qze,
  setup(t) {
    process.env.NODE_ENV !== "production" && If(() => {
      t.onChange && VPe("switch", "`on-change` is deprecated, please use `on-update:value` instead.");
    }), zd === void 0 && (typeof CSS < "u" ? typeof CSS.supports < "u" ? zd = CSS.supports("width", "max(1px)") : zd = !1 : zd = !0);
    const { mergedClsPrefixRef: e, inlineThemeDisabled: n } = g9(t), r = Rh("Switch", "-switch", Wze, uze, t, e), i = TRe(t), { mergedSizeRef: s, mergedDisabledRef: a } = i, o = Se(t.defaultValue), u = Ii(t, "value"), c = gRe(u, o), d = de(() => c.value === t.checkedValue), l = Se(!1), f = Se(!1), p = de(() => {
      const { railStyle: O } = t;
      if (O)
        return O({ focused: f.value, checked: d.value });
    });
    function m(O) {
      const { "onUpdate:value": T, onChange: N, onUpdateValue: H } = t, { nTriggerFormInput: $, nTriggerFormChange: j } = i;
      T && Cm(T, O), H && Cm(H, O), N && Cm(N, O), o.value = O, $(), j();
    }
    function g() {
      const { nTriggerFormFocus: O } = i;
      O();
    }
    function y() {
      const { nTriggerFormBlur: O } = i;
      O();
    }
    function b() {
      t.loading || a.value || (c.value !== t.checkedValue ? m(t.checkedValue) : m(t.uncheckedValue));
    }
    function E() {
      f.value = !0, g();
    }
    function v() {
      f.value = !1, y(), l.value = !1;
    }
    function _(O) {
      t.loading || a.value || O.key === " " && (c.value !== t.checkedValue ? m(t.checkedValue) : m(t.uncheckedValue), l.value = !1);
    }
    function D(O) {
      t.loading || a.value || O.key === " " && (O.preventDefault(), l.value = !0);
    }
    const S = de(() => {
      const { value: O } = s, { self: { opacityDisabled: T, railColor: N, railColorActive: H, buttonBoxShadow: $, buttonColor: j, boxShadowFocus: U, loadingColor: V, textColor: B, iconColor: R, [ho("buttonHeight", O)]: K, [ho("buttonWidth", O)]: Q, [ho("buttonWidthPressed", O)]: P, [ho("railHeight", O)]: I, [ho("railWidth", O)]: G, [ho("railBorderRadius", O)]: te, [ho("buttonBorderRadius", O)]: ee }, common: { cubicBezierEaseInOut: Z } } = r.value;
      let ye, he, Ee;
      return zd ? (ye = `calc((${I} - ${K}) / 2)`, he = `max(${I}, ${K})`, Ee = `max(${G}, calc(${G} + ${K} - ${I}))`) : (ye = $2((Ca(I) - Ca(K)) / 2), he = $2(Math.max(Ca(I), Ca(K))), Ee = Ca(I) > Ca(K) ? G : $2(Ca(G) + Ca(K) - Ca(I))), {
        "--n-bezier": Z,
        "--n-button-border-radius": ee,
        "--n-button-box-shadow": $,
        "--n-button-color": j,
        "--n-button-width": Q,
        "--n-button-width-pressed": P,
        "--n-button-height": K,
        "--n-height": he,
        "--n-offset": ye,
        "--n-opacity-disabled": T,
        "--n-rail-border-radius": te,
        "--n-rail-color": N,
        "--n-rail-color-active": H,
        "--n-rail-height": I,
        "--n-rail-width": G,
        "--n-width": Ee,
        "--n-box-shadow-focus": U,
        "--n-loading-color": V,
        "--n-text-color": B,
        "--n-icon-color": R
      };
    }), M = n ? A9("switch", de(() => s.value[0]), S, t) : void 0;
    return {
      handleClick: b,
      handleBlur: v,
      handleFocus: E,
      handleKeyup: _,
      handleKeydown: D,
      mergedRailStyle: p,
      pressed: l,
      mergedClsPrefix: e,
      mergedValue: c,
      checked: d,
      mergedDisabled: a,
      cssVars: n ? void 0 : S,
      themeClass: M == null ? void 0 : M.themeClass,
      onRender: M == null ? void 0 : M.onRender
    };
  },
  render() {
    const { mergedClsPrefix: t, mergedDisabled: e, checked: n, mergedRailStyle: r, onRender: i, $slots: s } = this;
    i == null || i();
    const { checked: a, unchecked: o, icon: u, "checked-icon": c, "unchecked-icon": d } = s, l = !(j2(u) && j2(c) && j2(d));
    return sn(
      "div",
      { role: "switch", "aria-checked": n, class: [
        `${t}-switch`,
        this.themeClass,
        l && `${t}-switch--icon`,
        n && `${t}-switch--active`,
        e && `${t}-switch--disabled`,
        this.round && `${t}-switch--round`,
        this.loading && `${t}-switch--loading`,
        this.pressed && `${t}-switch--pressed`,
        this.rubberBand && `${t}-switch--rubber-band`
      ], tabindex: this.mergedDisabled ? void 0 : 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
      sn(
        "div",
        { class: `${t}-switch__rail`, "aria-hidden": "true", style: r },
        ru(a, (f) => ru(o, (p) => f || p ? sn(
          "div",
          { "aria-hidden": !0, class: `${t}-switch__children-placeholder` },
          sn(
            "div",
            { class: `${t}-switch__rail-placeholder` },
            sn("div", { class: `${t}-switch__button-placeholder` }),
            f
          ),
          sn(
            "div",
            { class: `${t}-switch__rail-placeholder` },
            sn("div", { class: `${t}-switch__button-placeholder` }),
            p
          )
        ) : null)),
        sn(
          "div",
          { class: `${t}-switch__button` },
          ru(u, (f) => ru(c, (p) => ru(d, (m) => sn(b9, null, {
            default: () => this.loading ? sn(TUe, { key: "loading", clsPrefix: t, strokeWidth: 20 }) : this.checked && (p || f) ? sn("div", { class: `${t}-switch__button-icon`, key: p ? "checked-icon" : "icon" }, p || f) : !this.checked && (m || f) ? sn("div", { class: `${t}-switch__button-icon`, key: m ? "unchecked-icon" : "icon" }, m || f) : null
          })))),
          ru(a, (f) => f && sn("div", { key: "checked", class: `${t}-switch__checked` }, f)),
          ru(o, (f) => f && sn("div", { key: "unchecked", class: `${t}-switch__unchecked` }, f))
        )
      )
    );
  }
}), Yze = () => ({}), Xze = {
  name: "Equation",
  common: ct,
  self: Yze
}, Kze = Xze, Zze = {
  name: "dark",
  common: ct,
  Alert: QUe,
  Anchor: KUe,
  AutoComplete: n$e,
  Avatar: E9,
  AvatarGroup: o$e,
  BackTop: c$e,
  Badge: f$e,
  Breadcrumb: g$e,
  Button: Fi,
  ButtonGroup: fje,
  Calendar: E$e,
  Card: x9,
  Carousel: O$e,
  Cascader: F$e,
  Checkbox: rd,
  Code: w9,
  Collapse: j$e,
  CollapseTransition: V$e,
  ColorPicker: C$e,
  DataTable: lHe,
  DatePicker: _He,
  Descriptions: CHe,
  Dialog: N9,
  Divider: PHe,
  Drawer: FHe,
  Dropdown: L_,
  DynamicInput: HHe,
  DynamicTags: VHe,
  Element: QHe,
  Empty: nl,
  Ellipsis: k9,
  Equation: Kze,
  Form: KHe,
  GradientText: JHe,
  Icon: hHe,
  IconWrapper: nje,
  Image: Hze,
  Input: As,
  InputNumber: pje,
  LegacyTransfer: qze,
  Layout: gje,
  List: yje,
  LoadingBar: Tje,
  Log: Eje,
  Menu: kje,
  Mention: wje,
  Message: cje,
  Modal: OHe,
  Notification: aje,
  PageHeader: Oje,
  Pagination: I9,
  Popconfirm: Rje,
  Popover: rl,
  Popselect: C9,
  Progress: P9,
  Radio: D9,
  Rate: $je,
  Result: qje,
  Row: $ze,
  Scrollbar: Bi,
  Select: S9,
  Skeleton: Vze,
  Slider: Qje,
  Space: L9,
  Spin: Xje,
  Statistic: Jje,
  Steps: rze,
  Switch: sze,
  Table: fze,
  Tabs: gze,
  Tag: _9,
  Thing: yze,
  TimePicker: O9,
  Timeline: _ze,
  Tooltip: i1,
  Transfer: wze,
  Tree: B9,
  TreeSelect: kze,
  Typography: Nze,
  Upload: Rze,
  Watermark: Fze
};
var SS;
const F9 = typeof window < "u", Jze = (t) => typeof t == "function", eqe = (t) => typeof t == "string", tqe = () => {
};
F9 && (SS = window == null ? void 0 : window.navigator) != null && SS.userAgent && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function uh(t) {
  return typeof t == "function" ? t() : ke(t);
}
function nqe(t, e) {
  function n(...r) {
    return new Promise((i, s) => {
      Promise.resolve(t(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(s);
    });
  }
  return n;
}
const U9 = (t) => t();
function rqe(t = U9) {
  const e = Se(!0);
  function n() {
    e.value = !1;
  }
  function r() {
    e.value = !0;
  }
  const i = (...s) => {
    e.value && t(...s);
  };
  return { isActive: B0(e), pause: n, resume: r, eventFilter: i };
}
function iqe(t) {
  return t;
}
function $9(t) {
  return Qy() ? (Gy(t), !0) : !1;
}
function sqe(t) {
  return typeof t == "function" ? de(t) : Se(t);
}
function H9(t, e = !0) {
  la() ? Tr(t) : e ? t() : ca(t);
}
function aqe(t = !1, e = {}) {
  const {
    truthyValue: n = !0,
    falsyValue: r = !1
  } = e, i = F0(t), s = Se(t);
  function a(o) {
    if (arguments.length)
      return s.value = o, s.value;
    {
      const u = uh(n);
      return s.value = s.value === u ? uh(r) : u, s.value;
    }
  }
  return i ? a : [s, a];
}
var IS = Object.getOwnPropertySymbols, oqe = Object.prototype.hasOwnProperty, uqe = Object.prototype.propertyIsEnumerable, lqe = (t, e) => {
  var n = {};
  for (var r in t)
    oqe.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && IS)
    for (var r of IS(t))
      e.indexOf(r) < 0 && uqe.call(t, r) && (n[r] = t[r]);
  return n;
};
function cqe(t, e, n = {}) {
  const r = n, {
    eventFilter: i = U9
  } = r, s = lqe(r, [
    "eventFilter"
  ]);
  return Ct(t, nqe(i, e), s);
}
var dqe = Object.defineProperty, fqe = Object.defineProperties, hqe = Object.getOwnPropertyDescriptors, R0 = Object.getOwnPropertySymbols, j9 = Object.prototype.hasOwnProperty, z9 = Object.prototype.propertyIsEnumerable, kS = (t, e, n) => e in t ? dqe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, pqe = (t, e) => {
  for (var n in e || (e = {}))
    j9.call(e, n) && kS(t, n, e[n]);
  if (R0)
    for (var n of R0(e))
      z9.call(e, n) && kS(t, n, e[n]);
  return t;
}, mqe = (t, e) => fqe(t, hqe(e)), gqe = (t, e) => {
  var n = {};
  for (var r in t)
    j9.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && R0)
    for (var r of R0(t))
      e.indexOf(r) < 0 && z9.call(t, r) && (n[r] = t[r]);
  return n;
};
function Aqe(t, e, n = {}) {
  const r = n, {
    eventFilter: i
  } = r, s = gqe(r, [
    "eventFilter"
  ]), { eventFilter: a, pause: o, resume: u, isActive: c } = rqe(i);
  return { stop: cqe(t, e, mqe(pqe({}, s), {
    eventFilter: a
  })), pause: o, resume: u, isActive: c };
}
function bqe(t) {
  var e;
  const n = uh(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const kc = F9 ? window : void 0;
function DS(...t) {
  let e, n, r, i;
  if (eqe(t[0]) || Array.isArray(t[0]) ? ([n, r, i] = t, e = kc) : [e, n, r, i] = t, !e)
    return tqe;
  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
  const s = [], a = () => {
    s.forEach((d) => d()), s.length = 0;
  }, o = (d, l, f, p) => (d.addEventListener(l, f, p), () => d.removeEventListener(l, f, p)), u = Ct(() => [bqe(e), uh(i)], ([d, l]) => {
    a(), d && s.push(...n.flatMap((f) => r.map((p) => o(d, f, p, l))));
  }, { immediate: !0, flush: "post" }), c = () => {
    u(), a();
  };
  return $9(c), c;
}
function yqe(t, e = !1) {
  const n = Se(), r = () => n.value = !!t();
  return r(), H9(r, e), n;
}
function vqe(t, e = {}) {
  const { window: n = kc } = e, r = yqe(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let i;
  const s = Se(!1), a = () => {
    i && ("removeEventListener" in i ? i.removeEventListener("change", o) : i.removeListener(o));
  }, o = () => {
    r.value && (a(), i = n.matchMedia(sqe(t).value), s.value = i.matches, "addEventListener" in i ? i.addEventListener("change", o) : i.addListener(o));
  };
  return If(o), $9(() => a()), s;
}
const jy = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, zy = "__vueuse_ssr_handlers__";
jy[zy] = jy[zy] || {};
const Tqe = jy[zy];
function q9(t, e) {
  return Tqe[t] || e;
}
function _qe(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
var Eqe = Object.defineProperty, MS = Object.getOwnPropertySymbols, xqe = Object.prototype.hasOwnProperty, wqe = Object.prototype.propertyIsEnumerable, OS = (t, e, n) => e in t ? Eqe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, NS = (t, e) => {
  for (var n in e || (e = {}))
    xqe.call(e, n) && OS(t, n, e[n]);
  if (MS)
    for (var n of MS(e))
      wqe.call(e, n) && OS(t, n, e[n]);
  return t;
};
const Cqe = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
}, LS = "vueuse-storage";
function Sqe(t, e, n, r = {}) {
  var i;
  const {
    flush: s = "pre",
    deep: a = !0,
    listenToStorageChanges: o = !0,
    writeDefaults: u = !0,
    mergeDefaults: c = !1,
    shallow: d,
    window: l = kc,
    eventFilter: f,
    onError: p = (O) => {
      console.error(O);
    }
  } = r, m = (d ? ch : Se)(e);
  if (!n)
    try {
      n = q9("getDefaultStorage", () => {
        var O;
        return (O = kc) == null ? void 0 : O.localStorage;
      })();
    } catch (O) {
      p(O);
    }
  if (!n)
    return m;
  const g = uh(e), y = _qe(g), b = (i = r.serializer) != null ? i : Cqe[y], { pause: E, resume: v } = Aqe(m, () => _(m.value), { flush: s, deep: a, eventFilter: f });
  return l && o && (DS(l, "storage", M), DS(l, LS, S)), M(), m;
  function _(O) {
    try {
      if (O == null)
        n.removeItem(t);
      else {
        const T = b.write(O), N = n.getItem(t);
        N !== T && (n.setItem(t, T), l && l.dispatchEvent(new CustomEvent(LS, {
          detail: {
            key: t,
            oldValue: N,
            newValue: T,
            storageArea: n
          }
        })));
      }
    } catch (T) {
      p(T);
    }
  }
  function D(O) {
    const T = O ? O.newValue : n.getItem(t);
    if (T == null)
      return u && g !== null && n.setItem(t, b.write(g)), g;
    if (!O && c) {
      const N = b.read(T);
      return Jze(c) ? c(N, g) : y === "object" && !Array.isArray(N) ? NS(NS({}, g), N) : N;
    } else
      return typeof T != "string" ? T : b.read(T);
  }
  function S(O) {
    M(O.detail);
  }
  function M(O) {
    if (!(O && O.storageArea !== n)) {
      if (O && O.key == null) {
        m.value = g;
        return;
      }
      if (!(O && O.key !== t)) {
        E();
        try {
          m.value = D(O);
        } catch (T) {
          p(T);
        } finally {
          O ? ca(v) : v();
        }
      }
    }
  }
}
function V9(t) {
  return vqe("(prefers-color-scheme: dark)", t);
}
var Iqe = Object.defineProperty, PS = Object.getOwnPropertySymbols, kqe = Object.prototype.hasOwnProperty, Dqe = Object.prototype.propertyIsEnumerable, RS = (t, e, n) => e in t ? Iqe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Mqe = (t, e) => {
  for (var n in e || (e = {}))
    kqe.call(e, n) && RS(t, n, e[n]);
  if (PS)
    for (var n of PS(e))
      Dqe.call(e, n) && RS(t, n, e[n]);
  return t;
};
function Oqe(t = {}) {
  const {
    selector: e = "html",
    attribute: n = "class",
    initialValue: r = "auto",
    window: i = kc,
    storage: s,
    storageKey: a = "vueuse-color-scheme",
    listenToStorageChanges: o = !0,
    storageRef: u,
    emitAuto: c
  } = t, d = Mqe({
    auto: "",
    light: "light",
    dark: "dark"
  }, t.modes || {}), l = V9({ window: i }), f = de(() => l.value ? "dark" : "light"), p = u || (a == null ? Se(r) : Sqe(a, r, s, { window: i, listenToStorageChanges: o })), m = de({
    get() {
      return p.value === "auto" && !c ? f.value : p.value;
    },
    set(E) {
      p.value = E;
    }
  }), g = q9("updateHTMLAttrs", (E, v, _) => {
    const D = i == null ? void 0 : i.document.querySelector(E);
    if (D)
      if (v === "class") {
        const S = _.split(/\s/g);
        Object.values(d).flatMap((M) => (M || "").split(/\s/g)).filter(Boolean).forEach((M) => {
          S.includes(M) ? D.classList.add(M) : D.classList.remove(M);
        });
      } else
        D.setAttribute(v, _);
  });
  function y(E) {
    var v;
    const _ = E === "auto" ? f.value : E;
    g(e, n, (v = d[_]) != null ? v : _);
  }
  function b(E) {
    t.onChanged ? t.onChanged(E, y) : y(E);
  }
  return Ct(m, b, { flush: "post", immediate: !0 }), c && Ct(f, () => b(m.value), { flush: "post" }), H9(() => b(m.value)), m;
}
var Nqe = Object.defineProperty, Lqe = Object.defineProperties, Pqe = Object.getOwnPropertyDescriptors, BS = Object.getOwnPropertySymbols, Rqe = Object.prototype.hasOwnProperty, Bqe = Object.prototype.propertyIsEnumerable, FS = (t, e, n) => e in t ? Nqe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Fqe = (t, e) => {
  for (var n in e || (e = {}))
    Rqe.call(e, n) && FS(t, n, e[n]);
  if (BS)
    for (var n of BS(e))
      Bqe.call(e, n) && FS(t, n, e[n]);
  return t;
}, Uqe = (t, e) => Lqe(t, Pqe(e));
function $qe(t = {}) {
  const {
    valueDark: e = "dark",
    valueLight: n = "",
    window: r = kc
  } = t, i = Oqe(Uqe(Fqe({}, t), {
    onChanged: (a, o) => {
      var u;
      t.onChanged ? (u = t.onChanged) == null || u.call(t, a === "dark") : o(a);
    },
    modes: {
      dark: e,
      light: n
    }
  })), s = V9({ window: r });
  return de({
    get() {
      return i.value === "dark";
    },
    set(a) {
      a === s.value ? i.value = "auto" : i.value = a ? "dark" : "light";
    }
  });
}
var US;
(function(t) {
  t.UP = "UP", t.RIGHT = "RIGHT", t.DOWN = "DOWN", t.LEFT = "LEFT", t.NONE = "NONE";
})(US || (US = {}));
var Hqe = Object.defineProperty, $S = Object.getOwnPropertySymbols, jqe = Object.prototype.hasOwnProperty, zqe = Object.prototype.propertyIsEnumerable, HS = (t, e, n) => e in t ? Hqe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, qqe = (t, e) => {
  for (var n in e || (e = {}))
    jqe.call(e, n) && HS(t, n, e[n]);
  if ($S)
    for (var n of $S(e))
      zqe.call(e, n) && HS(t, n, e[n]);
  return t;
};
const Vqe = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
qqe({
  linear: iqe
}, Vqe);
const Nu = $qe();
aqe(Nu);
de(() => Nu.value ? Zze : null);
const Wqe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24"
}, Qqe = /* @__PURE__ */ W(
  "path",
  {
    d: "M6.76 4.84l-1.8-1.79l-1.41 1.41l1.79 1.79zM1 10.5h3v2H1zM11 .55h2V3.5h-2zm8.04 2.495l1.408 1.407l-1.79 1.79l-1.407-1.408zm-1.8 15.115l1.79 1.8l1.41-1.41l-1.8-1.79zM20 10.5h3v2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6s6-2.69 6-6s-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4s4 1.79 4 4s-1.79 4-4 4zm-1 4h2v2.95h-2zm-7.45-.96l1.41 1.41l1.79-1.8l-1.41-1.41z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), Gqe = [Qqe], Yqe = Ze({
  name: "WbSunnyOutlined",
  render: function(t, e) {
    return X(), se("svg", Wqe, Gqe);
  }
}), Xqe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24"
}, Kqe = /* @__PURE__ */ W(
  "path",
  {
    d: "M9.37 5.51A7.35 7.35 0 0 0 9.1 7.5c0 4.08 3.32 7.4 7.4 7.4c.68 0 1.35-.09 1.99-.27A7.014 7.014 0 0 1 12 19c-3.86 0-7-3.14-7-7c0-2.93 1.81-5.45 4.37-6.49zM12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4 2.26a5.403 5.403 0 0 1-3.14-9.8c-.44-.06-.9-.1-1.36-.1z",
    fill: "currentColor"
  },
  null,
  -1
  /* HOISTED */
), Zqe = [Kqe], Jqe = Ze({
  name: "DarkModeOutlined",
  render: function(t, e) {
    return X(), se("svg", Xqe, Zqe);
  }
}), eVe = /* @__PURE__ */ Ze({
  __name: "switch",
  props: {
    round: { type: Boolean, default: !1 },
    darkBackground: { default: "linear-gradient(135deg,#42e695,#3bb2b8)" },
    lightBackground: { default: "" }
  },
  setup(t) {
    const e = t, n = ({ checked: r }) => ({
      background: r ? e.darkBackground : e.lightBackground
    });
    return (r, i) => (X(), gt(ke(Gze), {
      round: r.round,
      "rail-style": n,
      value: ke(Nu),
      "onUpdate:value": i[0] || (i[0] = (s) => F0(Nu) ? Nu.value = s : null)
    }, {
      "checked-icon": Zt(() => [
        et(ke(CS), null, {
          default: Zt(() => [
            Jr(r.$slots, "dark", {}, () => [
              et(ke(Jqe))
            ])
          ]),
          _: 3
        })
      ]),
      "unchecked-icon": Zt(() => [
        et(ke(CS), null, {
          default: Zt(() => [
            Jr(r.$slots, "light", {}, () => [
              et(ke(Yqe))
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["round", "value"]));
  }
}), tVe = ["width", "height"], nVe = {
  __name: "StickerSvg",
  props: {
    width: {
      type: [Number, String],
      default: 22
    },
    height: {
      type: [Number, String],
      default: 22
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      viewBox: "0 0 512 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, r[0] || (r[0] = [
      W("path", { d: "M480 336V160C479.961 126.064 466.463 93.5296 442.467 69.5334C418.47 45.5371 385.936 32.039 352 32H160C126.064 32.039 93.5296 45.5371 69.5334 69.5334C45.5371 93.5296 32.039 126.064 32 160V352C32.039 385.936 45.5371 418.47 69.5334 442.467C93.5296 466.463 126.064 479.961 160 480H320C323.919 480 327.703 478.564 330.634 475.962L474.634 347.962C477.371 345.395 479.105 341.938 479.528 338.21L479.566 338.026C479.756 337.361 479.901 336.684 480 336ZM336 428.07V392C336.014 380.971 340.401 370.398 348.199 362.599C355.998 354.801 366.571 350.414 377.6 350.4H422.304L336 428.07ZM64 352V160C64.028 134.548 74.1512 110.146 92.1486 92.1486C110.146 74.1512 134.548 64.028 160 64H352C377.452 64.028 401.854 74.1512 419.851 92.1486C437.849 110.146 447.972 134.548 448 160V318.4H377.6C358.087 318.422 339.379 326.183 325.581 339.981C311.783 353.779 304.022 372.487 304 392V448H160C134.548 447.972 110.146 437.849 92.1486 419.851C74.1512 401.854 64.028 377.452 64 352Z" }, null, -1),
      W("path", { d: "M208 176V168C208 157.391 203.786 147.217 196.284 139.716C188.783 132.214 178.609 128 168 128C157.391 128 147.217 132.214 139.716 139.716C132.214 147.217 128 157.391 128 168V176C128 180.243 129.686 184.313 132.686 187.314C135.687 190.314 139.757 192 144 192C148.243 192 152.313 190.314 155.314 187.314C158.314 184.313 160 180.243 160 176V168C160 165.878 160.843 163.843 162.343 162.343C163.843 160.843 165.878 160 168 160C170.122 160 172.157 160.843 173.657 162.343C175.157 163.843 176 165.878 176 168V176C176 180.243 177.686 184.313 180.686 187.314C183.687 190.314 187.757 192 192 192C196.243 192 200.313 190.314 203.314 187.314C206.314 184.313 208 180.243 208 176Z" }, null, -1),
      W("path", { d: "M320 192C324.243 192 328.313 190.314 331.314 187.314C334.314 184.313 336 180.243 336 176V168C336 165.878 336.843 163.843 338.343 162.343C339.843 160.843 341.878 160 344 160C346.122 160 348.157 160.843 349.657 162.343C351.157 163.843 352 165.878 352 168V176C352 180.243 353.686 184.313 356.686 187.314C359.687 190.314 363.757 192 368 192C372.243 192 376.313 190.314 379.314 187.314C382.314 184.313 384 180.243 384 176V168C384 157.391 379.786 147.217 372.284 139.716C364.783 132.214 354.609 128 344 128C333.391 128 323.217 132.214 315.716 139.716C308.214 147.217 304 157.391 304 168V176C304 180.243 305.686 184.313 308.686 187.314C311.687 190.314 315.757 192 320 192Z" }, null, -1),
      W("path", { d: "M328 264V240C328 235.757 326.314 231.687 323.314 228.686C320.313 225.686 316.243 224 312 224H200C195.757 224 191.687 225.686 188.686 228.686C185.686 231.687 184 235.757 184 240V264C184 283.096 191.586 301.409 205.088 314.912C218.591 328.414 236.904 336 256 336C275.096 336 293.409 328.414 306.912 314.912C320.414 301.409 328 283.096 328 264ZM216 264V256H296V264C296 274.609 291.786 284.783 284.284 292.284C276.783 299.786 266.609 304 256 304C245.391 304 235.217 299.786 227.716 292.284C220.214 284.783 216 274.609 216 264Z" }, null, -1)
    ]), 8, tVe));
  }
}, rVe = ["width", "height"], iVe = {
  __name: "FileSvg",
  props: {
    width: {
      type: [Number, String],
      default: 20
    },
    height: {
      type: [Number, String],
      default: 20
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      viewBox: "0 0 512 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, r[0] || (r[0] = [
      W("g", { "clip-path": "url(#clip0_4129_855)" }, [
        W("path", {
          d: "M87.6177 316.621L87.6236 316.615L352.802 48.4514C352.803 48.4503 352.804 48.4493 352.805 48.4482C374.902 26.3552 413.467 26.3563 435.561 48.4514L436.622 47.3907L435.561 48.4514C458.376 71.2656 458.376 108.383 435.561 131.197L435.555 131.203L180.985 388.774C180.984 388.775 180.983 388.776 180.982 388.777C173.07 396.686 159.194 396.685 151.282 388.774C143.091 380.584 143.091 367.247 151.282 359.055L151.288 359.049L395.235 112.102C395.236 112.101 395.237 112.1 395.238 112.099C398.132 109.202 399.469 104.729 399.469 100.434C399.469 96.1361 398.131 91.6612 395.235 88.7642L394.174 89.8248L395.235 88.7641C388.788 82.3173 378.343 82.3173 371.896 88.7641L371.89 88.7706L127.944 335.718C127.943 335.719 127.942 335.721 127.94 335.722C106.874 356.793 106.875 391.044 127.944 412.112C148.37 432.538 183.929 432.508 204.324 412.112L204.33 412.106L458.9 154.536C458.901 154.535 458.902 154.534 458.903 154.533C494.311 119.121 494.31 60.5257 458.9 25.1141L457.839 26.1747L458.9 25.1141C441.6 7.81479 418.608 -1.50024 394.175 -1.50024C369.742 -1.50024 346.747 7.81473 329.463 25.1135L329.457 25.119L64.2793 293.284C13.9626 343.601 13.9625 425.447 64.2783 475.762C114.595 526.079 196.455 526.079 246.772 475.762L436.683 285.852C443.129 279.406 443.129 268.961 436.683 262.514C430.236 256.067 419.791 256.067 413.344 262.514L223.435 452.424C223.435 452.424 223.434 452.424 223.434 452.424C187.155 488.674 123.897 488.674 87.6177 452.424C50.1805 414.987 50.1805 354.059 87.6177 316.621Z",
          "stroke-width": "3"
        })
      ], -1)
    ]), 8, rVe));
  }
}, sVe = ["width", "height"], aVe = {
  __name: "AddSvg",
  props: {
    width: {
      type: [Number, String],
      default: 24
    },
    height: {
      type: [Number, String],
      default: 24
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      "enable-background": "new 0 0 512 512",
      viewBox: "0 0 512 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, r[0] || (r[0] = [
      W("g", null, [
        W("g", null, [
          W("path", { d: "m256 439.98c-13.81 0-25-11.19-25-25v-317.96c0-13.81 11.19-25 25-25s25 11.19 25 25v317.96c0 13.81-11.19 25-25 25z" })
        ]),
        W("g", null, [
          W("path", { d: "m414.98 281h-317.96c-13.81 0-25-11.19-25-25s11.19-25 25-25h317.96c13.81 0 25 11.19 25 25s-11.19 25-25 25z" })
        ])
      ], -1)
    ]), 8, sVe));
  }
}, oVe = ["width", "height"], uVe = {
  __name: "LocationSvg",
  props: {
    width: {
      type: [Number, String],
      default: 24
    },
    height: {
      type: [Number, String],
      default: 24
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      viewBox: "0 0 512 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, r[0] || (r[0] = [
      W("path", { d: "M255.999 0C153.754 0 70.572 83.182 70.572 185.426C70.572 312.314 236.511 498.593 243.576 506.461C250.212 513.852 261.798 513.839 268.422 506.461C275.487 498.593 441.426 312.314 441.426 185.426C441.424 83.182 358.243 0 255.999 0ZM255.999 469.729C200.152 403.391 103.964 272.512 103.964 185.428C103.964 101.594 172.166 33.392 255.999 33.392C339.832 33.392 408.034 101.594 408.034 185.427C408.033 272.515 311.86 403.37 255.999 469.729Z" }, null, -1),
      W("path", { d: "M255.999 92.1338C204.557 92.1338 162.707 133.985 162.707 185.427C162.707 236.869 204.558 278.72 255.999 278.72C307.44 278.72 349.29 236.869 349.29 185.427C349.29 133.985 307.44 92.1338 255.999 92.1338ZM255.999 245.328C222.969 245.328 196.099 218.457 196.099 185.427C196.099 152.397 222.97 125.526 255.999 125.526C289.028 125.526 315.899 152.397 315.899 185.427C315.899 218.457 289.028 245.328 255.999 245.328Z" }, null, -1)
    ]), 8, oVe));
  }
}, lVe = ["width", "height"], cVe = {
  __name: "RecordSvg",
  props: {
    width: {
      type: [Number, String],
      default: 24
    },
    height: {
      type: [Number, String],
      default: 24
    }
  },
  setup(t) {
    const e = t;
    return (n, r) => (X(), se("svg", {
      width: e.width,
      height: e.height,
      viewBox: "0 0 512 512",
      xmlns: "http://www.w3.org/2000/svg"
    }, r[0] || (r[0] = [
      W("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M223.999 48C188.653 48 159.999 76.6538 159.999 112V192V272C159.999 307.346 188.653 336 223.999 336H255.999H287.999C323.345 336 351.999 307.346 351.999 272V192V112C351.999 76.6538 323.345 48 287.999 48H255.999H223.999ZM191.999 112C191.999 94.3272 206.326 80 223.999 80H255.999H287.999C305.672 80 319.999 94.3272 319.999 112V192V272C319.999 289.673 305.672 304 287.999 304H255.999H223.999C206.326 304 191.999 289.673 191.999 272V192V112ZM127.999 224C127.999 215.163 120.836 208 111.999 208C103.162 208 95.999 215.163 95.999 224V272C95.999 342.693 153.306 400 223.999 400H239.999V464H191.999C183.162 464 175.999 471.163 175.999 480C175.999 488.837 183.162 496 191.999 496H255.999H319.999C328.836 496 335.999 488.837 335.999 480C335.999 471.163 328.836 464 319.999 464H271.999V400H287.999C358.692 400 415.999 342.693 415.999 272V224C415.999 215.163 408.836 208 399.999 208C391.162 208 383.999 215.163 383.999 224V272C383.999 325.019 341.018 368 287.999 368H255.999H223.999C170.98 368 127.999 325.019 127.999 272V224Z"
      }, null, -1)
    ]), 8, lVe));
  }
}, dVe = { class: "mb-1 text-xl font-medium text-gray-700 dark:text-gray-300" }, fVe = { class: "text-gray-500 dark:text-gray-400" }, hVe = { class: "mt-2 flex items-center justify-center gap-2" }, pVe = /* @__PURE__ */ Ze({
  __name: "FileSizeLimitModal",
  props: {
    fileSizeLimit: {}
  },
  setup(t) {
    const e = t, n = $n();
    function r(s) {
      return s >= 1e6 ? `${Math.round(s / 1e6)} MB` : s >= 1e3 ? `${Math.round(s / 1e3)} KB` : `${s} B`;
    }
    const i = de(() => r(e.fileSizeLimit));
    return (s, a) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[200px] max-w-full rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", dVe, _e(s.$t("fileSizeLimitTitle", "File too large")), 1),
        W("div", fVe, _e(s.$t("fileSizeLimitMessage", [i.value])), 1),
        W("div", hVe, [
          W("button", {
            class: "h-10 w-[100px] grow rounded-lg border border-gray-200 text-base dark:border-stone-400 dark:text-stone-400",
            onClick: a[0] || (a[0] = (o) => ke(n).closeAll())
          }, _e(s.$t("confirm")), 1)
        ])
      ]),
      _: 1
    }));
  }
}), mVe = {}, gVe = {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function AVe(t, e) {
  return X(), se("svg", gVe, e[0] || (e[0] = [
    W("path", {
      d: "M14.3163 5.88986L15.9608 7.10645C16.1459 7.24337 16.0523 7.54637 15.8183 7.54783L15.3022 7.55097C15.3017 7.55097 15.3012 7.55097 15.3007 7.55097C15.168 7.55097 15.0596 7.44353 15.0588 7.31078C15.0564 6.92247 14.7399 6.60883 14.3514 6.61202C13.9631 6.61441 13.6502 6.93114 13.6526 7.31945C13.6572 8.06969 14.1652 8.70081 14.8536 8.89516V8.92919C14.8536 9.3175 15.1685 9.63231 15.5567 9.63231C15.945 9.63231 16.2598 9.3175 16.2598 8.92919V8.8937C16.5337 8.81777 16.7845 8.6717 16.9896 8.46395C17.2991 8.15055 17.468 7.73542 17.4649 7.29391V7.2895C17.4614 6.77378 17.2117 6.28272 16.7971 5.97597L15.1527 4.75942C14.9659 4.62123 15.064 4.32348 15.2967 4.32348H15.8135C15.947 4.32348 16.0555 4.43191 16.0555 4.56517C16.0555 4.95348 16.3703 5.2683 16.7586 5.2683C17.1469 5.2683 17.4617 4.95348 17.4617 4.56517C17.4617 3.81119 16.9523 3.17425 16.2597 2.97916V2.94531C16.2597 2.557 15.9449 2.24219 15.5567 2.24219C15.1684 2.24219 14.8536 2.557 14.8536 2.94531V2.97822C14.1594 3.17223 13.6484 3.80997 13.6484 4.56517C13.6485 5.08525 13.8981 5.58044 14.3163 5.88986Z",
      fill: "#6B7280"
    }, null, -1),
    W("path", {
      d: "M15.5568 11.8741C18.8314 11.8741 21.4954 9.2108 21.4954 5.93705C21.4954 2.6633 18.8313 0 15.5568 0C12.2822 0 9.61816 2.66334 9.61816 5.93709C9.61816 9.21084 12.2822 11.8741 15.5568 11.8741ZM15.5568 1.40625C18.0559 1.40625 20.0891 3.4388 20.0891 5.93709C20.0891 8.43539 18.0559 10.4679 15.5568 10.4679C13.0576 10.4679 11.0244 8.43539 11.0244 5.93709C11.0244 3.4388 13.0576 1.40625 15.5568 1.40625Z",
      fill: "#6B7280"
    }, null, -1),
    W("path", {
      d: "M23.5165 13.4617C22.756 12.4827 21.3832 12.2985 20.3949 12.9841L17.7197 14.7738C17.348 14.0816 16.617 13.6098 15.7777 13.6098H13.8694C12.9061 12.7063 11.6201 12.1934 10.2936 12.1934C9.29803 12.1934 8.32955 12.4746 7.49297 13.0067C6.73917 13.4862 6.12258 14.1486 5.69888 14.9305L5.34066 15.1496L5.24785 14.8781C5.12222 14.5108 4.72266 14.3147 4.35525 14.4402L0.475925 15.7658C0.108659 15.8913 -0.0876531 16.2912 0.0379719 16.6586L2.38514 23.524C2.51082 23.8916 2.91052 24.0874 3.27774 23.9619L7.15707 22.6365C7.50352 22.518 7.73049 22.1399 7.58724 21.7209L13.7429 21.5303C15.4193 21.5281 17.0269 21.0133 18.3925 20.0413L23.0346 16.7393C24.0989 15.9818 24.3186 14.4936 23.5165 13.4617ZM3.4883 22.4039L1.59605 16.8691L4.14469 15.9983C4.41924 16.8014 5.75358 20.7042 6.03694 21.5331L3.4883 22.4039ZM22.2194 15.5935L17.5773 18.8955C16.448 19.6992 15.1182 20.124 13.7318 20.124C13.7245 20.124 13.7172 20.1241 13.71 20.1244L7.11127 20.3286L5.80674 16.5128L6.59963 16.028C6.59982 16.0279 6.59996 16.0277 6.60014 16.0276C6.71686 15.9562 6.80813 15.8513 6.86382 15.7378C7.51092 14.4189 8.82516 13.5995 10.2936 13.5995C11.3548 13.5995 12.3404 14.0243 13.0688 14.7957C13.203 14.9378 13.3958 15.0159 13.58 15.0159H15.7777C16.217 15.0159 16.5744 15.3731 16.5744 15.8122C16.5744 16.2466 16.223 16.6084 15.7777 16.6084H11.8107C11.4224 16.6084 11.1076 16.9232 11.1076 17.3115C11.1076 17.6999 11.4225 18.0147 11.8107 18.0147H15.7777C16.3666 18.0147 16.9199 17.7854 17.3351 17.3695C17.6257 17.079 17.8247 16.7218 17.9187 16.3325L21.1822 14.1492C21.1861 14.1466 21.19 14.1439 21.1939 14.1412C21.5787 13.8724 22.1118 13.9455 22.4061 14.3244C22.7165 14.7238 22.6316 15.3001 22.2194 15.5935Z",
      fill: "#6B7280"
    }, null, -1)
  ]));
}
const jS = /* @__PURE__ */ mn(mVe, [["render", AVe]]);
function V2(t, e) {
  if (typeof t != "object") return;
  if (t.getRangeAt) {
    if (t.rangeCount === 0) return;
    t = t.getRangeAt(0);
  }
  if (t.cloneRange) {
    let r = t.cloneRange();
    r.collapse(!0), t = r.startContainer, t.nodeType === 1 && (t = t.childNodes[r.startOffset]);
  }
  if (!t) return;
  let n = t;
  for (; n && n.nodeType !== 1; ) n = n.previousSibling;
  t = n || t.parentNode, t && bVe(t, e);
}
function bVe(t, e) {
  if (t.scrollIntoViewIfNeeded)
    t.scrollIntoViewIfNeeded(!1);
  else {
    e = e || t.parentElement;
    const n = t.offsetTop - e.scrollTop;
    (n < 0 || n > e.offsetHeight - t.offsetHeight) && (e.scrollTop = t.offsetTop);
  }
}
function Ml(t) {
  const e = window.getSelection();
  e && (e.removeAllRanges(), e.addRange(t));
}
function qy() {
  const t = window.getSelection();
  if (t && t.rangeCount > 0)
    return t.getRangeAt(0);
}
function rc(t, e) {
  return e.map((n) => ({ at: n, index: t.lastIndexOf(n) })).reduce((n, r) => n.index > r.index ? n : r);
}
function yVe(t, e) {
  e = e || window;
  for (var n = { top: t.offsetTop, left: t.offsetLeft }, r = t.offsetParent; r != null && r != e; )
    n.left += r.offsetLeft, n.top += r.offsetTop, r = r.offsetParent;
  return n;
}
function vVe(t, e) {
  do
    if (e(t)) return t;
  while (t = t && t.parentNode);
}
function zS() {
  const t = qy();
  if (t) {
    const e = t.cloneRange();
    return e.collapse(!0), e.setStart(e.endContainer, 0), e;
  }
}
const TVe = {
  name: "VueAt",
  props: {
    value: {
      type: String,
      // value not required
      default: null
    },
    at: {
      type: String,
      default: null
    },
    ats: {
      type: Array,
      default: () => ["@"]
    },
    suffix: {
      type: String,
      default: " "
    },
    loop: {
      type: Boolean,
      default: !0
    },
    allowSpaces: {
      type: Boolean,
      default: !0
    },
    tabSelect: {
      type: Boolean,
      default: !1
    },
    avoidEmail: {
      type: Boolean,
      default: !0
    },
    showUnique: {
      type: Boolean,
      default: !0
    },
    hoverSelect: {
      type: Boolean,
      default: !0
    },
    members: {
      type: Array,
      default: () => []
    },
    nameKey: {
      type: String,
      default: ""
    },
    filterMatch: {
      type: Function,
      default: (t, e) => t.toLowerCase().indexOf(e.toLowerCase()) > -1
    },
    deleteMatch: {
      type: Function,
      default: (t, e, n) => e === t + n
    },
    scrollRef: {
      type: String,
      default: ""
    }
  },
  emits: ["update:value", "at", "insert"],
  data() {
    return {
      // at[v-model] mode should be on only when
      // initial :value/v-model is present (not nil)
      bindsValue: this.value != null,
      customsEmbedded: !1,
      hasComposition: !1,
      atwho: null
    };
  },
  computed: {
    atItems() {
      return this.at ? [this.at] : this.ats;
    },
    currentItem() {
      return this.atwho ? this.atwho.list[this.atwho.cur] : "";
    },
    style() {
      if (this.atwho) {
        const { x: t, y: e } = this.atwho, { wrap: n } = this.$refs;
        if (n) {
          const r = yVe(n), i = this.scrollRef ? document.querySelector(this.scrollRef).scrollLeft : 0, s = this.scrollRef ? document.querySelector(this.scrollRef).scrollTop : 0, a = t + i + window.pageXOffset - r.left + "px", o = e + s + window.pageYOffset - r.top + "px";
          return { left: a, top: o };
        }
      }
      return null;
    }
  },
  watch: {
    "atwho.cur"(t) {
      t != null && this.$nextTick(() => {
        this.scrollToCur();
      });
    },
    members() {
      this.handleInput(!0);
    },
    value(t) {
      this.bindsValue && this.handleValueUpdate(t);
    }
  },
  mounted() {
    this.$slots.embeddedItem && (this.customsEmbedded = !0), this.bindsValue && this.handleValueUpdate(this.value);
  },
  methods: {
    itemName(t) {
      const { nameKey: e } = this;
      return e ? t[e] : t;
    },
    isCur(t) {
      return t === this.atwho.cur;
    },
    handleValueUpdate(t) {
      const e = this.$el.querySelector("[contenteditable]");
      t !== e.innerHTML && (e.innerHTML = t, this.dispatchInput());
    },
    dispatchInput() {
      let t = this.$el.querySelector("[contenteditable]"), e = new Event("input", { bubbles: !0 });
      t.dispatchEvent(e);
    },
    handleItemHover(t) {
      this.hoverSelect && this.selectByMouse(t);
    },
    handleItemClick(t) {
      this.selectByMouse(t), this.insertItem();
    },
    handleDelete(t) {
      const e = zS();
      if (e) {
        if (this.customsEmbedded && e.endOffset >= 1) {
          let d = e.endContainer.childNodes[e.endOffset] || e.endContainer.childNodes[e.endOffset - 1];
          if (!d || d.nodeType === Node.TEXT_NODE && !/^\s?$/.test(d.data))
            return;
          d.nodeType === Node.TEXT_NODE ? d.previousSibling && (d = d.previousSibling) : d.previousElementSibling && (d = d.previousElementSibling);
          let l = [].slice.call(d.childNodes);
          l = [].reverse.call(l), l.unshift(d);
          let f;
          if ([].some.call(l, (p) => {
            if (p.getAttribute && p.getAttribute("data-at-embedded") != null)
              return f = p, !0;
          }), f) {
            t.preventDefault(), t.stopPropagation();
            const p = qy();
            p && (p.setStartBefore(f), p.deleteContents(), Ml(p), this.handleInput());
          }
          return;
        }
        const { atItems: n, members: r, suffix: i, deleteMatch: s, itemName: a } = this, o = e.toString(), { at: u, index: c } = rc(o, n);
        if (c > -1) {
          const d = o.slice(c + u.length);
          if (r.some((f) => {
            const p = a(f);
            return s(p, d, i);
          })) {
            t.preventDefault(), t.stopPropagation();
            const f = qy();
            f && (f.setStart(f.endContainer, c), f.deleteContents(), Ml(f), this.handleInput());
          }
        }
      }
    },
    handleKeyDown(t) {
      const { atwho: e } = this;
      if (e) {
        if (t.keyCode === 38 || t.keyCode === 40) {
          t.metaKey || t.ctrlKey || (t.preventDefault(), t.stopPropagation(), this.selectByKeyboard(t));
          return;
        }
        if (t.keyCode === 13 || this.tabSelect && t.keyCode === 9) {
          t.preventDefault(), t.stopPropagation(), this.insertItem();
          return;
        }
        if (t.keyCode === 27) {
          this.closePanel();
          return;
        }
      }
      (t.keyCode >= 48 && t.keyCode <= 90 || t.keyCode === 8) && setTimeout(() => {
        this.handleInput();
      }, 50), t.keyCode === 8 && this.handleDelete(t);
    },
    // compositionStart -> input -> compositionEnd
    handleCompositionStart() {
      this.hasComposition = !0;
    },
    handleCompositionEnd() {
      this.hasComposition = !1, this.handleInput();
    },
    handleInput(t) {
      if (this.hasComposition) return;
      const e = this.$el.querySelector("[contenteditable]");
      this.$emit("update:value", e.innerHTML);
      const n = zS();
      if (n) {
        const { atItems: r, avoidEmail: i, allowSpaces: s, showUnique: a } = this;
        let o = !0;
        const u = n.toString(), { at: c, index: d } = rc(u, r);
        d < 0 && (o = !1);
        const l = u[d - 1], f = u.slice(d + c.length, u.length);
        if (i && /^[a-z0-9]$/i.test(l) && (o = !1), !s && /\s/.test(f) && (o = !1), /^\s/.test(f) && (o = !1), !o)
          this.closePanel();
        else {
          const { members: p, filterMatch: m, itemName: g } = this;
          !t && f && this.$emit("at", f);
          const y = p.filter((b) => {
            const E = g(b);
            return m(E, f, c);
          });
          if (o = !1, y.length && (o = !0, !a)) {
            let b = y[0];
            f === g(b) && (o = !1);
          }
          o ? this.openPanel(y, n, d, c) : this.closePanel();
        }
      }
    },
    closePanel() {
      this.atwho && (this.atwho = null);
    },
    openPanel(t, e, n, r) {
      const i = () => {
        const s = e.cloneRange();
        s.setStart(s.endContainer, n + r.length);
        const a = s.getClientRects()[0];
        this.atwho = {
          range: e,
          offset: n,
          list: t,
          x: a.left,
          y: a.top - 4,
          cur: 0
          // todo: 尽可能记录
        };
      };
      this.atwho ? i() : setTimeout(i, 10);
    },
    scrollToCur() {
      let { wrap: t } = this.$refs, { cur: e } = this.atwho;
      const n = t.querySelector(`.atwho-li[data-index="${e}"]`), r = n.parentElement.parentElement;
      V2(n, r);
    },
    selectByMouse(t) {
      const n = +vVe(t.target, (r) => r.getAttribute("data-index")).getAttribute("data-index");
      this.atwho = {
        ...this.atwho,
        cur: n
      };
    },
    selectByKeyboard(t) {
      const e = t.keyCode === 38 ? -1 : 1, { cur: n, list: r } = this.atwho, i = this.loop ? (n + e + r.length) % r.length : Math.max(0, Math.min(n + e, r.length - 1));
      this.atwho = {
        ...this.atwho,
        cur: i
      };
    },
    // todo: 抽离成库并测试
    insertText(t, e) {
      e.deleteContents();
      const n = e.endContainer;
      if (n.nodeType === Node.TEXT_NODE) {
        const r = e.endOffset;
        n.data = n.data.slice(0, r) + t + n.data.slice(r), e.setEnd(n, r + t.length);
      } else {
        const r = document.createTextNode(t);
        e.insertNode(r), e.setEndAfter(r);
      }
      e.collapse(!1), Ml(e), this.dispatchInput();
    },
    insertHtml(t, e) {
      e.deleteContents();
      const n = e.endContainer, r = document.createElement("span");
      if (r.appendChild(document.createTextNode(" ")), r.appendChild(this.htmlToElement(t)), r.appendChild(document.createTextNode(" ")), r.setAttribute("data-at-embedded", ""), r.setAttribute("contenteditable", !1), n.nodeType === Node.TEXT_NODE) {
        const i = e.endOffset;
        let s = n.splitText(i);
        n.parentNode.insertBefore(r, s), e.setEndBefore(s);
      } else {
        const i = document.createTextNode(this.suffix);
        e.insertNode(r), e.setEndAfter(r), e.insertNode(i), e.setEndAfter(i);
      }
      e.collapse(!1), Ml(e);
    },
    insertItem() {
      const { range: t, list: e, cur: n } = this.atwho, { suffix: r, atItems: i, itemName: s, customsEmbedded: a } = this, o = t.cloneRange(), u = t.toString(), { at: c, index: d } = rc(u, i), l = a ? d : d + c.length;
      o.setStart(o.endContainer, l), Ml(o), Ml(o);
      const f = e[n];
      if (a) {
        const p = this.$refs.embeddedItem.firstElementChild.innerHTML;
        this.insertHtml(p, o);
      } else {
        const p = s(f) + r;
        this.insertText(p, o);
      }
      V2(window.getSelection()), this.$emit("insert", f), this.handleInput(), V2(o);
    },
    htmlToElement(t) {
      const e = document.createElement("template");
      return t = t.trim(), e.innerHTML = t, e.content.firstChild;
    }
  }
}, _Ve = { class: "atwho-inner" }, EVe = { class: "atwho-view" }, xVe = { class: "atwho-ul" }, wVe = ["data-index"], CVe = ["textContent"], SVe = { ref: "embeddedItem" };
function IVe(t, e, n, r, i, s) {
  return X(), se("div", {
    ref: "wrap",
    class: "atwho-wrap",
    onCompositionstart: e[2] || (e[2] = (...a) => s.handleCompositionStart && s.handleCompositionStart(...a)),
    onCompositionend: e[3] || (e[3] = (...a) => s.handleCompositionEnd && s.handleCompositionEnd(...a)),
    onInput: e[4] || (e[4] = (a) => s.handleInput()),
    onKeydownCapture: e[5] || (e[5] = (...a) => s.handleKeyDown && s.handleKeyDown(...a))
  }, [
    i.atwho ? (X(), se("div", {
      key: 0,
      class: "atwho-panel",
      style: Qt(s.style)
    }, [
      W("div", _Ve, [
        W("div", EVe, [
          W("ul", xVe, [
            (X(!0), se(wt, null, on(i.atwho.list, (a, o) => (X(), se("li", {
              key: o,
              class: vt(["atwho-li", s.isCur(o) && "atwho-cur"]),
              "data-index": o,
              onMouseenter: e[0] || (e[0] = (...u) => s.handleItemHover && s.handleItemHover(...u)),
              onClick: e[1] || (e[1] = (...u) => s.handleItemClick && s.handleItemClick(...u))
            }, [
              Jr(t.$slots, "item", { item: a }, () => [
                W("span", {
                  textContent: _e(s.itemName(a))
                }, null, 8, CVe)
              ])
            ], 42, wVe))), 128))
          ])
        ])
      ])
    ], 4)) : Fe("", !0),
    Gt(W("span", SVe, [
      Jr(t.$slots, "embeddedItem", { current: s.currentItem })
    ], 512), [
      [Ra, !1]
    ]),
    Jr(t.$slots, "default")
  ], 544);
}
const kVe = /* @__PURE__ */ mn(TVe, [["render", IVe]]);
var W2 = { exports: {} }, qS;
function DVe() {
  return qS || (qS = 1, function(t) {
    (function() {
      var e = [
        "direction",
        // RTL support
        "boxSizing",
        "width",
        // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does
        "height",
        "overflowX",
        "overflowY",
        // copy the scrollbar for IE
        "borderTopWidth",
        "borderRightWidth",
        "borderBottomWidth",
        "borderLeftWidth",
        "borderStyle",
        "paddingTop",
        "paddingRight",
        "paddingBottom",
        "paddingLeft",
        // https://developer.mozilla.org/en-US/docs/Web/CSS/font
        "fontStyle",
        "fontVariant",
        "fontWeight",
        "fontStretch",
        "fontSize",
        "fontSizeAdjust",
        "lineHeight",
        "fontFamily",
        "textAlign",
        "textTransform",
        "textIndent",
        "textDecoration",
        // might not make a difference, but better be safe
        "letterSpacing",
        "wordSpacing",
        "tabSize",
        "MozTabSize"
      ], n = typeof window < "u", r = n && window.mozInnerScreenX != null;
      function i(s, a, o) {
        if (!n)
          throw new Error("textarea-caret-position#getCaretCoordinates should only be called in a browser");
        var u = o && o.debug || !1;
        if (u) {
          var c = document.querySelector("#input-textarea-caret-position-mirror-div");
          c && c.parentNode.removeChild(c);
        }
        var d = document.createElement("div");
        d.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(d);
        var l = d.style, f = window.getComputedStyle ? window.getComputedStyle(s) : s.currentStyle, p = s.nodeName === "INPUT";
        l.whiteSpace = "pre-wrap", p || (l.wordWrap = "break-word"), l.position = "absolute", u || (l.visibility = "hidden"), e.forEach(function(y) {
          p && y === "lineHeight" ? l.lineHeight = f.height : l[y] = f[y];
        }), r ? s.scrollHeight > parseInt(f.height) && (l.overflowY = "scroll") : l.overflow = "hidden", d.textContent = s.value.substring(0, a), p && (d.textContent = d.textContent.replace(/\s/g, " "));
        var m = document.createElement("span");
        m.textContent = s.value.substring(a) || ".", d.appendChild(m);
        var g = {
          top: m.offsetTop + parseInt(f.borderTopWidth),
          left: m.offsetLeft + parseInt(f.borderLeftWidth),
          height: parseInt(f.lineHeight)
        };
        return u ? m.style.backgroundColor = "#aaa" : document.body.removeChild(d), g;
      }
      t.exports = i;
    })();
  }(W2)), W2.exports;
}
var MVe = DVe();
const OVe = /* @__PURE__ */ Fr(MVe), NVe = {
  name: "AtTextarea",
  extends: kVe,
  emits: ["update:value", "at", "insert"],
  computed: {
    style() {
      if (this.atwho) {
        const { x: t, y: e } = this.atwho, { wrap: n } = this.$refs, r = this.$el.querySelector("textarea");
        if (n) {
          const i = t + r.offsetLeft - r.scrollLeft + "px", s = e + r.offsetTop - r.scrollTop + "px";
          return { left: i, top: s };
        }
      }
      return null;
    }
  },
  methods: {
    handleValueUpdate(t) {
      const e = this.$el.querySelector("textarea");
      t !== e.value && (e.value = t, this.dispatchInput());
    },
    dispatchInput() {
      let t = this.$el.querySelector("textarea"), e = new Event("input", { bubbles: !0 });
      t.dispatchEvent(e);
    },
    handleDelete() {
      const t = this.$el.querySelector("textarea");
      if (t.selectionEnd - t.selectionStart > 0) return;
      const n = t.value.slice(0, t.selectionEnd);
      if (n) {
        const { atItems: r, members: i, suffix: s, deleteMatch: a, itemName: o } = this, { at: u, index: c } = rc(n, r);
        if (c > -1) {
          const d = n.slice(c + u.length);
          i.some((f) => {
            const p = o(f);
            return a(p, d, s);
          }) && (t.value = t.value.slice(0, c) + t.value.slice(t.selectionEnd - 1), t.selectionStart = c + 1, t.selectionEnd = c + 1, this.handleInput());
        }
      }
    },
    handleInput(t) {
      if (this.hasComposition) return;
      const e = this.$el.querySelector("textarea");
      this.$emit("update:value", e.value);
      const n = e.value.slice(0, e.selectionEnd);
      if (n) {
        const { atItems: r, avoidEmail: i, allowSpaces: s } = this;
        let a = !0;
        const { at: o, index: u } = rc(n, r);
        u < 0 && (a = !1);
        const c = n[u - 1], d = n.slice(u + o.length, n.length);
        if (i && /^[a-z0-9]$/i.test(c) && (a = !1), !s && /\s/.test(d) && (a = !1), /^\s/.test(d) && (a = !1), !a)
          this.closePanel();
        else {
          const { members: l, filterMatch: f, itemName: p } = this;
          t || this.$emit("at", d);
          const m = l.filter((g) => {
            const y = p(g);
            return f(y, d, o);
          });
          m.length ? this.openPanel(m, d, u, o, t) : this.closePanel();
        }
      } else
        this.closePanel();
    },
    openPanel(t, e, n, r) {
      const i = () => {
        const s = this.$el.querySelector("textarea"), a = n + r.length, o = OVe(s, a);
        this.atwho = {
          chunk: e,
          offset: n,
          list: t,
          atEnd: a,
          x: o.left,
          y: o.top - 4,
          cur: 0
          // todo: 尽可能记录
        };
      };
      this.atwho ? i() : setTimeout(i, 10);
    },
    // todo: 抽离成库并测试
    insertText(t, e) {
      const n = e.selectionStart, r = e.selectionEnd;
      e.value = e.value.slice(0, n) + t + e.value.slice(r);
      const i = n + t.length;
      e.selectionStart = i, e.selectionEnd = i, this.dispatchInput();
    },
    insertItem() {
      const { list: t, cur: e, atEnd: n } = this.atwho, { suffix: r, atItems: i, itemName: s } = this, a = this.$el.querySelector("textarea"), o = a.value.slice(0, n), { at: u, index: c } = rc(o, i), d = c + u.length;
      a.selectionStart = d, a.focus();
      const l = t[e], f = s(l) + r;
      this.insertText(f, a), this.$emit("insert", l), this.handleInput();
    }
  }
}, LVe = { class: "relative flex flex-col items-center justify-between" }, PVe = { class: "text-base font-medium text-gray-700 dark:text-gray-300" }, RVe = { class: "mt-5 flex w-full items-end" }, BVe = { class: "mr-2 text-[18px] font-medium text-gray-700 dark:text-gray-300" }, FVe = { class: "mt-5 flex w-full flex-col" }, UVe = { class: "mr-2 text-sm font-normal text-gray-700 dark:text-gray-300" }, $Ve = ["value"], HVe = { class: "mt-2 flex w-full flex-col" }, jVe = { class: "mr-2 text-sm font-normal text-[#939393] dark:text-gray-300" }, zVe = { class: "mt-1 flex" }, qVe = {
  key: 0,
  class: "mr-4",
  src: YT,
  alt: "LINE Pay Logo"
}, VVe = {
  key: 1,
  class: "mr-4",
  src: XT,
  alt: "Stripe Logo"
}, WVe = {
  key: 2,
  class: "mr-4",
  src: KT,
  alt: "Paypal Logo"
}, QVe = { class: "mt-4 flex w-full flex-col" }, GVe = { class: "mr-2 text-sm font-normal text-gray-700 dark:text-gray-300" }, YVe = ["placeholder"], XVe = { class: "mt-5 flex items-center justify-center gap-2" }, KVe = ["disabled"], ZVe = /* @__PURE__ */ Ze({
  __name: "PaymentCollectionRequestModal",
  props: {
    isLinePayEnabled: { type: Boolean },
    isStripeEnabled: { type: Boolean },
    isPaypalEnabled: { type: Boolean }
  },
  setup(t) {
    const e = t, n = ["TWD", "USD"], r = Yt(), i = $n(), s = Se(""), a = Se(0), o = Se(n[0]), u = Se(""), c = de(() => r.state.imkit.uid), d = de(() => r.state.imkit.selectedRoomId), l = de(() => r.state.imkit.rooms[d.value]), f = de(
      () => o.value === n[0] && e.isLinePayEnabled
    ), p = de(() => e.isStripeEnabled), m = de(() => e.isPaypalEnabled), g = de(() => {
      const b = e.isLinePayEnabled || e.isStripeEnabled || e.isPaypalEnabled, E = {
        [n[0]]: e.isLinePayEnabled || e.isStripeEnabled || e.isPaypalEnabled,
        [n[1]]: e.isStripeEnabled || e.isPaypalEnabled
      }[o.value] || !1;
      return b && E && a.value > 0;
    }), y = async () => {
      if (l.value.type === $a.Direct) {
        const b = l.value.memberIds.find(
          (v) => v !== c.value
        ), E = r.state.imkit.users[b];
        await r.state.imkit.config.callbacks.onPaymentRequestCreated(
          s.value,
          d.value,
          E.nickname,
          E.id,
          a.value,
          o.value,
          u.value
        );
      }
      i.closeAll();
    };
    return Tr(() => {
      const b = l.value.roomTags ?? [];
      b.length > 0 && (s.value = b[0]);
    }), (b, E) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[400px] max-w-full rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", LVe, [
          W("button", {
            class: "absolute right-0 top-0 flex items-center justify-center",
            onClick: E[0] || (E[0] = (v) => ke(i).closeAll())
          }, [
            et(Br, { class: "h-6 w-6" })
          ]),
          W("h1", PVe, _e(b.$t("paymentSendRequestMessage")), 1),
          W("div", RVe, [
            W("p", BVe, _e(o.value), 1),
            Gt(W("input", {
              "onUpdate:modelValue": E[1] || (E[1] = (v) => a.value = v),
              type: "number",
              placeholder: "0",
              class: "hide-spin m-0 h-full min-h-[39px] w-full text-[40px] font-medium outline-none dark:bg-zinc-800"
            }, null, 512), [
              [ds, a.value]
            ])
          ]),
          W("div", FVe, [
            W("p", UVe, _e(b.$t("currency")), 1),
            Gt(W("select", {
              "onUpdate:modelValue": E[2] || (E[2] = (v) => o.value = v),
              class: "mb-4 mt-1 h-[34px] w-full appearance-none rounded-[5px] border-none bg-[#f2f2f2] px-[10px] text-[#1a1a1a] outline-none"
            }, [
              (X(), se(wt, null, on(n, (v) => W("option", {
                value: v,
                key: v
              }, _e(v), 9, $Ve)), 64))
            ], 512), [
              [g7, o.value]
            ])
          ]),
          W("div", HVe, [
            W("p", jVe, _e(b.$t("paymentSupportedMethods")), 1),
            W("div", zVe, [
              f.value ? (X(), se("img", qVe)) : Fe("", !0),
              p.value ? (X(), se("img", VVe)) : Fe("", !0),
              m.value ? (X(), se("img", WVe)) : Fe("", !0)
            ])
          ]),
          W("div", QVe, [
            W("p", GVe, _e(b.$t("paymentRequestMessage")), 1),
            Gt(W("input", {
              "onUpdate:modelValue": E[3] || (E[3] = (v) => u.value = v),
              class: "mt-1 h-[40px] gap-[10px] rounded-[6px] bg-[#F3F4F6] px-[12px] py-[10px] outline-none dark:text-[#1a1a1a]",
              type: "text",
              placeholder: b.$t("paymentInputMessageOptional"),
              maxlength: "100"
            }, null, 8, YVe), [
              [ds, u.value]
            ])
          ])
        ]),
        W("div", XVe, [
          W("button", {
            class: "h-10 w-[100px] grow rounded-lg border border-[#02B13F] text-base text-[#02B13F] dark:border-[#02B13F] dark:text-[#02B13F]",
            onClick: E[4] || (E[4] = (v) => ke(i).closeAll())
          }, _e(b.$t("cancel")), 1),
          W("button", {
            disabled: !g.value,
            class: "h-10 w-[100px] grow rounded-lg bg-[#02B13F] text-base text-white disabled:cursor-not-allowed disabled:opacity-50",
            onClick: y
          }, _e(b.$t("submit")), 9, KVe)
        ])
      ]),
      _: 1
    }));
  }
}), JVe = /* @__PURE__ */ mn(ZVe, [["__scopeId", "data-v-47de052c"]]), eWe = { class: "relative flex flex-col items-center justify-between" }, tWe = { class: "mt-5 text-xl font-medium text-gray-700 dark:text-gray-300" }, nWe = { class: "mt-5 text-sm font-medium text-gray-700 dark:text-gray-300" }, rWe = { class: "mt-5 flex items-center justify-center" }, iWe = {
  class: "flex h-10 grow items-center justify-center rounded-lg bg-[#02B13F] text-base text-white",
  href: "/dashboard/settings_payment_flow"
}, sWe = /* @__PURE__ */ Ze({
  __name: "PaymentCollectionNotSetModal",
  setup(t) {
    const e = $n();
    return (n, r) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[360px] max-w-full rounded-xl p-5 flex flex-col gap-3 w-[300px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", eWe, [
          W("button", {
            class: "absolute right-0 top-0 flex items-center justify-center",
            onClick: r[0] || (r[0] = (i) => ke(e).closeAll())
          }, [
            et(Br, { class: "h-6 w-6" })
          ]),
          et(Jf, {
            width: "50",
            height: "50",
            color: "#02B13F"
          }),
          W("h1", tWe, _e(n.$t("paymentCollectionNotSet")), 1),
          W("p", nWe, _e(n.$t("paymentCollectionNotSetDescription")), 1)
        ]),
        W("div", rWe, [
          W("a", iWe, _e(n.$t("paymentGoToSetting")), 1)
        ])
      ]),
      _: 1
    }));
  }
}), aWe = {}, oWe = {
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function uWe(t, e) {
  return X(), se("svg", oWe, e[0] || (e[0] = [
    W("g", { "clip-path": "url(#clip0_4386_1535)" }, [
      W("path", {
        d: "M14.5 18.25L8.25 12L14.5 5.75",
        stroke: "currentColor",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      })
    ], -1),
    W("defs", null, [
      W("clipPath", { id: "clip0_4386_1535" }, [
        W("rect", {
          width: "20",
          height: "20",
          fill: "white",
          transform: "translate(2 2)"
        })
      ])
    ], -1)
  ]));
}
const lWe = /* @__PURE__ */ mn(aWe, [["render", uWe]]), cWe = {
  width: "36",
  height: "36",
  viewBox: "0 0 36 36",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, dWe = /* @__PURE__ */ Ze({
  __name: "SettingSvg",
  props: {
    color: {}
  },
  setup(t) {
    return (e, n) => (X(), se("svg", cWe, [
      W("path", {
        d: "M26.0625 20.2207L24.7832 19.127C24.8438 18.7559 24.875 18.377 24.875 17.998C24.875 17.6191 24.8438 17.2402 24.7832 16.8691L26.0625 15.7754C26.159 15.6928 26.2281 15.5828 26.2605 15.46C26.2929 15.3372 26.2872 15.2074 26.2441 15.0879L26.2266 15.0371C25.8744 14.0528 25.347 13.1403 24.6699 12.3437L24.6348 12.3027C24.5526 12.2062 24.4432 12.1367 24.3208 12.1036C24.1984 12.0705 24.0689 12.0752 23.9492 12.1172L22.3613 12.6816C21.7754 12.2012 21.1211 11.8223 20.4141 11.5566L20.1074 9.89648C20.0843 9.77157 20.0237 9.65665 19.9337 9.56699C19.8437 9.47733 19.7285 9.41718 19.6035 9.39453L19.5508 9.38477C18.5332 9.20117 17.4629 9.20117 16.4453 9.38477L16.3926 9.39453C16.2676 9.41718 16.1524 9.47733 16.0624 9.56699C15.9724 9.65665 15.9118 9.77157 15.8887 9.89648L15.5801 11.5645C14.8787 11.8301 14.2255 12.2088 13.6465 12.6855L12.0469 12.1172C11.9273 12.0749 11.7976 12.07 11.6752 12.1031C11.5527 12.1363 11.4433 12.2059 11.3613 12.3027L11.3262 12.3437C10.6499 13.1409 10.1226 14.0532 9.76954 15.0371L9.75196 15.0879C9.66407 15.332 9.73633 15.6055 9.9336 15.7754L11.2285 16.8809C11.168 17.248 11.1387 17.623 11.1387 17.9961C11.1387 18.3711 11.168 18.7461 11.2285 19.1113L9.9336 20.2168C9.8371 20.2994 9.76804 20.4094 9.7356 20.5322C9.70315 20.655 9.70886 20.7848 9.75196 20.9043L9.76954 20.9551C10.1231 21.9395 10.6465 22.8477 11.3262 23.6484L11.3613 23.6895C11.4435 23.786 11.5529 23.8555 11.6753 23.8886C11.7977 23.9217 11.9272 23.917 12.0469 23.875L13.6465 23.3066C14.2285 23.7852 14.8789 24.1641 15.5801 24.4277L15.8887 26.0957C15.9118 26.2206 15.9724 26.3355 16.0624 26.4252C16.1524 26.5149 16.2676 26.575 16.3926 26.5977L16.4453 26.6074C17.4722 26.792 18.5239 26.792 19.5508 26.6074L19.6035 26.5977C19.7285 26.575 19.8437 26.5149 19.9337 26.4252C20.0237 26.3355 20.0843 26.2206 20.1074 26.0957L20.4141 24.4355C21.1208 24.1706 21.7788 23.7905 22.3613 23.3105L23.9492 23.875C24.0688 23.9173 24.1985 23.9222 24.3209 23.8891C24.4434 23.8559 24.5528 23.7863 24.6348 23.6895L24.6699 23.6484C25.3496 22.8457 25.8731 21.9395 26.2266 20.9551L26.2441 20.9043C26.332 20.6641 26.2598 20.3906 26.0625 20.2207ZM23.3965 17.0996C23.4453 17.3945 23.4707 17.6973 23.4707 18C23.4707 18.3027 23.4453 18.6055 23.3965 18.9004L23.2676 19.6836L24.7266 20.9316C24.5054 21.4412 24.2262 21.9235 23.8945 22.3691L22.082 21.7266L21.4688 22.2305C21.002 22.6133 20.4824 22.9141 19.9199 23.125L19.1758 23.4043L18.8262 25.2988C18.2746 25.3613 17.7176 25.3613 17.166 25.2988L16.8164 23.4004L16.0781 23.1172C15.5215 22.9062 15.0039 22.6055 14.541 22.2246L13.9277 21.7188L12.1035 22.3672C11.7715 21.9199 11.4941 21.4375 11.2715 20.9297L12.7461 19.6699L12.6191 18.8887C12.5723 18.5977 12.5469 18.2969 12.5469 18C12.5469 17.7012 12.5703 17.4023 12.6191 17.1113L12.7461 16.3301L11.2715 15.0703C11.4922 14.5605 11.7715 14.0801 12.1035 13.6328L13.9277 14.2812L14.541 13.7754C15.0039 13.3945 15.5215 13.0938 16.0781 12.8828L16.8184 12.6035L17.168 10.7051C17.7168 10.6426 18.2773 10.6426 18.8281 10.7051L19.1777 12.5996L19.9219 12.8789C20.4824 13.0898 21.0039 13.3906 21.4707 13.7734L22.084 14.2773L23.8965 13.6348C24.2285 14.082 24.5059 14.5645 24.7285 15.0723L23.2695 16.3203L23.3965 17.0996ZM18 14.3672C16.1016 14.3672 14.5625 15.9062 14.5625 17.8047C14.5625 19.7031 16.1016 21.2422 18 21.2422C19.8984 21.2422 21.4375 19.7031 21.4375 17.8047C21.4375 15.9062 19.8984 14.3672 18 14.3672ZM19.5469 19.3516C19.344 19.555 19.1029 19.7164 18.8374 19.8263C18.5719 19.9363 18.2873 19.9926 18 19.9922C17.416 19.9922 16.8672 19.7637 16.4531 19.3516C16.2497 19.1487 16.0883 18.9076 15.9784 18.6421C15.8684 18.3766 15.8121 18.092 15.8125 17.8047C15.8125 17.2207 16.041 16.6719 16.4531 16.2578C16.8672 15.8437 17.416 15.6172 18 15.6172C18.584 15.6172 19.1328 15.8437 19.5469 16.2578C19.7503 16.4607 19.9117 16.7018 20.0216 16.9673C20.1316 17.2328 20.188 17.5174 20.1875 17.8047C20.1875 18.3887 19.959 18.9375 19.5469 19.3516Z",
        style: Qt({
          fill: e.color
        })
      }, null, 4)
    ]));
  }
}), fWe = {
  key: 2,
  class: "relative h-10 w-10"
}, hWe = {
  key: 0,
  class: "flex h-12 w-full items-center justify-center"
}, pWe = { class: "relative flex items-end justify-center gap-3 p-3 pl-3" }, mWe = { class: "overflow-hidden text-ellipsis whitespace-nowrap" }, gWe = {
  key: 2,
  class: "absolute bottom-16 left-2 z-10 flex items-stretch gap-1 rounded-lg bg-white p-1.5 text-gray-900 shadow-md dark:bg-zinc-800 dark:text-gray-100"
}, AWe = { class: "text-xs" }, bWe = { class: "text-xs whitespace-nowrap" }, yWe = { class: "whitespace-nowrap text-xs" }, vWe = { class: "whitespace-nowrap text-xs" }, TWe = {
  key: 4,
  class: "relative flex grow flex-col items-stretch rounded-lg bg-gray-100 px-4 py-3 dark:bg-zinc-700"
}, _We = {
  key: 0,
  class: "absolute top-[-40px] left-[50%] flex translate-x-[-50%] gap-5"
}, EWe = ["onClick"], xWe = { class: "flex items-center gap-3 bg-gray-100 dark:bg-zinc-700" }, wWe = { class: "flex w-0 min-w-0 grow flex-col items-stretch justify-center gap-3" }, CWe = ["disabled", "placeholder"], SWe = {
  key: 0,
  class: "flex gap-3"
}, IWe = ["src"], kWe = ["onClick"], DWe = /* @__PURE__ */ Ze({
  __name: "ChatRoom",
  props: {
    isTestPreview: { type: Boolean },
    pinchatLink: {},
    chatStyle: {}
  },
  emits: ["send", "goBack"],
  setup(t, { emit: e }) {
    const n = e, r = t, i = Yt(), { t: s } = Ri(), { open: a } = Jn({
      component: nPe
    }), o = () => {
      const { open: Ve } = Jn({
        component: pVe,
        attrs: {
          fileSizeLimit: te.value
        }
      });
      Ve();
    }, u = de(() => r.isTestPreview ? `Test Bot ${r.pinchatLink.split("_")[0]}` : c.value.displayName), c = de(
      () => i.state.imkit.rooms[i.state.imkit.selectedRoomId]
    ), d = de(() => i.state.imkit.selectedRoomId), l = de(
      () => !!i.state.imkit.isRequesting[`/rooms/${i.state.imkit.selectedRoomId}/messages`]
    ), f = de(() => {
      var ut;
      const Ve = Object.keys(i.state.imkit.isTyping).map(
        (_t) => new Fn({
          _id: _t,
          messageType: "typing",
          sender: {
            _id: _t
          }
        })
      );
      return ((ut = i.state.imkit.messageMultiList.main) == null ? void 0 : ut.array().concat(Ve)) ?? [];
    }), p = de(() => G.value.fixedRoomEnabled || zN().has("roomId")), m = de(() => Nu.value ? "dark" : "light"), g = de(() => G.value.linePayEnabled || G.value.stripeEnabled || G.value.paypalEnabled), y = de(() => f.value.at(-1)), b = de(() => i.state.imkit.isRoomInfoVisible), E = de(() => i.state.imkit.navigationTargetId), v = Se(null), _ = Se(""), D = Se(!1), S = Se(!1), M = Se(!1), O = Se(null), T = Se(null), N = Se(!1), H = Se(), $ = Se([]), j = Se([]), U = Se(!1), V = Se(!1), B = Se(), R = Se(Wn().subtract(5, "second")), K = Se(!1), Q = de(() => !0), P = de(() => {
      var Ve, ut, _t;
      return ((_t = (ut = (Ve = f.value[f.value.length - 1]) == null ? void 0 : Ve.template) == null ? void 0 : ut.quickReply) == null ? void 0 : _t.items) ?? [];
    }), I = de(() => i.state.imkit.replyId), G = de(() => i.state.imkit.config.settings), te = de(
      () => G.value.fileUploadSizeLimit ?? 2e7
    ), ee = de(() => i.state.imkit.isSearchInRoomMode), Z = de(() => i.state.imkit.config.styles), ye = de(() => r.chatStyle), he = async () => {
      const Ve = async () => {
        if (_.value) {
          const { replyId: _t } = i.state.imkit;
          let zt = _.value.trim(), wn = [];
          if (zt.includes("@"))
            for (const jn of c.value.memberIds) {
              const Y = i.state.imkit.users[jn];
              zt.includes(`@${Y.nickname}`) && (wn.push(Y.id), zt = zt.replace(`@${Y.nickname}`, `@${Y.id}`));
            }
          const Hn = {
            roomId: c.value.id,
            messageType: "text",
            message: zt,
            reply: _t || null,
            mentions: wn
          };
          _.value = "", await ca(), B.value && (B.value.style.height = "auto", B.value.style.height = Math.min(B.value.scrollHeight, 64) + "px"), await i.dispatch("imkit/sendMessage", Hn), i.commit("imkit/setState", { replyId: null });
        }
      }, ut = async () => {
        if ($.value.length > 0) {
          const _t = {
            roomId: c.value.id,
            messageType: "image",
            images: $.value,
            files: j.value
          };
          $.value = [], j.value = [], await i.dispatch("imkit/sendMessage", _t);
        }
      };
      await Promise.all([ut(), Ve()]), n("send");
    }, Ee = async () => {
      var ut, _t;
      if (f.value.length >= i.state.imkit.numberOfTotalMessages)
        return;
      const Ve = await i.dispatch("imkit/loadMessages", {
        roomId: c.value.id,
        beforeMessageId: (ut = f.value[0]) == null ? void 0 : ut.id
      });
      Ve && Ve.length > 0 && ((_t = v.value) == null || _t.scrollToIndex(Ve.length));
    }, be = async () => {
      var Ve;
      V.value = !1, i.state.imkit.messageMultiList.main != i.state.imkit.messageMultiList.tail && await i.dispatch("imkit/loadMessages", {
        roomId: c.value.id,
        afterMessageId: (Ve = f.value[f.value.length - 1]) == null ? void 0 : Ve.id
      });
    }, ve = (Ve) => {
      _.value += Ve.i, M.value = !1;
    }, Ce = () => {
      S.value = !1;
    }, Ne = () => {
      M.value = !1;
    }, qe = () => {
      S.value = !S.value, S.value && (M.value = !1);
    }, $e = () => {
      M.value = !M.value, M.value && (S.value = !1);
    }, Xe = () => {
      var Ve;
      (Ve = H.value) == null || Ve.click();
    }, at = async (Ve) => {
      var jn;
      const ut = Array.from(
        ((jn = Ve == null ? void 0 : Ve.target) == null ? void 0 : jn.files) || []
      );
      if (ut.some((Y) => Y.size >= te.value)) {
        o(), H.value && (H.value.value = "");
        return;
      }
      const _t = ut.filter((Y) => Y.size < te.value);
      if (_t.length === 0 || _t.length > 10) return;
      const zt = _t.filter((Y) => Y.type.startsWith("image")), wn = _t.filter((Y) => Y.type.startsWith("video")), Hn = _t.filter(
        (Y) => !Y.type.startsWith("image") && !Y.type.startsWith("video")
      );
      if (zt.length > 0) {
        const Y = await Promise.all(zt.map(N2)), J = {
          roomId: c.value.id,
          messageType: "image",
          images: Y,
          files: Array.from(_t)
        };
        await i.dispatch("imkit/sendMessage", J);
      }
      if (wn.length > 0)
        for (const Y of wn) {
          const J = await P7e(Y), { width: me, height: Oe, duration: rt } = J, ht = {
            roomId: c.value.id,
            messageType: "video",
            video: J,
            file: Y,
            width: me,
            height: Oe,
            duration: rt
          };
          await i.dispatch("imkit/sendMessage", ht);
        }
      if (Hn.length > 0)
        for (const Y of Hn) {
          const J = {
            roomId: c.value.id,
            messageType: "file",
            file: Y,
            originalUrl: "",
            extra: {
              mimeType: Y.type,
              fileName: Y.name.split(".").slice(0, -1).join("."),
              bytes: Y.size,
              fileExtension: Y.name.split(".").pop()
            }
          };
          await i.dispatch("imkit/sendMessage", J);
        }
      H.value && (H.value.value = "");
    }, Ie = async (Ve) => {
      const ut = ((Ve == null ? void 0 : Ve.dataTransfer) || {}).files || [];
      if (ut.length === 0 || ut.length > 10) return;
      if (Array.from(ut).some((wn) => wn.size >= te.value)) {
        o();
        return;
      }
      const _t = await Promise.all(Array.from(ut).map(N2)), zt = {
        roomId: c.value.id,
        messageType: "image",
        images: _t,
        files: Array.from(ut)
      };
      await i.dispatch("imkit/sendMessage", zt);
    }, ne = (Ve) => {
      Ve.preventDefault();
    }, ue = async (Ve) => {
      const _t = (Ve.clipboardData || {}).files;
      if (!(_t.length === 0 || _t.length > 10)) {
        if (Array.from(_t).some((zt) => zt.size >= te.value)) {
          o();
          return;
        }
        Ve.preventDefault(), $.value = $.value.concat(
          await Promise.all(Array.from(_t).map(N2))
        ), j.value = j.value.concat(Array.from(_t));
      }
    }, ie = (Ve) => {
      $.value.splice(Ve, 1), j.value.splice(Ve, 1);
    }, Te = () => {
      setTimeout(() => {
        D.value = !1;
      }, 0);
    }, je = (Ve) => {
      !D.value && Ve.keyCode == 13 && !Ve.shiftKey && !G.value.sendButtonEnabled && (Ve.preventDefault(), he());
    }, We = () => {
      B.value && (B.value.style.height = "auto", B.value.style.height = Math.min(B.value.scrollHeight, 64) + "px");
    }, Qe = () => {
      i.commit("imkit/setState", {
        isSearchInRoomMode: !0
      });
    }, xe = () => {
      n("goBack");
    };
    let Be = 0;
    const At = async (Ve) => {
      U.value = !1, i.commit("imkit/clearChatRoom"), Promise.all([
        i.dispatch("imkit/loadMessages", { roomId: Ve }),
        i.dispatch("imkit/fetchRoom", Ve)
      ]).finally(() => {
        var ut, _t, zt;
        G.value.enableReadReceipt && (((ut = c.value) == null ? void 0 : ut.numberOfUnread) ?? 0) > 0 && (i.dispatch("imkit/updateLastRead", Ve), i.dispatch("imkit/insertUnreadMessage")), (_t = c.value) != null && _t.isSuperuser && i.dispatch("imkit/getBlockList", c.value.id);
        for (const wn of i.state.imkit.deliveringMessages.values())
          wn.roomId === Ve && i.commit("imkit/pushMessage", wn);
        (zt = v.value) == null || zt.scrollToBottom(), U.value = !0;
      });
    };
    Tr(() => {
      Ct(
        d,
        async (Ve, ut) => {
          Ve !== ut && Ve && At(Ve);
        },
        { immediate: !0 }
      ), Ct(
        [() => f.value.length, () => y.value],
        ([Ve], [ut]) => {
          var _t, zt, wn, Hn, jn, Y;
          Ve < ut || Ve - ut > 1 || ((_t = v.value) == null ? void 0 : _t.getOffset()) !== void 0 && (((zt = v.value) == null ? void 0 : zt.getOffset()) + ((wn = v.value) == null ? void 0 : wn.getClientSize()) >= ((Hn = v.value) == null ? void 0 : Hn.getScrollSize()) || ((jn = y.value) == null ? void 0 : jn.senderId) === i.state.imkit.uid ? (V.value = !1, (Y = v.value) == null || Y.scrollToBottom()) : V.value = !0);
        }
      ), Ct(E, (Ve) => {
        var _t;
        if (!Ve) return;
        const ut = f.value.findIndex((zt) => zt.id === Ve);
        ut !== -1 && ((_t = v.value) == null || _t.scrollToIndex(ut)), i.commit("imkit/setState", { navigationTargetId: "" });
      }), Ct(I, () => {
        I.value && (N.value = !1, setTimeout(() => {
          var Ve;
          (Ve = B.value) == null || Ve.focus();
        }, 0));
      }), Ct(_, () => {
        if (R.value.add(5, "second") > Wn()) return;
        R.value = Wn();
        const { socket: Ve, selectedRoomId: ut } = i.state.imkit;
        Ve.emit("typing", ut);
      }), document.addEventListener("visibilitychange", () => {
        document.hidden ? Be = Wn().unix() : Wn().unix() - Be > 60 && (i.state.imkit.socket.connect(), At(d.value));
      });
    });
    const xt = () => {
      const { open: Ve } = Jn({
        component: rPe
      });
      Ve();
    }, Rt = de(() => c.value.memberIds.map(
      (Ve) => {
        var ut;
        return (ut = i.state.imkit.users[Ve]) == null ? void 0 : ut.nickname;
      }
    )), Xt = de(() => {
      var Ve;
      return !((Ve = c.value) != null && Ve.isSuperuser) || c.value.memberIds.length <= 1 ? !1 : c.value.memberIds.filter(
        (ut) => ut !== i.state.imkit.uid && !ut.endsWith("_sub")
      ).reduce((ut, _t) => ut && i.state.imkit.blockedUsers[_t], !0);
    }), { open: jt } = Jn({
      component: JVe,
      attrs: {
        isLinePayEnabled: G.value.linePayEnabled,
        isStripeEnabled: G.value.stripeEnabled,
        isPaypalEnabled: G.value.paypalEnabled
      }
    }), { open: Tt } = Jn({
      component: sWe
    }), bn = () => {
      g.value ? jt() : Tt();
    };
    return (Ve, ut) => {
      var zt, wn, Hn, jn, Y, J, me, Oe, rt, ht, qt;
      const _t = Mc("touch");
      return c.value ? (X(), se("div", {
        key: 0,
        class: "flex h-dvh flex-col bg-white dark:bg-zinc-800",
        onDrop: ar(Ie, ["prevent"]),
        onDragenter: ne,
        onDragover: ne
      }, [
        ee.value ? (X(), gt(RPe, { key: 0 })) : Gt((X(), se("div", {
          key: 1,
          class: "flex h-15 items-center gap-3 border-b border-solid border-gray-200 px-3 py-2.5 select-none dark:border-zinc-700",
          style: Qt((zt = ye.value) == null ? void 0 : zt.header)
        }, [
          r.isTestPreview ? Fe("", !0) : (X(), se(wt, { key: 0 }, [
            p.value ? Fe("", !0) : (X(), se("div", {
              key: 0,
              class: "cursor-pointer rounded-[5px] p-[6px] hover:bg-[#00000033] sm:hidden!",
              style: Qt(`color: ${(Hn = (wn = r.chatStyle) == null ? void 0 : wn.header) == null ? void 0 : Hn.color}`)
            }, [
              et(lWe, { onClick: xe })
            ], 4)),
            c.value.avatars.length === 1 ? (X(), gt(Zr, {
              key: 1,
              url: c.value.avatars[0].url,
              name: c.value.avatars[0].name,
              class: "!h-10 !w-10 !text-lg"
            }, null, 8, ["url", "name"])) : (X(), se("div", fWe, [
              et(Zr, {
                url: c.value.avatars[1].url,
                name: c.value.avatars[1].name,
                class: "absolute top-0 right-0 !h-7 !w-7 rounded-xl !text-base"
              }, null, 8, ["url", "name"]),
              et(Zr, {
                url: c.value.avatars[0].url,
                name: c.value.avatars[0].name,
                class: "absolute bottom-0 left-0 !h-[30px] !w-[30px] rounded-xl border-2 border-white !text-base group-hover:border-gray-100 dark:border-zinc-800"
              }, null, 8, ["url", "name"])
            ]))
          ], 64)),
          W("div", {
            class: vt([
              "overflow-hidden text-base overflow-ellipsis whitespace-nowrap",
              (jn = r.chatStyle) != null && jn.header ? "" : "text-gray-900 dark:text-gray-100"
            ])
          }, [
            W("div", null, [
              An(_e(u.value) + " ", 1),
              c.value.extra.showOnlineStatus ? (X(), se("div", {
                key: 0,
                class: vt(["flex items-center gap-1 text-xs", c.value.extra.agentOnlineStatus ? "text-[#5DD42E]" : ""]),
                style: Qt(
                  c.value.extra.agentOnlineStatus ? "" : `color: ${(J = (Y = r.chatStyle) == null ? void 0 : Y.header) == null ? void 0 : J.color}`
                )
              }, [
                W("div", {
                  class: vt([
                    "h-2 w-2 rounded-full",
                    c.value.extra.agentOnlineStatus ? "bg-[#5DD42E]" : "border border-[#989898] bg-transparent"
                  ]),
                  style: Qt(
                    c.value.extra.agentOnlineStatus ? "" : `border-color: ${(Oe = (me = r.chatStyle) == null ? void 0 : me.header) == null ? void 0 : Oe.color}`
                  )
                }, null, 6),
                An(" " + _e(c.value.extra.agentOnlineStatus ? ke(s)("online-status-online") : ke(s)("online-status-offline")), 1)
              ], 6)) : Fe("", !0)
            ])
          ], 2),
          ut[9] || (ut[9] = W("div", { class: "grow" }, null, -1)),
          G.value.showDarkModeSwitch && !r.isTestPreview ? (X(), gt(ke(eVe), {
            key: 1,
            round: ""
          })) : Fe("", !0),
          G.value.searchInRoomEnabled && !r.isTestPreview && !p.value ? (X(), se("div", {
            key: 2,
            class: "flex h-9 w-9 cursor-pointer items-center justify-center rounded-[5px] hover:bg-[#00000033]",
            onClick: Qe
          }, ut[8] || (ut[8] = [
            W("img", {
              class: "h-6 w-6",
              src: H0
            }, null, -1)
          ]))) : Fe("", !0),
          (c.value.type === ke($a).Group && G.value.showGroupChatRoomInfoButton || c.value.type === ke($a).Direct && G.value.showDirectChatRoomInfoButton) && !r.isTestPreview ? (X(), se("div", {
            key: 3,
            class: "relative flex h-9 w-9 cursor-pointer items-center justify-center rounded-[5px] hover:bg-[#00000033]",
            onClick: ut[0] || (ut[0] = (Bt) => ke(i).commit("imkit/setState", {
              isRoomInfoVisible: !b.value
            }))
          }, [
            et(dWe, {
              color: ((ht = (rt = r.chatStyle) == null ? void 0 : rt.header) == null ? void 0 : ht.color) ?? "#6c727f"
            }, null, 8, ["color"]),
            Jr(Ve.$slots, "setting", {}, void 0, !0)
          ])) : Fe("", !0)
        ], 4)), [
          [_t, xt, "longtap"]
        ]),
        et(ke(z0), {
          ref_key: "vl",
          ref: v,
          class: vt(["grow overflow-auto p-2", { "opacity-0": !U.value && !l.value }]),
          "data-key": "id",
          "data-sources": f.value,
          "data-component": LNe,
          "wrap-class": "flex flex-col",
          "estimated-size": 66,
          keeps: 50,
          onTotop: Ee,
          onTobottom: be
        }, {
          header: Zt(() => [
            l.value ? (X(), se("div", hWe, ut[10] || (ut[10] = [
              W("svg", {
                class: "h-6 w-6 animate-spin fill-blue-400 text-gray-200 dark:fill-sky-700 dark:text-gray-700",
                viewBox: "0 0 100 101",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
              }, [
                W("path", {
                  d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                  fill: "currentColor"
                }),
                W("path", {
                  d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                  fill: "currentFill"
                })
              ], -1)
            ]))) : Fe("", !0)
          ]),
          _: 1
        }, 8, ["class", "data-sources"]),
        W("div", pWe, [
          V.value ? (X(), se("div", {
            key: 0,
            class: "absolute -top-10 right-0 left-0 flex h-10 cursor-pointer items-center bg-gray-200/90 px-3 dark:bg-zinc-600/90",
            onClick: ut[1] || (ut[1] = //@ts-ignore
            (...Bt) => v.value.scrollToBottom && v.value.scrollToBottom(...Bt))
          }, [
            W("span", mWe, _e((qt = c.value.lastMessage) == null ? void 0 : qt.string), 1)
          ])) : Fe("", !0),
          G.value.locationInputEnabled || G.value.audioInputEnabled ? (X(), gt(aVe, {
            key: 1,
            class: vt(["h-12 w-5 shrink-0 transform cursor-pointer fill-slate-500 object-contain transition dark:fill-slate-400", { "rotate-45": N.value }]),
            onClick: ut[2] || (ut[2] = () => {
              N.value ? N.value = !1 : K.value = !0;
            })
          }, null, 8, ["class"])) : Fe("", !0),
          K.value ? Gt((X(), se("div", gWe, [
            G.value.locationInputEnabled ? (X(), se("div", {
              key: 0,
              class: "flex min-w-16 cursor-pointer flex-col items-center justify-center gap-1 p-2",
              onClick: ut[3] || (ut[3] = //@ts-ignore
              (...Bt) => ke(a) && ke(a)(...Bt))
            }, [
              et(uVe, { class: "fill-slate-500 dark:fill-slate-400" }),
              W("div", AWe, _e(Ve.$t("location")), 1)
            ])) : Fe("", !0),
            G.value.audioInputEnabled ? (X(), se("div", {
              key: 1,
              class: "flex min-w-16 cursor-pointer flex-col items-center justify-center gap-1 p-2",
              onClick: ut[4] || (ut[4] = () => {
                K.value = !1, N.value = !0;
              })
            }, [
              et(cVe, { class: "fill-slate-500 dark:fill-slate-400" }),
              W("div", bWe, _e(Ve.$t("audio")), 1)
            ])) : Fe("", !0),
            G.value.paymentEnabled ? (X(), se("div", {
              key: 2,
              class: "flex min-w-16 cursor-pointer flex-col items-center justify-center gap-1 p-2",
              onClick: bn
            }, [
              et(jS, { class: "fill-slate-500 dark:fill-slate-400" }),
              W("div", yWe, _e(Ve.$t("paymentCollectionTitle")), 1)
            ])) : Fe("", !0),
            G.value.paymentEnabled ? (X(), se("div", {
              key: 3,
              class: "flex min-w-16 cursor-pointer flex-col items-center justify-center gap-1 p-2",
              onClick: bn
            }, [
              et(jS, { class: "fill-slate-500 dark:fill-slate-400" }),
              W("div", vWe, _e(Ve.$t("paymentCollectionTitle")), 1)
            ])) : Fe("", !0)
          ])), [
            [
              ke(So),
              () => {
                K.value = !1;
              }
            ]
          ]) : Fe("", !0),
          G.value.audioInputEnabled && N.value ? (X(), gt(EPe, { key: 3 })) : (X(), se("div", TWe, [
            et(W7e),
            Q.value ? (X(), se("div", _We, [
              (X(!0), se(wt, null, on(P.value, (Bt, mr) => (X(), se("div", {
                key: mr,
                class: "cursor-pointer rounded-full bg-gray-100 px-2 py-1 text-center text-xs dark:bg-zinc-700",
                onClick: (wr) => ke(aa)(d.value, Bt.action)
              }, _e(Bt.action.label), 9, EWe))), 128))
            ])) : Fe("", !0),
            W("div", xWe, [
              W("div", wWe, [
                et(NVe, {
                  class: "flex",
                  members: Rt.value
                }, {
                  default: Zt(() => [
                    Gt(W("textarea", {
                      ref_key: "input",
                      ref: B,
                      "onUpdate:modelValue": ut[5] || (ut[5] = (Bt) => _.value = Bt),
                      disabled: Xt.value,
                      type: "text",
                      rows: "1",
                      class: vt(["w-full resize-none bg-gray-100 placeholder-gray-400 outline-none dark:bg-zinc-700", {
                        "cursor-not-allowed": Xt.value
                      }]),
                      placeholder: Xt.value ? Ve.$t("textareaBlockedHint") : Ve.$t("TypeMessage"),
                      onCompositionstart: ut[6] || (ut[6] = (Bt) => D.value = !0),
                      onCompositionend: Te,
                      onKeydown: lh(je, ["enter"]),
                      onInput: We,
                      onPaste: ue
                    }, null, 42, CWe), [
                      [ds, _.value]
                    ])
                  ]),
                  _: 1
                }, 8, ["members"]),
                $.value.length > 0 ? (X(), se("div", SWe, [
                  (X(!0), se(wt, null, on($.value, (Bt, mr) => (X(), se("div", {
                    key: `${Bt.id}-${mr}`,
                    class: "group relative h-12 w-12"
                  }, [
                    W("img", {
                      src: Bt.thumbnailUrl,
                      class: "absolute bottom-0 left-0 h-full w-full rounded-lg bg-gray-200 object-cover dark:bg-zinc-600"
                    }, null, 8, IWe),
                    W("img", {
                      src: NP,
                      class: "absolute -top-2 -right-2 hidden h-5 w-5 cursor-pointer group-hover:block",
                      onClick: (wr) => ie(mr)
                    }, null, 8, kWe)
                  ]))), 128))
                ])) : Fe("", !0)
              ]),
              G.value.stickerInputEnabled ? (X(), se("button", {
                key: 0,
                ref_key: "stickerButtonEl",
                ref: O,
                class: "shrink-0",
                onClick: ar(qe, ["stop"])
              }, [
                et(nVe, { class: "fill-slate-500 dark:fill-slate-400" })
              ], 512)) : Fe("", !0),
              G.value.emojiInputEnabled ? (X(), se("button", {
                key: 1,
                ref_key: "emojiButtonEl",
                ref: T,
                class: "shrink-0",
                onClick: ar($e, ["stop"])
              }, [
                et(vN, { class: "fill-slate-500 dark:fill-slate-400" })
              ], 512)) : Fe("", !0),
              G.value.fileInputEnabled ? (X(), se("button", {
                key: 2,
                class: "shrink-0",
                onClick: Xe
              }, [
                et(iVe, { class: "fill-slate-500 dark:fill-slate-400" }),
                W("input", {
                  ref_key: "fileInput",
                  ref: H,
                  type: "file",
                  multiple: "true",
                  class: "hidden",
                  onChange: at
                }, null, 544)
              ])) : Fe("", !0)
            ]),
            G.value.stickerInputEnabled && S.value ? Gt((X(), gt($Ne, {
              key: 1,
              onClose: ut[7] || (ut[7] = () => {
                S.value = !1;
              })
            }, null, 512)), [
              [ke(So), [
                Ce,
                { ignore: [O.value] }
              ]]
            ]) : Fe("", !0)
          ])),
          G.value.emojiInputEnabled && M.value ? Gt((X(), gt(ke(v7e), {
            key: 5,
            class: vt(["absolute right-2.5 bottom-16 overflow-auto", ke(Nu) ? "is-dark" : "is-light"]),
            native: !0,
            theme: m.value,
            onSelect: ve
          }, null, 8, ["class", "theme"])), [
            [ke(So), [Ne, { ignore: [T.value] }]]
          ]) : Fe("", !0),
          N.value ? Fe("", !0) : (X(), se(wt, { key: 6 }, [
            _.value.length > 0 ? (X(), gt(D0, {
              key: 0,
              class: vt(["my-auto mr-1 ml-0.5 h-6 w-6 cursor-pointer fill-blue-500", { "sm:hidden": !G.value.sendButtonEnabled }]),
              style: Qt(Z.value.sendButtonEnabled),
              onClick: he
            }, null, 8, ["class", "style"])) : (X(), gt(D0, {
              key: 1,
              disabled: _.value.length === 0,
              class: vt(["my-auto mr-1 ml-0.5 h-6 w-6 cursor-not-allowed fill-gray-200 dark:fill-gray-700", { "sm:hidden": !G.value.sendButtonEnabled }]),
              style: Qt(Z.value.sendButtonDisabled)
            }, null, 8, ["disabled", "class", "style"]))
          ], 64))
        ])
      ], 32)) : Fe("", !0);
    };
  }
}), jXe = /* @__PURE__ */ mn(DWe, [["__scopeId", "data-v-60b70405"]]), MWe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKklEQVR4nO3aP0oEMRSA8SfiFl7CPu1AgpV51ovmLeQK9v45gF7Aq6jXEO/gegy1WBlhQZHNvEJQNt8P0kw1fMyEhEQEAAAAAAAAALCtaq27Ue0qqT19jry4HJ/99Xv9C6HWWVK7T2qrbyOXW+ldqHUWc3n4EUdtFdXeh/l8X3oVGnHW41AXB9Kj4IgT1Z5FZEd6ExxxUi6vUe1YOp2Q7ybjHJ0W6U0gzmbEaSBOA3EaiNNAnAbiNAzD2Z5nEZjUTqRHSe2GOA0plxdWyA0xl+XmL6i8dbmF+CqpXfOLNTBJOyNN7th7/90GIk0jkgORHIjkQCQHIjkQyYFjn986OMxl2eXB4RpHzw5cXnDg+ovDeFkq5XKRcnkcR1Q75wIVAAAAAAAAAMg2+AByUSBd2KYVoQAAAABJRU5ErkJggg==", W9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVR4nO3WPQrCMBiA4W+yh/BcniABFyNIsrsnOPRS/kz1KlJ35SsdOkhtRaGp7wOB0pZ3CGlSEQAAAAAAAAAAJsC5sjA+bU2IZxviXUd77fTZrHrr3WFpQ7zakB6vhvGp0ndm0XOuLPpi3eiQmZx6T3SZvIt1opvce2J9ugwOhnjKvScmxHpEsM69J2OCNsRb7j35uyVtQ3Tf3BSm3pP2QK8GxKrVfr/IvdfQQ7sv+smPwpR7DZ0dXRL6HehG0WwWPh313uCZy6gHAAAAAAAAAID8wBNoenSqsgBAfQAAAABJRU5ErkJggg==";
var Vy = { name: "Toggle", emits: ["input", "update:modelValue", "change"], props: { value: { validator: function(t) {
  return (e) => ["number", "string", "boolean"].indexOf(typeof e) !== -1 || e == null;
}, required: !1 }, modelValue: { validator: function(t) {
  return (e) => ["number", "string", "boolean"].indexOf(typeof e) !== -1 || e == null;
}, required: !1 }, id: { type: [String, Number], required: !1, default: "toggle" }, name: { type: [String, Number], required: !1, default: "toggle" }, disabled: { type: Boolean, required: !1, default: !1 }, required: { type: Boolean, required: !1, default: !1 }, falseValue: { type: [String, Number, Boolean], required: !1, default: !1 }, trueValue: { type: [String, Number, Boolean], required: !1, default: !0 }, onLabel: { type: [String, Object], required: !1, default: "" }, offLabel: { type: [String, Object], required: !1, default: "" }, classes: { type: Object, required: !1, default: () => ({}) }, labelledby: { type: String, required: !1 }, describedby: { type: String, required: !1 }, aria: { required: !1, type: Object, default: () => ({}) } }, setup(t, e) {
  const n = function(a, o, u) {
    const { value: c, modelValue: d, falseValue: l, trueValue: f, disabled: p } = Nl(a), m = d && d.value !== void 0 ? d : c, g = de(() => m.value === f.value), y = (v) => {
      o.emit("input", v), o.emit("update:modelValue", v), o.emit("change", v);
    }, b = () => {
      y(f.value);
    }, E = () => {
      y(l.value);
    };
    return [null, void 0, !1, 0, "0", "off"].indexOf(m.value) !== -1 && [l.value, f.value].indexOf(m.value) === -1 && E(), [!0, 1, "1", "on"].indexOf(m.value) !== -1 && [l.value, f.value].indexOf(m.value) === -1 && b(), { externalValue: m, checked: g, update: y, check: b, uncheck: E, handleInput: (v) => {
      y(v.target.checked ? f.value : l.value);
    }, handleClick: () => {
      p.value || (g.value ? E() : b());
    } };
  }(t, e), r = function(a, o, u) {
    const { trueValue: c, falseValue: d, onLabel: l, offLabel: f } = Nl(a), p = u.checked, m = u.update;
    return { label: de(() => {
      let g = p.value ? l.value : f.value;
      return g || (g = "&nbsp;"), g;
    }), toggle: () => {
      m(p.value ? d.value : c.value);
    }, on: () => {
      m(c.value);
    }, off: () => {
      m(d.value);
    } };
  }(t, 0, { checked: n.checked, update: n.update }), i = function(a, o, u) {
    const c = Nl(a), d = c.disabled, l = u.checked, f = de(() => ({ container: "toggle-container", toggle: "toggle", toggleOn: "toggle-on", toggleOff: "toggle-off", toggleOnDisabled: "toggle-on-disabled", toggleOffDisabled: "toggle-off-disabled", handle: "toggle-handle", handleOn: "toggle-handle-on", handleOff: "toggle-handle-off", handleOnDisabled: "toggle-handle-on-disabled", handleOffDisabled: "toggle-handle-off-disabled", label: "toggle-label", ...c.classes.value }));
    return { classList: de(() => ({ container: f.value.container, toggle: [f.value.toggle, d.value ? l.value ? f.value.toggleOnDisabled : f.value.toggleOffDisabled : l.value ? f.value.toggleOn : f.value.toggleOff], handle: [f.value.handle, d.value ? l.value ? f.value.handleOnDisabled : f.value.handleOffDisabled : l.value ? f.value.handleOn : f.value.handleOff], label: f.value.label })) };
  }(t, 0, { checked: n.checked }), s = function(a, o, u) {
    const { disabled: c } = Nl(a), d = u.check, l = u.uncheck, f = u.checked;
    return { handleSpace: () => {
      c.value || (f.value ? l() : d());
    } };
  }(t, 0, { check: n.check, uncheck: n.uncheck, checked: n.checked });
  return { ...n, ...i, ...r, ...s };
} };
const OWe = ["tabindex", "aria-checked", "aria-describedby", "aria-labelledby"], NWe = ["id", "name", "value", "checked", "disabled"], LWe = ["innerHTML"], PWe = ["checked"];
Vy.render = function(t, e, n, r, i, s) {
  return X(), se("div", ea({ class: t.classList.container, tabindex: n.disabled ? void 0 : 0, "aria-checked": t.checked, "aria-describedby": n.describedby, "aria-labelledby": n.labelledby, role: "switch" }, n.aria, { onKeypress: e[1] || (e[1] = lh(ar((...a) => t.handleSpace && t.handleSpace(...a), ["prevent"]), ["space"])) }), [Gt(W("input", { type: "checkbox", id: n.id, name: n.name, value: n.trueValue, checked: t.checked, disabled: n.disabled }, null, 8, NWe), [[Ra, !1]]), W("div", { class: vt(t.classList.toggle), onClick: e[0] || (e[0] = (...a) => t.handleClick && t.handleClick(...a)) }, [W("span", { class: vt(t.classList.handle) }, null, 2), Jr(t.$slots, "label", { checked: t.checked, classList: t.classList }, () => [W("span", { class: vt(t.classList.label), innerHTML: t.label }, null, 10, LWe)]), n.required ? (X(), se("input", { key: 0, type: "checkbox", style: { appearance: "none", height: "1px", margin: "0", padding: "0", fontSize: "0", background: "transparent", position: "absolute", width: "100%", bottom: "0", outline: "none" }, checked: t.checked, "aria-hidden": "true", tabindex: "-1", required: "" }, null, 8, PWe)) : Fe("v-if", !0)], 2)], 16, OWe);
}, Vy.__file = "src/Toggle.vue";
var Sm = { exports: {} }, RWe = Sm.exports, VS;
function BWe() {
  return VS || (VS = 1, function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(RWe, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(r, i, s) {
        var a = i.prototype, o = a.format;
        s.en.formats = n, a.format = function(u) {
          u === void 0 && (u = "YYYY-MM-DDTHH:mm:ssZ");
          var c = this.$locale().formats, d = function(l, f) {
            return l.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(p, m, g) {
              var y = g && g.toUpperCase();
              return m || f[g] || n[g] || f[y].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(b, E, v) {
                return E || v.slice(1);
              });
            });
          }(u, c === void 0 ? {} : c);
          return o.call(this, d);
        };
      };
    });
  }(Sm)), Sm.exports;
}
var FWe = BWe();
const P_ = /* @__PURE__ */ Fr(FWe), UWe = {
  key: 0,
  class: "relative flex flex-col items-center gap-4"
}, $We = { class: "text-center text-lg font-medium text-gray-900 dark:text-gray-100" }, HWe = { class: "text-center text-sm text-gray-500 dark:text-gray-400" }, jWe = { class: "flex w-full gap-3" }, zWe = ["disabled"], qWe = {
  key: 1,
  class: "relative flex flex-col items-center gap-4"
}, VWe = { class: "text-center text-lg font-medium text-gray-900 dark:text-gray-100" }, WWe = { class: "text-center text-sm text-gray-500 dark:text-gray-400" }, QWe = { class: "flex w-full gap-3" }, GWe = /* @__PURE__ */ Ze({
  __name: "MoveOutConfirmModal",
  props: {
    memberIdToMoveOut: {},
    roomId: {}
  },
  setup(t) {
    const e = t, n = $n(), r = Yt(), i = de(() => r.state.imkit.users), s = Se(!1), a = Se(!1), o = () => {
      n.closeAll();
    }, u = async () => {
      if (e.memberIdToMoveOut) {
        a.value = !0;
        try {
          await r.dispatch("imkit/removeMembers", {
            roomId: e.roomId,
            uids: [e.memberIdToMoveOut]
          }), n.closeAll();
        } catch (d) {
          console.error("Failed to remove member:", d), s.value = !0;
        } finally {
          a.value = !1;
        }
      }
    }, c = () => {
      s.value = !1, n.closeAll();
    };
    return (d, l) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col items-center gap-5 max-w-[350px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        s.value ? (X(), se("div", qWe, [
          et(Br, {
            class: "absolute right-0 h-7 w-7 cursor-pointer",
            onClick: c
          }),
          et(Jf),
          W("div", VWe, _e(d.$t("kickOutErrorTitle")), 1),
          W("div", WWe, _e(d.$t("kickOutErrorDesc")), 1),
          W("div", QWe, [
            W("button", {
              class: "w-full rounded-md bg-[#EF4444] px-4 py-2 text-white",
              onClick: c
            }, _e(d.$t("confirm")), 1)
          ])
        ])) : (X(), se("div", UWe, [
          et(Br, {
            class: "absolute right-0 h-7 w-7 cursor-pointer",
            onClick: o
          }),
          et(Jf),
          W("div", $We, _e(d.$t("kickOutConfirmTitle", [i.value[d.memberIdToMoveOut].nickname])), 1),
          W("div", HWe, _e(d.$t("kickOutConfirmTip")), 1),
          W("div", jWe, [
            W("button", {
              class: "w-1/2 rounded-md border border-gray-300 px-4 py-2 text-gray-700 hover:bg-gray-50 dark:border-zinc-600 dark:text-gray-300 dark:hover:bg-zinc-700",
              onClick: o
            }, _e(d.$t("cancel")), 1),
            W("button", {
              class: vt(["flex w-1/2 items-center justify-center gap-2 rounded-md px-4 py-2 text-white", a.value ? "cursor-not-allowed bg-red-300" : "bg-[#EF4444]"]),
              disabled: a.value,
              onClick: u
            }, [
              a.value ? (X(), gt(_c, {
                key: 0,
                class: vt(["h-4 w-4", a.value ? "fill-red-300! text-white!" : "fill-red-500"])
              }, null, 8, ["class"])) : Fe("", !0),
              An(" " + _e(d.$t("kickOutGroup")), 1)
            ], 10, zWe)
          ])
        ]))
      ]),
      _: 1
    }));
  }
}), YWe = { class: "absolute inset-0 flex w-full flex-col divide-y divide-gray-200 bg-white sm:relative sm:w-[250px] sm:max-w-[250px] sm:min-w-[250px] dark:divide-zinc-700 dark:bg-zinc-800" }, XWe = { class: "flex h-15 items-center gap-4 px-3" }, KWe = {
  key: 1,
  class: "relative h-10 w-10"
}, ZWe = { class: "overflow-hidden text-base text-ellipsis whitespace-nowrap text-gray-900 dark:text-gray-200" }, JWe = {
  key: 0,
  class: "flex flex-col gap-2 p-4"
}, eQe = { class: "flex items-center justify-between text-base font-medium" }, tQe = { class: "text-sm text-gray-500 dark:text-gray-300" }, nQe = { class: "flex flex-col gap-4 overflow-auto p-4" }, rQe = { class: "mb-2 text-base text-gray-500 dark:text-gray-300" }, iQe = { class: "flex flex-col gap-3" }, sQe = { class: "relative h-[50px] w-[50px]" }, aQe = { class: "flex flex-col overflow-hidden text-base text-ellipsis whitespace-nowrap" }, oQe = { class: "text-base text-gray-900 dark:text-gray-100" }, uQe = {
  key: 0,
  class: "text-sm text-gray-500 dark:text-gray-400"
}, lQe = {
  key: 0,
  class: "relative ml-auto"
}, cQe = ["onClick"], dQe = {
  key: 0,
  class: "ring-opacity-5 absolute right-0 z-10 mt-2 min-w-[150px] rounded-md bg-white shadow-lg ring-1 ring-black"
}, fQe = {
  class: "py-1",
  role: "menu",
  "aria-orientation": "vertical",
  "aria-labelledby": "options-menu"
}, hQe = ["onClick"], pQe = ["onClick"], mQe = ["onClick"], gQe = { class: "text-gray-500 dark:text-gray-300" }, AQe = { class: "text-gray-500 dark:text-gray-300" }, bQe = ["src"], yQe = /* @__PURE__ */ Ze({
  __name: "ChatRoomInfo",
  setup(t) {
    Wn.extend(P_);
    const e = Yt(), n = de(
      () => e.state.imkit.rooms[e.state.imkit.selectedRoomId]
    ), r = Se(!0), i = de(() => e.state.imkit.users), s = de(() => e.state.imkit.uid), a = de(() => e.state.imkit.config.settings), o = de(
      () => e.state.imkit.config.settings.customRoomInfoIframeUrl
    ), u = de(
      () => e.state.imkit.config.settings.customRoomInfoIframeUrl + `?roomId=${e.state.imkit.selectedRoomId}`
    ), c = de(() => e.state.imkit.blockedUsers), d = de(() => n.value.type === "group"), l = () => {
      e.commit("imkit/setState", { isRoomInfoVisible: !1 });
    }, f = (D) => {
      e.dispatch("imkit/blockUser", {
        roomId: n.value.id,
        uid: D
      });
    }, p = (D) => {
      e.dispatch("imkit/unblockUser", {
        roomId: n.value.id,
        uid: D
      });
    }, m = de(
      () => !!e.state.imkit.isRequesting[`/blockStatus/room/${n.value.id}`]
    ), g = Se({}), y = (D) => {
      const { open: S } = Jn({
        component: GWe,
        attrs: {
          memberIdToMoveOut: D,
          roomId: n.value.id
        }
      });
      S(), b(D);
    }, b = (D) => {
      for (const S in g.value)
        S !== D && (g.value[S] = !1);
      g.value[D] = !g.value[D];
    }, E = () => {
      for (const D in g.value)
        g.value[D] = !1;
    }, v = (D) => m.value || D === s.value || D.endsWith("_sub") || D === "BOT" ? !1 : n.value.type === $a.Direct ? !0 : n.value.isSuperuser, _ = async (D) => {
      r.value = D, await e.state.imkit.config.callbacks.onChatbotStateChange(
        n.value.id,
        D
      ) || (r.value = !D);
    };
    return Ct(
      n,
      () => {
        r.value = n.value.extra.isOpenBot ?? !1;
      },
      { immediate: !0 }
    ), (D, S) => (X(), se("div", YWe, [
      W("div", XWe, [
        W("img", {
          src: MWe,
          class: "cursor-pointer sm:hidden",
          width: "36",
          height: "36",
          onClick: l
        }),
        n.value.avatars.length === 1 ? (X(), gt(Zr, {
          key: 0,
          url: n.value.avatars[0].url,
          name: n.value.avatars[0].name,
          class: "h-10! w-10! text-lg!"
        }, null, 8, ["url", "name"])) : (X(), se("div", KWe, [
          et(Zr, {
            url: n.value.avatars[1].url,
            name: n.value.avatars[1].name,
            class: "absolute top-0 right-0 h-7! w-7! rounded-xl text-base!"
          }, null, 8, ["url", "name"]),
          et(Zr, {
            url: n.value.avatars[0].url,
            name: n.value.avatars[0].name,
            class: "absolute bottom-0 left-0 h-[30px]! w-[30px]! rounded-xl border-2 border-white text-base! group-hover:border-gray-100 dark:border-zinc-800"
          }, null, 8, ["url", "name"])
        ])),
        W("div", ZWe, _e(n.value.displayName), 1)
      ]),
      Jr(D.$slots, "default", {}, void 0, !0),
      n.value.extra.bindBot && (n.value.isSuperuser || s.value.endsWith("_sub")) ? (X(), se("div", JWe, [
        W("div", eQe, [
          An(_e(D.$t("chatbotSwitch")) + " ", 1),
          et(ke(Vy), {
            value: r.value,
            classes: {
              toggleOn: "bg-green-500 !border-green-500",
              toggleOff: "bg-[#e5e7eb] !border-[#e5e7eb] dark:bg-[#3f3f46] dark:!border-[#3f3f46]"
            },
            onChange: _
          }, null, 8, ["value"])
        ]),
        W("div", tQe, _e(D.$t("chatbotSwitchDescription")), 1)
      ])) : Fe("", !0),
      Jr(D.$slots, "afterChatbotSwitch", {}, void 0, !0),
      W("div", nQe, [
        W("div", null, [
          W("div", rQe, _e(D.$t("members")), 1),
          W("div", iQe, [
            (X(!0), se(wt, null, on(n.value.memberIds, (M) => (X(), se("div", {
              key: M,
              class: "flex items-center gap-4"
            }, [
              W("div", sQe, [
                et(Zr, {
                  url: i.value[M].avatarUrl ?? "",
                  name: i.value[M].nickname,
                  class: "relative h-[50px] w-[50px] text-lg"
                }, null, 8, ["url", "name"])
              ]),
              W("div", aQe, [
                W("div", oQe, _e(i.value[M].nickname), 1),
                i.value[M].city && i.value[M].country ? (X(), se("div", uQe, _e(i.value[M].city) + ", " + _e(i.value[M].country), 1)) : Fe("", !0)
              ]),
              v(M) || d.value && M !== s.value ? Gt((X(), se("div", lQe, [
                W("button", {
                  class: "flex h-8 w-8 items-center justify-center rounded-full hover:scale-110 hover:transform hover:bg-gray-100 hover:transition sm:group-hover:flex dark:bg-zinc-800",
                  onClick: (O) => b(M)
                }, S[1] || (S[1] = [
                  W("img", {
                    width: "20",
                    height: "20",
                    src: W9
                  }, null, -1)
                ]), 8, cQe),
                g.value[M] ? (X(), se("div", dQe, [
                  W("div", fQe, [
                    d.value && M !== s.value ? (X(), se("button", {
                      key: 0,
                      class: "block w-full px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-100",
                      role: "menuitem",
                      onClick: (O) => y(M)
                    }, _e(D.$t("moveOut")), 9, hQe)) : Fe("", !0),
                    v(M) ? (X(), se(wt, { key: 1 }, [
                      c.value[M] ? (X(), se("button", {
                        key: 0,
                        class: "block w-full px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-100",
                        role: "menuitem",
                        onClick: (O) => (p(M), b(M))
                      }, _e(D.$t("unblock")), 9, pQe)) : (X(), se("button", {
                        key: 1,
                        class: "block w-full px-4 py-2 text-left text-sm text-gray-700 text-red-500 hover:bg-gray-100",
                        role: "menuitem",
                        onClick: (O) => (f(M), b(M))
                      }, _e(D.$t("block")), 9, mQe))
                    ], 64)) : Fe("", !0)
                  ])
                ])) : Fe("", !0)
              ])), [
                [ke(So), E]
              ]) : Fe("", !0)
            ]))), 128))
          ])
        ]),
        W("div", null, [
          W("div", gQe, _e(D.$t("createdAt")) + " " + _e(ke(Wn)(n.value.createdAt).format("lll")), 1),
          W("div", AQe, _e(D.$t("updatedAt")) + " " + _e(ke(Wn)(n.value.updatedAt).format("lll")), 1)
        ]),
        !n.value.isSuperuser && a.value.showLeaveRoomButton && !s.value.endsWith("_sub") ? (X(), se("button", {
          key: 0,
          class: "w-full rounded-lg border p-2 text-gray-500 dark:text-gray-300",
          onClick: S[0] || (S[0] = (M) => ke(e).dispatch("imkit/removeMembers", {
            roomId: n.value.id,
            uids: [s.value]
          }))
        }, _e(D.$t("leaveGroup")), 1)) : Fe("", !0),
        o.value ? (X(), se("iframe", {
          key: 1,
          src: u.value,
          frameborder: "0"
        }, null, 8, bQe)) : Fe("", !0)
      ])
    ]));
  }
}), zXe = /* @__PURE__ */ mn(yQe, [["__scopeId", "data-v-7ffa7d2c"]]), vQe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAADHoAAAM5CAYAAADCZ7d8AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAOgHSURBVHgB7N0LlGT3XR/43/9fPU+NpLYsy8KA1SYKGIGtFiLGPomn7zgkmDWSpr1Y62UDGi2bBJKzq3GyZ3PyONGIPM+SrORw8tjsyRnpbF7ISXoexoKzwJQIwSHHoDHGTnhs3GYNGNuYlixpRjNd97/3VvdI857pdz0+H6m6br2mu2/XrfrfW7/v/xcBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyQFMBo+4nq9leXt23Lcfbsba9ervP2qOtbLrh/J23vnE03R6fuvHa/kkpKN0Wqd17y75eSI6Xb4qrSniixJ1ah+c7Nz5e2B3BtJb7cvLEvxkrl8uXmsVd/XIoXm/u8eOn3TGdTSl+59AH1y72SX3jte9R15PzF126f6MX2eD7OLJ7pX9wdp2NfdyEAAAAAAAAAAAAAxpygB2yEE9VE3PjVFF98PseLX7ctdtyU4pWXc9z0UifO7six/UyO57fn2BMTcaZOsW0iR27Oy9mlUEbZNhml3h11vilK9MMVOWLptlTf3Gy5O6NOnUjl5tIPQZTtUdK5wMZEc7r1vJ9m4qKf7qqXU/t/ar5dufj1oTQ/QspxOemSf/OihzaPSyXHatTNz9L+PMC1pVWEPJZc+3El1c2X+rofX0pdUqqvcb9ee8/+Umq29hJL9y/N9bk833zPM/3vmVIbGDndv1tKzzcvDKea2041L0kvRt3eHgt1aW5PzWNSc/2SLzevHC82p4Xlf3Mxcq8XL3SWvt+u5vK2V+o4taOOs83yrq/WsefGOr70xTo+8+BiHDp0pd8VAAAAAAAAAAAAYEMJesD1evqu7bHnxp2xa9fuWMg3xLZ6V5zt7Y6Jzvbo9W6I0tkVqd4RKe9szt8QdZ6INspRym050vYScUOkckPzL93YnNrwxp6oyy0ppe1R2ttiWwCwIUob/Ih4uXmtfbkNocRSF5IXm6HQ6ea23486vRy5vNxcbu7T+/0o+aW2K0lz3UvR6/RiW+9UvBKnYlvn5ai3vxTbT52OU189FWfPvBwPfuZMAAAAAAAAAAAAAKwTQQ9ofeLebfHVG2+IF/tdM27v1OmGqMsbSq5fH7nz+qh7r4uSbiq5H9DYHSV25xS7+uGNEstBjbQrouxo7rdj1d0rABgkbReRl5rT2eXll5uB08t1pJea1/lX2q4iKZWXoo728u9F5IWUYqG5/g96OX0+on4hzjTvLJ+qfkeHEAAAAAAAAAAAAOB6CXowPj72HTdF76Y3Rpz9llzH10UpX9NsAV9XIr4xotzSbA67mnttazaKbc31ubm9E5EnmvO200anfx0AXKp5K0lnm7Nes9xrLvVK6odDFpvr6ub943SU9MXmXeR3Uyn/X13yf46c/2vEmd+LxYnPxWx3IQAAAAAAAAAAAACWCXowvJ7+QCdu/rWd8fwtN0au29Pu6KQ9MRG3xtnOt+Yobyw5vj6ivCnquDOldEsAwEBJdUT95RLx5cjx2dRLv1534gtRp99qrv+d5g5fjZxPRUy8HJ1tC/Hi507Hg585EwAAAAAAAAAAAMDIEvRgOBy/d3ekXbdHmXhTc+nWKOW2HHFHlLi1lPiayOWNzdP51lSivX1nAMCwK3Gq5PhSc/6VKOn3U475SOX3o9S/W0f6nag7n+tf3nbqi/Hf/OILAQAAAAAAAAAAAIwEQQ8Gz9N3bY89r78zehNTua6/pbnm7SWlr2/OJ1MpNzbnu5unbnNebggAGD+nmvfBF5r3wedLxOko8VIzovt8ivJrqXR+ozcRn44vlU/Hw93TAQAAAAAAAAAAAAwdQQ+2xtPv2hVxw/a46ZXdcaq3Oya2vy3XMR2pfGOJ5rzEZPPk3BZtd47UnEp0wvMVAC6vRB0pnWoWzvbDHxG/37xr/kaK9Gt11L/c7/7RSZ+PbadOxY4dL8eX3nA2HvxILwAAAAAAAAAAAICBo3CezfGx77gpzuz5ushnb28u3RqR355KfFNEfVeKfIfuHACwoRab0xdKic+UiE9Hp/y/UXfmo+TPRn3qy/Erv/DlOBR1AAAAAAAAAAAAAFtO0ION87E/flen17ur1PXdJdJbc4o3l4jbo8Qtza17AgDYIqkXqTzfvCfPlxRfSCX9RurUv9KLzidjR+c340/89PMBAAAAAAAAAAAAbAlBD9bPiWpnvNSbyb303hLxruaar08l3RA5dkSJnQEADKpeczrVnE437+ELKcV/qkv+t5HTL8Z9P/vbAQAAAAAAAAAAAGwaQQ9WrjTPm2e+48Y4u+u2iLNvybHtO0qqvzPV8W2R0o3BYLloKy8X314u95B0uSsvf+crXruaO13h2wLXZZWb2XVvaOlK15bL/zTlGv9AuvQhDJoSZyPHr0VJP1On8ovRS/85dsSX48UvfjEe/MyZAAAAAAAAAAAAANadGmqu309Ut0cdb811fXfz1Pm2EvGNqTmPKNuDC523ZZVy/sVmKS1VMpflL+lKj3v1y7mb0mu3pPPuc9H9LvpnAIbWBS9t6YKz5sZ0wT3LBTdemk0rl/t3lh/0aiQlXTXTRsRic/p8s75+rXlP+uU60mcip0/FnvLp2NddDAAAAAAAAAAAAGBdqAfn6o7ftzvKi38kR9lfUrwr1eVrm2fNrVFiZ4yjcwGL8wMa6TKhjdUGPQDYEKsJepz/mKXrU5wfKhnzUEivOf1BpPR7zRvdp+pcPxt156fjn7/hs/GRj/QCAAAAAAAAAAAAWDU15rymNM+Hj1Q3xI6zN0Xa/odz6X2wueqdzS23pxSTze07YpSfMxcENpYCGed31bCxAHAlr3UUSf08X0mvJUDSqIdBUiw2K+B08675QqT0yznSv+3l+ERMvPI7sWPHC7p9AAAAAAAAAAAAwMqoXWfJT/zxb4xe723Rq9+VcnpvivSHI8r2GCUXdONIy8GOoqsGABvu/C4gpbzW3WmEQyALza/58yXqn42oPx6n61+PBz/+lQAAAAAAAAAAAACuSX37OJurJmMivyOXxe8uJd2dUrk76jwZqeQYFv2K2aXzcl5g47wa2v6yMAcAg2zprWzpDeuC97A47/3r3HvecDnbnH6r+dE/2fxe3bqkZ+KB7m8GAAAAAAAAAAAAcEVq38fRT739hnz25h8odX4wlXhblHhd80wY+HDHZQtfrxD0AIBRcKWgx7n3xPPfGwdc+y59pkT5UjPi+Hgp+R/GjeU/xL7uYgAAAAAAAAAAAAAXUBc/Dg5Fjne++41Rp2/Oi+n7o5T3NX/6W2NQ//7ptQnL+zWtAhwAcFVlOf24FP4oQxH+aH7E/5hK+bd1yT/dXJyP2e5CAAAAAAAAAAAAAOrnR9rTH+jE9i98U47OvpLL96S6vCNSuiUGyAUzlcdQzUwOAANt6T32XOuPc9defHnLtR09Ph91ebaeKEciOj8f93W/HAAAAAAAAAAAADDGBD1G1dHqzpzL/xglZqOUNzd/6t2xlfqtOS69fHHQAwDYSOnVjh8DF65M6bdLlN9IJR2pX4l/Fg92XwwAAAAAAAAAAAAYQ2rsR0Vp/pbPfPeNcealO3IuHywlvz+lmGqu3xlbZfnZVYonGgAMsn7wMl10xVYoUTeDhpdLik80P86/qzu9n4rdE/819nUXAwAAAAAAAAAAAMaE+vth1wY8Plq9Puq0N6dyX5Syv7l2MrZIWX5GDdQM4QDAivS7fbx6IbbSbzWDiqfrkn88bopfjX3d0wEAAAAAAAAAAAAjTtBjyHU+uvf+qNNDJWJvlHh9bObftP1Oy8Wf/YJQ4Q4AGF3nve9vwff+1eab/3Rd8r+I56pfjkOH6gAAAAAAAAAAAIARJegxrI5Wd+ZU//mo0/dGSm+KKDk22Kuze58r8tzKgk8AYNy82Iw7fjNS+Wi94+zj8d6PfyUAAAAAAAAAAABgBAl6DJOn79oeO974lijl4ZzKQ801t8cmKCktd+uQ6gAALlWWR5Sb1t0rxRea7/pEvbhtLt7/M78eAAAAAAAAAAAAMEIEPYZBaf5OP1ndkc+W7ysRfyqV+ObYIP36zLRUqFnCEwQAuH4lbWLYI+J0ifKLKfK/rvPEx+K+n/6tAAAAAAAAAAAAgBGgjn8IdD767j8Vvc4jJeJtEWVHbIByXrgjNrdIEwBgLRaaYcvPl5z+fuyJn4993cUAAAAAAAAAAACAISboMaiO37s78o3fmBfrPxslHoyUXhfr/Pcq/X8tRSpSHQDABkvL3cI2ZNiRzjT/+gvNP/7P65T/Vpz64gvx4GfOBAAAAAAAAAAAAAwhQY9BdKK6NV5IP5Cj/nPNpT8UG2FDiy0BAK7k3PBzwwYhv9l8jw/XOf513Nf9cgAAAAAAAAAAAMCQEfQYJCeqiVio35Mm0g+lunxX8+fZHeulDXaUpXPhDgBgq5WNHJOk8pVU0s/m3PnRs/f97H8KAAAAAAAAAAAAGCKCHoPiRDXReTF9X6nLX48o69/Fo/1LC3gAAANq/YMf5UyK9Cu9SH8/8lePxX2/9HIAAAAAAAAAAADAEBD02Gonqp3xfLo75d6PpJL+ZKyTsvyX1b0DABhv6eUU5Vg/8PHKF38lHvzMmQAAAAAAAAAAAIABJuixlT72HTfls7t+IFJ5JErcGetk/WfEBgAYbs346DPN8OjDcTr9y3iw+2IAAAAAAAAAAADAgBL02CrH79udywv/pFl6X5S4JQAAuLx2xLouIdb0+5HKj9en09+IB7tfCAAAAAAAAAAAABhAgh6b7WN37ogzXz+dOvVfTyXeEyV2xlqsW+EjAMAAOzdqXeu4J8XpUuITpU7/c5x9w6fiwY/0AgAAAAAAAAAAAAaIoMdm+th33NR5Zdf7Sy5/tbl0ZwAAsDLrFXIt6XN1qn8k6vzvYra7EAAAAAAAAAAAADAgOsHmmKsmc+n8zUjx55pLU7FKpS1uTBI6AABrkmIyRZpJObaX2Td9PD7y+cUAAAAAAAAAAACAASAvsBl+8l235Fe2t108frg57Yo1aIMeaT1msQYAoPWlZoT1TL3j7IfivR//SgAAAAAAAAAAAMAWE/TYaMff/Y5OyX+nlJiJ1XZQaf9Kwh0AAJd3bkS7hvFS89B/Xxbrg3FL51diX1d3DwAAAAAAAAAAALZMDjbOseqdnZJ+rJR4T6wm5JGWOngIeQAAXEVZPq0hwpwi/dE0kf/PeKG+PwAAAAAAAAAAAGAL6eixUY6+Z29OvR+LEm+PFWrDHUm4AwBg86X47ZTKX+zd93M/HgAAAAAAAAAAALAFBD3W26FDeeLen9nXqzt/P0W5O1ZIyAMAYMvNp076y72XXzkaD378VAAAAAAAAAAAAMAm6gTr5xP3bos9v/ODUdKPpYg7Y4WEPAAA1tnqYs2TUeKdafvES+X7Xv/p+Fe/ezYAAAAAAAAAAABgkwh6rJdP3Lstf37PD6eIv91cujVWSsgDAGDjrDzwcVOU+LaUt50t//JzHw8AAAAAAAAAAADYJIIe6+HpD3Q6p868PyL9tebS7St67OpmmQYAYCVWN+baEyW9vXzf1O/Ev/rcrwYAAAAAAAAAAABsAjGD9XB07/tzpH8YKwx5FF08AAA2Vzv6Xen4K8VXmkHbj9Tx0v8V9/3SywEAAAAAAAAAAAAbSEePtfqJdz+Q6/yjzdKbr/sx6YIzAAA2UT9su6JHxK7mQdOlbH8+3v+mT8dHPr8YAAAAAAAAAAAAsEFysHo/UU13FvNfa5buvO7HrGYWaQAA1s0qO6rd3gyc/0pn98QDAQAAAAAAAAAAABtIU4lV2nZs5o8sRvyDVOKdAQDAcFp5CHc+dXr/W+/lrxyNBz9zJgAAAAAAAAAAAGCddYKVO/6db05RPxElZgIAgKHW5jxWkH6eLCV/S2zb/emYfcdvxUc+o1cbAAAAAAAAAAAA6yoHKzNXTeZy9u+WiPdc1/31TAEAGGgrHa6lSG/tlPRXY9tvTwUAAAAAAAAAAACsM0GPlXj6ru051X8pSvpvo8TENe/fVg2a4xkAYMSUXKL8sdTZ9kT8wrt2BQAAAAAAAAAAAKwjQY/rdbja2dn1hocipx+MKNuveX8hDwCA4XRdLT7S9lTie/KXtv/TtuNbAAAAAAAAAAAAwDrpBNf29Ac6cdOL704l/b3m0tde8/5CHgAAw+26wh59b065nC6zb/lkfGT+TAAAAAAAAAAAAMAa6ehxPXb+3ptTyf9LszR1XfcX8gAAGG7teO76wh6TUdKfju357XHokLE1AAAAAAAAAAAAa6YY7VoOVztzpB9JqbwvAAAYH9cf9viGnHr/PO7+mW8PAAAAAAAAAAAAWCNBj6s5UU3kW+o/3yx9b5SYCAAAxsv1hT3ae7wl5fyX4unq9gAAAAAAAAAAAIA1EPS4khJp4qv13oj0Q83yzqve9/pmegYAYBhdZ2eP5i7flXeVh9uOcAEAAAAAAAAAAACrJOhxJR+9d1cd6QejxDdc9X5t0V8JAABG2fWFPXaXOj4Yt+R3BAAAAAAAAAAAAKySoMflPH3X9ty78X+PEt8X6SrrSMgDAGB8XDvskZqb395Jvb8cc9VUAAAAAAAAAAAAwCoIelzOjtveE6n+/mveT8gDAGC8XEdnj1Livc0o+2AAAAAAAAAAAADAKgh6XOwn3/01KcoPR6SbAgAALnYdYd8c5UAcq94ZAAAAAAAAAAAAsEKCHuc7XO3MZ/IHU8S7AwAAVu/mVOq/F8e/880BAAAAAAAAAAAAKyDocc6hZl3ctnh3s/RnmtPrAgAA1iCldG/unf3B+Ad37ggAAAAAAAAAAAC4ToIe59zzR2/Ii/lAlHjrFe+TAgAAXlWuNj4ssbMZP/5A3PHGtzXLRpIAAAAAAAAAAABcF0GPZZ0y8Z3N6vjvr3qnEgAA8KrUjg+vGuFIb85p4s/GR+99fQAAAAAAAAAAAMB1EPRozVWTJZW/GVFuDgAAWImrhoFLbm7/n6K+8XsDAAAAAAAAAAAAroOgx9N3bc8T9Q9FpLdc6S4lBQAAXN1Vxowp1X86jn/nmwMAAAAAAAAAAACuYSLG3e7bvrEsxv6Uys4r3SWVAACAVUslfVMqZz9Yn6j+j9jXXQwAAAAAABhXc9VkbI+pqJtTiclcmvOIyeZg+s3tzSX6l68qRcz3F0r6XHNhoU79ywuxGCdjtrsQAAAAMOTGO+hxoprIz9fvjZTviavOwQwAANdw9XDwDc3pg9teqP+fsxHPBQAAAAAAjLo20DER07nEdHMQ/e7SnKd+iKNMxuWmRFo+zr6y4o3S/z+fO0afm9PRmYWS4mSztJAiPVu3y/d1uwEAAABDZLzDDUerO3OUZ5qlOy97e7t2dPMAAOA6leXR9RU6wi02HzD9nfrUmb8TD378VAAAAAAAwCg5F+yoY39J5e7mWHkVA6Q5ht9NJX2yznFE8AMAAIBBN95BjyPV/5pT+dEAAIDN8ak6L35P3PcffisAAAAAAGDYteGOTuxPUR5K/c4dMRnDoe360c2RjvZ6cSRmuwsBAAAAA2R8gx4/+V235DOnfyNK3HLpjVp5AACweu1I8vID7dSL6D1WP/Dv/0YAAAAAAMCwOl5VqZRHhyzccWUpnqxTekqnDwAAAAbFeAY9TlQT+YX4uxHlL158U2nWSJLxAABgza4cHq7LtrfH/p/+VAAAAAAAwLCYqybzRP1I1OlAc2kqRtN8SumxXi+6MdudDwAAANgi4xn0mKumcy7/qll6awAAwGYr8WP1zekvxL7uYgAAAAAAwCB7LeBxMEahe8f1mY9cnqwX81MCHwAAAGyFHOPm6bu251S/t1n6ugAAgC1QctoXX03fFAAAAAAAMMDy8b2P5Fw+G3U6FOMT8mhNtb9z87ufaNbBowEAAACbbPyCHttuu6v5+mBz2nPxTWU8+5sAALDJUolvzql8b3zgA50AAAAAAIBBM1dN56MzJ6NOT8R4BTwuthT4ODrz2c6x6kAAAADAJhmvoMeJamfzG78zUrrnkttKv+AOAADW12XDxKUTdXwgHvrSNzfjUHFjAAAAAAAGxnIXj+eaxbuDc6ZKKYfzsZnDMVdNBQAAAGyw8SoqO17d2inl/y4l3hsAALBJ2s5xlwkVL0aJv1j/Qfqn8XD3dADrY66ajJ0x2Wxh0802NplLTPWvT+WOgJKeb74uXHBdioX63HUp5vvnubncnr67Ox8AAABc6tz+d718amf7L0sz/ufzll91rf3ya++vLbx6+8Tyvpt9Nlh/zbadOmWuOZ5dBVczn1J6rHd/98kAAACADTJWQY/Okep7S4p/0Rwp3B4AALBJrhD0aK5Pz5bT8cF4sPuFAFbneFXlEtPNFnV3aT6Abja3qYB11ryEz0dbUJRiIbXLJX2uX3CUlq9fjJMx210IAACAYfdMNdUPbvRiejmwMdUc2Lq5tPvby5MpDNq+d3+fbTm4v7zP9nx7+dV9tjYYIhQC1zZXTeVcToTja9cvl0P1fT/3WAAAAMAGGJ+gx4lqIn21/FQq8Z4Lbzi3CkoAAMBmqyP9cDzQ/ScBXL9+uKM81OzG7Y+4aIZQ2DoL54qL0lIQpC0qOikEAgAADJw2zLEY0/0umM2ptN02SkyPweQJC6XdT2vOm/22T/aDIO3JfhsIeaxB87pypPTSw15HAAAAWG/jE/T4d9Ufy50y1yzdGgAAMCBKlF8sX/vSu+Pbf+lsAFc2V03mifqRqNPBEO5g+PSLidpCIgEQAABg0zT70jHRD3Sc64R5Lsxhv/pS9tsYX0Iea1YiTpY67fOaAQAAwHoam6BHPlr9tWb3ujnFjgAAgMHxe3Wk74kHup8I4FICHoywtggg9WeTTZ+sO9GN93VPBgAAwGpcGuqoxqBDx2Y4FwB5ts6vhj/mA0ZFe+wtl+fC68WaNa8V3XL/s/sCAAAA1sl4BD2OVnemqP9ZirT3whvaX78EAABsnVRH1P+ovil/KPZ1FwN4VT6+91EBD8bM+QVE3biv2w0AAIDLWQp2VLmOqkSZaT71nA42y3x/3y2afbc2vG/fjSGWj1ZPRpSHgvWRyhP1/T/3oQAAAIB1MPpBjxPVROeF+N7mAOc/DsVBAABstVT6U3udr7nmP5acHm4+FP4vAbTFKtM5l7kwkyD0Z4NMkY4qHgIAgDF3rmNHHfsFOwZPf99NaJ8h05mrDpRcDgfrK6UP1fd3nwgAAABYo9EPejz9Xbfkbaf/auT4CxfeoJsHAACDIj2fUv1ner/8c/8mDkUdMMby8b2PRJ18EAqXN98czujWKR2NxejGbHchAACA0fVMNZXP9oMdD6TSD3aY1G44LCx3/Dhad5p9t/d1TwYMmrnm9SWXE2GilY2wUNfpnua4zXwAAADAGox+0OPo3ntySv8mSnxDAADAQEp1RP2P6t7i34j3/8IXA8ZUPrb38SjpYADXpZ0xNkd6qtfrhz7mAwAAGH7HqypHPVPqtF/XjpFxLrT/lG4fDIp8fO+jUadDwYZojtkcKfc/OxsAAACwBmMQ9Jj5yznibwcAAAyMc8PwCzrMzdel/A+x/+d+IWDczFWTqVPmUokqgFUR+gAAgCH2WrjjQDK7/qhbaA4NHkmRnm32347o1MiWaI7F5VyeC683G6qu075mG+8GAAAArNJEjLgc8WAAAMBAKZe7ciqn/J46QtCD8bL0wXK32SzuDmDV2qBUiVLl5kBIOTZzJEc62ru/+2QAAACDqd0fnqgfKSVVqS5VOzHI6M/QR2OyOQZyoNl/O9Dsvx22/8ZW6ETsL0IeG67Zxvc3x/u7AQAAAKs02scL56qpnOtPN7/m7gAAgAHXzsZe7n92X8AYyUdnTjZnQh6wMeabIz/dupce0+UDAAAGwFw1GRNRpVIe0dWSi/Q7fdQpPRX36QDAxkrHZk54DdoUC3Wd3qJzDwAAAKs10kGPfGzmr0SJvxUAADAMUizWi+meeH/3VwPGQD629/Eo6WAAG64NE+ZIT5kllqHWFkbujMlYjOnmmN9kXpoNeTLa81RuvuC+JX2uf55ioU4xH23h3GKcVGADAGyJdnK6ifqhqPv7wJMBVye0z8ZZ6q77B8GmSCk97FgMAAAAqzW6QY+n37Ur7drxkVSX9716XYlR72ECAMAQKc3YNJULr6tT+lDc330iYMTl43sfbZ7whwLYbPPNm8+Rupc/rGCIgfZMNRVno8olpksqdzTH9aabodNUrN1CMwY72fxb8ynSs71OnIz3dU8GAMBGOF613TseNXM+qyW0z3rrHK/2l7rMBZsjxZP1/c8+HAAAALAKoxt7+Gj1rblXfrxZuuvcVZcrpAMAgK108Ri1Wfw35ab0/bGvezpgVLUzmeby2QC2VltsYIZYBkXbrWMipnMd+0uUB9Yp1HG9FpYL6I72etG1TQAAa9LOlt+JA6WUh5oxzXTA+hDaZ13ko9Wh5ij0o8Fmma8fePYtAQAAAKswskGPzrGZ7y8lPtwsvi4AAGBAXRr0SP+lROe/iwd+5lcCRlQ+OtOGPKYCGAwCH2yl41WVS3moGQTtby5NxgAwazIAsCptwGOifiTqdDAGZFzDiLIPxxqko9WRFOWBYNPUDzw7uhOwAgAAsKFGc4fy6WpP3hE/2nws+0MBAAADrx2Wv5r2eLFZ/EvNhz//uLlaPzpGTmeuOlByORzA4FEsxGYZniLI+Wa76NouAICrEvBgi7QB5ZLSh+O+7pGA65SOzZxIJapg09Tb01viu+1TAgAAsHI5RtHuxdtKXd4aAAAwFC7Ic+xpLr8tPvKunQGjZq6aKrk8GsBgKnEg5/LZfGzmcLu9Bqy35nmVj1ZPts+zqNOhGPxCyCnbBQBwRW3A4/jeR4dobMOIaYv1c13m2s6pnWPVgQAAAABgpIxm0GMx3pByfGsAAMAQKHFh1KOk9K1x4443BoyYTvRnC5wKYLApbGe9tUWQx/Y+3i+CjPJQDGMRpO0CADhHwIPBM1VKOSzwwfVIJU0FAAAAMBRGL+hxotoZufOOZun1AQAAQyAtn867PB2nencEjBjdPGDInCtsP7730baYLWAVXi2CLOlgjILztwsAYOx05qoDAh4MMIEPAAAAgBEyekGPU70bUynviwtr5QAAYJjsidz5E/F0tSdgVByvqtDNA4ZTnQ7lXJ5TKMSKNK/7bYHZyBZBtttF+/vp7gEA46EZ26RjMydKLodDwIPB92rgY/l4DAAAAABDaPSCHvX2G1OkuwMAAIbNeVHllOPe2BU7A0ZEruNAAMPsXKHQcwrbuZZ8bO/juS4nYvQDflO6ewDAiGvGvunYzFw7tkklqoDhMtU+d/OxmcP24wAAAACGz8gFPTql9/bm7PYAAICh81rSI5Xyx+Js/YaAkVEE8mE0TCts54rmqql8dOZklHQwxonuHgAwktoxb9vZLpXYHzDMShzo78cJfAAAAAAMlZELepRe+ROvLqcAAIChUZr/zrOnGa6/I2AUzFWTzdfpAEbHa4XtVUDreFW1hZDN0rgG+9ruHieabUIhKAAMu3Zc04ZXmzFvc2kyYFQsBT5OdI5VBwIAAACAgTdaQY8TMVFy+pZzF5OkBwAAQySVCy/nTv3OgFEwIeQBI6pf2J6P7X18OdDFmMrH9z6S63IiFEK228ScjjcAMKSaMW07tl0e1+hKyaiaKqUc1pEOAAAAYPCNVtDjVHV7KuXO164oAQAAw+W8sHJK74qn79oeMORyEfSAkVbSwX4nh7nKtj6G+qGGOj0RvKbteCPsAQDD5Vx3smZsGzAe2pDyZwX3AQAAAAbXaAU9evHtzdcbAgAAhtX5bT1KvDHybd8QMOzK2M/wDuOgLRJ6TnH7eMnHZg63oYbgUm3Yoy2aAwAG24VdPKYCxs1ycL9zrDoQAAAAAAyUkQp65DboUQQ9AAAYYhc2pbshdtTfFjD8BD1gXLTF7UdnPhtz1VQw0vohjxIHgitri+ba9QQADKa5aloXD+ibKqUc7o9d7csBAAAADIzRCXo8/a5dkcodkWIiAABgNOzMJb8tYPgJesB4abt7nDAj7Ojqd6oQ8rg+zXoS9gCAwZOP732kHbOGLh7wmnbs2m4Xc1UVAAAAAGy5EQpF3PCGUs68OTUCAABGw0SUckd84t7d8e2/9HIAwPBYmhH2+N476vt+7rFgZDR/00ejNuv1irQFc8f3ztsWAGAAzFWTqVMORx37A7icfnA/ju89ZPwKAACMjGeqqeZYwGT0Yjq3kxSWmIpUbi5LExZebdLChdScoqTn2+U6xXy0p4nm9N3d+QDYYKMT9Nh19mubD5nfFAAAMOza6HJZWiqpOcDw+d1TzfJnAgCGTZ0OpWMzVemlh2PWAe9htxzyOBSsXLPe8rHq+fr+7hMBAGyNuWo65zLXL+YArq4dvx6dOVDXaZ99OQAAYKi0oY6zUeUS0yXKTGq7eZ4pl4Y5ylJpxvVZKuDIZXnxTHM6OtMunmyDHynSs3Vqlu/rdgNgHY1M0KOzmN5Ycrk1AABg2JWlYwPLBxXeGGmbcS4AQyuVqFIuJ+q5SoHQMJurpqMuh4LVK+XxZj2ebLaDbgAAmyof3/vI8lhmMoDr1Xb3eC6OVY8JLAMAAANrrprMnTjQHIS/O0rsPz/Ucf1BjtVp/v3p5ntON997fz8E0oY/UnRTpKN1J7rxvu7JAFiD0Qh6PP2uXSWXb4hXD86+NgUyAAAMp6UxbSrp9hy9N/YCAIZav0Conqvazh5HguEyV031Z79mzZr1eLjZDu5ptoOFAAA2RT629/Go08EAVmOyDSw329EddS8/ZhwLAAAMhOVwR4nyQCqlGqRy4XYCtIhS5cVogx/zkaJbp/SUbh/AauQYBTfsuLl5efyG164Q8gAAYMi9OrVE2VXqeGsbbg4AGG6TbVggH9/7aDBUco5D0bY2Zz1MpY7QDABsirlqMh2bORFFyAPWrNmO+t095qqpAAAA2CrHq6rd12/2T/6gDaUvhSoG2lSUOJDrciIfnfls51h1wH4VsBKjEfQ427ulRLmnv7zRvZYAAGATpPJqeDlFSt8Su3bdEgAwCup0SNhjeHTmmg8dojwUrJv2g6d8rFJwCgAbaakj2XNDUPABw2RqOeyxPwAAADZL272j+VwpH535gzYwMcT7+lOllMPNftVn87GZwwIfwPUYjaBHiT0pyluWFiU9AAAYDefGtiXVU9E7e3MAwKio06F0bGauPTgfDK7mQ4aSi1DORijNevX8B4CNMVdN94vRdSSDjaBTIwAAsDnOBTxy+Wz7uVJzzegcU2+7fAh8ANdhNIIeuXNL8+WNSxdKAADASFjOMKeS7ow6C3oAMFJSif0plxMOYA+unONQKJDcKJO5UyuOA4B11vno3odyO8YcpeIPGERtp8Zjex8XXgYAANbdKAc8LibwAVzDiAQ9Yrp5xcsl9YsEAABgJKSyPLhN8frYFm8NABgxzaGc6SzsMZj6f5PyULBxSjrouQ8A66cNeZReejKEPGBzNONZ4X0AAGA95eN7HxmLgMfFzgU+2u6JAvXAeUYi6JHruLM9F/IAAGBk1fkPBwCMpilhj8Gz3M2DDZY65fEAANasLYRYDnkAm0h4HwAAWBfHqyofnTkZdXoixnkCh7Z7Yi7PdY5VBwIgRiToUWIp6AEAAKMqRS3oAcAoE/YYJLp5bJpUYr/nPQCsTX+2y6WZPoGtcW5/bjoAAABWYq6azMf2Pp7rZp8i4u6gNVVKOZyOzfjcDBiBoMehQzlFeXsAAMAoS/HWAIDRJuwxIHTz2FzN+j4QAMCqCHnAwBD2AAAAVqbt4pHLc1HSweASqUR//eRjlfUDY2z4gx7v/Hjbpul1AQAAoygtnVIdfyg+8IFOAMBoO1ccNL5tuQdCmQk2UXnEcx4AVq7z0b0PCXnAQJnsF2m12yYAAMBVtBM3LHfxmAquZjJKebztehLAWBr+oEfvlTcHAACMqrJ8SrErPvClNwQAjL6pJOyxZTrHq/3hg5XN1j7XzXwMACvQmav2l156MoCBk9ttU9gDAAC4gnxs5rCJG1aopIPp6MxzzWdnUwGMlaEPenTq+KYAAIBxsDMZ+wIwFlLEdOqUw8Gmq+s4EGy63CkK4QDges1V0yUbK8IgE/YAAAAupx/yKD6HWI32s7O8NFHaVABjY+iDHqUodgMAYEz0amNfAMZGKrFfK+rNl6LMBJuveb4HAHBtc9VUzmUuljpiAQNM2AMAADifkMe6mFoOezguAmNi6IMeEfXXBgAAjINOenMAwDgp6WA+Vh0MNsfxqgpFk1tlsvlgpgoA4MqWQh4nmqWpAIZCP+xhnAsAAGMvH9/7qJDHuplKnf4kGMAYGP6OHnW6IwAAYAzkKIIeAIyfUh5XGLQ5conpYMvkjvUPAFeTOuVwCHnA0Ol34ZmrjHUBAGBMdeaqA1GnQ8G6SSWqfGzv4wGMvOEOevTbD5UbAwAAxkCJ+No4dGgEuvIBwMosFwZNBRuqNB8MBFvG+geAK2tn/kzeK2FYTdqnAwCAMdXsB5RcHg3WX0kHTZQGo2+4i8S2Ld4SOd0QAAAwFsqeuLd7SwDA+JlMS4VBk8GGSVF0zt1Czfq/OwCAS+Tjex8x8ycMvamcywlhDwAAGC85x6HQnXPDpI4QDYy64Q569CZuSaXsKikAAGCkLY150+7my60BAGOoeSuczp3aAeuNNR1spSlhJgC4SFsULuQBo2JKgB8AAMZIP+hdHgo2TL/7qa4eMNKGO+iR63Y2413NixUAAIy+EoIeAIy3kg7mY9XBYP3NVUIeg2BnKHoDgHPmqsl+B4Dw/gijYinAXx4PAABg5C1382CD6eoBo224gx7RubUtdtPRAwCAUbc05E03RF3fFgAwzkpzwLo/CxTrakIB5UA4rYU9AJyz3M1tKoDRUuJAPr5XIRIAAIy8MhNsuH5Xj2d8bgajaqiDHnmx3tO8Sm3T0QMAgFG3NOQtO5qFPQEA420ydcrhYF11zJQ9EDodxawA0OrMVQfabm4BjKY6HYq5qgoAAGA0He+P96eCTZHPxv4ARtJwd/RI+dbmy+4AAIAR14abU8SOnNPNAQBjrp2dKB+rFP6tp0VBDwBgQMxVUyUXs/3DiMu5zOnWCAAAoynXUQWbphTrG0bV8AY9nr5re6T65kgxEQAAMB52RSq3BADQHrV+VFEQAMDoyTkOhVk/YRzo1ggAACOqREwHmyZFuTuAkTS8QY8dr9vRfH1dlBQAADA2eun18Qvv2hUAgKIgAIAR05mrDkSUhwIYC0vdGvc+HgAAwEhJUe4INtNUACNpeIMer+zZ1rwb7JLzAABgfDSD35R2x0K9LQCA5aKg6mAAADD85qqpksujAYyXkg42238VAADACEmTweZ6ppoKYOQMcUePxW2lxA0BAADjIpUopZ6M052dAQAsKeXRmKt8YMBI6KVYCAAYUznHoTADJYylnMth+3UAAAAAFxreoEc6u7v5+vpUSgAAwFhoh74p3RR5z44AAM6ZzJ3yeLAmvYmYD7beoqAHAGPqeLW/OfDxUADjaip3ah19AAAAAM4zvEGPzrZtzdddAQAAY6XcEIsvbwsA4DUlDsRcVQWrtyjoMSAEPQAYS7kW3IWxV9JB+3UAAAAArxneoMfimZ3NT39zAADAWEm7Y8fE9gAALpA6xeyvayNgMAhmuycDAMZMZ6460JxNBTD2ci6HY66aDAAAAACGOOixbUcnldgZAAAwXm6OuifoAQAXaY4TVZ1j/SJBVmO2u9Csxflgy5QIIQ8Axs9cNVWywC7wqqmc42AAAAAAMMwdPRZ3REk3BQAAjI3U/Bc3RNq+IwCAS5RSHjX76+qViE8GWyh9LgBgzOQch0I3D+AC/f26qQAAAAAYc8Mb9CipU5KOHgAAjJPSftkd9dltAQBcjtlf1yCl6AZbJunoAcC46Rdyl4cC4CKpUw4HAAAAwJgb3qBHLttSKYIeAACMjdI/pd1RF0EPALii8oiuHqtT9wQNtlJdC9oAMF6Wu3kAXCKVqJr9uioAAAAAxthwBj0OtT93uTEAAGCMpP6p5Oikm+PQoeENbQPAxprU1WPV2qDHQrAVFmK22w0AGBe6eQDXkLOuHgAAAMB4G87isK+5txN1ujkAAGAcdfLumOkKegDAFenqsSqz3YWSdPXYCiXSswEAY0Q3D+A6TOVjlRA/AAAAMLaGszjs62/Lzaefgh4AAIynOnbGjV9NAQBcia4eq5R76alg05UURwIAxoVuHsD1KuVRIX4AAABgXA1n0GPXqRS5bA+lbQAAjKXyuvjUjZ0AAK5C8eBq9KIfOFgINtNCs+IFPQAYG7p5ACsgxA8AAACMreEMerz41ZxLuSlKAADA+CnppnjTdkEPALi6qZirqmBlZrsLEbp6bKq2m0d/vQPAGNDNA1ix8oiuHgAAAMA4Gs6gx6kbc5S8K7T0AABgDOUUu+L5MwbDAHANqVMeDVasrnWX2Ex1Lz0WADAmdPMAVkFXDwAAAGAsDWfQAwAAAACuIZWodPVYhdlut6ToBhuupNRt1vd8AMA46M/IX2YCYMV09QAAAADGz3AGPbbFRKS4vTSf1gMAwFhJ/dPt/TExAHBNuVMeClas6DKxKUovrGcAxkYnYn9zNhUAKzfZ6fRfQwAAAADGxlB39JDzAABg3BRjYABYmRL7zfy6Crp6bLwUT7brOQBgTJRcHg2AVapDiB8AAAAYL0Md9FiazhgAAMZHfwRcBwBw/SZzjoPBipVeejjYMLWuKQCMk+NVFbp5AGuQSlQx138tAQAAABgLwxn0OLsjl1Je107JCAAA46YZC39N7HplyEPbALB5SiozwcrNducjhBE2RN2s1/76BYDxkOs4EABrlDo6AwEAAADjYziLw7a9clNKcX8AAMAYasbCfzLKjpsCALguZn5dvbqOJ0rEfLBu2vVZz3YPBQCMi7lqqnkHfCgA1mh5324yAAAAAMaAWYABAGDYpAAAVijn2B+s3Gx3odTp4WDdNOtzXwDAGOlEVAGwTpp9u4MBAAAAMAYEPQAAAAAYA2aRXrXZbreu04eCtavTY836nA8AGCMll0cCYN3YtwMAAADGw9AGPYpZjAEAGFclAICVm4y5qgpWZ7b7RHM87kiwau36q2e7hwIAxslcNd18nQ6A9TNl3w4AAAAYBzp6AADAkBF6BoDVyR0zv65F6aWHS8R8sGLtemvXXwDAmMk5DgbAOmteW/YHAAAAwIgb2qCH2jYAAAAAVqTE/pirJoPVme0ulDrtE/ZYmX7Io1lv7foLABg7ZSYA1p0QPwAAADD6JmJYlQAAgLGUiuEwcG31A8+O7xwJc9XU8tKr5zn3lydLirubF9HJFGU6GEdtyKP923eD1Zntzpe5al/K5blYWp9cRTNmW1gOecwHAIyb41UVdZkKxk6JNB8pTjY7pQvNhc/VdT8ovLB8ml++28IVg7BL4ewLT51mv64s79O1l0uZTsaj42yyeZ5UzXOoGwAAAAAjaniDHgAAAACX81pB9bnzqC+6Sz8wN1e1Bf9tCKRqLs8If4yH5u+9vxb0WJtmG6vnqn05lxOhuO6KhDwAGHe5jgPByGtDHSlFtxljfzJ6cbK56uS5AMeqJypZevwlIZBL9uuWAiHT0Yk29DGzHP6YCsaCfTsAAABg1A1x0KOdmNQ8xgAAjKPxnaQfYF3NdvtFSHXEkfbicpFQ1RaLlCgzCoRGVXmo+XIwWJtm+xH2uLLzQh4nAwDGVpkJRk47zkkpHal78Wy0RfZtx7fYIkuBkG57an6GJ/o/31Kgfzp14qFUShWMMPt2AAAAwGjT0QMAAACgtVQkdOS84Ecb+jgg9DFyJqP52zZ/726wNkthj3tSLidsI68pEfOlTrNCHgCMtX6xfZkKRkIb7oiUuqUXH24unizLHTsG0nKgv/mZn1wO8+8X+hhZ9u0AAACAkSboAQAAAHA5s91uvTQ7bBv6OKA4aHTkHNW5vy1r1M7gPFftC2GPvuWQR9vJYz4AYIzlTlSxZW0eWC/t2CbV6al+t4xBDndcydLP/ORy6GMqRxwouTxk3Do67NsBAAAAoywHAAAAAFc3232y3N/dV9fpLRHpqWColVRmgvXThj3qdM/YbxttEWS7HoQ8ACBKlAeCoVVS6jb7PvvKA8++pZ7tHhrKkMfFmjFa+7v0f6c6PdyGWIKhZ98OAAAAGGVDHPQwDRAAAOPKWBhgy7TFQQ90Dwh8DLdUooq5ajJYP7PdheVt40MxZpqR2UI0v3c92z0wEkWQALBWc9VUf7zF0GnDD/2Ax/3dtkNZN0ZVG+QX+BgJ9u0AAACAUaajBwAAAMBKvRb4UBg0rCYUH26I2e4TbRBqXLaL5vf8ZNvFo25+7wAA+joTMR0MleXg6mNt+GGkAx4XawMfddoXkT4cDDOvOQAAAMBIEvQAAAAAWK2lwqB7FAYNn1wLemyY2e58v0iwTo9FWzQ4gs4rhpxuf98AAF5V6tgfDI2SUnc5uHooxtFSiP/gOIWVR03OXnMAAACA0SToAQAAALAWs92F5cKgfQqDhkl5INhQbbFgvRSEeipGyNgXQwLANZWZYDjU6UPl/u4+wdV4LawsxD90Sip3BwAAAMAIEvQAAAAAWA+z3bb4uw17nAyGwVTMVZPBxlqaIflAO0PysAc+2oBHP9ClGBIArmyumo52nMVAawPq7bimnu0+EVxgOcT/oRjRznSjKJWYtm8HAAAAjCJBDwAAAID1sjQL7D1mgR0SE1EFm2OIAx8XBTy6AQBcUSdiOhhobcijDagb11zFbPcJHRuHShvy8NoDAAAAjBxBDwAAAIB11s4CG3V6LBhouRb02HQXBT4GtXiu9GdwTh9ufs57BDwA4PrVOfYHA6sZ43yyNOMb3cmuw2z3ZBH2GBq5I+gBAAAAjJ6JAAAAAGDd1bPdQ3muisjl0WAglVTuDrZGG/iIONAulrmqyjkOlCgzKWIqtkgb7kgpHal70XYcOVlmuwsBAKxICuOrQbUc8qjCGOf6tR0b56p9zT7dia0cp3I9vPYAAAAAo0fQAwAAAGCDCHsMtlRiugRbbrbbrSO67WKZq6ajE1WKeCBKmW7OJ2OD9Lt2pHSyeR58sq7jSAh3AMDazFVTzTvsVDBwhDzWQNhjKJSiowcAAAAwegQ9AAAAADbQcthjKnJ5KBg0k9EGC2a7J4PBsPS3OFkinmgv9oMfEVM5x3RJ0c7SOxklptIKikj7gY5IC5GiDXV8rq6j/z2a03xb7CjsAwDrozPRvF/XwYBpxjrzpU77hTzWYCnsMZtyOREbGERm9VII8QMAAACjR9ADAAAAYIPVEQdTxN1t8UkwUDqdmO4tFf0ziJaDH802dOT8q/tFXHNVW2R3rtDu/OX58x4/f8njAIANUeqogoGyHPLYd/GYiFVoxqX1XPVwzmUuGEzPVFPx3Z7rAAAAwOgQ9AAAAADYaG3XgKUZYJ8LM8AOlFKEb4bW0qzUZqYGgAFRUrk7SVUOlFKnDwl5rKPZ7pE4Wn24WbOPBAOnczaqXsSTAQAAADAicgAAAACw8Wa783WdZoOBUqLMBAAAa5YEaAdLnR7rBxNYV/UD3YMlRTcYOKXEVAAAAACMEEEPAAAAgM0y2+1GpA8HAyOFYiAAgDWbq9qQh851A6JEzNez3UPBhii99HDoLDd4UrkjAAAAAEaIoAcAAADAJqrrONQWXgWDYjKeqaYCAIBV60wIzw6SUqd9wcZZ6tb4WDBQiq5CAAAAwIgR9AAAAADYTLPdhVL3Z4BlUCwqCAIAWItSRxUMhjp9uA0iBBtrtvtEiTgZDIykqxAAAAAwYgQ9AAAAADbbbLdbUnSDgZCLGagBANaipHJ3sOXazoF1xBPBpih1+lAwSKYCAAAAYIQIegAAAABsgdJTFDQ4FCYCAKxFKmbSHwQlpcd089hEAvyD55lqKgAAAABGhKAHAAAAwFaY7Z6MSE8FW66UmA4AAFZnrmpDHsZTW6zt5hH3d58MNlXppceCwXFa6AwAAAAYHYIeAAAAAFukruNQsOVSxFQAALA6E0Ieg6DfzYPNp6vHQOl0vB4BAAAAo0PQAwAAAGCrzHbnFQUNhMnlmagBAFihTphBf6vp5rG1dPUAAAAAYCMIegAAAABsIUVBA2MqAABYsVKbQX+rlTp9ONg6bVePiJPBlivFfh0AAAAwOgQ9AAAAALZSWxSkq8eW63QUKAIArEYJ46gBcCTYUinS0WAQ6DAEAAAAjAxBDwAAAIAtpiho6xUFQQAAq5PKzcGWKe2+xGx3PthSdR1PBFvP6xEAAAAwQgQ9AAAAALZY3Ysnm7OFYOuUmAoAAFYsFR09tlLJ/X0Jttpsd0GnRgAAAADWk6AHAAAAwFZbKgo6GWyZEoIeAAArNle1XdF0RtsizRh2Pu7rHgkGQu6lp4ItVSJNBQAAAMCIEPQAAAAAGACKgrZauSMAAFipqWDLJB0kBkovQugGAAAAgHUj6AEAAAAwABQFba1kJmoAgJWbMIbaSnVKR4PBsdSpsRsAAAAAsA4EPQAAAAAGgaKgrTYVAACsSC4xHWydRfsPgyaF8M1WSqVMBQAAAMCIEPQAAAAAGBCKgrbYM9VUAABw/YqOHlulpNRtw+LBQKl7cTIAAAAAYB0IegAAAAAMCEVBAAAMmalgS6QIIfFBNNvtNl8FcAAAAABYM0EPAAAAgEGhKGhrnVaoCACwEiWVO4ItISQ+uErytwEAAABg7QQ9AAAAAAaIoqCt0+kIegAArEQqMRlsjaWQOAMolfTJAAAAAIA1EvQAAAAAGCCKgv5/9u4EQI7zrvP+76kenZallmP5ttV24jgnHuciIaApJYQcxJIagvOyYaPxLscGWCSzLLthCZJggYVlI5kA4drVKBASctCaURwTcqjkOJcd2yPH8SlbLR+yLEvy6J4ZdT/PW0/NjKzbOma66/h+nFb3jI7MdNdUP/U8/9/zBwAAQHYYgh5t4IyJhNQygSIBAAAAAAAA54igBwAAAAAAQIpQFNQ+ztHRAwAA4My4itByxolweIo1G3RpBAAAAAAAwLkj6AEAAAAAAJAiFAW1FTtSAwAAnK5ayNipXYzqQnpVo3r864DQcs6YugAAAAAAAHKCoAcAAAAAAECaUBTUPsbNEgAAAE4XQY82sU3C4RlQFwAAAAAAAHAOCHoAAAAAAACkT10AAABAmnWoIrQLQY/UMxsFAAAAAAAAnAOCHgAAAAAAAKlDUVA7OJmKAAAAgHQbUDWiA2D61YXWc9otAAAAAACAnCDoAQAAAAAAkD51AQAAAClWkspCyzlj6OaRAcZyTdcOxrgXBAAAAAAAkBMEPQAAAAAAAFKGoqA2cY5iRQAAgNPVIOjRFnQsyIRmB9d0beHMFgEAAAAAAOQEQQ8AAAAAAICUoSioPQy7UgMAAJw2V2Ls1A7xmJWOHlnQ4JquLYwGBAAAAAAAkBMEPQAAAAAAANKGoiAAAACknSPo0RYUsmcFr1MbWMO1NAAAAAAAyA+CHgAAAAAAAOlDURAAAACA41DInhHViGu6dmhwLQ0AAAAAAPKDoAcAAAAAAEDaUBQEAACA9KOjRztQyJ4hpi60Wr8AAAAAAAByokMAMCowRpPNJE0vTdXU0mTN6JimS6e8TNecd6lmlKZr9uTzD//Zpmtq4NA+bT24UzuGB7RtaJf2NA5oyA5rf3NQjfj3nXNC9pj4OOgwJU0rTdF58bHgb+VJM/Ty6ZfrwimzNHPSeZpkXnz72B0fBzuGdye3pw5u187hPclxMGQPaTi+NZ0VssmfE2Z0TNe0YHLyml80paw5k2erMv0SzYqPCX+eGDPYHNIL/pwwuENbDm7TruG9yXEwGB8D+xsHBQAAgLPhi4JcRWiligAAAHC6CHq0w1Q6egAnMcCmCQAAAAAAIE8IegBIivhfOeMKXXvelXrd+VfrVefP1RtnvVJzpszW5OD0ThOHbENbh3bq7hce1v17NumRfU/qh3u3aPOBrRpsDgvp54v2r55+mV4zY66ujY+Hl593ud4y+9W6Jv7c9NKU0/o3xo6DTfue1sY9j+vh+Bh4aN8WPbrvqSQIgvSbFP/MXzS5rNecX9ErkmPgNXp1fE64evqlmj3pfJXM6TUD84EPH/x5YM/m+FjYlBwD/ljwobCGbQoAAAAAAAAAgHxzhA5ayBlDNw8AAAAAAJArBD2AAvNF/G+/4PV62+zX6tUz56oy7dLTLug/li8Onzvt4uT2gcu6ki4Pj+5/Oin0/8bz9+obO+/V0wefF9Lnimlz9I4L36C3XvBavWHmK3Xt+Veo3DFDZ+PI4+Cdc96oQTucFPs/uLeuewce1e3bv6d7Bh4R0ue8jml6S/lV+ulL3pYEvl4782pdMvllSVePs3HZ1AuT24/Ofk3y8dbBnXooPg7692zS15+/R9HO+zTUPCQAAACcnDOubhwdJgAAAAAc4b1RXcgEZzRgaH7fMkauztMNAAAAAADyhKAHUECXT52j33rFB3XT5e9IunlMMZNkzrKY+2Rmxf/um8uvSm6LLv0JHWgO6i+fqOmTW3q1a3iP0H4XTJ6pmy6br/98zc/Gx8SFmlaaog5T0niaGkzWteddoVdMv1zvuehHteTlH9Dtz31Pn3jiX3T3wENC+/nX/caLf0zdV71Xb4p/Xs/rmJq8buPtsqkvS25dF3bql+beqDt33q+eJ2/Xuue+pWHbEAAAAAAAAIBscVJ5fFcWgJxxZnfyk4IWMRsFAAAAAACQIwQ9gIKYWpqs155/tX796qp+5rIuzShNU6uc3zE9uf3+q/+jfrHyfn1yc6++sv0uPbSvToF3i/nuDFdNu1gfvvI9+pXKAl0y5QK1gg8S+UDRlGCSPnTFu1S9dJ7WbfuW/qbepx/sfYLwTxtcNGW2fiZ+HX7jmp/VK2dcKaPWLMn6MNHM+HzwvovfmtzuHnhYf/HEF7Vh50Y9O7RTDdsUAAAARhhntlAUBAAAgNQybhbD1ZYbEDLD8Hq1VLy80C8AAAAAAIAcIegB5Jwv7H/59Cu0+Kp366bL58ePL1c7+ZDBH7/ml/XhK39Ka576ij6/db3qB7YJE++KaXOSrhrdV75Hb7vgdWqn6aUp+uDl79D8C9+gf3j6K/r0U1/VD/dtpsi/BXzo650XvlG/OPf9+sk5b0pei3byXX/+tvO3ddu27+hT8bGwfse92tc4KAAAAAAAAADAcQgOZEtdaJ1qFAkAAAAAACBHCHoAOferV1d185Xv02tnVjTJpOdH/tXnV/Sx6xbrxkt+TL/z4N/qzl0/ECbOW2a/Sr93Xbd+4oLrNaOjdd1cXspFU8r6lbkL9K45b9b/e/I2feKJLwoT58L4+f7Nl9+kD13xk7pi6kVKC9/pZcGlb9cbyq9U77Y79T8f/RRdXgAAAAAAAAAAmWas6i4QWsAZEwkAAAAAACBnCHoAOeS7eFw4uaxfrtyopdd8QOWO82Xiz6XNeaWpetvs1+mzb16uFQ/36NNPf1UH7ZCco9f7eJlWmqL3X/Jj+p+v+o+qTL9UHaaktPHBk9eff7X+6NW/rEumXKC/3/IlPXnwOTWdFcZHR1DS62ZcrT993UeSn7lpwWSljT82K9Mv0Ucqi/SK8y7Xnzz2T/oWATAAAAAAAAAAQEY1pYicR2vEq6C9rC4CAAAAAIC8IegB5MykoEM3zHyF/uu1/y4p8J+coi4eJ+JDKZdOeZluff1v6PqZL9df1P9Fj+57Spawxzkx8X+XT7tQt1xzkz505bs0Z3JZaeaDSNNLU/Rbr/j/9NbZr9WfPvZPinbepyF7SDg3MydN1wcve4d+55X/XldNu1hpNzk+h/30xW9Lwh7/67FPa+22O7Xn0H4BAAAAAAAAAJAp1aiu3q6B+FG6F2lywDYVCQAAAAAAIGfYRATImXdf9Batev1vaOElP576kMeRpgST9EuVG/Xx1/560nkC5+aq6Rfpz1+/RB+5emHqQx5H8l0dwgs79ec/siQ5hnFuppYm6zeu+Tn90Wt+ORMhjyNdN+Mq/e/X/qp+/7r/kHR9AQAAAAAAAAAge0yvMKGcVFc16hcAAAAAAEDOEPQAcuQ9PuTxul/Xj85+jUomez/evsj/XXPerM+8cZkunDJLODsXTJ6pT7x+qW68+O2aEkxWFvluDn/8ml/Ru+e8RTh7/+0V/04fvfZDumDSTGXRhZNnJQGwj73yw5pemioAAAAAAAAAALLEWq0VJpQhTAMAAAAAAHKKoAeQA1ODyVp0yY/rL3/kN3X19MuUZYExelP5On3+Tb+v1828OvkYp8c/V/456+n8qN570Vsz/9xVpl+ij7/+17X4yvckxzhOX3nSDC27rlu/F9+y/tz5r/9Xr/4Z/fdrP6TLpl4oAAAAAAAAAAAyJIpvA8KEsVarBAAAAAAAkEMEPYAc8F0w/ug1v5wUxufFj13wOv3paz6i15xfEU7PK867InnO3nXxm3MTkHnVjKuSsEL1sp8QTo8PeSy55gP6jZd/QHkxvTRFt7z8Jv2PV/57TQ46BAAAAAAAAABAJlSjAcmsESaEMyaKn+O6AAAAAAAAcoigB5BxF0yeqT96zS/puhlXKU86TEnvnPNG/dlrflU4Pb977YeT52yyyVchvA8w/clrPqKXn3e58NI+cFmo37jmAyp3zFCe+LCH7+5y02XvEAAAAAAAAAAAWUHHiYnjJEI0AAAAAAAgtwh6ABk2Z8ps/fnrluhVM+Yqj3zY4x1z3qiPXvsL7OJ/CpPi5+ZX5i5Q9bJ5yXOWR5dPvVB/9tpf1eXT5ggn1znzFUnnC9/VI4+mlaYkXT1+4mXXCwAAAJggdQEAAADAeEo6TtDVY7w5f/22IOoRAAAAAABAThH0ADJq5qTp6r7yPXr3xW9WYIzyqmQCffSVv6BfuOLd6gjyGWI4Fz7Y8YFLu/Rb1/5/SceDPPupi96cFPnPymmI4Vz5zif/8Kbf1aty1t3nWK+ccaWWXbdYV02/WCbH5z4AAAAAAAAAQH5Yq6Xx3YAwbpwxKwQAAAAAAJBjbJEPZJAPdrxx1nX6T5WFumDSTOWdDzD82jVV3b9nk74/8IjwoutmXBUfB4t01bSLlXdTg8n64GXv0N0vPKRPPfUVNZ0VRkwtTdYvVxbo5dMvUxG8/WU/oo/MXag/ePRTOtAcFAAAAAAAQOrcHlaO+rihFz/uOKKD1KAGVI0o/AWAvIvP9bYWrggCt1I4d0Y9dPMAMoyxMoBWqIVlTVX5uM8fec7xgvhcE5wgkMs5CAAApABBDyCDLpxc1pKXf0BzC1Dc75n4v9edf7V+ae6NenT/09pzaL8gzeiYpv941U/rLbNfnXT2KILypBn6tWt+Rrdv/562De4SRnS9rFOLr3yPpgSTVQSTTUd8Dvw5RTv79ZXtdwkAAAAYL44ddgEAp+KLRCaroqY6g3iqKn7jqMi4WfH7R8U/NkoKSEaKSIbdyf+d4SMe+77rvV3+0UD8N+rxVOiA8ffObLEm+biuhvopLgGAHKhGq1xfV5dxWiScNX/d5pp08wBS6djxstz1bmzcHN8fHi+fw1jZPzbObPSP4/FyP2NloCDGQhuNkevvY67JD59n/B81GgtyuKPPKSdzsj1GXzwHeQOH547N4UCav34f8NfvyTnJP/a/NxYceW9UFwAAwDki6AFk0H+au1A3Xvx2FYkPMvzCFT+lz279utY/f58w0s3j5rnv0+SgWKfyG2Zeq//y8g/qvz/0N2paunpcMvUCffTaX9AlUy5QkUwJJul3X/lh3bv7UT0/xNwtAAAAxokxDC4BACNuCzuTAjWnTmfc9Sa+l5wvKjmaS4pIxoMvfOuUe/EfDlxyN1ZcMuCM+n1Rmw0UjRa01QUAyBTXNDfHJ/jOFwsQcaaMNSsc74FA+/mi6w6FgVUYj5fnxuPW+NzmKseOlydorLzIPw4YKwP54rv9jAU5/DW4D3Ek5xY/boqvx08U2hi/a/KXMhZW02io5Ogvwo2cjpLz1FgZS2+XRkNqdY2E1HwgpJ6E1HwQ5KejfgEAALwEgh5Axlw17SL9/BXvVBFNLU3W772yW3e/8LD2NQ6qyKZ3TNEt19ykmR3TVUQ/d9l8feqpr+gHe55Q0f38Ze/UG8vXqYg6Z12rD13xLn3iiS+q6Qj9AAAAAACAs3R0kdpIqKPhymO/bZzSoBx/HaHk/Ne5ZLSgzReMREZmQ7OpiGI2AMiAajTgauF8BW49YY+zYM2tthqtEoDW82PmkhYFcl0uHpcmoY7R5bkUjJdPOFb24Y9AppexMpAyI9fgycYKSeefsTDH8IvX4YnWhTgmjBntADry0WggZCwMMhIE6U86e450KqrTqQgAAByLoAeQMR+4bL6uOe8yFdWPXfA6ve/it+pzz6xXkb1x1qv0zjlvUFFdOHmW/v2V79bvPvR3GrYNFdUFk2fqd175YU0vTVERTStNTrob/ev2u/Tw3i0CAADIG78bYkoKS4H28ou/U1Ue29HPfyo4cuc8v3PosZzZHf86siAaL5Za/9jvnud3yxuO71ksRSv5HSltfAzb5BguB34HSKex4oWy36HyqD9/xPFrTbLz40DyMQv942tdGAayXc6Z0DgXpqhI7Uz4Y6rbyXUH8YHl+rp86KPXlhSxMygApFg1qhP2OHPxW/RGV42WCkDrHDtmHh0rZ6TwuhKP7SvxWHlRMlbu7er3AWnboR7GykALHR/qOCoo5mU9zHEuXuxWNHKOPaJTkQ+r1Y2Lz1vB4fBHXQBwCuaQW2n6upg/PtJIN6UBgnTIMoIeQIZcO+NKLbrkx9VhSioq/73/whU/pX997i7taexXEfni/g9e/o7kvqimlabonRe+QV++4PWKdtynIgqM0a/MXRAfB+erqOLJWL2pfJ1+bPZr9dj+p9S0dPUAAADAuYkXGetka9rIF8MfUpiEOIybe3g3P7myhk/x99xLfNKNrI9qbLe8kcXSo3bMixdMo/jzdYo9cNaOLFzwxUQ+gPTijpSn/rvu5J9IFvjHPhw5dgfiD334o54UKfkFqhujSDg9vlDNalH8pC6W9TuFmlwVlBzexdjvi5J0+zC32qbWUgwCACn0YtijlhT44ZSSkIc1oQBMvLFwhzXdxrpKXsbMI+da1xmPlZckY2UfkLZaxVgZGGfHdcx0ncnmF6OKHOo4Q0lYbbRT0ZHhj37mgwCcTHzeWCQc44huSmPhX2PWMGeKLCHoAWSE37H/p+a8SW+cfZ2K7m0XvE7vvfhH9bmt6+Vc8Upw3lx+lX7igh8pdODHe93Ma/Szl3Xprhce0oHmoIrmsqkXJt1tim5GxzT93OXv0Dd23qf6/mcFAAAAnJORXfTRKr54xKnTyS00vjh+2B1e9PUT7xO98HvkjnnxgumSJATii+j9gulI+GMtC6Y4KV+4UNKiw8fwsbtRTtyUVXn02PVFSouSBSofXDKik8PJHBfuKIxKPHm6Mgi00nf6CGTWNBdEPQIApIcPe0g3mFq4XIFbJpyYNWvi52kpO68CEyi+vglKSae4hca6MG+B6BOoxNcHS+Kx8pLDY+WRYj/OM8CZGtv4Ir7ujs8hXfH8SGdGO2ZmwVj44+j5oJGuHxHzmADw0kbm1l2nnzNVX1ePbZoVBD6QdgQ9gIy4ZOrL9M4L36ipwWQV3exJM/TjF7xe67Z9u3AF/ud1TNO75rxJrzr/KhWdD7q8PT4Orpg2R4/ue0pF85byq1WZfokg/Wj5VfrRWa8m6AEAAHInXqCpnKRVASYOC/oTabQw3owEO8KxguuUFY+UD++Ib5NdPn3wwxd99Dab8YIpE/7F9uLOtouSwoXRU3QajuHjOjkUfXdaX6jWYZc4Z8KRQrVi88eH88dHb9ey+ICNWMAEgHSx1Wh5/N5VN4FbNtLRDl481Bow1qyIn59VAjAxamElCLQ0CUW7JFReOIfHyoGWqa+LsTJwOm6Pzx2HkmDHwiM7dtCto/WOmMdcNraBzWh4jXlMAHgpTt1BEM8d94W32gVcdyK9CHoAGfGaGXP1zjlvFEb2D3n7y16vq6ZdpIf3PakiuWjy7KTAv+jdPMZcN+NKvSq+FS3oMbU0RW+94LW6eMoFgjRr0gz95EVv0j9v/YYAAADypVC7jqeDIegxIdaFYbzouyxZ+HXK2nHtgx9+4XpR4Nt693WtTUIf7IpfHGOBAWu6jXWVjOxsWzlud9qiHLNHde8whSxUewmV0QXMbnasA4CUqUY9rhauNb5zBd095IyJXFM3O96ngInx4nV6KIxhrAycyuj1dhLuGPbzIwQ7Uqh8RHhNrrerP57F2kDXYgA4pZGuyH3z5toFd9wiIIUIegAZ8d6L36oZHdOEEa+eUdH1s15RuKDHK6ZfruvLrxBG+A43v3DFu9W37dsqksq0i/WTc96okgmEET9/+Tt1ywOf0L7GQQEAAOQIQY8WM3T0GD+jxfGyZulY5448OBz68LviB67HNoI1FH7k1JGFTzYT4Y4TOrKTgzFmRW4DH2OvF907Th9FbACQPtVowEq+u0dPEMT3PrhYMKMBD/++FAnA+GPcfHpGx8o+OB+fl1ZQII3COmozhVR25sUpxK9VZ/zadY52La4nHT6NWcM5DQBOwJmlprcrdNbM99fmAlKEClEgI9538VuFF00OOvTui96ionn3xW/WjBKBnyP57i7+eCgS383m5dMvF140rTRFb7/g9QIAAMiNWkjIow2aTdWFc+MDHuvmLQsCt1nWLFd+A0sV//357zPo61odf98VIR984VNf1/rAuvU+JKH8qDjnVge9XZtLfWG38iK/r1frjBSxcS4DgDSpRnW7MOq21lwdjzlvccr/dYoPeMTf73y3IJpPyAOYAPE4j3HzmfPPlX/OGCujUHy4ozdcFc8fvOCPf98xVGxIlAcjXYv8OS2eG+K8BgDH8wE5U3KrBaQMHT2ADHjFeZfrqmkXC0f7yTlvUtG848I3CEe7ZMoFesOs6/TdF36oonjz7FfT4ecEfOjnK9vvEgAAQE5UBGTJ4Q4ebqmsKdbi7+Fd8eetss3gVnbFz6ji7Gw7FvhYZkd2J6sri9iJePzR4QMA0scHPqRV8aNVrhaGQaBuJ9dlcnK96MMdpqkNyffIjqnAxPDX6iW7TC6+VnfC2WKsjLzz4Q7Zrrx15sVJVQ53Lurt6g+MubXZVMS5DQBGurqbvnkr7YI7bhGQEnT0ADKg62WdwvEum/IyVaZfoqKYPfl8vfr8inC8G8rXqkjeUn61cLy3z36dpndMEQAAQC50sEtaW0ylo8fZKNXC7gJ08HhpziyNn4f1ueqWUATF3dm2knRxWDdvmbIkfr2C3rCHnYgn0EixB+cyAEibahT5Lh9u4Yark7CmzK1Opl8Z4qSBpHOHMbf4biW+e4etRssJeQAT4/C1enytKoyP0bFy5q6jgBPxQbC+cOnYnEjh5/UKyu9en2wIMtbp87aQAjUA8OPnWrhIQErQ0QPIgLdf8DrheMYYzb/wDVr95JdVBG+Y+UpNDjhtn8hPXPAj+uTmtSqCSfEx8ObZrxKOd9GU2bpq6iV6eN8WAQAAZF3gxIJKO7yXXcvOSLwg7NtYx4uBTHi/KB/dEgqi9KV5i13TrZIrcCGDNcvj47U79cfrkV2DKDxpBc5lAJBmPvQhRf6hi98j47vOIFDojK6PxzUVI5eK60knU4+X8vzXulFN+VBKP6EOoAV8mH3kWj0UJkIlM9dRwIn47h1W8VyeW+znQ4yAUT7M1nDdrq8rCmTWNBdEPQKAggoCt9rWwohrWKQBFcNAyvmi7qumXyyc2OtnXqOieFP5OuHErpp+kWZ0TNO+xkHl3SumX66Lp1wgHK88aUZyLBD0AAAAueDiRWO0GpO1Z6IWdsYT3TWO1ZNKuiVo3bzl9sY7VgipE/TNW+ma7Gw7yh+v98ULVzfHC1fp20kjKUJxq2VNRWg1zmUAkHYjRSeHgx+e87/Ukt2YKyrF5/J4zO6M5sqHJZOAq6uYcwxO+hBH8sCoHv9b9fgTu238WM2kS2L/WOGzE4BWCtbN8+Ho5YUOs7fOyFi5b94q2wxWUASIVPObJ5TU7eQWGksIDKfmO6jGx0roN38wxqwg8AGgoOL3Trcyvta+WUCbEfQAUu7CybM0q2OGcGKvPb+iorhq2kXCic3sOE/XzbhK9ww8ory7ZCohj5OZWpqiOZOZtwYAAPngjLveUBHTUk5JQRJOw+EuCOyq/9KsWW76ujpd09xM0UdK+OKGwEXxD/31wpHKSXgrTQX9SSGKXTbaxQPtxI7FAJA91Wikg0bMnuC3D19u1sLKMb915McDOjYQf4L3AS5dgRQY7bipZJd+tJQzS+NrqUWjwflIQJrE7/NBh12cXFfTvQNn7nC3TwWuxzaCNcwJACgUp+74vXQNYzy0G0EPIOV80GNaxxThxF5x3hWaHHRo2DaUd5UZlwonNi2YoksK0uXijeVXCSc2ozSNIAwAAMgNw86LrWcMRfinIVg3b5lrmuXCaYt/nheZwHXaWkiBdLv5AofArZfoRHNSvqB/3Ty1Pewx1sXDmYqQFnT3AIA8On58WheAbKHjZhqMXGsyVkZaxNfUxrll8S2Mr/MFnKNKMl8UuO74POcDH7eyoQ2AojAlt8wd0UETaIdAAFLtoimzdV5pqnBik4IOvWzyLOXd9I4pOr80XTgx38nhZZNnqgiunDZHODEf+vIdkEqG4Q0AAMiFTqGljFxdOCUf8vCLesLZGCn6OH7HZLQKIY/T5xfv+8K2ddEI+uatDCyvVWqNdCrifAYAAJAC8XX6kvg65z4xdk6HkU54mxkro218wCO+XvPX1MYpFDC+xgIf95X6wm4BQAEk76e1MBTQRlRCAik3vTQ1CTPgxAIZzShAAKLccb4mB5OEE5sUlHR+RzGCMLMnnS+c3HmlKZoaTBYAAECmrWPCsC2c2SKcVKkWLiLkcc4Ie7RR/NyvFcVPp8+5lS1fwPJhnN6u/vh83LaQCU6PX+AcPZ+FAgAAQOvVwrIPSMfX6auEtKlQBI2WI+CB1qo451b7YBvnOgBF4Lt6CGgjgh5Ayvkgg/8PJ1YyJc3oyH/Hkxkd09QRf684sUmmQ9MLcBx4kw2Bn1MpBaXkBgAAkGWlBoXI7WAD9QsnVgsrLnCrhfEwFvYoCy2TFEBJ1wtnJPA/9y06Vn2YbHQnYl6n7EjOZ0m3JwAAALTOSLfCiIB0qpWTImjGyphoBDzQXkngg66fAPKOrh5oN4IeADItMCbpepJ3hsDPSyrK8zN78gzh5GaWztO00hQBAABkmQtYlGuLhgaEE0qCCRLBhPFTCUpupdASpVrYTQHUWauY0sSHvHzxkwtcTZxnssma5UmYigAbAADAxBsJefhrdALSWRCPlSmAxoQg4IEUGe36uTkJtzE3ACCn6OqBdiLoASDTXPzfsG0IKIqDzSHh5A7aQQ01hwUAAJBtjsX69qCjxwkkRfKiy8y4c+qOFz4XCRMrXlx2AQsw5yJerF80YbuVxa+P6euq+eInIducWZp0ZKGADQAAYOLUws7RLngVITNGC6AJe2B8+LBXb9hDwAOp5DeCiN+nSn3JfDIA5MpoVw/CbGgLgh4AMs06p33Ng8q7vY39OmQPCTjQIOhxKj741XBNAQAAZNbIJGGn0GoDqkZ09DhWvHhMkfzEiRc+V7MwMLGCDrtEFEGdswnZrWxkJ+L7kiAJ8qJCARsAAMDEKH1p3mK6bWba2FiZOT+ctWDdvCUjYS+3WEB6VZxzq4O+rtXMDwDIm6CkbgFtQNADSDkfYhimwP+kfEePIuzef8AOqSGK10/mYPz8PDf0gorghcZe4eT2Nwc1aOnoAQAAsqvUwU5s7eCkunCceOLQF2BXhIlSDgItFSaGX0y2pls4Z6O7lYUaLyMhD1+kVhHypjLa2YMCNgAAgHHiQx6uaXpEyCPrRsbK8esp4EzE11emr2t9PMexSpwHkBVO3aMBNzb4AJAbTm6hgDYg6AGk3MChfRQtn4IPwWwb3qm8Gxjep32N/HcuOVtDzUPxc1SMAMSzQ7uEE/OdPPY2DqhhCUUBAIDscpadzdvDbBGOF7glwgSLn2O6ekyIkpLgXEUYF+PW1aMWdo7sQMprk2NlCtgAAADGxxEhD+REEL+ewbp5dE/FaRnr4pFswABkjw+41YK+eSsFADkwuiES6zloOYIeQMptH35B+xuDwoltG9qlA40hFcG2wWJ0rDgbB5qD2jqY/8CPt3n/VuHEDjSH9PzQbgEAAGSb6xJazkj9wtHWJbv3V4SJVqbd98SwJUeR+TiKF7E6z3URyxepjXbyYDGsAChgAwAAODeEPHLMmuWMlXFKtbByRBcPINucWRr0dm1Ouu8CQNZ1EL5E6xH0AFJux9Bu7WscEE5sU4GK3n+w9wnhxPY2D+rZoWIEPfr3bBJObODQXm0d3CEAAIDMqoWdorC+LWxA0ONYgSV80Cq0+54AviCC3S7Hmw9ndOosHVGkRsijSChgAwAAOCuEPAqAsTJOZl0Y+k0SmNdAzvjuHveV+sJuAUCGxWtnoYAWI+gBpNzB5pAe2vekcGLf3vkDFcXG3RT4n8y2wZ16+uB2FcET+7dq0A4Lx9vXOEjQAwAAZFpQYnKwbRqqC8dw1wstMR6dEnC0UsfZBxJwckGgRToLFKkVHAVsAAAAZ6YWdsbjZ3bxLwLGyjhGfDwsCWzSCbMiIH/KzrnVnPcAZJkzrJ2h9Qh6ABlw9wsPCyd2x87ibLr6AB09TurugeL8jPjw1w/3bBaOt+vQXj1xoDhdfgAAQA45t0Roj2pER48jjYQOKJRvHf98V4Rx49hVa0KczSJWqRYuIuQBCtgAAABOUy30O57XRCe84mCsjFHJcWAJeaEA4vOe6euqsfENgCxKNu4CWoygB5ABD+6tC8fbNbxXj+1/WkXx/NCAnqFbwQnd+8KjKpLvvvCgcLxH9j2ZdPUAAADIpFroJwYrQss5YyLhaHRDaLlSied8PLGr1sSIF7EqZ/Lnk52IA7dagEcBGwAAwKmNhDzYyb+IGCsXXtDXtdofBwIKIp5jWhS/593n3/sEANlS1u2cu9BaBD2ADPjuCz/UtuFdwtG+9vz3NWwbKoqms/rKc3cJR9vXPKg7dm1UkfRt+5aG7LBwtC8+s0EAAABZFQRaKrSFkasLRymxc2jLOUchz3iKF4s5hidG5bT/5ItFarwWeJEvXPrSvMUCAADAceLx81oR8iguwh6FlYQ8nLoFFM/I3NHIJlgAkB2DjNnRWgQ9gIxYv/0+4Wg+6FE0//b83Wq4pvAiH3452BxSkTx1cLse3vuk8CIf+Ll798MCAADILtcltIkpVnL8dDQozG454+YK48hwDE+UWlg+jT9DyAMnFTRND2EPAACAowV981bGd3QmLDof9ugL2QymQJKffUIeKLaxsMciAUBGlEoEPdBaBD2AjPj6ju9r2BWne8VL2Ta0Uw/tq6tofrh3s544sFV40dd33KOieXZoh36w9wnhRQ/s2axdw3sEAACQRaVa2C12bGwb21S/AACnZ+pLhzdGQx4VAScRNM0qduwEAAAYEaybt0TOUNyPEc6tJBhdDEkHF372Aa8czyXVOPcByAo6tKPVCHoAGfHtXQ/o/t2bBMnG75bRjn7VDzynonny4HO6c8cP6Ooxyode7h14VEWz59ABrd9xn/Y1DgpKfh7+anNNAAAAWeUCt0xon2oUCQAwLkZ3Iq4IOLXy6I6dFQEAABSZHw9Zs1zAEQhG51+y8Q8/+8BR6AAKIEPoZI2WIugBZMSWg8/p009/TUN2WEW389Bu3bbtO9o6uENF4wv7b3vuO0ngo+h8cf9Xt39fj+8vZoeTb+16QI/T3SVx564f6N7djwkAACCL6ObRXs6YSACAccFupDhDhD0AAEDhjXbDo1AMxxrZ3Z6xcj7Fr6sL3EoBOI4PewR9IXNLANLNuFkCWoigB5ARg81hbdjRr4f3Pqmie+rgdn3rhR+oqO7a/aDu2/2YXPxfkT2y70n1brtTuw7tURE9sf8Z/cuzG1R0/tzY++yd8XmB8BMAAMgmunm0l3HaKADAuWMnYpydihkpYKO4EQAAFE4SlGbzD5xcZTQYzVg5Z0zJrRYBL+DknFtJ2AMAgBcR9AAy5PEDz+i+PY/JumIX+K/fcZ+eOVi8bh5jtg3u0le3363djf0qKv8z0L97kzbGt6JqOqtPP/VV7beDKjJ/XvzG8/ck3W4AAACyhm4e7WcDRQIAnJtaWB7diRg4Y0bqDErsZgsAAApmXRgSlMZpqJiSqwm54eeDjVMoAKfm4nmCL81bLABIIefMbAEtRNADyBBfyPyJJ76oJwu8c/22oV36X499Wg3XVFH5kMM/PP1vunfgURXVjkO79Zf1WnI8FNnmA89q+UOrk9BHEfnzwJqn/lUP7N0sAACAzKmFZbp5pECDoAcAnKsg0CoRXMS5cOoe3dEaAACgEAKb7OgPvCQfCgj65hGMzoNaWGE+GDh9QdP0EPYAkEpGswS0EEEPIGN8F4MvPrtBRXSgOaT/9uBfa9fwHhXdYHNYf7bps8lzUkS1rXfoe7seFKTPb12vjXseVxFt3r9Vn3+GDUMBAEA2BR12iSiKbSsXX2KrGg0IAHDWRrpTORbdce78jta1cJEAAABybjTgWhFwupxZGvSFS4VMi+eD/bVzRQBOWxL2qIWhAAAoMIIeQAZ96ql/1dMHn1fRfGfXA/r69nuEEXcPPKyvbr9bRbPr0F79vye/LIzYPvSCeuLnY6CxT0Wz8onP68mD2wUAAJA5tbCSFDOirYxRvwAAZ4/dSDHOgsCtTsZJAAAAecWcEM6Wcyvj46dTyC5rugXgjMVzBTXOfwCAIiPoAWTQw3uf1O8+9Hfa3divonh435P6w0f/Qc8O7RRG+M4mf7rpM3pgzxMqikE7rD957NPq3/OYMGLIHtIXt27Qhh3FqVGzzulv6n36QkG7GwEAgOyLFyZoS5YC1pheAQDOWhBoudiNFOOrnIyTamFZAAAAOWRKbqWAszRa7FwRMmekGybXz8BZKnP+A5AmRq4uoIUIegAZ1HBN9W67U2ue/FcNu4bybl/joP7fltv0vYEHhaN9f+Bh/VV9rXYd2qO8O9Ac0m3PfUdf2BqpYZvCi7YN7dKKR3r0wJ7NKoJ79zwaH/c17RzaLQAAgKwJ1s3zO59XhPZrKBIA4Owki+tusYDxVwkogAQAADnkC72N0yIBZ69iSm61kDm2xPUzcI4qoxtDVAQA7eYMBWtoKYIeQEbtaRzQX2z+or7/wsPKu89vjfTpZ76qweawcDQf+vnnZ76hTzzxL8q7e3Y/oo9v+mfVD2wTjrdx9yb97kN/n5wb8mzr4A6t3PS5pMsPAABA1iQ7t1mzXGg7Z0ykajQgAMBZoTsVJpRTd9AXLhUAAECOuMAtE3COjFMY9M0jGJ0ltbDsXzcBOFcVM9LZgy6gANqN9UW0FEEPIMM2H3hWv/PQ3+qgHVJebdr/jH734b/TtsFdwokNHNqnT9bX6u4XHlJeHWwO6WMP/V99f+AR4eS+uuNu/d8ttynP/uGpf9OXn/sOXV0AAED21MJKvKDPImxKGKlXAICzkgQX6U6FiebicVMt7BQAAEAOMIbGuHJmaTxWDoVMKHUQ8gDGSzyv30kXUABtZwh6oLUIegAZZp3TN3fer1+670/11MHnlCf+e3tg72Z96J4/IORxGp4fGtBH7v+47hl4JOnykScDjX366EN/Gx/rG3P3vY033/XmTzZ9Wn+3ZZ2GbL464PjX/l+evSMJt+W9awkAAMihWlgZ3fmcnaZSwjYVCQBwVtiJGK0SsFMnAADICcbQGG+jY+WKkHrOigA7MJ58F9B183hfBdA28Rpjv4AWIugB5MC6576tP3zsH7RtKD+BiAf31fXbP/yk+vc8JpyejXs2JYEI39nDB2XywId8bn38C/qHp74inB4f+vnjxz6tzz79DeXFsGuo9uw39T8e+jsBAABkzoshj4qQCvHVUl3ViElYADgLwbC6xXsaWqcSlCzFGwAAINMYQ2OClE3JrRZSL56LJOgBjDdrltPZCEAb0dEDLUXQA8iBfY2D+vwzkf6m3peLXfx3Hdqr//nIp7R+x71qWDo4nK6RDi8b9QePfkpP5qDDy2B8LP/Nlj79bXwbOLRPOH1bDmzTikd79JXtdynr/HG9/vl79T8fXaMnDmwVAABAphDySCVj6OYBAGfPLRHQSs4s1ZfmLRYAAEBmMYbGxDBOYdAXLhVSzcjNFYBxR2cjAG3DZnJoMYIeQE74Qvg/feyf9NEH/1a7G/sz2dGh4Zp6fP9W3XzvH6m27Q4N24ZwZvxz9tXn79ZHNv6Zfrhnsw657D2HLv5vf+OgVjzSkxzTvqsHzpwPe3zk/o/rM898XQeag8oifxx88dkN+g/3/S89uLdO8AsAAGQLIY/Usk2zRgCAs1UW0GJB06yieAMAAGQYY2hMHOeWMVZOO8M5AJgYZePDHgDQQk4i5IGWI+gB5IjvgPAXm/9F7/3Of9V3X3gwU2GPIXso6T7woXt+X7dt/y4F3efAv+5fff4eLb7vj9S37VuZ6vLiwz6P7n1Kv/aDlVr5+OeSYxpnz4c9fuuBv9QfPfaPenZop7LkmcEd+pNNn0lCHtuGdmUyvAYAAAqsFnYS8kineFRZVzWKBAAAsqRsSm61AAAAAByLQmcAhWWkzqBv3koBQIsYmQ0CWoygB5AzTWd198BD+vUfrNRnnvmassAX83/88X/Wbz7wF/HX/rAcBd3nzHfFuG/3Y/qvP/xk0uVlT+OAsuALW6PRY/frOkRHl3HhQxI+NPNfH/grPbSvriy4d/TY/cTmL2a2GwkAACiuYN28JUHg7hMhj1QyRpEAAEDmGKcw6AuXCgAAAMBRkkLn3nC5AKCInFmqWrhIANAC1tDRA61H0APIIb/z/cbdm/TRh/5Ga576Vw0c2qe08kXoH3vo7/W/N31Gm/Y/I4wv39Hh/265Tb/z4N/o8RQ/v8O2ob/bsi4JpUQ7++noMs4Gm8Oqbfumfm3jqqRzzrBLb4jmjp0b9Wv3f1y9z35Tew7tFwAAQGbUwrLp66rFM3yrhNSyTbNGAAAgm5xbFo+5KgIAAABwDLeEsTKAogoCt5pzIICWaLKhHFqvQwBy65mDO/SfNv6Z1jz5r/q1q6t62wWv1WVTL1S7WTk9N7RLX3nuLv2fx/9ZD+6tCxNnX/OgPlnv1Vef/75+ce6Nev/Fb9Orz5+rNPBf21e3362/3FxLCvx9RxpMDB/22LCzX/fsfkQ/e2mXfvPlH9Qrz79Sk037hwL+db9/9+Px+eCzWvfct7WvcVAAAACZsi4MAxsvJDi6eKSZk+qqRpEAAEBWlU3JrY7f0+cLAAAAwJEYKwMoMs6BACbc6DpjXUCLEfQAcs53SvDF3XfvfkgfuHS+PnzlT+nNs1+tGaVpaoddh/bqy9u+o88883V9Y8c9ydeH1vAdU3z3lH/bfpd+sfJ+vWvOm3TBpJlqBx/wuHPnD/TPz3xDX97+He0Y2i20hg9R+E4/G/c8rg9ePl8LL/lxXXvelQqMUas1XFP373lC67Z9S1/cGunhfU8S9gEAANlSCyt+8cBYFwqpFw95IycAAJBlxil0tTAkvAkAAAAczY+VTV+41C6I6DgMoHA4BwKYaEaml3VGtANBD6AgDjSG9NlnvqZ7Bh7WvAs79YFLQ4XxfasM2mH1Pfst9T13p765835tHdwh63jra7VDrqFo5316dN9TeudFb9RPX/Q2veuiN2tmx3S1ig8erX32Tn1l+116/MAzatim0Hr9ux/Tpv1P62vb79HCS388CXxcMW2OWmXLwef0uWe+odu3f0/3vPBIEv4BAADIjFpYDkp2mZxbKi5rMsM2za0CAACZFwRuta2FN6gaDQgAAADAi5xbFs9d9jBWTg9nXN3QCRpojZFz4Fp23AcwEazVWgFtQNADKBDfPeOHe+t6ZN9T+qenv6ofu+B1uvHit+sdc96gi6dcoPNKU1Uygc6Vi//zO/XvaxzQs4O79PUd9+gLz2zQA3uf0O7G/nhcTSVUO/mAzdODz+sfnvqKvrA10sunXaZfuPLdSeDjsqkv08xJ52mSKfkUqs6V786wvzmoXcN7dPcLD+uft35D337hAe0c2p0cI2gv393D/3x+b+BB/dnjn9V7L/pR/eylXbpuxlW6YPJMTQkmjcs5wR9zB/1xcGivHt33tL7wbKTbn/uedgwPJCEwzgkAACAzbgs7g4a646uexfEKXVnIjHjE2R8v7vQLAADkQSUItNRKywUAAADgSOWg5FbGY+WbhXRwZrfYLQholbLvwh7/xM0XAIyj0XXGSEAbEPQACsgX2O8+tD8ptPY3X9D9U3PepM7ytbp2+hW6YtpFujK+ndcxVTNK017y37PxW9mB5qB2DA1o2+AuPTO4Qw/ve1J37NioO1+4X4PNYSF9fPH9/sag7t/7hH77wU9qxqM96px5rebPuUHXnneFrpl+meZOvzgJfkwvTVVwGsGPYdfQ8/FxsH3oBT19cLs2H3hWd73wkNbvuE/bhnYJ6eQDH/72N/W+5PbqGXMVXniDbojPCXOnXayrp1+qC6eUk84vpxMASoJezYPaenCHnht+QU/s25ocB/58sGk/XVwAAEDG1MJyPHvSaZxbZhouFDLJGbp5AACQL4d3Kq4LAAAAwIucuuOx8hqKEdMhXl2nuwrQQsYpDPrC7uaCqEcAME5YZ0Q7EfQAkHRb+Owz39Dntq7XBZNm6uXnXa5XzZir8uQZumraRZrdcX5S6D856NB5HdPUcA0NNQ/pUHzvd+jffWiftg7u1LPxzRf21w8+qx1Du4Vs8YX+d+66P7nNiF/nV8THwWvOv1oXTp6lCyafr8unzNG00pT4WJiSHAdm9O94A/ExsOvQHr0QHw9PHnxOTx7Yrkf2PannhweSrh7Ilof2bUlu0zum6LL4dX/1+XOTc4Hv/HPh5Jk6rzQtOSf43/ddPw40h5LwxsH4fldjb/Lzv314l+r7n9MTB7bG54WtSUchAACAzBgNdwRWi5LuHVZ078i2+MKEdsoAAOQNu3QCAAAAJxaPlZfFY+VISIO6ALSUc25lvM6zVtWIoBWA8eDXGSMBbULQA8BhvsPDjuHdye17LzyYfM4X9k8NJqvDlFQygSYHk+L3rfg/a+NfbdLJ45BtUMSdMz7A0b97U3Lz/Gt/fsf05DjwN38c+KTHcPNQ8vv+OBi0w0knB38cIR8ONIa0qfG0Nu1/OvnYHwc+4DHJdGhSUIpvHcnn/DnAv+6+o8tgcyg5FjgOAABA5twWdgZNhU5uoXGuk3BHjhixoAMAQA75XTpdLQzZqRgAAAA4Gjvap4exqrtAAFqrHJTsMivdIgA4VyPrjHUBbULQA8Ap+R36/Q3F5rty+K4dKDZ/HOxtHBAAAECm3R5W1FBn4FRRfHNyXUbx44ZLgh1GyBvbNCsEAAByiZ2KAQAAgBNzzi1jR/sU6NCArAC0mjNL43NgL5tDADgX8bxj3bHOiDYj6AEAAAAAQB71hd0qoCTAMca4uf7OaSTUkQQ6ho/uPEawI9+cMRG77AAAkF/sVAwAAACcVCUItNRKy4W2aTbUH9DRA2gLNocAcK6MNWsc64xoM4IeAAAAAADkUODcahXdaKaDMEdxOaNbBQAAco2digEAAICTcUvisfIqxspt5ItDe7v8818WgJbym0O4WhjS1QPA2Ui6eVSj5QLajMwwAAAAAAAAcsdPwOrGaK0AAEDeJTsVCwAAAMCxyoyVU6EuAG0RBGyKBuDsOGtuFpACBD0AAAAAAACQO86YFQIAAAWR7FTMDrkAAADAcRgrt5/ZKADtUgn6QgJvAM6MjdcY6QaElCDoAQAAAAAAgFxJunksiHoEAACKgp2KAQAAgBNjrNxmxioSgPZxbhmBNwCnyxkT2Wq0XEBKEPQAAAAAAABArtDNAwCAImKnYgAAAODEGCu3U1PqF4B2IvAG4LT4jeRcU1UBKULQAwAAAAAAALlBNw8AAAqrHJTULQAAAADHosi5naqRD3oMCEAbEXgDcGrx+uJGZ838+H2b92ykCkEPAAAAAAAA5AbdPAAAKDDnlggAAADACVDk3F6mVwDaic0hAJycNWucNaGqUV1AyhD0AAAAAAAAQC7QzQMAgMKrlNaFiwQAAADgWHT1aCejfgFoLzaHAHAM5ztuWXOLrUbddPJAWhH0AAAAAAAAQC7QzQMAAFgKNwAAAICTcIuFtrBN9QhAu1VUC0MBKLzRgMcKZ83VthqtEpBiBD0AAAAAAACQeU6mn24eAADAOIUUbgAAAAAnRJFzu1SjAWcUCUBbmZJbJgCFlIQ7jOmx1tw8GvBYThcPZEGHAAAAAAAAgIxzVlUBAAAoKdxYEi/eRgIAAABwFF/kzFi5PYxMbzyLGQpA2/jNIZwPvFWjSEDO2MAtVSPYLRyrntyqUd0JyB6CHgAAAAAAAMg2ox4/QSsAAAAlhRuLXC0ssysfAAAAcDSKnNvHNtUTBFopAG0VlNxiS+ANedQR9OpG1sqAvAkEAAAAAAAAZJST6rZpVggAAOAIQaClAgAAAHCceKy8SGi9ajTgDMXlQNu5+BzoN4cAACADCHoAAAAAAAAgs5wxK+jmAQAAjueWCAAAAMAJuMUUObeHY8MaIA3KbA4BAMgKgh4AAAAAAADIJN/NQwuiHgEAAByvrFoYCgAAAMCxyqUSXT3aohpF8a8DAtBWzrguAQCQAR0CAAAAAAAAMshZM18AAAAnEZTcYitFAgAAAHAU67t6SD1CG5hb45nNZcJZc0lYxgzIqG78ZkAjn9zi76wd/XgkUHO6oZqKSioHTuX435zr/MdOFSNXEXLJOIXObw4xEr4CACC1CHoAAAAAAAAge6xZES/C1AUAAHAyTotUC2+JxwzsmAsAAAAcYbTIucxYufWs1aog0BL5LoQ4qdEwR90Y9Vtpo5pJgGPkdsRx6zR+7LFfg/8ZkTpVUmfg1OnkuowPgSAX4p/DRWwOAQBIO4IeAAAAAAAAyJR48a7uqtFyAQAAnFo5KKnbSqsEAAAA4ChBoKXxWHm50Fo+pNAb0tXjCEmow5govt8wGujoH9vkZzyDHGdsJFAS+dtYCMTVwkp8F5qSFhvnQiHDks5GSwUAQIoR9AAAAAAAAEBm+EU/Z818AQAAnAYnt1AEPQAAAIDjOOO6hLYoelcPP8drjFlrm9ogH6TIUufmka+1x/nbWOgjcMvo9JFJZdXCMH5NIwEAkFKBAAAAAAAAgIww1qzI1MIfAABoK+MUqhYWsngKAAAAOJXRsXIotF7SKcLcqgJxxkTWmFusNTe4hRtm2wXRzfHz0JPpuV7/tcffQ/z9XG2TzYnMGiFTgkCLBABAihH0AAAAAAAAQDYY9dhqxI7cAADgjAQldQsAAADAcYJAodAWvquHk+rKsSPCHbPdgmi+FsRzu9WoX3lUjSK7MOqOv9er/fctZIRbLAAAUqxDAAAAAAAAQMr5RU/XNLcIAIDT4GTqow8HZOKbk+/oEN9c2ST3KBIntzC+IywKAAAgxso4mjOuS2iPajTgauEtJnA15Ug8jztgrLnV+muwpHNJwVSjevwczI9f2+74tV0Wn1crQpqVk85G1SgSAAApRNADAAAAAAAAqeYXB51vfV/EhUEAwCn5IjVjFFlpo5ryu4LWfVHFqf9OrBZW5IstSuoMnDrjz11v5DqFXDJOoauFZcYSAACgSI4ZK9fjT/UzVsaxkrHy7fFr/t5THxuYINVorevrivzroIzzXSxcUyt8wbwT4uehJ74OjUyg5XSNSDff2Sh+r4wEAEAKEfQAAAAAAABAqhlrVrgqi80AgBFJ8YjUq6bWju6UeeZG3lf8zRe+jfy7IwVtoSlpoXFukZArpZIWNaUeAQAA5NhEj5V9Mazvlkbnj3wJDmmRpQNe27imudkE7j5l9efKqMc2zRo6IpxAfD6Nf7a6VQv7g8CtFFJptAvocgEAkEIEPQAAAAAAAJBe1qyw1YiFZgAoON/dyVhza1J8NFFdGUYK2nqcv42FPgK3zPjdjJF5Tq5LBD0AAEAOHTFW7tFEbZQxOlZO/j9qYTn+/1xkSlpsnAuFzBstcmb+rV18GKAWVoPArVeWjAQ8VogNel5aPL9tk+4ersYcQ/rEr0knXUABAGkVCAAAAAAAAEghZ7TWVqPlAgAUlpPq1pib3cINs5P3hFYtuvtClWrUE///Xm2tme93RhayzYkuLQAAIFd8wMNvkOGsuXp0rFxXK/gxuR8rL4jmx2PlGySzRsg04xT6AI/QPr4bRvzzrAzw18f+Otku2HAzIY8zUI36nZ9fGOmYhJTxXUAFAEAKEfQAAAAAAABA6vgFL9c0NwsAUEijRWu3+KCFFkQ9aqdqFI0WsVGQkW1l1cJQAAAAGXeCgEf7diCvRv12YdQdj5WvJhydcR0KhbZKfp5teoNTYwEPf32cBFNw5qpRnbBHOo12AQUAIHUIegAAAAAAACBVkpBHvOBFq3QAKChrbh0tWlulNPGBj5EOHzdTlJFNQUDxGgAAyDbf/TQVAY9j+eLlkXA0Y+WMCixj5TSIf7a70xb2IOAxzkbDHvKhPaSH4xwIAEgngh4AAAAAAABIjSNCHnUBAArFvwf44hFbjZamOuxXjXpGijLSu9MqTswZdugEAADZ5Lt4xGPlqluwocpYGRPDLRRSIQl7yNyqNiPgMYHiuW9/ThfSpKLbw4oAAEgZgh4AAAAAAABIBV+04PwCFyEPACic0Z2Jb8hM8YgvyliY7LS6QsgM43forIVlAQAAZIgvth4dK69VFoyOlX13D7FjfZZQ5Jwi8c/Q0nZdbxLwaJH4uY2f51uE1CgdoqsHACB9CHoAAAAAAACg7UZDHn7xsF8AgGKx5pbU70x8ErYaLbfWXO27kQhZ0SkAAICssGbFaLF1XVlTjXrisfINjJWzgyLndBm93qy27GfIqIeAR4tVo1XOKBJSwTnmCwAA6UPQAwAAAAAAAG3n/C6PhDwAoFB8yM8XkdhqtEpZVo3qPqxIAVs2BIEWCQAAIOX8WNnEcyW+0FtZ9uJYmTmfDHByXUK6VKO1yeY4Mms0Afy5xgfK4mvz2XbBhpsJeLSea7YwzINT4hwIAEgjgh4AAAAAAABom7HCBb9oKQBAYfgiBmfNDbkpIhkpYLuBArb0c8ZdLwAAgBQb63rarEY9ygM/Vl644QbZiSlUxzhydPRIpfhnyC6Mun03yfEKfDiZfmvMLfG55uokUJbBDpu5ET/3ySZIaDsjVQQAQMoQ9AAAAAAAAEBb5K5wAQBwWkZDHvN9sYryZKQ4Yz4FbOlmnDoFAACQUkcEonMXILbVqJuxcupVVAvLQjodHfi49Uy7QCTdO+K/5ztruoXRDVoQrSLgkRLVKHJGbITUfuX4HMicAQAgVQh6AAAAAAAAoOXGQh55LFwAAJxcbkMeY6rRgC9gc0aRkFYUbgAAgFTK/VhZhD0yoYOuHqk3EvhY6hZuuNpac4NNukGYW50xkZOpjwQ6RviPZUxPEu7w3Tviv5ebzpo545rmFh3x2qE9SiU2hwAApEuHssiq4QI9baQrBAAAABSMc2ZLPDPbEAAAGVWEwgUAwPGKdP53TVNV4NbH6xgUCKRQUFJoJcKmAAAgNY7YEKOunPNhj6AWxoMyt1hIncCpYoXMGNlEp//Y18yd5DFSzJ//e8Nb41dsmdA2ji6gAICUyWZHj0D7jMydAgAAAArIGN2pIe0TAAAZRMgDAIqpSIVriWqUfL/+fU9IIXe9AAAAUqRocyVWWuoI3qaSc3T0ANrFWq0SXT3aKn5vqggAgBTJZtBjxJAAAACAYqKbBwAgk5wxkbPmBkIeAFA88fn/5sKd/wl7pBY7dAIAgFSx5pbRXfmLg7FyahlC0UD7xOfG+KfwVqFtOAcCANImy0EPAAAAAAAAZIU1t7oF0fyRxSoAQKFYsyI+/69VEVWjkU5W7MiZKoYdOgEAQFrE8yW2Gq1SERH2SKuKamFZANqCrh5txzkQAJAq2Qx6TDloZdwuAQAAAMV0UFOmWQEAkBXW3GKr0VIBAArHF23F7wHLVWTVqG59RxOkSVm3hxUBAAC0UTJWlparyEaC0YyV04cOeEC70NUjDSoCACAlshn02DfNyrphAQAAAEVktFv7DhL0AACkXlKwYM0Nhd2ZEgCg0W4WSDqaUKiRJqVDCgUAANBGyViZzqd+rBzF80e3CKkRlAh6AO002tUDbVLiHAgASJFsBj1mTXYyOiQAAACgiJw9lIyJAQBIMWdMNFqw0C8AQDFZs8Lv0Csk7MJoqTOKhFRwjh06AQBAG1lzK2PlI1SjVYyV08RdLwDtU40GOCe2j/NdQAEASIlsBj1277UKzB4BAAAABWRLGkjGxAAApJU1K9yCaD4FCwBQXElXp2q0XDiKa5qb4zt2bU4D4+YKAACgDZKxstit/VjxWLkqxsqp4By72QPtFp8TVwjtwcYQAIAUyWbQY84UF1/0DgkAAAAoooY5pP1T6OgBAEidpFDBmvkU9gIAnKEg4YSqkX+v5LlJAYrXAABAuyRjZTbHOF41GojHyjcLbWdEkTOQAr5TNuG3NnCcAwEAKZLNoIfUkDXbBQAAABTTXr1+b1MAAKSIM1rrrLkhXpSPBAAoNB/804KoRzixarQqft+MhLaieA0AALQDY+WXUI3WMlZOhbJqYVkA2qcaDTiZDUIb0AEUAJAe2Qx6PD/HKXB09AAAAEAxGbdbT1xjBQBACji/q5g1t7gFG6p+8UkAgMKjm8dLc02eoxQo6/awIgAAgBZirPzS4rGy7+rBHFP7VQSgrQKrtULLGT9fAABASmQz6PFzn7dq2D0CAAAAisi63brp83T0AAC0nTMm8l08bDVaJQAAxA7Fpy3pgGXWCO01SPEGAABoHcbKp6ka1eOx8q1CW5VK6hSAtooXgyOhHSoCACAlshn0MPH1rwmG40cNAQAAAMXSUGAOCQCANvJdPKwxN7sF0fyRxXcAAEawQ/Hps1bLhbaieA0AALSSMRTsnq54rOw3FaGrRxs5drQH2m8k+FYXWq8Wcg4EAKRCNoMe3khx2z4BAAAAxbJbrjQkAADaxZpbnTVXswMlAOCEmhSvnbaRgg26erQRxWsAAKCVbJMuFaetGg3Q1aPNHDvaAymxQWi9qcwXAADSIbtBD9McdnIHBAAAABSIkw74sbAAAGix+D1oo7Vmvq1GS0cW2wEAOJozJqLT05mxVj1CG7nrBQAA0ALxvEp/PFbuF04bXT3azLhZAtB+Rrx3tMMgQQ8AQDpkN+jhOobiL3+vAAAAgCIxOiQbOAEA0CLOL6hbc4tbuKFT1SgSAAAnEb9n0J3iTMXvrc7QBaVdnDOzBQAA0ALG0MntjI109egV2sI5dQpA2xmjutAOBD0AAKmQ4aCHGvEv+wUAAAAUidMuuRKd7QAArWHNrc6aq201WiUAAF5Kk8DC2XBNs0JoEzdXAAAALWAZK58VOuC1j6HIGUiFZoOOHm3RwTkQAJAO2Q16lA4diq8qKHADAABAsRizT9OawwIAYAI5YyI7EvBYOrJ7IgAAp+ak/vg9oy6cDV+0wfttG1C8BgAAWiEeK9fjsTKFumcj6S5r6kI7VASg/UbmWpgzaLGSY74AAJAO2Q16NN2gnNstAAAAoEic3a/hSQQ9AAATYjTgMd8tiOZTrAsAOBNGZoNwdpJQpVkjtAOFGwAAoAXMRuFcMFZul1rIeBlIBUPQAwCAgspu0GNoxqAx5gUBAAAABWJM8LzsITrbAQDG1TEBj0gAAJwhGygSzpq1Wiu0A4VrAABgwhnDWPlcxGPlSGiPqYyXgTRwxtUFAAAKKbtBj2k7BmW1RwAAAECROHNIU6ZZAQAwDgh4AADGTUN14Vz0xzd26GyH28OKAAAAJpBtJmM9nK2ROSvGyu0wSNADSAPjzBahpZxTRQAApEB2gx6X6pCM9gsAAAAoFLtD0w7S0QMAcE6cMWsJeAAAxtFA/H5C8dq5qEYDzlAACAAAkFOM886Z6RXagaAHAAAA0EbZDXq86Z5D8a8vxLemAAAAgEIww/IFVPOjhgAAOEPOv4dYs8JaM9stiKoEPAAA48UZQ+HaODDObBRab5BdOgEAwMRxPuRRjehGca4IRbdFqcRYGUgJ3kcAACioDmVZYPbIaii+NJ4uAAAAIOec3JAbCTsDAHDanDFR/P7Rq6Z6HIUFAICJ4LRbOGcmUOSslggAAAD5YQxzMePANhUF2d3KFgDOFe8lAAAUVKaDHtZqZyB3IH5I0AMAAABFMJSEnQEAeAm+e4eRWRPPnaylcwcAYKIZqd8J56rZUD/Fa63ndymmdTwAAJgoxmkjY+VxURcAAAAAFEy2lwxK2hGvIB0QAAAAUAwH4vHvTgEAcBK+e4c15hZnzdV2YbSUkAcAoBWMoehqXFSjutilEwAAIG8Y342HpEutqQst5ZwqAgAAANA2me7ooWZpu1xjv98uDAAAACiAgxpq7hIAAEdw8SK3sVpjpZ7RAlEAAFqq2SToMX7MQPzuXhYAAABygVD0+HHSRiOCBwAAAACKI9tBjw63W00z7CPkAAAAQAHsV2na8wIAFN4R4Y7Id+1gZgQAgHygeA0AACBfmoaOHuPF0B0FAAAAQMFkO+ixc8cON2v2fhp6AAAAoCAGNXn3bgEACskZE5mmNlhprapRP+EOAECKUHA1Tiheaz3nCNYAKKhaWNZUHd1FqnHEOTGI35OCI96XBuPH1Yj3KeBMNRjfjSOeSwAAAACFku2gx7+//4B6u3aKpAcAAACKwGmn3vu9vQIAFIKLF6+NMWttUxs0Eu4YINwBAEilqRRcAQCQGj7AMVkVNdUZ+DCbcXPja8myRoJtZaMk3FFOrjqHT/Hv2GM+DuJbb5d/5K9NB+I1+rr/wDiz0X/OBur392rE9wRCAEwMzi2tVxYAAACAtsl20MPImV6zJZmEAgAAAHLOlcyjfgwsAEAujRTKGN+po1fNpDAm4qQPAEDh1AUAwOnyoY4OhYFV6IybG19YdsbThxU1jvgzTuO9b+JIWORwRyQX+l+DsWDISCCk7ozqxpkNNlBE+APAuDDx3BmTZa1l3CwBRXJ7WDn82MbjHXtM2KlNHSGd3PWG8x8AAIWU7aBHwmwm6AEAAIBCsGarAAC5MRrs8GGODWPBDgEAAAAAcCrrQh/sWOTkuoxc51jnjZQV/1VMUgjp/Ne6zIc/XG9Xv1ES/FirG7n+RYFMJcg7XkxTAy4QAJzcWFCjEY9DRkMZwWhXs7HgUjxk8r832uEsCcRWDv/9YWoQAQBAumQ+6GGc3ezGeQsSAAAAIJVKzU0CAGTSWLcO47TRWvXHn4pUjeoCAAAAAOCljIY74qvLxbJurCgxU+KvtzP++jvj72OJ7/gRfyKyJXOrfjrqFwAAwKn4LmZTVVYjHk84lZPwhnFz3YtdxspJYONUQY3R36LMEAAAZEnmgx7NRnNjMKkkAAAAIPca2iwAQKolgQ6ZAeMLVqSNaia7NvaPhTrYDwwAAAAAcFpqYTnosEtkzdKxcEeO+J20u4OG6/adPgJjbm0uiHoEAACKy3fjeDHI0ek7cLj4fqTjRjwWGj7mzztCGwAAIP8yH/TQ9EM71Cg14sFb9r8XAAAA4GScDmlW8JgAAG03FuaIV5F8h44t1qhOoAMAAAAAMC4OBzzcUlmTt4DHcXynD+fc6qC3a5kxZgWBDwAAcs4HOg4pPNyVYyzMMXxMsJUgBwAAQA7CEe/73h71dm2PH10mAAAAIKecMVs0PxoUAGDCHA5w+HujuvH3PshhkxCH/3w9uVWjgSP+DgAAAAAA4yJYN88HPJYXIeBxApWxwIe15ub42jsSAADIrlpYVoc6k+4cctefMNBBmAMAAOCUctEFwxnzQ+McQQ8AAADkmHtSAHAmjOlRkTltOfJDazSgpsYCGgPH3DTWiePofwIAAAAAgBaohZ1B4Hpkdb1QiZ+L9eqbt8o2gxVHbrYAAABS7LZ4PNNU+GKow3XGY5vDCHQAAACcuVwEPeKB4QPx3bsEAAAA5JRx5l4KjgGcCbsgulkAAAAAACDVRrt4rBKO5szSIHCLbC2cf6LNGQAAQBsd0a3DyS00vmtH48VOHYQ6AAAAxkcugh7x9NcmHRkBBgAAAHLGym0WAAAAAAAAgNwI+rpWxxN/3cLJJN09bC2sqhr1CwAAtM+6MAxku5wzoXFJt44k2EGoAwAAYOLkIuhhm41HglIwKKepAgAAAHLHDMnZTQIAAAAAAACQfbWwHAQuite3rxdeig973Ge/NK9b779jjQAAQGv4rh0lLQrkuuIxyyJZ37HDEOwAAABooXx09Jhc2qmG2xo/ukYAAABAzjhpkxRsFwAAAAAAAIBsGwt5iJDHmQiapsfWwi2qRpEAAMDEuC3sDKxdONq1I/SLlAAAAGiffAQ99nfscpMPbTSGoAcAAABy6VGV7G4BAAAAAAAAyLSg5FbSyePsBIGr2Vp4g6pRXQAAYHysC8NAtstZ020arkLXDgAAgPTIR9BD2m2SXY4BAACA/DFGW5wJ9goAAAAAAABAZgXr5i2TVbdwtsomcDUn3SAAAHD2bg8rQcMuTsIdlnAHAABAWuUk6PG1fbLhEyq5ZvxBSQAAAEB+NOOJ1Y2aoQEBAAAAAAAAyKZaWJF1y4VzEs+VdprecLldGC0XAAA4fbWwHJTU7eQWmmEXEu4AAABIv0B5cJOaJrBPSu45AQAAADnipF1Np22aHzUEAAAAAAAAIJOCwK0XxolbkgRnAADAS1sXhkFvuCoei2yWcyuNUygAAABkQk46ekhN6Skjs81IlwkAAADIj2fiUfs2AQAAAAAAAMikUi30u2dXhPFSNiW32knzBQAAjndk9w7ru3cAAAAgi/LR0cMrBc9K5ikBAAAA+bJN+5vPCAAAAAAAAEAmucAtE8ZVsht5LQwFAABe5AMe6+Yto3sHAABAPuQn6HFjtMNY+5ScrAAAAIBcMNbIbdJN33xeAAAAAAAAADLHd/OI7yrCuAtKbrEAAIAPeFSC3nBVEvCwZnn8mbIAAACQefkJesRsEPxQRgcEAAAA5II7YBWPcQEAAAAAAABkEt08JpDTIr9zuQAAKKqRgEdPEvCQWyICHgAAALnSoTwx6o8ncwbjRzMEAAAAZN9gMsYFAAAAAAAAkD21sFNyFWGilINAS620XAAAFIkPeAT+/Y/uVgAAAHmWr6DHoB5wU9wuI3OhAAAAgIxz0i4/xhUAAAAAAACAzAkCdQsTyhnXJQAAiqIWloMOu0TWLRXdOwAAAHIvUJ7cFO0zxtwjAAAAIAeSsW08xhUAAAAAAACADCKEMNGMU6jbw4oAAMi5YN28JUHgNsua5SLkAQAAUAj5CnrErA2+KwAAACAHrHGMbQEAAAAAAIAsqoW+ALNTmHDBIS0SAAB5tS4Mg96u/njhcJUIeAAAABRK7oIeMu7bcjooAAAAIOuM+YYAAAAAAAAAZE8HIY9WcXILBQBA3tTCctA3b2Vg3fr4o+sFAACAwslf0KNDT7tADwgAAADIMOf0HR3QDgEAAAAAAADInMAR9GgVw3MNAMgb38UjcPfJmaUCAABAYeUv6GH37jHOfUUAAABAhhlj/k3T9u4RAAAAAAAAgOxxqgitUlYtJOwBAMiFI7p4VAQAAIBC61DeHLxmyE7f9t2gYQ7JaJIAAACAjHFyB5zMd/3YVrpHAAAAAAAAALLFSRUjtEpQUmilfgEAkFW1sGJKbnU8iAgFAAAAKI8dPW76fFPN0iMu0A8EAAAAZJExT6ipp5OxLQAAAAAAAIDsMW6W0Dp0UAEAZNm6MAwCt94Q8gAAAMAR8hf08Kx2GKuNSjZKAQAAALLFOHOPjJ4WAAAAAAAAgEyK5/gqQss4uS4BAJBBwbp5SwLr1scPKwIAAACOkM+gx8ZojwJzfzx9dlAAAABAlhgNxr/+IBnTAgAAAAAAAMgoVxFaxlAcCwDIoGDdvGWyZpUAAACAE8hn0GO5rJW9P57NeV4AAABAhjjnnrWBvufHtAIAAAAAAACQPbWwLLRamecdAJAlQV/XalmzXAAAAMBJ5DPo4XVs/Zaz2iQAAAAgU8xTKh28XwAAAAAAAMDRKGLPig51Cu1QEQAAGZCEPJy6BQAAAJxCfoMe79s0ZAJ9VQAAAECGuJL5st73vT0CAAAAAABIMePMFqHVCHpkRInXqi1KJQI2AID0I+QBAACA05XfoEfMOn1RAAAAQJYM6zYBAAAAAAAAyCzn6CzRDo6ADQAg5Qh5AAAA4EzkOuihBdHjzuhhAQAAABngjHlAsxm/AgAAAAAA4CRuDytC+hH0aA9H0AMAkF6EPAAAAHCm8h30MHJG+lz8qCkAAAAg5Zxz/6T5UUMAAAAAAAAAMsuJoEdbGDdXAACkULBu3jJCHgAAADhT+Q56xKwtfSW+e0YAAABAuj0p5zYIAAAAAAAgGwaE1hskQJAFRgQOAADAiCTkYc1yAQAAAGco90EPGfN4/OttAgAAANIsMOvVdJsFAAAAAACQDQQ92qBUIuiREZ1CyzmZigAASJNa2EnIAwAAAGcr/0GPhV9/zlj79fjRXgEAAAhIHycNWGmtfvabzwoAAAAAAAA4iXgeqSykmy/oBAAAqIWVIHA1AQAAAGcp/0GPWHOSuy+e9LxPAAAAQDpt0qH4BgAAAAAAkBWGjh5t4ejokXodhHHaxjmeewBAagSBWxvfVQQAAACcpUIEPfT9O+tO+m78qCEAAAAgXRrOmUiz9bAAAAAAAAAywjQJerSFcbOEVAuc6OjRJoaONwCAlAjWzVsW310vAAAA4BwUI+ixXFbWfCZ+tEMAAABAugwosLdrfkQoGQAAAAAAAKfkCBGkXvwahQIAAMVVCyuyZrkAAACAc1SMoIdXjfqd9JAAAACAFLHG3KkFd3xDAAAAAAAAGdLsUF1oOSNVhFQzcnMFAAAKKwjcegEAAADjoDhBj5iTPhlPrQ0LAAAASAujNQIAAAAAAMiahgaEdiirFpaFNKPrCgAABRWsm7dMBHMBAAAwTgoV9FBQ+raTu1MAAABACjjj7pI9dJcAAAAAAACyh6BH+1SEdFoXhgIAAMVUCyuyZrkAAACAcdKhIjm47Xk36ZIeU2rOkyvY9w4AAICUMcPOmv+tWcF2AQAAAAAAZA9BjzYJSgqt1C+kTuDo5gEAQFGZklstJ+AwJ1M/4sMBmaOuoQbMaV5TOeduiP/s9QIAAIVTrLDDTQ8Oq3bRN53T9+PBz1sFAAAAtEnSaa6jea/m39kQAAAAAABA1lSjAfV2Ce3gKPJKqXgdOjQCAABFU6qF3c65UMitJLRhVI/HevX4g93xpwasjR+P8PcDGgtuVKP66f2bpyfoDZdzDQAAQDEVr6tFWU+73abXBK4zHi1NFQAAANBi8UTgvnjR96s6r2OrAAAAAAAAMsvvUOsqQks5ukaklpGbK7SNM0ftmg0AQMu4wC0TMs+HOYxRFD/YMhri8F30Bo4MbtC0BQAAtFLxgh7zo4a+EK7VJC2OP3qVAAAAgJZzm9Qwa+Ox6aAAAAAAAAAyyw0ILWekTlcLy0lXFaSHf03kCOEAAFAwSTcPws+Z5IyJjNNGa7VWPtQRj68JcgAAgDQpXtDD+0D0sF0brgmM+2MBAAAALeac+Wc/JhUAAAAAAECGOZkthsL2dvHPeySkR0f8mlgBAICCoZtHtvhwh5N61VQPwQ4AAJB2xQx6eMPqcVP0a0a6QgAAAECLOJmn/VhUAAAAAAAAGRevs9FRok2CQKEl6JEqgdUiAQCAQqGbRza4+LrFWHNrPH5eldGueBUBAIBCClRUN0XbnDX/RwAAAEALOae/9GNRAQAAAAAAZF9daAtnXJeQKvFrcr3QVkauLgAAWohuHunm4usVa8wtzpqrbTVantGQBwAAKLDidvTwJuuzruE+bGRuEAAAADDB4snEr6m09+8FAAAAAACQA8aq7oq7rVxbGafQ1cIyxWopEb8WxrlQaC9ndgsAgBahm0d6+YCHM2aFFkQ9ygFn3Nx4/A8AAAqo2FOv++c8b4z56/jRPgEAAAATa19gzad1z427BAAAAAAAkAcdImTQRqWSFgmpUBKvRUpwTgIAtIwtucVCqjg/FrBmhbPmhryEPAAAQLEVO+hx0+ebtnRen3NmvZKxHgAAADAh4vlE3dGcoq9p+XIrAAAAAACAHGg21C+0jRXFhWlhA4IeqWAIegAAWqQWVnyHNSE1nDGRD3jYarQ8b13vjDMVAQCAQqKZ8vu+/Jwz+qf4EW1cAQAAMFF2q6l/1F3hVgEAAAAAAOQHRdVtZJw6VQvLQtsZuS6h7QznJABAiwSBlgupMNrF4xa3IJqvalRXLrmKAABAIRH0iGfdNFNrrdPXBAAAAEwAa0yk6obP0M0DAAAAAADkyshOuRRWt0+5VKKTRLuV1oX+NSBwkwLNpuoCAKAlCHmmgZM2jnbxWKW8qoWdAgAAhUXQw5sfDcqYP4kfbRMAAAAwjuIJxk1ywUoBAAAAAADkU11oGyu3WGgrZwnbpAjBMwDAhBsNeVaE9rLmVrdwQ2d+u3iM6iBQDABAkRH0GDPp4KPxNNyfSWZYAAAAwDhw8dgyXuj9c8203xYAAAAAAEAumY1C2xinULWwIrRHLSyLsE2a1AUAwAQj5Nl+xpqbbTVaqgIInOjoAQBAgRH0GPO+7+2xDfdPTvqqAAAAgHPlZGXdnXLua5ofNQQAAAAAAJBPdaGtgkDdQluURKFnqlQjOnoAAFrALRTawkkD1pr5zWrUo4JwPtgNAAAKi6DHkX72m886uVvjR88KAAAAOAfO6EnnzEr9zB0PCQAAAAAAIKeMJejRfm7JSGcJtJot0c0jLZzULwAAJlhpXehDnoy72sRZc7OqUaQCMXLXCwAAFBZBj2MNDd8Z/9ojAAAA4BwYp8+rsf3fBAAAAAAAkGNNiqvToBwEWiq0Vi2sGHZYTg9j6OYBAJhwztLNq22suUXVaK2KJB5vxr9WBAAACougx7Fu+s5Bu8v8vpM2CQAAADgL8Vhym3Xmj3TTg8MCAAAAAADIt7qQAnT1aLUg0HIhNYzTRgEAMOFcl9B6Rj22Gq1SwZREqBgAgKIj6HEiN0eDrmE/6Jw2CwAAADgTxu1yzv2UqhE7yAEAAAAAgPxL5kBMXWg3unq0HIWeqWIInQEAJlgt7BTdFVrOSXXbNCtUQC4g6AEAQNER9DiZaTN+aEr66/jRPgEAAACnw7hd8RD7D/Tk1kcFAAAAAABQEE7spJ8OSVePijDhSrWwWxR6pool6AEAmGBBiaL7dnDGrFA1qquQCBYDAFB0BD1O5n23D9mS+ad4QqgWf9QQAAAAcErGWhusj8eP/6jf2DQkAAAAAACAgjCiwDolyqbkVgoTzpbcYiFdGpyHAAATyzmCHq3mu3loQdSjIloXhiJYDABA4RH0OJX3Rs/IBP8nHqg/JgAAAOAUnNzD8WLi7+qecJcAAAAAAAAKxFj1C6lgnBaplhSFYaKsC0NDoWf6VCPOQwCACWXkrhdaKunmUVCBVbcAAEDhEfQ4lXiErhvXb3TOfiz+aIcAAACAE3BGTzrn/lAfiB7W8uVWAAAAAAAABdKUIiE1gsCtVi0sCxPCOLdMSBUnwmYAgAlWCztFd4WWKnQ3j4TrEgCciUExDwDkEEGP03Go9BVr3J85uQMCAAAAjuDHiM64P9W0qb0CAAAAAAAoompUj38dENKiEpTcSmHclWphN9080shsEQAAE6jUQcij1YxMYdde/ZhTBIsAnCneq4BcIuhxOm6K9sns/4RxpkfJpkQAAABAspNMw/kxYsl9Tu/+t/0CAAAAAAAoKGfYUT9VnLqDvnCpMH5qYdkFdPNII2PoKgQAmFjOEvRsNWu1VgVlS26xgMxzbAbRYiVHRw8gjwh6nK4b7zlgh80fOKfbBAAAAHjOfE2lSX+i933zeQEAAAAAABSYcWajkC7OrVQt7BTGRVCyPuRREVLHNgmaAQAmljPueqGVBlSNIhVRLazQQQ554AxdP1vNOa5XgTwi6HEmboq2OdmPOuk+AQAAoNDiMeF34wvlj+rGrz0pAAAAAACAgjOWQus0CgJX88Viwjkp1cJFcoYOKenF+QcAMKGME+HZFnLGFPa9PQi0XABwNoybKwC5Q9DjTC365oPO6FecxK5EAAAABeUC83g8JvwNVSMWEAEAAAAAAGJNKRLSqBIEbj1hj3MQP3cucCuFVHI+5FGN2C0YADBxamE5/rUstIxx2qAiSsbsbrGAHDDObBFai25AQC4R9Dgb9264xzn3x/Gk0VMCAABAocRjwKfjseDHdO/8ewQAAAAAAIAR1agumbqQRoQ9zlb8nCXPXfwcCqlkDN08AAATrINuHq1mg2K+v9PNA8A5qoyGEwHkCEGPs7FcVrOCLzprfs8ZbRMAAAAKwY/9nDMrtNPUtHy5FQAAAAAAAI5UzJ13s4Gwx5mqheX4OVsrQh6pZmU47wAAJlTgCHq0XEPF69ZFNw/kD1332qBU0iIByBWCHmdrftRQWZ/1hX5Obo8AAACQay6eiIjHfcs1S/+om6NBAQAAAAAA4GjsrJ92Y2EPihVfykjII4ofXS+kW1ORAACYSI7QZxsUrkCcbh7IIYIebeDkugQgVwh6nIv50aBmqscp+G9OhrAHAABATvmxnnPBEp0frEnGgAAAAAAAADiObWqtkHY+7HFf0BcuFU6sFibPkQh5pJ6T6qpGdQEAMIEc3b1ab2rBCsRv80FsunkgX4yNx+poPadFfuMCAcgNgh7nyhf6Dc35f87pvzi5rQIAAECuxJO3W/1YT8PPfZaQBwAAAAAAwCmMFFyza2cWOLcy6Ju3kgKQY6wLw9GQR0VIPWPo5gEAaAHjZgmYQEHD1QTkTQdzA21SDkrqFoDcIOgxHm76/LBm6R+dC5Y5OTp7AAAA5MRIJw+zzI/1dNODwwIAAAAAAMBLML1CNjizNAk11MJQRVcLyz74Eli3Pv6I8EtGWMP5BgAw8YwzFQETJFg3b5kIGSOHmg06erSNc0sEIDcIeowXv7vz8JxPOaf/7NipCAAAIPOSkIf03zS8/VN08gAAAAAAADg9xrLDfsZUgsCtD/q6VqsWVlREY108nFkqZEtD/QIAYMK5ioCJ4Mff1iwXkE/U0LZPJegLub4FcoKgx3hKOnsEn3PO/XcnPSMAAABkkjPa4qz9Tc1UD508AAAAAAAATl9TWitkj1N3EvgY2VG4GGphxfR11Ua7eFSETHHGRKpGdQEAMJFqIZ2+MGH8+FtAXjFWby/nlhV2MwcgZwh6jDe/2/Os4P/GE0v/yRndJQAAAGSKk+5zDfPrKgdr6OQBAAAAAABwhqrRQLxGFglZlOwoHPR2bS71hd25LQqJv6+gN+wJArfZOC0SMslIvQIAYOJVhNYbVO4DNqMB64qAXDN1oV3KSZiMwCKQeQQ9JsL8qKEF0Zecdb/oZL4rAAAAZIKzZoML7C/qZ6IvJWM6AAAAAAAAnDHjzAYhyyrOudVJh4++rtW5CXysC0PT17XeBzzimcDFQqbZJt2DAAAt0JH/wEEqdeQ7AFGqhYt8wFpA7rkBoZ0qZiTsURGAzCLoMZEW3fGDeBL0t53V3QIAAEBqOakZ377hjP0d3fjNewUAAAAAAICzZi0dPXKiEk+cdSedL/q61meyy0ctLPvdkpOAh3XrjVMoZF48l1tXNaoLAADkUsnlOGATj6dd4FYKKASzUWgrI3X6TRyS63kAmdQhTKxFG77pPhe+w01zHzNWvxqfOGcIAAAAqREvCh6Mb5/U0PAf6qbv7BIAAAAAAADOTTWK1BvW45mXipALPiDh5MIgiF/Vvq7IyPRao37dGL/WabMuDAPZLudMaJwLFX+hRsgTf/w5AQAw8UoNVRzbKLecc+pUHvkQst9dX/nuWAIcoS6kQdK10/R1LQ5k1jQXRD0CkBkEPVrhpmifPhf+gZvmnjPW/HI8HL1OAAAASIPH4wvav9Zw8Ne66Tv7BAAAAAAAgPHSG9+WCLkz0hXDhYGvtO/tGnBG/caZDTZQvwLV9dNRv1rl9rCihjoD2etHgh3qlHXlJAog5JW1WiUAAJBbLqdBCFNyq+NvriKgIIxVnbBcehzewKG3a1l8wRxZY3rj6+lI1WhAAFKLoEer+LDH+vCv7B49GJ8wfy+eWPzR+GTJ2xgAAEB7uHiCcKOz+h1V77hdAAAAAAAAGFfWam0QEPQogPLh4IeNP/I3H/7wO7ca1Y0zW/y9NclOrgPx6ujIzXtvVD/pv+oDHEr+vXJyc6rEC6vJvYyb5Xd5Nr4AcNiHOjyCHUURH1v9qp7i2AEAYBy5gKL8djBy1+ete1fQN29lPJBZJKBAmvHYnQLZVKrE56PuwLluX8Hserv6R6/fNybX7v42du0+GN8IggBtRdCjleZHg/rca77hpl34uJz50/jE+N74NDlFAAAAaBkntydefL7dlfQxDe3YIgAAAAAAAIy/ahT5gn/54nwUTdlInfLdNXxZfvy/YKxSzx7xp3q7Tv4vDJ+itM+JUEeBOWNuFQAAyLtKEvx9bz7CncG6ectkzVIBxVMXUu+I6/dFybW7v41du/ukzqmu3See30hiQKObRxyxmUS/GskmAIRQkHsEPVrtpgeH418fi08+VdMX/pZz+hXjdA3dPQAAACaasc7ZTfHY62/toUN/pZu+c1AAAAAAAACYQL4g2y0TAIyXpiIBAIDcKx1S2JR6lHGjIY/lAorIF+H3hvV4XqAi4Oz4jSRGunsmjthMYrQbiTHqt8b0qhFfKxL8QA4RLmgjO7j9z511v+aMWScAAABMKOfU54x+yZaDvyTkAQAAAAAAMPGspSAbwDgy6lE1Hzt7AwCAU7Nyi5VxhDyApCZ/o4AJMtqNpDuwrhYE7gXT17W+1Bd2C8gRgh7t5Lt7lINvOKulVubWpMUQAAAAxpWTGZIzn3Ydjf+i++64U/OjQQEAAAAAAGDiVaPIGcIeAMaHbZo1AgAAhWCcOlULy8ooQh7ACCPVBbRI/N4ROudWB71dm4O+rtXx+0hFQMYR9Gi3+VEj2XVkpn7LWVN1MrcR+AAAADh3zmgwvn3ZNfWTtj/8sN5/5xNaLisAAAAAAAC0jJHpFQCcI+cLxKpRJAAAUBTlINBSZRAhD+BFJmDzB7RFJen0ETgCH8g8gh5pMRL4iNxQx686BX8cn2QeEgAAAM5KvOj3YHz7bTfZ/qJ+JrpTy5cT8AAAAAAAAGgD21SPAOAcOWNWCAAAFIxbkrWuHkHfvJWEPIAXNRsEPdBmI4GP9UFfmMnwIEDQI21u+tqTmun+3Br3IcmsiWeshgUAAIDT4mT2+TGUc8F/0OBFf6X3fPNZAQAAAAAAoH2q0YAzFHYAOHtJN48m5xEAAAooO109amE52TXeGQqJgSPFcwKSqQtor4qcW2n6utbT3QNZQ9AjjeZHg1p4x33WaqmVPhRPft8ro0EBAADgRFy80HfQyTzirPmPfgylWe4e3fT5pgAAAAAAANB2rslO/ADOnvFhsWpUFwAAKKCkq0dFaRZ/fUHgIr9rvACcyAYBKWCcQt/dIz5vLxKQEQQ90synGRdFX3B7Z/ykrPmYM7onPtXQ4QMAAOAwMxyPkb7nrPkdV2q8TdX1n0vGUPOjhgAAAAAAAJAO1ShyUr8A4CxYwmIAABRZ2ZTcaqXVutAXDd8XP7peAE7MMB+AVPHhvFqwbt4yARlA0CMLPnTbC3aWVrmG6bbSf3FODwkAAKDgnEzdOveHbnLjF1XWX+j9d74gAAAAAAAApJIxZo0A4EwZ9dDNAwDQLsaqLrRdsgN737yVSpNaWPZfU2Dd+vijsgCclG0qEpA21iwn7IEsIOiRFX5X6p+JHtBM/b0z5sPxEPYv48/uEwAAQME4mXgMZNY4q5s1bD6u93zrh3TwAAAAAAAASDfbVE98NyAAOAN08wAAAAlnlqamIHesi0f8NQnAS6tGvqMH8wFIH8IeyACCHlkzPxrUwuj7dmH061bmhvj2187pARH6AAAAeWbUSDp4+LGPdEM8FuqOJwMi3RQxBgIAAAAAAMiCajQQT/LcKgA4XXTzAAAAR/IFue3s7HF0F4+KAJwB0ysgjQh7IOUIemTZwmiThub8ups06d/JmT90ct8TAABAzjiju+ILq/8T3/+8Zuo/J2MgAAAAAAAAZI61WiUAOE108wAAtFuzQ3UhXXxnj96uzaqFFbWKD3ism7csCNxmungAZ8dYRQLSyprl+tK8xQJSiKBH1t30+aZ++ms/sMNzPu6CoNsac4uT6Y8HlcMCAADIKBfPmzqru43Tf3BBx8/bWVquBdF3NT9qCAAAAAAAANk00tVjjQDgpdDNAwCQBg0NCGlU8aGLoK9r9YQGPo4MePgiYKksAGelKa0VkGJB06yKz/udAlKGoEde3PT5Yd0YPazz9RduSO+10oec9DXn9EI8C0boAwAApJ9RIx6/DDijf3Fyv+yM+9nm8PBn9f6vP6H50aAAAAAAAACQedZquQD8/+3dC7Td110f+N/+36uHnThWjHFDgERhsgYmdIgDhsCUqY4gdBJPY+lkLTQsZjq2V6aLVUoncoeZThlayzMd3qxYlBBKSyIXOtPaNFdySszDxEdxEgeCiRzAZPIg14mTKJYjX9uyLd17z3/P/p9zJcu2bOtxzrnn8fl4nXPfsn31P/u/H7/v3ryAZp7YaR4AjAlBj3GW47pTgY/3t1oxCAutLc2flW7fdlf5sx8R8IABaXeaWpBOwPjaUtr9hd59AMbIfDBd+rtcHy6P38l3tfaX4cb3pxQ7c6QrU+Q3ls9vDgCAMZJzrJQ3n0hV/pOcq9+NS+LO2H7QyR0AAAAA06jZof9A65YyK3RtAJxBqtPe7DQPAMaDoMckaAIfOV8XB7b1CslTpIN1ikMxH4vxlhfpU9zR2hqrcWWVY2uOvCPlfGXUgh0wDCmng+UF2woYX1vTXF7IEdsDxoSgxzTrhz469V2tj5VhxytylX+givSm0qH9oZTj66LZNxsAYH3kHOlLZaLsg+Xt3VHPfyQfWv1M7OkIeAAAAABMueZUj6oKQQ/gOXLEYm539gQAjIN2Z6kJD4QTHSbFlpRjZ+lR7KxKpyKWy+PAtl7/Yu3rS5HKI8fW5oMU5e1yPvXDCulguMpcwL4yF3BjwBgr95FWur21u76mc3PAGBD0mAXbO8ej6bDe1fq39dH4g9gYry1d1DeVBum/T5G3BgDACOWcHsyp/k+Rqn+fY8Nn4mUrD8X2OwU8AAAAAGaFUz2A55FTuikAYKykpXKHEvSYYL1Ax0k5gPVS5gLy7ds6TSF9wDjL+cZYaO0PJ00yBgQ9Zkn/hI8H1x6d/P7v+pm8fMl3xMbcLjfPHyyN0zekSFeE6wIAGJQUqznnh8qE2YM50p2R5w7ElvrPYvuHBDsAAAAAZtjaqR47wu7IwJqc0v64prMvAGCM5Ij7nhEUAOC8pZwOlpa1FTDetqS5/N7SB9gesM4U9M+yt977ZHn+WPPIB37olZFWvjPV9ffmSN+RUnxf+fzlAQBwfh4ufYo/TTl/NKfqE1GVPsdbOw8HAAAAADT6p3rsjcg3BkCRu3FDAMCYSRFLAcBA1HXcXFVhHoCx15w8kxdarTJ/1QlYR4Ie9O34wy+X5y/Xd7XujEfmXpWr7neU2+pVKVXfW96+IUV6WQAAvIAccTxS+liu44/Lh38a8/Vf5lc88dm46t6VAAAAAIBnWSvweEc41QOo0029ABgAjJsUh8pC6LUBwIVrd5by7ds6TRF9wJhLc/nGHNEJWEeCHjzT9s7x8vzpMkD5TNzx2vfn7jddEieqy9N8+juR6u8rjdZ3lgHM15fvuajcbDcHADB7ctQ5xYnSJzhe3j+Scvp41PHhXK/cHZs2fDU2Pvh4vOWzy+XrOQAAAADg+bQ7S/VC66aqyu8MYGaVieTF3O7sCQAYQ6kbS7kKAAYkd9PeVOVWwJhzqgfjQNCDM+sVZn72RP8RD9cRnypvfyUO/K1LIm36vlitv6fcbL81R/q2cuv9ptKgXVF+xrAGAKbXarnvPxy5fiBV1WdyHX8Z3TgUm5/6aL76jx8LAAAAADgf7c7N+cC2d6SIrQHMpFyn7QEAY6obcUhBFMBAdcpjKZzuyQRwqgfrTdCDc7PjI4+X5z9oHvVdrc1xrEy612lrzvHaSPGtKfIby9f+izIZ/9IAACZaub8fi6q6P9f1feU+//HyqS9GXT2Y5y7569j5/icDAAAAAAYg1+n6VOW7Apg9dbop2p3FAIDxtRgADE67sxQHWnvLbMCNAWPOqR6sN0EPzt/2zvHon/Txqbj1hzdGHLksX5wuj9V4RY74zyLF96XI351yem1p7TYGADDWcm9Dmvh8ivSROsc9UdWfKffwL0c9fyRWL1uKXbd1AwAAAAAGrVksP9C6pcxQXRvAzChz0ou53dkTADDO+gXJi+XOtTUAGIi6jpurKgQ9mAjlWt1ZO9WDdSLowWDsum25PB9ee/xFedxZHv+qTM5FvvX7LovNm//LqPN3R4rvSim/onz68sj5stIEvjRFfkn5eC4AgKHLkY5FykfLffhYRPpaTulzUcdflnvyR2Pzhk/Fm3//aA4AAAAAGK26jt1l4XxHeXdLAFOvzEMv5TptDwCYDAfLY2sAMBjtzlI+0DqQIu8IGHu9jUl2B6wDQQ+Gb9c9R6M/4GkekW993ca46IpviUivLR/+jZTTN0fOr8qRXhUpf3PKcXmkuCwAgAtSFsqORUqLUcfDKdUPlHvvl8vnvhB1+mzMp8PxZCzGrs6xAAAAAID11u4s1Qutm6oqvzOAqZdTuqG87hcDACZBikNl8dXpcwADlOu4OfU3fIBxtyUWWq3eibQwYoIejN6u+5cj7v9Uea95RH3rD8/F/KNfF3NPvSJSujzndGm5jb+qzO59Y0rpPy/vv6Z82ytSTpdHylUAAM+QI7rl6dFyH/1C+fCB5rj78vGDUeUvlUnHr8SGWMpPVIfjpRc9ElffcSIAAAAAYBy1Ozfn27ftSDlaAUyvOu0tr/d9AQATou7GoUrFEsBgtTudMgfQMQfAJCj9gJ11RCdgxAQ9WH+7buuW54fWHn1N+OOJIxvyltgc1fymqPJ8jvqSWK2/vUrz3xgpf0tO8eqoY2t5vzn9Y2Pk2FTenytNanNdz6fIG6LJ1APA5MnlPteNnE70pg0jLZdPlUdaLY+j5e62WAa6DzRhjjry/xd1/mxsrh6PlbmV8u0nYuXEifj6TSvROtgt35sDAAAAACZE7qbrU5U/Ec1uicDUaTYqyu3O7gCAyXIoABi4MgdwU5kDaAWMuRx5W8A6EPRgPPXDH83j+LO+8qn62d97a+ulcfHcFbHSfVXMVa+MnK+IXH9diuobcs6XRRWbo06XRYqLI+WXRE4vKT91SYrYVJrfuQCAkUvdspjVnKzxWLkXlUc6Ue5fxyKloynlJ8q96vGc0teijgdibm6pjGwPx/GqOa3jcOzqHGv+BOkNAAAAAKZSu7NYL7Sur6q8EMBU6YU86rQ9AGDStDtLcWBbE/a4MgAYHKd6MCFS6QPkhdaWXp8ARkjQg8nXL3htHn99+qfrPVHF97zlpXH80c0RF22JjScuiW71kqjnXhJzq5fkXG2MOl1eWuBXRE4XVylfkZvTQVJ6efnxl0azU1TOL+8HQgDg7OQmpJjSo+XdR8oHS+Ue81iq8iN1Lh9HOhK5fiRS/WjU5d61Ye7RWK0ej/nlE5Hnn4iV5aN5w4lj8Wf3Ho89UQcAAAAAzKJ2Z38caO0ts23vCGBq5Dq1mzBXAMBESgfL3UzQA2DAnOrBxJjvBZL2B4yQoAfTq1cge8dj0dstPR464/fc+sMbY8ORi2M+z9cxf3HE8qZIaVOsNK+NamOk7qZcpUsjx9dFzpdGnS6OKl9Rpbg0p7isfP5l5fsviZya00GuKI+Xpn5IBIApkXthwtQECp+IFEfK26VI+alURxPeaAIdj5f7wCNRxeHy9WNR50fLx8vlvnGirFqdiM3zy/mp8n7auBxPzh2Pyz5zIv7ksyuCHAAAAADw/Oo69qQqdpR1l60BTL463RDtzqEAgAlV+qadXIcgMsCgtTudONC6JSJfGzDGqhxbFXsxaoIezLZdty2X5+U4Ry/UWOfm6Q/fdGk8Ub0s5pcvjRPVxojupb0AyYb6smhOEol8cZnMLF+Pl0Y3XrL2k5f1vifnDSmnS6OKufJ+Vb6wsf/l8n5KG0/7V22Ik6/hHKn8M98bVj79XzIfz36Np+bPTBue8x+dyr+t/HvLn5/ijP/Dea58ZUMAvIDS/nVLO7Ly/N+Qy9dS9wxfaD737J9bLd+7evoPl0fz871mtrRb/a/nnNe+vFz+3fWpn029r62W5nGpfG+39/15LYCR8pHSBtelPT4ec6uPR5p7Klby0bX/lIdiZeOxqLqP9T7e1Tkcz///CwAAAAAMS7uzlBda21OVPxHNKezA5KrTTXW7c3MAwATrrkanqgKAIWg2eyht7I4w/mes5dcHjJigBwzDD93Z7PDePL4Y5+FU8fCtr9sYG664uPf+fJqP1bXTQubqFPWGiyJ3+8GPulvF/PxFUeWnwxh12hxVbH7WH70punHRc/6F8+WfnJrAyZmDHlXelHJ1UZyt1N0Q3fSSuBBVav59P1Aerw2YYc1pEqmKW2M1Px6jNpeeKG3Dytl+e85xvLQix8/8xV7T9mTU8dw/r0rHS3v1zJ+r45mfq6uVWF19KqqqH+ZIc8tRrTxVPt9vMufTsdJG9oMhKw89GbvuP+cQHwAAAAAwZtqdxXqhdVNV5XcGMJnqdEvd7uwJAJh0TRD59m2dlKMVAAxWGf/HgdbeiHxjwJjKOa4MGDFBDxhnvULlZxQrPxzr5JyOnLqr1bQtm+NCPFq/vKri0shJ0IOZlctrPkd6V15Z/rV4+cYnY/SOx/bOagAAAAAArJfmFIADra1lxvQdAUyUss5xX253rgsAmBIpp4PlDtcKAAauruPmVMW1KWJrwBgq1+aWHDBagh7A4PULw4/FhfjAW1Zi+cmvPs8ZIzDVcu5lqz6ZU/6/YsPFd8aOzmMBAAAAADCj6h2d3en2ba+3ezJMjhyxmOvUCgCYInUd+6oq7DYPMAzNyUkLretTle8KGE9bA0asCoBx9Cd3rESVHg+YPcdyiv05p3bs+ND74uo7hDwAAAAAgJmXu6ndFI4HMPbWQh7bm0KtAIBp0u4sRqTFgHXWGxul2BcwbdqdTmln9wYAPYIewHjaE3V0c1PgvhowI8pA/MG6m/7viPkf708QAQAAAADQ0+zsWaftwh4w3k4LeSwGAEynWwLWUelvNWOjduT0QMAUquvYY+zP2LqjtTVghAQ9gPGV4lh5OhEwA3KKI7mbb4zVE3tjxx99NQAAAAAAeKZ2Z7FX0BThlAAYQ0IeAMyCunaKAuur9LeuL/2tQwHTqr/Rw/UBgKAHML7qXD0cKT8ZMNXSYznn2/Ox9Lp424feE7vueSoAAAAAADizdudQXacbAhgrQh4AzIwmfJyiE7AemrFQu7M/YNq1O52ItDcAZpygBzC+5vKTZVZ4JWA65bLocTjqeGdern4sfrTzcAAAAAAA8OLanX213T1hbAh5ADBrUqQDAaNWp5vqdufmgBlR17GnjDWcXgPMNEEPYHzl+rEyPF4OmEI5xRdySv+03tR9V+zqHA4AAAAAAM5eu7OvKXQKYF3liPtynd4g5AHALKm7sa+8WQoYlX7IY0/ALGl3lspYox3aW8bJW4x9GS1BD2B81dVj5flEwBTJkZ7MOe3P3XpXXBK/HVfffSQAAAAAADhnvUInYQ9YNzmlTq5TqynACgCYJb17X9obMAp12ivkwcxqdxad6AnMMkEPYHxtmHusTBELejA1corDuc6/nDfGP4r23X8S2zurAQAAAADAeRP2gHVSp1vyNZ3tQh4AzKq67p3qAcNV+lxlzLM7YJa1O/uN+xkTiwEjJugBjK/cfSznOB4wBcq1/Lmc8r+IlQ2/HFd3HgwAAAAAAAaiCXvY4RNGqE43ldfddQEAs6zdWcwpOgHD0g95XBfAyU0ebglYRzmlxYARE/QAxtdLYymSoAeTL9fx8TxX/1g89Td+PXbd+WgAAAAAADBY7c6+tbCH0wVgSHJ5faXyOusVWQEAkbt2mGdIhDzgOZrXhIAd6yqHuj9GTtADGF/bO6uR8iMBEypHWqqj+sW8svzmeOvdfxS7busGAAAAAADD0Q97bM8RiwEMVPO6yuX11S2vswAA+tqdjqJjBk7IA55X7qZ2GZscClgHybXHOhD0AMZainQkYDL9ea7jhjjx1Z+OXfccDQAAAAAAhq/dOZSFPWCgyuvpvuZ11by+AgB4htxNNwQMipAHvLB2Z6mMTdrG/KyHuhL0YPQEPYDxltOXAiZKqnOKD9fd9FPxxQf/39h1/3IAAAAAADA67c7iWtjDAjxcqDrtzTsOXtm8rgIAeK5eEDLdEnChhDzg7Dw95l8MGKVV1xyjJ+gBjLcUxwImRBlALJVr9j256l4bL4/fi//5sycCAAAAAIDRawo/dhx8Q9TppgDOWW/No0431O3O7gAAXlBdR3O/XAo4X0IecG6EPRix3rXmlEvWgaAHMNZS1F8IGHupzjl/OtXpn9XXdP5+/N0P/3Vs76wGAHCSxQ0AeCE5PRowyd5ih29gfNXtzp66TjcEcNaaApamaKq8fm4OpkpOeTEAGLx2p6yDpL0B56NOe4U8xkyytjkRhD0YqXRfwDoQ9ADGWlqtHgsYb6tlUvxPc1T/R70l/k0AAGdiMnT0FgPgPHXntSEjl/zOByvre4yW3/cApVp7MGpJGzwb2p2b6zq9RvEHnIU63ZLr9AY7lU4pIfPRE4oenHljj9Ezvj4X9Y7OntLfdP/k3NTppvM9Qc0cwvDU5gomRz/s8QbtL8OWU+wPWAeCHsBYW93QPRowxnIdt+fV+b8Xl5bO3PbO8QAAnsNE8+jllBYD4HytardHre5ahBosO2uNUul3uH4HSfHayHW77nszY22nz3KfuCWA58hNeLNON/R2k+7tSs40SgJvI6XgcLC65ivWQfVAcE6yk+Q4F/2Qx544X+YQhmfV73ailPFL3nHwDU5WYqi60QlYB4IewHibi88HjKEyMftgHekf5G8+9iPxtj/6dGzvrAYAcEZdC5qjl8PujMD5a/d2G7WQNVrulYOU/D5HKeU4GAxMd9X1uw7c82ZJ6efUOzrXNQVVAZySU+o0u+DW7c7NwVRLtb7GKCVjk0FbDEbKjvbnod3pKDTmbKQ6XX9BIY8whzBkfrcTqIz3dxvvMwzNmHlt7QxGTtADGG/HvqZAjbGTI+7Mufqf4sRD74mr7l0JAODFLAYjVRaROwFwQdKBYCTWFggUGQ9Q3XWE+ijVtd/3QAnbjdpS+Z0r3phBTUFVXafXZONVZtzJUzzyNZ3tilZmQzf03Uap7jpFaqD6Y2d9t1FaNc98Pso4eY8TfXg+Tf+rjEW2d9udfXGhzCEMhfnaybY23r8+vDYYoNJ269ezbgQ9gPG26/7lyNXRgDGQc6yUx0LO+R/Hzrt+v3d9AgAvrjkuV/BgpGpHxwIXqCxI7wtGwgLBEJRFbgUVo9H7PSuSHwJhu1HJkZxIM8ua+8WOg6+x2yezyikeM8o83cj0woS9nf0ZLP23UVkb7ymSPR9NW1undigy5lmae0PT/xrs/cEcwqClCL/TSdfu7KvLa83mDgxC7zq6ZgDhPDhPgh7A2MtV/eWAdVYWPB7IUe3Jc3P/KHZ+6M8DADgnKVuAG5W1RWQFl8CFatoRi9FDZoFgeJJF7pEo8yV7g4ETthudnOxqzqndPrcrAGFWOMWD7JSJkSh9ZUHCIXCi4OikZAOFC1LusbVAMacpfbD7chl3DLr/ZQ5h8JwWPCWazR2aYFWYv+TCpJS1CawrQQ9g/NXxhYB1k1Zzzh/Jdf3j8U2P/WK89YNfCgDgnFmAG51kV0ZgEHo7NloAGTaFP8NT+h7NztTCSkMkqDRUwnaj4iQ8Tmp3OgpAmAVO8WBNM0+nrzFE+spD1NyzneA4EnVXv+iC9e63fo8Uddqbdxy8cigh2/7pIO7rg5JinzD0FCnrHPWOzu66Ttfb3IHzVXcr93LWlaAHMPZSZUDCeknLOfL7c8r/JHZ+6ANx1b0rAQCcn3bnUBZAGImyAKdoGBgIhfLDpfBnyISVhq63CyXD4fodDcUbPNvTBSCvUQDCtGmu6XJtt53iQU/T3tllfqiE+ocrJafSDJtTowen6V9aG5lxdbqhbnd2x1CZQxgUIbcp1e7s689l6kNwjurSJhhDs84EPYAJkL4YMGJl8uqROuLdeVP9D2PH3R8JAOCCZQGE4VOsBgyS4p+hUiQ/fE1YSaHukDRtgz7HUAnbDZ+ANM+rtG95x8HXRL8f5HXIRMvNNVyu5d6JNe2O01Z5Wrtzs1MRhqQpBhPqH6q6G/uM9YZLWGmwytpI2zU7e9aCtttHcZKaOYQB6a+x6R9NqzLWr3d0rnO6B2er145HOA2TdSfoAUyCwwGjs1o6an+Wu1U7dnR2x5vv/koAAIPR7nTsXDVcitWAgWuKf7Tdg6dIfjTanaVcFu6Cgcopdep2Z08wXMJ2wyUgzVlo2rq6KY634ycTqvTj9zcBj959u3daFDyTvvLgrRWD7QmGy1hvqJxAOgT9a3a7wuLZ0cyd9DZ5KetiMQrmEC5Y7x5ujW02ON2Ds9QLvpo/ZAwIegBjr86CHoxKerI8/U7p0L893nbXwQAABi530w3BcCgaBoaktN1N8YTCsEGp015F8iPUW1BPe4OBaBa9czcUVI2KsN1QKN7gnDy946fCPCZGL5TZXLPXHGybJ+AFtTuHyrVirm5Aen3lflGv8fMo9DcVclLREAjRDElzapw+5Wwoc3/5ms72kffDzCFcEAXdM+bpsf4btMucieAr40TQA5gA+asBw/dUeby7jvTP4r7OJwMAGA4LyEPRK1ZTNAwMS7PoUad2cMHWTkLYHYxUWbTbbaH7wp1WuLYYjEwTtrPgPFiKNzgvTTHpjoOvKX0ir0nG1tMBj87odo9m8rU7N0dtN+MLpa+8PvSVh6C/mVAnGA5hj6nWW6cpf7/rOfdnw57z1LR9CrpnU1m3NtbnTPqnvsB4EPQAJkD6YvTGRDAEKVbLxfW5Oqf/sd5w0f8ZOzqfjT1RBwAwPP1dhey2NiClL7NksgkYurLIL6h3YUp7fV/uhsDMOikL3W2LdedP4do66hcCNW2HQo1BqNNexRtckHZnX1ME0hQCua8wLnpFhSldL+DB+SqLYrvLdXQoOC/6yuuo3Tk5L6qvPAA50iGbCY2AsMdUata8yt/rG9a9L2bDnnNXp1u0fZwc6zdrINpnolkL07dnjAh6AOMv1yci0uMBg5biaM7NgHvuR2NH5z/G1Xc8FgDASKzttmYBeQDK4sH1JpuAkejv9HpTcO7KgmFpr1tNEUqwPtYKgCzUnbteSEnh2vpyKt5AOFWJQWoKgXpto8AH6+hUwKMJHwmxcSGe7iubqztHQh5joF/ULOxxgfrXss0pRkbYY2o0G3E1BcH5moPtsZn3s2HP2euHPK4LOKnZrNBYf7bVaW/drIXBGEkBMO4O/K1XVjF/T3nvVQEDUjrkx8pN8F/W9dxvRvuDnwsAYPQWWltTle8q9+StwXlJdbq+21bMAYxWtdDaE1W+MTg7ZVHIrnBjRP/j3DQLWxF7hJTGxELruqrK7yzvbQnOyVpgSeCO4Sj3liriulzla91fGIUmuJa7cZPTOxi4hdaWtb7ylcGL6u3e3u1twKJ/MQ4WWleWvvJdoa98zk6dGN3uCHuNWtPuzuWFlKMVTJy1PtnYbsRlDvdFCHlwNspcXOkf32isPxvWQtxv0L9n3Ah6AOPvff/VFWlu/vYU6Y0BA5AjHS6Trz8fx+PfxK7OsQAA1k+/2HLBAvK5aRbfqjrdIOQBrJuF1s6qyu8NBRTPq2mrUz/kYfencaOQ4kW5fsfYQuvKtf7z1uCsKMJkZPqBj525yu/wGmUYBDwYlepAq/QB8zuC51fm5fSVx5Bg/zlzKs14UJA/WSZpzsS19TxszMO56gU+ooz1s/XsKaVPxDgT9ADG3/tbl6c6/4fSYP1AwAUonbJuufX9Xq7jp+1IAgBjZKG1papijwXks7M20dTWnwHWnQKK57W2c/xOiwLjzWL3mbl+J4Cw9NlrTqVpd3YHjJpdPxmQXiFhpFvqOvaZB2CU9JXPzLzcBGiCl/255muDF7QWIGwLRI+JhdbutRMcGWNrGwncMFFzJjbsOcUmalywhVar9DOu08+YLkIejDtBD2D8feCNL6tWL/qNyPm/Czh/S3WkA1GXiT0dMwAYTxYyXpTFN2DsKKB4rqaoOHpjT231JFCIe8rajpR77Wg4ORRgPj/FG4yNhdbONBfvSDm3As5Bb/wfcSC6vYCHfiXrY6HVKn3l9+orrzHWmyz9ueamr+wk0jNxKs14sqnK2ForAr5+Yk9Wc22dXF+7Xr0QA1FeU+W55ZSPySfkwSQQ9ADG362tl1abojki+O0B56F0yh7MOe2NubIg8tbOwwEAjC+TzWc0SUeBAzNKsfzJxcKbJnbBd5b1+h9xc1mU2xEzymL3BGuu37l4ryLyp7meGUtr4dgceZvxLs/ntNM79utTMjaE+0/2LW5wiscEcv0+h+t5AvRPQL/ZdTseTm2KEeXvZNKDfv1ra0/5v3pHzBDrawxdv7+xu4z3dxjvTxYhDyaFoAcw/u5qba4eL4ONnP9JwDnIkZbL0125m38+ussfi133PBUAwGRQMPy0FPvq/lHgdgsExtuMFlBYLJwiM9j/cOrBFNF/Prk42/Sb9weMs+b1OhfXCmhxktM7mAgz2lc21psSTqfpXc/lfnNDXGPsNzGM8dbftK7NzNC1ZSMIRm6hdWVZI7mu3He3OeljzNXpljpitzE4k0DQAxh/t/7wXLXpqz9RmiyTaJyLI5HzrXWuflqnDAAm2CwvZvQXEW6xiycwcWbkdISp2tGPZ6gWWntyla+d/v5Hb8dwi1nTZjaLMBdzSjcpWmPilD5TeW4p4JtNTdFZ6sZBfUkmzgz0NYz1ptgMhi1dzxPOqTTrYiZO7W1O92gKnMs9PaZQ83dY/v9u6ZonYD01Y/652Fn6zTts9DA+hLmZRIIewPjLkeb+U+vtuc7/OuDF5dIp+0rplL27Xjnxa7HrnqMBAEy+GSlYO23hbZ8dhoCJt9BqNbtXTdtitCKJGdEUU0TszFV+x9T1P1LaV3fDaWHTrtm1eC5unOaF5JkovmF2nNr1M+8Q+phep4U7jPmZfFM4V2esN0OmdL7idGunRd0S3djvep4CTvcYiZkcY05ZmKi0e/el/rzXfv1txspCa0t5bsb9O532sX6c8sOkEvQAJsLcgdaPlI7Ob5Zb7sUBL6BcJ58vjx+LE+me2NU5FgDAdFlbhFsrftkSU2Jt4e1AWXjbZ+ENmDprC4al7d42yQvS2uoZNi27vjY7lSksnT1T0gaf1CvA7J9Gs1/Ag6l1KvSh+GManNaHVGzGdJqCvrKx3gzrB/yvm5YTHfWVp19zAum0nsCwnmwiEBMf+Dj1d9jQ/jEJTg9+pHh95HzlNK17jxvtPJNO0AOYCHO3t/5uzvk3y7tXBDxXc4rHEymq36o3Hf/peLNTPABgJiy0dvZ3PpnM0IdFZGAmlbZ7rQhoZ0wARRI8Q3/Re/ek7LZert/FSOlQ1Y0D3bCLK3F6aHqiQh/aYmZaufeU59ZUBA5nRI60WNrYA6XN6pQPO+6/zIymvZqLnSmX9moCQmr6FzzHJPeVU9pfd+OW8uEh950ZMGUnMKwnhb9ncHL8UcU7xv1+3rR/uU5N2+deznRYaDWvuSb8caXwx2Bo55kWgh7AZHh/q5XqeG8ZSGwNeJYygPt0zvHvYmN6T1zdeTAAgNnTX4jr7XoyrsUvvWKPFJ2y6HYwFFsCnB7YG6siimbyP5W2uu4X5nUCzqRZeJsrC98RO8ap79GEO1K5hhX58KLGuP/cFGs0ISVtMZzBydeu0z7GxqkC24j7nNoBa04LqY1TgVqZmztU/lsOCnfwosZ0vNfQV+YUgY/zclrQ72b9thfRP2mwGXvsGIexR6/96//9CVUzO/rhj62nwh9Nv1oA5AX11uPruKX0k27WRjAtBD2AyXD7m7435ZX3lkbr2wJOk+t0X95Q//N4SfUHsb1zPAAAGgutVlmMaya6tpUZna2jnoRuJpHKiPtQyvGACWeAs9AvBGoWD1uj3K1qrUCio73mgq1D36O/wN3bNfxgnWKxV1zafM41zLlaaDXt7Wlt8Oj6z6eu49J3XiuSbtrhQwG8uP5rt3XytevEj9E4tYmDYAecvfXqKzfF8DnuK2O9pm9h0xXO3zrNNZ+hr9xcywL9PJPAx1lxwvoFOn3udjSh8+bvaEsZ5+xPkQ7W3d687RbhNlizNpcXzetiLrZWpX9SXi+v7n3c76tsjRlxco2nvD1ojM60EvQAJsPt27895boJenx3QPQWU75WFq7+sJ7r/lzc+6Y/jz176gAAeCH9XU+aia9m4WNrGRG/Op/cQT73Pl8eecvzFRavLaydXAAok0bNzkGxWL7w6Fpx5WLE2sNCAcCFe3qx4kztdv/tC7bbaXHt3abNborhl6If6Gg+3xRHaK8ZrrUd186w2LbW72gm6M+86PbMfkfecjKQ1Hy0VqjWCaEOhqnfBm+NtV0Do19g8axr+Kza4OZCb95felY73H9YfIXBOdl3WsdND6bNyU0c1gpGFkMoGAbn5DxdabOavnJ5rV367PHeWfWV+2O9Z8/PHdLHYOhedLx3QX3l5vp2HXNumsBHxO5c5R3jdHLuejrt9A4nOQ3DaScNRH/O4PW9z7/IffxpTVuYS/uZ9vdaxm56oLSpi3V/I5PQBsIF6ge0tpz+6K2zNPr9lsin3y/yM+8d4xIWec46T9Nf0u9nxgh6AJPhd37wW9KG1Sbo8beDmVcGiJ/JdfqFWJ6/LXbd+WgAAAAAAADP9OzwR8QWJ388lx3TAYCpstC6Ls3FtbPY7zt5olPuxk2hPwcATAFBD2Ay/G7rFakb7y0D0TcHs+7P6xQ/G6889jtx1b0rAQAAAAAAnL1n7aTf2303x5ZpPgHk9DBHb+f/eu2EN6cLAQDTqr+be2vaQx+9kztS2l9342D5cL9wBwAwTQQ9gMnw2298WXrJ5vemKt4WzKQcaTlS/mhejZ+Ktx28JwAAAAAAgMHqFwQ2jyYIsnUtCPLq3sc5mhNCmkDI1hgTawGOpbLqvZj6wY3mkw/Ude/9psjvUO+tgj8AYJadFvqInJvT3rbEBMspdVI3DtYRndLP6wQAwJQS9AAmRnX7tveUyfnrQts1c3Kkw2Wx5udiw4O/Hld/9kQAAAAAAADrZ6HVC32c9mhs7T3PxZYqP6t4sB8WeX45Ho1+MOOUOpWPu6c+t/Sch/AGAMD5WWi1qipaOcW2cQ9+9IK9KR1KOe6r69gfTZBXPxAAmBGKpYGJUd2+bW8Zwf3DaJYImBWrZdD+6VSnd9ftzq8GAAAAAAAAAACDs9C6sjxvXQt/vH69wh850mKkaEIdzQltzclszYkdiwEAMKPmA2BC1Dk9UkV0y9BO0GM2rNaR9kcd78pb4mMBAAAAAAAAAMBgtTtNqOJQHb0TM3py/wS3rb3HXGztndiW4tX55Cluee1t5C0vFArphTf6lsrPL5XvXVz7QhPmWIz+aW2HTg905AAAoCHoAUyOlL4cuV4u720MplnOkY+lXP1abLzoZ+JP3ngs9uypAwAAAAAAAACA4Wt3+gGM/iNeqGjjXIIZQhwAAGdP0AOYHDk/GZFqw75plpZz5M/kbvUv8svjd2L7HasRdwQAAAAAAAAAAAAAzApBD2ByVPVD0Y3VSCmYTjnijpyrd8fqV++K7fevBgAAAAAAAAAAAADMGEEPYHKsVE/GXK6DqZMjLaecb8lz1U3x1g9+KQAAAAAAAAAAAABgRgl6AJPj4jgcJ2I5mCq5jj/LVbwzLx+5NXbd7+8XAAAAAAAAAAAAgJkm6AFMjqfi4aiiG0yJtJqj/khO8VPxjcc+HlfdvxIAAAAAAAAAAAAAMOMEPYDJsaVzLB5v1ZFzMNlyiuM51/8huvHz8bYP/VUAAAAAAAAAAAAAAD1VAEyK7bGacv5SMLFyjjpHfDLX1f8SVfWTQh4AAAAAAAAAAAAA8ExO9AAmSp3ioeRAj0m1Gik+mbvVP4633XUwAAAAAAAAAAAAAIDnEPQAJkrK6cEISY+Jk+Jo+Wv7QK7TL8fb7joUAAAAAAAAAAAAAMAZCXoAkyXHlyIFk+WpuptujLzx1mj/wZEAAAAAAAAAAAAAAJ6XoAcwUVKKrzjPY1KkJ3PkT+Zcvz3ad98fAAAAAAAAAAAAAMCLEvQAJko3pyNVEvUYeymORuT35ZX63fG2u/8qAAAAAAAAAAAAAICzIugBTJa5+FLUwRjLEUu5m38mNuV/G9fcfSQAAAAAAAAAAAAAgLNWBcAkObYsODCuUhzPkQ7l1fp/iKXqXXG1kAcAAAAAAAAAAAAAnKsUABOmOrBtNZqzPRgbOdJyynFbneOXot05FAAAAAAAAAAAAADAeZkPgEmT49FIcVkwLh7OEe/Kc/Gr8dbOwwEAAAAAAAAAAAAAnDdBD2Di5BSHUwh6jIOc469yxC/G8kP/LnbdvxwAAAAAAAAAAAAAwAUR9AAmT47FSPG6YN3kiKfK47diOd0YuzqHAwAAAAAAAAAAAAAYCEEPYOKkyI83z6ybIynnW3Oufjp2dZYCAAAAAAAAAAAAABgYQQ9g8lTpoeZICUYul1/7J3JO747l5ffFrnuEPAAAAAAAAAAAAABgwAQ9gMmT40gwYulEzvkDeTn9b/Etjz8QV927EgAAAAAAAAAAAADAwAl6ABOnTvG1yokeo9Kc4nEk5bgtb17+57HznqMBAAAAAAAAAAAAAAyNoAcweVJ8JQQ9RiJH/qsc1c/m5RMfEPIAAAAAAAAAAAAAgOET9AAmz2r9WFRVMFw5x4dyN/1kXBafiO33rAYAAAAAAAAAAAAAMHSCHsDkSfPHItdHI8VlwcDlFIdzHb8Vy/Uvxq67jwQAAAAAAAAAAAAAMDKCHsDkyflEzMWxyIIeg5YjPpXr9MuxPH9b7Lrz0QAAAAAAAAAAAAAARqoKgEmzoT6R63gsGKjyO/14rtM/iEOxT8gDAAAAAAAAAAAAANaHEz2AyZPmn4zUPRoMRI74SorYl2PlN6P90c8FAAAAAAAAAAAAALBuBD2AyVPHanl+IrhgOceXc0q/kE889O7Ydf9yAAAAAAAAAAAAAADrStADmDxPbXgqbep+LbgAaTlH/nBO+V2x4+D7AgAAAAAAAAAAAAAYC4IewAR62bFITx2OnILzslpH3BaR9sTL0mIAAAAAAAAAAAAAAGND0AOYPLtuW44DrQcixfHIeXNwdnLUOeVjua5ujHbn5gAAAAAAAAAAAAAAxk4VABOozukzEflrwdlJcTxX8aGcq7fHlvjVAAAAAAAAAAAAAADGkhM9gMmU8ufK8yPl8Y3Bi6vjt3PU74xL5z4d2zurAQAAAAAAAAAAAACMJUEPYDKd+PrP540PfT6l+JvB8+nmiCMpx7+sNy//erz5nqMBAAAAAAAAAAAAAIy1KgAm0a7buinFXwTPK+d0qDz+Xr185JeEPAAAAAAAAAAAAABgMjjRA5hYdVQfq8ozz5JjJUe+vTxuip0f+vMAAAAAAAAAAAAAACaGoAcwuU6s3hOb556InF8S9OScj+ZUvTe6K78Qb/voQwEAAAAAAAAAAAAATJQUAJPswLY7qog3x4zLOerSov9Fruf+1/jmR++Kq+5dCQAAAAAAAAAAAABg4jjRA5hsdfVLMVe/KfJMt2fHo0q/nyN+Ltof/FgAAAAAAAAAAAAAABNL0AOYbFX1FznqQyniqphBOcdXcxW/GXOrt8R/++FPBwAAAAAAAAAAAAAw0aoAmGSf+KMjqRv/OiI9GbMkR50j/jTX1Y/Hpk0/E1d/+DMBAAAAAAAAAAAAAEy8FACT7kDrqpTzu1KK746ZaNfSkznyJ3Ou3x47774/AAAAAAAAAAAAAICp4UQPYPKdeOiTKcX+8t7xmHYpjkaqfyV356+NHXf/VQAAAAAAAAAAAAAAU8WJHsB0+N0feHVa7b6vNGrfGVMq53w0p7m/HxuevDOu/uPHAgAAAAAAAAAAAACYOoIewPR4f+v7qzr+KCJvjOnyVI7405zn/vfY+cGPBgAAAAAAAAAAAAAwtaoAmBZv7Xy4PL87Ii3HlMgRD5fnX8sb0o8KeQAAAAAAAAAAAADA9JsPgClSr8Yvpfn6tSlXb4nyFBMsR1rMET+f6/Tv4+rOUgAAAAAAAAAAAAAAUy8FwLRZ+IHvSVX9Gyny62MC5ciPR1QfyhF74mVxKLZ3VgMAAAAAAAAAAAAAmAmCHsB0OtB6c2ng3p0ib40JkiMdy5H/nziRboxdncMBAAAAAAAAAAAAAMwUQQ9gei20dlZV/FxE/taYDJ+rc7wnltOvxK7OsQAAAAAAAAAAAAAAZs58AEyrLfF79VJESulnU8rfFuMr54h7c07/NJZPfCR23fNUAAAAAAAAAAAAAAAzyYkewPR733+9Lc1Vv5Jy/M3S6lUxRnLkx8rjd2PTxT8Rb/79owEAAAAAAAAAAAAAzDRBD2A2/N5/c1k6fuI3UpW3R47LYt2lOkf+65TTv6qXT7zLKR4AAAAAAAAAAAAAQEPQA5gd729dHnX8SMp5d2n8XrOep3vknPbnlH8lqmN/HG+998kAAAAAAAAAAAAAAAhBD2DW3Pq6jbHx615bVdVPRo7rY8RyxJdSnd9ZX7z6W/F3PnqktMI5AAAAAAAAAAAAAADWCHoAs+mu1nwsxfenFD9RWsLvSjleGSlvjCHIkY5Fzos5pf8YJ+LXY1fncAAAAAAAAAAAAAAAnIGgBzDb3v9dF0d9yd+uov7eHOkHU6TvjMgXxwCUP+/B8vyxnOPuWE4fiF2dzwYAAAAAAAAAAAAAwAsQ9ABo3Pq6jXHxZd8U3Q3fEHX9nWkuro4cV5VG8vJz+FNyjvhSqtKH627dibn88Vi56MFYvfRrseu2bgAAAAAAAAAAAAAAvAhBD4AXcqD12kjdby/N5beVxyujCX7kVPW+VsWxqPPRSOkrkeu/jmrjoXjrnV8IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAn2/wMPpc2RBdi1IAAAAABJRU5ErkJggg==", TQe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGwAAABsBAMAAAB9SEr+AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAbUExURUdwTP///////////////////////////////xb9HQ4AAAAIdFJOUwCAvz5nE+qvkBVomAAAAT1JREFUWMPtl70LwjAQxatWXP0aHHUQOlZxcFRcHIuIriIOHV0ER6ui+bMl2ErvcmlCEKQxb+tLf5RqLu/V85yc7NKkBRS+3docuB1MrRjUM+JuPUD2CWFntM763G1g9wqpGl5nN25PBTsEWEVYv3O7J9gzBZbQWLOk2CD7V4M8ds3ctgT7WL08ltD3OMxhDvsFZjjdlh54Po0tFZhh4ng4/9iRu1XsPlEsbnH+vdMUp+UQp/AIhHQ3y26Y6AvXcayuaqnW3Yim6KqWzUfMDjRGV7VUU3HrFw5Objz6FCapaqn49U4PSxB2KTcmHuZamBgdVmPjGJ6eoRbmF205ObbB2CPSwZY6Xx105Ctj8WtPM3w3w1/SG0NqH/7ZVjacbksPPL8Qi2WYYeJIqpoq3yRVTZmmkqqmym4np5LrBeYgWB5+6q94AAAAAElFTkSuQmCC", _Qe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAADQUlEQVR4nO2bu2sUURSHz4CISlR8pNi4e24S151zx0ez2XMmD1gROxEVEcRHIYJYCPaCna9CBBULK/uUAUX0D1Ax4gpa2EUbg6CkMaiIyjWKSdjsIzs7z/vBVFvsnW9/587cc+8CWCwWi8ViscQL5cpu1PJQaZ5Ad3gk6vHEijwN7VCaZ5WWX+ZCkm/9mg9EPa54UK2uUFqe/5MzT9J3pfkgZB0kvrRYjpX0FyQpzyWlvqBMJ0mp6ipF8rqRnExLUsS3WpGTSUno8R6l5Wc7gjIjqVjkdUg81a6cBZKocgjSCmq+t1w5qZdUcP39ncpJraRcqbwZST4EJSh1khTJeJByUiUJtZzohpxUSCq4I32K+FM3BSVZkjPXwuiunPmSsOSPQlLALpdW/YsnICkMDpbXI/HTMAUh8QNIEoOhSuLZfvKrod6g646sNd29gpbzqPmq0nIbSS6i5tMDJdkVF0mo+VWr4wkCxywKleZHpv3ZJNJTqOUGUjkXjST+gVqueJ63MhQzWPJHkfhZ2wMl+aI0X8uVy2vCkoRa3iqqDIcixoAkZ5p1+JpPklLr18MKGknS8qRDOaZVcrfXq/ZAWKArhwP7ZYmnTTu1G0lCkveo/b0QAU67Xb4m8Z8Z8Hxu2BdqN0kk43nP3wgR4sRREmr+GKdlhBMnSUh8v9kTMpOSUMuMeWhAjHEik0T8eOv2oQIkAAc13wlKkiL+3PTppvmk+V5IEE6YkpKKY9ZggZUb8XRSSihCSfKy0bIkqThBlptZZEIKcYJLEs/mt/lbIG0Ui2O9ZrINJkV8HdIE7hzboLRMBjgXvYO0gAHL+XeZM4qQkq3jWt2b7LTcPDkFaU0OktT+zEkdTdx8AdKYHCSpmc87fgUgvglpTE7uv5yOXgGQ5DJkQM6yJSHxOUhpWS1FW+WGxPsgA8lZVj8JNX8NdXciJnJalpSYvXQMXk5Lksy5RciwnIaSzA5u7LuHfVTZ1OGE3CoLJu65E2HsQ8aT0yBJlbMQZ/rCS85iHLPNDXEmn/dXK80vIpCTDBTJ0aXkmGRB1kHPP27lNKDXq/YokjfzJE3a5NST5FaOocdHzL//uhpZi8VisVgsFosFYs5vllNJQwrDPNkAAAAASUVORK5CYII=", EQe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEOElEQVR4nO2bz2sUSRTHe6K7/jgIiyxozFQFHZ33OojoOO+NUchRA7q7Fw9ehM0ejR7iwt7UgwcNCOqfkL/Do7/BX+BlYTHir+hZYY3rzsjrnsiYVFfPD2e6OtQXGoaZ7p6qT7/36tWr6iDw8vLy8vLy8vLy8vLyck6l0pF1KqydVkB3NfAHjdzo4fhfI73SwHOjY7QnyLtGdta2KeDHPUJJOOizBp4Jcm050C843xwXgjxKIZ8ZAJz8QlJA9wYIqKGQrgTB8TVBXqSB3g8SUBPSkyLQyW0lGnEe1qDh6EEdwB8U8h0FNB2G4Y8eEFosFuhhsTw+7C0IbVZFD7qypMxdAQcY+4BOeUBoAYR8xwNCW+Cm9x4Q2t3MA0IPqNFLoPYWhB5Qw1sQ9i8X8i6GHlDDWxB6F2tkNR/zMQg9oIa3ILSVLHhRA99QQOeL5doxPcaodh/6KZiYWDsyUtsgZVxZi9NAJzTQ1Xidj/5b9S6mgB4qpD8iGJ32MaxuUcB/KeS/Vx0gBfx4tFw9HHwfFVYNIIX0rzz1zFc9HLWaFwq4ErigrGHo5Qfw/WGobg5ckVuWQ3dLJdqU1uZKpfKDgupRDXRNId9WQO8U8Kf4oHfynQaeVbtqB4MgGFodgID+KZUO/Zy20UKX+axA6MBdF+QauTa3gBTSR40H9trbSb8poOc9WOfzUaRf8wroT0sTC7IrRCPXv8N/1SXB7Gi4zxqOBn4qMSURDvBcH/5zrm1IWQMqhvyLpW0X+ma1QOecB6SQniQ9SYk5JreSeCXTjmgPZLqlvGxOUT4afq/bHo4bgICmjW3SE+vNAZluyn7KFohTps7H39HU0nkygZVrDefNp45u2QGiz0kJoQzLpk63wmlp/2QrpObnyeXnCSSjJaVtMM0Q0M3kJHBlniOuYulDBCkJzpIU8KOV9+UFazKZoXtdNHeiejQB6KuUBz1pg9NMF94Y21I+MO4eoJCOG9sDdN1idV/jSqeSWlLifYFnndrEqSMLqu0zd4RvJ1/Di1JF7BSO1JOkfNKpu8cNkpIkDh7Q9rCiEtpjnWelxZm0IG4GT29tgKazALS1Utlobg8vplpfm5DagbN0v8SbyMZGFSVeHlCiiuXx4UFDyo2LLbOkU3Gxqf+BO6mkag3SHcJpH5IlSLsmDTyb2JGQf+/6vkhTXQ3zrkntqh3sU6IokF53nCg6qKGoTLrSJR9lMtVwURp4xhR/4reDupus7hjbXzSmEHl8G7Ikb0EizZuCaQukQrQU3Ua5Q+BopFsG93rWdTE/a0mB3VgwA16MXcUcT5YBfS3nJiSf9W6mLU7JiZKr4ypkXrTPgQqyiSF+F79nOHWNdCl3o1Y7kgK7OXC36VJI87mPOWmKlp6BZ0x5UnKs4QW5JrejVdCdhiT7jacldEsmm9HoFi8JvY1WMIAvNzPkttzpCzIGFAwMLQUoAAAAAElFTkSuQmCC";
var Im = { exports: {} }, xQe = Im.exports, WS;
function wQe() {
  return WS || (WS = 1, function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(xQe, function() {
      return function(n, r, i) {
        r.prototype.isYesterday = function() {
          var s = "YYYY-MM-DD", a = i().subtract(1, "day");
          return this.format(s) === a.format(s);
        };
      };
    });
  }(Im)), Im.exports;
}
var CQe = wQe();
const SQe = /* @__PURE__ */ Fr(CQe), Q9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHElEQVR4nO3UQU7CUBSF4bcQGbsVYeAajO90A9wHa5B32YhO3BEkRgYkxggbgDTRxBGa0Nse5XzJnXXQk79pSiIicsGa6fIW5hsUP5w88037bPrrcqnbH8d+XvtsYpFni0k2X//25fu69p0a83Hng1Hqy9DjTnwZrxp8rsZ8nEtdEdZd5VJvzh4oIv8TCH5U30+DuwaCqiocCQRVVTgSCKqqcCQQVFXhSCCoqsKRQFBVhSOBoKoKRwJBVRWOBIKqKhwJBFVVOBIIqqpwJBBUVeFIIKiqwpFAUFWFI4GgqgpHgvl+6Kpfl80/4geX+kwzuNTH8MH3s8V1Nn8feizM3zB/uEp9uJsuRzB/Qqm7/sfWXVu2t7EiIiKSunIEhOq3p0W+CNEAAAAASUVORK5CYII=", IQe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAEGAAABBgHN0zO8AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAoNJREFUOI2tlL9PU1EUxz/n9t1XBQelk7+ipChurp1k15TEmJLwQ9sGEwedjDvhD4AJB4mm5UdqpItC4o4TDO4oGgcjWwlGiLS3fcfh+ZpSCgnGM713bs7nfs+55xxRVf6neUcd5F/XbihmSFQHRDkPoMIWyCoSlAvD/kanOGlXmJ0nEfPctMIYYI64L0BYiHn26csM20cCs2+q103DvAeSQAV0RpEVqdmvAOq7pKBpkCdAQuGLENwujMQ3DwGz8ySM59ZDmLz1rZd7keFnx3IUOSvx+pyqDip80bpNzT2gQmtKMc9NR7Crm969VtijWboezdIV/Rdy7Fz57N0FeSfQZ6ybis4MRA/AGFDxrZebmCBoVVQ749ZqZ9xaq29igoCalwMqKPfHF6v9TaBihsJvnemUpkKvQm+7v5BjR1SfAyYwsaEmUFRvAUggy51qdpxJTFbCS0NG1IeXAGw8fM2hMqe7nVsDLgMIdAPkSy5qke971qaWMvzeD+xXH4dRLjYVhllBbQ85qcLTNoxRCRmRwh/ADfVdEuzHpQy/wd6MgnIl9wugOGJ72oGNmksioLDVVKgiHwCM6uBJFSKaDkGy2gQKwRIQqMjjfJGzh2Lgm8C3dv9oiXMgj4GGBI1yE1gY9jcQFoAEfr04OXlwhv1dm/J3barVNzmJ8anPAT0K86/G4p9CwX9H72GZnrpz6wJ9IrKsVS9byLHTKcvREudCmKaBzZi1qWhJHFgO+VL1mmLeC/QB26I6IzFZ2Q/CdjplXFIbmlaRJ0APsAnBnY7LIbLsPAlj3RTKfY5ZXwpznrXPjl1frTa+WO0Px0kHRLmggipsGWRVgkY5qlm7HQn8V/sDpc0NjXW+Pa0AAAAASUVORK5CYII=", kQe = { key: 0 }, DQe = { class: "mb-3 flex items-center justify-between text-xl font-semibold text-gray-700 dark:text-gray-300" }, MQe = { class: "mb-1 flex items-center justify-between text-gray-700 dark:text-gray-300" }, OQe = ["placeholder"], NQe = {
  key: 0,
  class: "mt-1 text-sm text-red-500"
};
const LQe = { class: "mt-3 mb-1 text-base" }, PQe = { class: "divide-y rounded bg-gray-100 dark:bg-zinc-800" }, RQe = { class: "grid grid-cols-6 gap-3 p-4" }, BQe = ["onClick"], FQe = { class: "flex items-center justify-center gap-3 rounded p-3" }, UQe = ["placeholder"], $Qe = { class: "mt-5 flex gap-3" }, HQe = ["disabled"], jQe = { key: 1 }, zQe = { class: "mb-1 mb-5 flex min-w-[380px] items-center justify-between text-xl font-semibold text-gray-700 dark:text-gray-300" }, qQe = {
  key: 0,
  class: "mt-1 flex flex-wrap gap-2"
}, VQe = ["onClick"], WQe = { class: "flex items-center gap-3" }, QQe = { class: "w-64 truncate overflow-hidden text-base text-ellipsis whitespace-nowrap text-black dark:text-[#F3F4F6]" }, GQe = { class: "flex items-center gap-3" }, YQe = ["onClick"], XQe = ["onClick"], KQe = { class: "mt-3" }, ZQe = { class: "text-[#60A5FA]" }, JQe = { key: 2 }, eGe = { class: "mb-2 flex items-center justify-between text-xl font-medium text-gray-700 dark:text-gray-300" }, tGe = /* @__PURE__ */ Ze({
  __name: "TagsModal",
  props: {
    roomId: {},
    roomTag: {}
  },
  setup(t) {
    const e = $n(), n = t, r = Yt(), i = Se([]), s = Se({}), a = Se([]), o = Se({}), u = Se(""), c = Se("#60a5fa"), d = Se(!0), l = Se(
      1
      /* Edit */
    ), f = Se(""), p = Se(!1), m = Se(""), g = Se(-1), y = de(() => {
      if (!u.value.trim())
        return !1;
      const V = i.value.includes(u.value);
      return d.value ? V : V && u.value !== m.value;
    }), b = [
      "#f43f5e",
      "#f97316",
      "#f59e0b",
      "#84cc16",
      "#10b981",
      "#06b6d4",
      "#0ea5e9",
      "#6366f1",
      "#8b5cf6",
      "#6b7280",
      "#64748B",
      "#78716c"
    ], E = de(() => zN()), v = (V) => {
      r.dispatch("imkit/updateRoomPrefs", {
        roomId: V,
        roomTag: E.value.get("roomTag") ?? n.roomTag,
        prefs: {
          tags: i.value,
          tagColors: s.value
        }
      });
    }, _ = r.state.imkit.rooms[n.roomId];
    _.pref && (i.value = [..._.pref.tags || []], a.value = [..._.pref.tags || []], s.value = { ..._.pref.tagColors || {} }, o.value = { ..._.pref.tagColors || {} }, i.value.length > 0 && (l.value = 0, p.value = !1));
    const D = () => {
      u.value && (i.value.length >= 5 || (i.value.includes(u.value) || i.value.push(u.value), c.value.startsWith("#") && (s.value[u.value] = c.value, u.value = "")));
    }, S = () => {
      u.value && c.value.startsWith("#") && (i.value[g.value] = u.value, delete s.value[m.value], s.value[u.value] = c.value, u.value = "");
    }, M = () => {
      i.value = i.value.filter((V) => V !== f.value), delete s.value[f.value];
    }, O = (V) => {
      f.value = V, l.value = 2;
    }, T = (V) => {
      u.value = V, c.value = s.value[V];
    }, N = () => {
      c.value = c.value.replace(/[^#0-9a-fA-F]/g, ""), c.value.charAt(0) !== "#" && (c.value = "#" + c.value);
    }, H = () => {
      l.value = 1, d.value = !0, u.value = "", c.value = "#60a5fa";
    }, $ = (V, B) => {
      l.value = 1, d.value = !1, u.value = `${V}`, c.value = s.value[V], m.value = `${V}`, g.value = B;
    }, j = () => {
      l.value = 0, p.value = !1;
    }, U = () => {
      p.value = !0;
    };
    return (V, B) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col gap-3 max-w-[420px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        l.value === 1 ? (X(), se("div", kQe, [
          W("div", DQe, [
            B[12] || (B[12] = W("div", null, " ", -1)),
            An(" " + _e(d.value === !0 ? V.$t("createTag") : V.$t("editTag")) + " ", 1),
            W("button", {
              class: "flex items-center justify-center",
              onClick: B[0] || (B[0] = (R) => ke(e).closeAll())
            }, [
              et(Br, { class: "h-7 w-7" })
            ])
          ]),
          W("div", MQe, [
            Gt(W("input", {
              "onUpdate:modelValue": B[1] || (B[1] = (R) => u.value = R),
              type: "text",
              class: vt([
                "w-32 grow rounded-md bg-gray-100 p-2 text-base placeholder-gray-400 outline-none dark:bg-zinc-700 dark:placeholder-gray-400",
                y.value && "border border-red-500"
              ]),
              placeholder: d.value === !0 ? V.$t("createTag") : V.$t("editTag"),
              onInput: B[2] || (B[2] = (R) => U())
            }, null, 42, OQe), [
              [ds, u.value]
            ])
          ]),
          y.value ? (X(), se("div", NQe, _e(V.$t("duplicateTagName")), 1)) : Fe("", !0),
          (i.value.length > 0, Fe("", !0)),
          W("div", null, [
            W("div", LQe, _e(V.$t("chooseColor")), 1),
            W("div", PQe, [
              W("div", RQe, [
                (X(), se(wt, null, on(b, (R) => W("div", {
                  key: R,
                  class: "h-8 w-12 rounded",
                  style: Qt({ backgroundColor: R }),
                  onClick: (K) => (c.value = R, U())
                }, null, 12, BQe)), 64))
              ]),
              W("div", FQe, [
                W("div", {
                  class: "h-8 w-12 rounded-md bg-white p-2 text-base",
                  style: Qt({ backgroundColor: c.value })
                }, "   ", 4),
                Gt(W("input", {
                  "onUpdate:modelValue": B[4] || (B[4] = (R) => c.value = R),
                  type: "text",
                  class: "h-8 w-50 grow rounded-md bg-gray-100 p-2 text-base placeholder-gray-400 outline-none dark:bg-zinc-700",
                  placeholder: V.$t("inputTagPlaceholder"),
                  maxlength: "7",
                  pattern: "^#[0-9a-fA-F]{6}$",
                  onInput: B[5] || (B[5] = (R) => (U(), N()))
                }, null, 40, UQe), [
                  [ds, c.value]
                ])
              ])
            ])
          ]),
          W("div", $Qe, [
            W("button", {
              class: "h-10 grow rounded-lg border border-gray-200 text-base dark:border-stone-400 dark:text-stone-400",
              onClick: B[6] || (B[6] = (R) => j())
            }, _e(V.$t("cancel")), 1),
            W("button", {
              class: "h-10 w-[40%] grow rounded-lg bg-blue-400 text-base text-white disabled:cursor-not-allowed disabled:bg-gray-200 dark:disabled:bg-gray-700 dark:disabled:text-gray-500",
              disabled: !u.value.trim() || !c.value || !p.value || y.value,
              onClick: B[7] || (B[7] = () => {
                d.value ? D() : S(), v(V.roomId), j();
              })
            }, _e(d.value == !0 ? V.$t("create") : V.$t("save")), 9, HQe)
          ])
        ])) : Fe("", !0),
        l.value === 0 ? (X(), se("div", jQe, [
          W("div", zQe, [
            B[13] || (B[13] = W("div", null, " ", -1)),
            An(" " + _e(V.$t("tag")) + " ", 1),
            W("button", {
              class: "flex items-center justify-center",
              onClick: B[8] || (B[8] = (R) => ke(e).closeAll())
            }, [
              et(Br, { class: "h-7 w-7" })
            ])
          ]),
          i.value.length > 0 ? (X(), se("div", qQe, [
            (X(!0), se(wt, null, on(i.value, (R, K) => (X(), se("div", {
              key: R,
              class: "flex min-w-[380px] items-center justify-between gap-1 overflow-hidden rounded-md bg-gray-200 p-3 text-base text-white dark:bg-zinc-600",
              onClick: (Q) => T(R)
            }, [
              W("div", WQe, [
                W("div", {
                  class: "circle-shadow h-4 w-4 rounded-full",
                  style: Qt({ backgroundColor: s.value[R] })
                }, null, 4),
                W("div", QQe, _e(R), 1)
              ]),
              W("div", GQe, [
                W("img", {
                  width: "20",
                  height: "20",
                  class: "cursor-pointer",
                  src: "https://img.icons8.com/ios-glyphs/30/637289/pencil--v1.png",
                  alt: "Edit Icon",
                  onClick: ar((Q) => $(R, K), ["stop"])
                }, null, 8, YQe),
                W("img", {
                  width: "20",
                  height: "20",
                  src: Q9,
                  class: "cursor-pointer",
                  alt: "Delete Icon",
                  onClick: ar((Q) => O(R), ["stop"])
                }, null, 8, XQe)
              ])
            ], 8, VQe))), 128))
          ])) : Fe("", !0),
          W("div", KQe, [
            W("div", {
              class: "flex cursor-pointer gap-2",
              onClick: B[9] || (B[9] = (R) => H())
            }, [
              B[14] || (B[14] = W("img", {
                width: "20",
                height: "20",
                src: IQe
              }, null, -1)),
              W("div", ZQe, _e(V.$t("createTag")), 1)
            ])
          ])
        ])) : Fe("", !0),
        l.value === 2 ? (X(), se("div", JQe, [
          W("div", eGe, [
            An(_e(V.$t("confirmDeleteTag")) + " ", 1),
            W("button", {
              class: "ml-2 flex items-center justify-center",
              onClick: B[10] || (B[10] = (R) => j())
            }, [
              et(Br, { class: "h-7 w-7" })
            ])
          ]),
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) mt-3 h-10 w-full grow rounded-lg bg-blue-400 text-base text-white",
            onClick: B[11] || (B[11] = (R) => (M(), v(V.roomId), j()))
          }, _e(V.$t("confirm")), 1)
        ])) : Fe("", !0)
      ]),
      _: 1
    }));
  }
}), nGe = { class: "w-full" }, rGe = { class: "text-center text-base font-medium text-stone-800 dark:text-stone-300" }, iGe = { class: "text-sm font-normal text-stone-700 dark:text-stone-400" }, sGe = { class: "flex w-full gap-3" }, aGe = /* @__PURE__ */ Ze({
  __name: "DeleteRoomModal",
  props: {
    roomId: {}
  },
  setup(t) {
    const e = $n(), n = Yt(), r = Se(!1), i = t, s = async () => {
      r.value = !0;
      try {
        await n.dispatch("imkit/hideMessagesFromUserInRoom", i.roomId), await n.dispatch("imkit/updateRoomPrefs", {
          roomId: i.roomId,
          prefs: {
            hidden: !0
          }
        }), e.closeAll(), n.state.imkit.selectedRoomId === i.roomId && n.commit("imkit/setState", {
          selectedRoomId: ""
        });
      } catch (a) {
        console.error("Error deleting room:", a);
      } finally {
        r.value = !1;
      }
    };
    return (a, o) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col items-center gap-5 max-w-[350px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", nGe, [
          W("button", {
            class: "ml-auto flex items-center justify-center",
            onClick: o[0] || (o[0] = (u) => ke(e).closeAll())
          }, [
            et(Br, { class: "h-7 w-7" })
          ])
        ]),
        et(Jf),
        W("div", rGe, _e(a.$t("chatroomDeleteConfirmationTitle")), 1),
        W("div", iGe, _e(a.$t("chatroomDeleteConfirmationMessage")), 1),
        W("div", sGe, [
          W("button", {
            class: "h-10 w-full rounded-md border border-gray-200 text-gray-800 dark:border-stone-400 dark:text-stone-400",
            onClick: o[1] || (o[1] = (u) => ke(e).closeAll())
          }, _e(a.$t("cancel")), 1),
          W("button", {
            class: vt(["flex h-10 w-full items-center justify-center gap-2 rounded-md text-white", r.value ? "cursor-not-allowed bg-red-300" : "bg-red-500"]),
            onClick: s
          }, [
            r.value ? (X(), gt(_c, {
              key: 0,
              class: vt(["h-4 w-4", r.value ? "fill-red-300! text-white!" : "fill-red-500"])
            }, null, 8, ["class"])) : Fe("", !0),
            An(" " + _e(a.$t("delete")), 1)
          ], 2)
        ])
      ]),
      _: 1
    }));
  }
}), G9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQElEQVR4nO2asUrEQBCGp7PxEbSx8VnEFzG7Bp05sJ05rS18jDsEX8Pn8CxV9ArbkVVEUEJyJrhZ838wXYr92ORLM0QAAAAAGBWVXOwG0evIuo5i3mUC2yqwXYag21SerD12Ff0xrLd1fbVFpRDSzf5W9vO2xZRKIW7wGjcL62t1qntUArGnbPZhXQe2m6OT8/1pCH+JP6UeTUf449NaTkzYXiYlHMUcwgCA/0U1mx9G0fvif0lsq+PZ/KBVOD2Y+7CDDetdq3D2Qw48BOFv5L4R3LDglXZ8w4JoOSrdRO6qotKCSjsqLai0o9JN5K4qKi2otKPSgko7Kt1E7qqi0oJKOyotfSrN/ZdaRjOsz63CaSEk+0GHm0WrcNp+SQshIzhsrwmiD/WZ7tAGq4fLtCNRnuj7mRedZQEAAABAf8UbgvvRyv0JTvIAAAAASUVORK5CYII=", oGe = { class: "mb-1 flex items-center justify-between text-xl font-medium text-gray-700 dark:text-gray-300" }, uGe = ["onClick"], lGe = /* @__PURE__ */ Ze({
  __name: "AddToFolderModal",
  props: {
    roomId: {}
  },
  setup(t) {
    const e = $n(), n = t, r = Yt(), i = de(
      () => r.state.imkit.sortedFolderIds.map((a) => r.state.imkit.folders[a]).filter((a) => a)
    ), s = (a) => {
      n.roomId && r.dispatch("imkit/addRoomToFolder", {
        roomId: n.roomId,
        folderId: a
      });
    };
    return (a, o) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col gap-3 w-[360px] relative max-h-80vh overflow-y-auto",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", oGe, [
          An(_e(a.$t("addToFolder")) + " ", 1),
          W("button", {
            class: "flex items-center justify-center",
            onClick: o[0] || (o[0] = (u) => ke(e).closeAll())
          }, [
            et(Br, { class: "h-7 w-7" })
          ])
        ]),
        (X(!0), se(wt, null, on(i.value, (u) => (X(), se("div", {
          key: u.id,
          class: "group relative flex cursor-pointer items-center gap-3 rounded-lg bg-slate-200 p-2 dark:bg-slate-700",
          onClick: () => {
            s(u.id), ke(e).closeAll();
          }
        }, [
          o[1] || (o[1] = W("img", {
            width: "30",
            height: "30",
            src: G9
          }, null, -1)),
          An(" " + _e(u.name), 1)
        ], 8, uGe))), 128))
      ]),
      _: 1
    }));
  }
}), cGe = {}, dGe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24",
  class: "fill-slate-700 dark:fill-slate-300"
};
function fGe(t, e) {
  return X(), se("svg", dGe, e[0] || (e[0] = [
    W("path", { d: "M15.478,15.48c-0.976,0.976-1.468,2.25-1.468,3.528c0,1.278,0.492,2.553,1.468,3.528c1.952,1.952,5.106,1.951,7.058-0.001s1.952-5.106,0-7.058C20.586,13.529,17.431,13.529,15.478,15.48z M20.011,17.001v1h1c0.552,0,1,0.448,1,1v0c0,0.552-0.448,1-1,1h-1v1c0,0.552-0.448,1-1,1h0c-0.552,0-1-0.448-1-1v-1h-1c-0.552,0-1-0.448-1-1v0c0-0.552,0.448-1,1-1h1v-1c0-0.552,0.448-1,1-1h0C19.563,16.002,20.011,16.449,20.011,17.001z" }, null, -1),
    W("path", { d: "M12,19c0-3.866,3.134-7,7-7c1.075,0,2.09,0.25,3,0.683h0V8c0-1.1-0.9-2-2-2h-7.172c-0.53,0-1.039-0.211-1.414-0.586l-0.828-0.828C10.211,4.211,9.702,4,9.172,4H4C2.9,4,2,4.9,2,6v12c0,1.1,0.9,2,2,2h8.08C12.033,19.673,12,19.34,12,19z" }, null, -1)
  ]));
}
const Y9 = /* @__PURE__ */ mn(cGe, [["render", fGe]]), hGe = {}, pGe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24",
  class: "fill-slate-700 stroke-slate-700 dark:fill-slate-300 dark:stroke-slate-300"
};
function mGe(t, e) {
  return X(), se("svg", pGe, e[0] || (e[0] = [
    W("path", {
      id: "XMLID_11_",
      style: { fill: "none", "stroke-width": "2", "stroke-linecap": "round", "stroke-miterlimit": "10" },
      d: "M20,4H4"
    }, null, -1),
    W("path", { d: "M15,3v1H9V3l0.429-0.429C9.795,2.205,10.29,2,10.807,2h2.386c0.517,0,1.012,0.205,1.377,0.571L15,3z" }, null, -1),
    W("path", { d: "M4.366,7l1.527,13.264C6.025,21.254,6.877,22,7.875,22h8.249c0.998,0,1.85-0.746,1.983-1.745L19.634,7H4.366z" }, null, -1)
  ]));
}
const gGe = /* @__PURE__ */ mn(hGe, [["render", mGe]]), AGe = {}, bGe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 24 24"
};
function yGe(t, e) {
  return X(), se("svg", bGe, e[0] || (e[0] = [
    $0('<g id="Rounded" class="fill-slate-700 dark:fill-slate-300"><g><path d="M10.69,9.313C9.693,9.801,9,10.815,9,12c0,1.657,1.343,3,3,3c1.185,0,2.199-0.693,2.687-1.69L10.69,9.313z"></path></g><g><path d="M16.155,14.779c-1.033,1.542-2.899,2.478-4.956,2.159c-2.098-0.326-3.811-2.039-4.137-4.137C6.743,10.744,7.68,8.878,9.221,7.845L6.732,5.355c-2.905,1.621-4.677,4.296-5.46,5.706c-0.332,0.598-0.321,1.318,0.004,1.92C2.431,15.119,5.751,20,12,20c2.952,0,5.219-1.092,6.91-2.467L16.155,14.779z"></path><path d="M11.278,7.073C11.515,7.038,11.753,7,12,7c2.761,0,5,2.239,5,5c0,0.247-0.038,0.485-0.073,0.722l3.43,3.43c1.074-1.192,1.86-2.401,2.33-3.205c0.354-0.604,0.354-1.345,0.019-1.96C21.537,8.834,18.219,4,12,4c-1.212,0-2.295,0.199-3.284,0.511L11.278,7.073z"></path></g><line class="stroke-slate-700 dark:stroke-slate-300" style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;" x1="4" y1="4" x2="20" y2="20"></line></g>', 1)
  ]));
}
const vGe = /* @__PURE__ */ mn(AGe, [["render", yGe]]), TGe = {}, _Ge = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 30 30",
  class: "fill-slate-700 dark:fill-slate-300"
};
function EGe(t, e) {
  return X(), se("svg", _Ge, e[0] || (e[0] = [
    W("path", { d: "M29.399,13.199l-4.5-5.999C24.337,6.448,23.439,6,22.5,6H4C2.897,6,2,6.897,2,8v14c0,1.103,0.897,2,2,2h18.5c0.939,0,1.837-0.448,2.399-1.2l4.5-5.999C30.195,15.74,30.195,14.26,29.399,13.199z M25,16.5c-0.828,0-1.5-0.672-1.5-1.5c0-0.828,0.672-1.5,1.5-1.5s1.5,0.672,1.5,1.5C26.5,15.828,25.828,16.5,25,16.5z" }, null, -1)
  ]));
}
const xGe = /* @__PURE__ */ mn(TGe, [["render", EGe]]), wGe = {}, CGe = {
  width: "512",
  height: "512",
  viewBox: "0 0 512 512",
  class: "fill-slate-700 dark:fill-slate-300",
  xmlns: "http://www.w3.org/2000/svg"
};
function SGe(t, e) {
  return X(), se("svg", CGe, e[0] || (e[0] = [
    W("path", { d: "M138.24 351.289L160.853 373.618L50.9156 483.413C50.9156 483.413 41 494 29.5 483C18 472 28.4445 461.084 28.4445 461.084L138.24 351.289Z" }, null, -1),
    W("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M329.102 372.196C330.43 377.518 330.356 383.094 328.885 388.378C327.414 393.663 324.598 398.476 320.711 402.347L278.044 445.013L66.56 234.667L109.227 191.289C113.128 187.45 117.948 184.677 123.226 183.232C128.505 181.788 134.066 181.722 139.378 183.04L219.022 202.951L299.378 122.738L388.978 212.48L308.764 292.551C308.764 292.551 322.133 344.178 329.102 372.196Z"
    }, null, -1),
    W("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M483.556 171.947C483.556 171.947 472.32 183.04 461.227 194.276C455.618 199.804 448.183 203.091 440.32 203.52C435.912 203.734 431.509 203.022 427.394 201.43C423.278 199.838 419.542 197.401 416.427 194.276L317.724 95.7156C313.909 91.946 311.133 87.2553 309.662 82.0976C308.192 76.9399 308.079 71.49 309.333 66.2756C310.582 60.4502 313.497 55.1136 317.724 50.9156C328.818 39.68 340.053 28.4445 340.053 28.4445L483.556 171.947Z"
    }, null, -1)
  ]));
}
const IGe = /* @__PURE__ */ mn(wGe, [["render", SGe]]), kGe = {}, DGe = {
  width: "512",
  height: "512",
  viewBox: "0 0 512 512",
  class: "fill-slate-700 dark:fill-slate-300",
  xmlns: "http://www.w3.org/2000/svg"
};
function MGe(t, e) {
  return X(), se("svg", DGe, e[0] || (e[0] = [
    $0('<path d="M138.24 351.289L160.854 373.618L50.9156 483.413C50.9156 483.413 41 494 29.5 483C18 472 28.4445 461.084 28.4445 461.084L138.24 351.289Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M329.102 372.196C330.43 377.518 330.356 383.094 328.885 388.378C327.414 393.663 324.598 398.476 320.711 402.347L278.044 445.013L66.56 234.667L109.227 191.289C113.128 187.45 117.948 184.677 123.226 183.232C128.505 181.788 134.066 181.722 139.378 183.04L219.022 202.951L299.378 122.738L388.978 212.48L308.764 292.551C308.764 292.551 322.133 344.178 329.102 372.196Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M483.556 171.947C483.556 171.947 472.32 183.04 461.227 194.276C455.618 199.804 448.183 203.091 440.32 203.52C435.912 203.734 431.509 203.022 427.394 201.43C423.278 199.838 419.542 197.401 416.427 194.276L317.724 95.7156C313.909 91.946 311.133 87.2553 309.662 82.0976C308.192 76.9399 308.079 71.49 309.333 66.2756C310.582 60.4502 313.497 55.1136 317.724 50.9156C328.818 39.68 340.053 28.4445 340.053 28.4445L483.556 171.947Z"></path><g clip-path="url(#clip0_4859_1096)"><path d="M463.188 394.812L378.812 479.188" class="stroke-slate-700 dark:stroke-slate-300" stroke-width="30" stroke-linecap="round" stroke-linejoin="round"></path><path d="M463.188 479.188L378.812 394.812" class="stroke-slate-700 dark:stroke-slate-300" stroke-width="30" stroke-linecap="round" stroke-linejoin="round"></path></g><defs><clipPath id="clip0_4859_1096"><rect width="150" height="150" fill="white" transform="translate(346 362)"></rect></clipPath></defs>', 5)
  ]));
}
const OGe = /* @__PURE__ */ mn(kGe, [["render", MGe]]), NGe = {}, LGe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 50 50",
  class: "fill-slate-700 stroke-slate-700 dark:fill-slate-300 dark:stroke-slate-300"
};
function PGe(t, e) {
  return X(), se("svg", LGe, e[0] || (e[0] = [
    W("line", {
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-miterlimit": "10",
      x1: "32",
      y1: "20",
      x2: "42",
      y2: "30"
    }, null, -1),
    W("line", {
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-miterlimit": "10",
      x1: "42",
      y1: "20",
      x2: "32",
      y2: "30"
    }, null, -1),
    W("path", { d: "M7.01,31.754V18.247c0-0.658,0.143-1.494,0.477-2.287H3c-1.676,0-3.04,1.364-3.04,3.04v12c0,1.676,1.364,3.04,3.04,3.04h4.481C7.151,33.253,7.01,32.415,7.01,31.754z" }, null, -1),
    W("path", { d: "M24.16,46.992c1.667,0,2.831-1.514,2.831-3.678V6.327c0-2.278-1.456-3.316-2.808-3.316c-0.91,0-1.838,0.433-2.607,1.213l-11.631,11.6c-0.64,0.566-0.934,1.648-0.934,2.422v13.507c0,0.767,0.293,1.841,0.881,2.358L21.51,45.695C22.565,46.768,23.533,46.992,24.16,46.992z" }, null, -1)
  ]));
}
const RGe = /* @__PURE__ */ mn(NGe, [["render", PGe]]), BGe = {}, FGe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 50 50",
  class: "fill-slate-700 stroke-slate-700 dark:fill-slate-300 dark:stroke-slate-300"
};
function UGe(t, e) {
  return X(), se("svg", FGe, e[0] || (e[0] = [
    $0('<path d="M5,16c-1.654,0-3,1.347-3,3.001V31c0,1.654,1.346,3,3,3h5V16H5z"></path><g><path d="M46,25c0,5.508-2.992,10.318-7.428,12.927l1.124,1.654C44.66,36.609,48,31.194,48,25s-3.34-11.609-8.304-14.581l-1.124,1.654C43.008,14.682,46,19.492,46,25z"></path><path d="M42,25c0-4.135-2.295-7.74-5.676-9.619l-1.13,1.662C38.049,18.554,40,21.552,40,25s-1.951,6.446-4.806,7.957l1.13,1.662C39.705,32.74,42,29.135,42,25z"></path><path d="M31.753,27.893l1.169,1.721C34.727,28.858,36,27.076,36,25s-1.273-3.858-3.078-4.613l-1.169,1.721C33.042,22.444,34,23.607,34,25S33.042,27.556,31.753,27.893z"></path></g><path d="M26.607,2c-0.663,0-1.303,0.279-1.753,0.765L12,16v18l12.854,13.234C25.305,47.721,25.944,48,26.607,48C27.927,48,29,46.927,29,45.607V4.393C29,3.073,27.927,2,26.607,2z"></path>', 3)
  ]));
}
const $Ge = /* @__PURE__ */ mn(BGe, [["render", UGe]]), HGe = ["textContent"], jGe = ["textContent"], zGe = ["textContent"], Wy = /* @__PURE__ */ Ze({
  __name: "HighlightedText",
  props: {
    text: {},
    highlight: {}
  },
  setup(t) {
    const e = t, n = de(() => {
      if (!e.highlight)
        return [{ text: e.text, highlight: !1 }];
      const i = new RegExp(`(${r(e.highlight)})`, "gi");
      return e.text.split(i).map((a) => {
        var o;
        return {
          text: a,
          highlight: a.toLowerCase() === ((o = e.highlight) == null ? void 0 : o.toLowerCase())
        };
      });
    });
    function r(i) {
      return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    return (i, s) => i.highlight ? (X(!0), se(wt, { key: 1 }, on(n.value, (a, o) => (X(), se(wt, { key: o }, [
      a.highlight ? (X(), se("span", {
        key: 0,
        class: "text-blue-400",
        textContent: _e(a.text)
      }, null, 8, jGe)) : (X(), se("span", {
        key: 1,
        textContent: _e(a.text)
      }, null, 8, zGe))
    ], 64))), 128)) : (X(), se("span", {
      key: 0,
      textContent: _e(i.text)
    }, null, 8, HGe));
  }
}), qGe = { class: "relative flex items-center justify-center gap-1.5" }, VGe = { class: "relative h-[50px]! w-[50px]! shrink-0" }, WGe = {
  key: 2,
  class: "absolute -right-1 -bottom-1 h-5 w-5 rounded-lg bg-slate-200 p-[3px]",
  src: _Qe
}, QGe = { class: "flex w-0 min-w-0 grow flex-col text-left" }, GGe = { class: "flex justify-between gap-2" }, YGe = { class: "flex flex-1 items-center justify-center gap-1 overflow-hidden" }, XGe = { class: "w-full overflow-hidden text-base text-ellipsis whitespace-nowrap text-gray-900 dark:text-gray-100" }, KGe = {
  key: 0,
  width: "14",
  height: "14",
  class: "mt-0.5",
  src: "https://img.icons8.com/ios-filled/50/4b5563/mute--v1.png",
  alt: "mute--v1"
}, ZGe = { class: "flex-none text-xs whitespace-nowrap text-gray-500 dark:text-gray-300" }, JGe = { class: "text-xs text-gray-500" }, eYe = { class: "overflow-hidden text-sm text-ellipsis whitespace-nowrap text-gray-500 dark:text-gray-400" }, tYe = {
  key: 1,
  class: "mt-1 flex flex-wrap gap-1"
}, nYe = {
  key: 2,
  class: "text-gray-500 dark:text-gray-400"
}, rYe = {
  key: 0,
  class: "absolute top-[calc(50%+28px)] right-3 z-10 flex flex-col items-stretch gap-1 rounded-lg bg-white p-1.5 text-base text-gray-800 shadow-md dark:bg-zinc-800 dark:text-gray-200"
}, iYe = /* @__PURE__ */ Ze({
  __name: "RoomCell",
  props: {
    source: {}
  },
  setup(t) {
    Wn.extend(P_), Wn.extend(SQe);
    const e = t, n = de(() => s.state.imkit.config.settings), r = de(() => s.state.imkit.config.styles), i = de(() => {
      let U = Wn(e.source.updatedAt);
      return U.isSame(Wn(), "day") ? U.format("H:mm") : U.isYesterday() ? "Yesterday" : U.isSame(Wn(), "week") ? U.format("dddd") : U.isSame(Wn(), "year") ? U.format("MMM D") : U.format("ll");
    }), s = Yt(), a = de(() => s.state.imkit.rooms[e.source.id]), o = de(() => {
      if (s.state.imkit.searchKeyword.length > 0 && (s.state.imkit.searchType === Wr.RoomName || s.state.imkit.searchType === Wr.RoomMember))
        return s.state.imkit.searchKeyword;
    }), u = de(() => {
      if (s.state.imkit.searchKeyword.length > 0 && s.state.imkit.searchType === Wr.Messages)
        return s.state.imkit.searchKeyword;
    }), c = de(() => {
      var U;
      return s.state.imkit.searchKeyword.length > 0 && s.state.imkit.searchType === Wr.RoomMember ? [
        `<span class="text-blue-400">${s.state.imkit.searchKeyword}</span>`,
        ...a.value.memberIds.map((V) => s.state.imkit.users[V]).filter((V) => V).map((V) => V.nickname || V.id).filter((V) => V !== s.state.imkit.searchKeyword)
      ].join(", ") : (U = a.value.lastMessage) == null ? void 0 : U.string;
    }), d = de(
      () => s.state.imkit.selectedRoomId === e.source.id
    ), l = de(
      () => !!s.state.imkit.roomIdsInFolders[e.source.id]
    ), f = de(() => s.state.imkit.actionMenuRoomId), p = de(() => s.state.imkit.searchKeyword), m = de(() => {
      var U;
      return ((U = a.value.pref) == null ? void 0 : U.sticky) ?? !1;
    }), g = de(() => {
      var U;
      return ((U = a.value.pref) == null ? void 0 : U.hidden) ?? !1;
    }), y = de(() => s.state.imkit.sortedFolderIds), b = Se(""), E = de(() => {
      var B;
      const U = a.value.roomTags ?? [], V = ((B = a.value.pref) == null ? void 0 : B.tags) ?? [];
      return [...U.filter((R) => R !== b.value), ...V];
    });
    Tr(() => {
      const U = a.value.roomTags ?? [];
      U.length > 0 && (b.value = U[0]);
    });
    const v = () => {
      const { open: U } = Jn({
        component: tGe,
        attrs: {
          roomId: e.source.id,
          roomTag: b.value
        }
      });
      U(), s.commit("imkit/setState", { actionMenuRoomId: "" });
    }, _ = () => {
      f.value === e.source.id ? s.commit("imkit/setState", { actionMenuRoomId: "" }) : s.commit("imkit/setState", { actionMenuRoomId: e.source.id });
    }, D = async () => {
      await s.commit("imkit/setState", {
        selectedRoomId: e.source.id,
        actionMenuRoomId: ""
      });
      const U = !!s.state.imkit.searchKeyword;
      await s.commit("imkit/setState", {
        messageSearchKeyword: U ? s.state.imkit.searchKeyword : "",
        isSearchInRoomMode: U
      });
    }, S = async () => {
      await s.dispatch("imkit/updateRoomPrefs", {
        roomId: e.source.id,
        prefs: {
          sticky: !m.value
        }
      });
    }, M = async () => {
      s.commit("imkit/setState", { actionMenuRoomId: "" }), s.dispatch("imkit/updateRoomPrefs", {
        roomId: e.source.id,
        prefs: {
          hidden: !g.value
        }
      });
    }, O = async () => {
      const { open: U } = Jn({
        component: aGe,
        attrs: {
          roomId: e.source.id
        }
      });
      U();
    }, T = async () => {
      await s.dispatch("imkit/removeRoomFromFolder", e.source.id);
    }, N = async () => {
      const { open: U } = Jn({
        component: lGe,
        attrs: {
          roomId: e.source.id
        }
      });
      U();
    }, H = Se(null);
    n6(H, () => {
      _();
    }, {
      modifiers: { prevent: !0 }
    });
    const j = de(() => s.getters["imkit/roomsInSelectedFolder"]);
    return (U, V) => {
      var B;
      return X(), se("div", qGe, [
        l.value && !p.value ? (X(), se("div", {
          key: 0,
          class: vt(["absolute left-2 h-[120%] w-1 shrink-0 rounded-full bg-slate-500", {
            "mt-4 h-full!": j.value[0].id === e.source.id,
            "mb-4 h-full!": j.value[j.value.length - 1].id === e.source.id
          }])
        }, null, 2)) : Fe("", !0),
        W("div", {
          ref_key: "roomCellRef",
          ref: H,
          class: vt(["group relative flex min-h-[66px] grow cursor-pointer items-center gap-3 rounded-lg p-2 select-none sm:hover:bg-gray-100 sm:hover:dark:bg-zinc-700", {
            "bg-gray-100 dark:bg-zinc-700": d.value,
            "ml-4": l.value && !p.value
          }]),
          onClick: D
        }, [
          W("div", VGe, [
            a.value.avatars.length === 1 ? (X(), gt(Zr, {
              key: 0,
              url: a.value.avatars[0].url,
              name: a.value.avatars[0].name,
              class: "relative"
            }, null, 8, ["url", "name"])) : (X(), se(wt, { key: 1 }, [
              et(Zr, {
                url: a.value.avatars[1].url,
                name: a.value.avatars[1].name,
                class: "absolute top-0 right-0 h-9! w-9! text-base"
              }, null, 8, ["url", "name"]),
              et(Zr, {
                url: a.value.avatars[0].url,
                name: a.value.avatars[0].name,
                class: vt(["absolute bottom-0 left-0 h-[38px]! w-[38px]! border-2 border-white text-base group-hover:border-gray-100 dark:border-zinc-800 group-hover:dark:border-zinc-700", { "border-gray-100": d.value }])
              }, null, 8, ["url", "name", "class"])
            ], 64)),
            m.value ? (X(), se("img", WGe)) : Fe("", !0)
          ]),
          W("div", QGe, [
            W("div", GGe, [
              W("div", YGe, [
                W("div", XGe, [
                  et(Wy, {
                    text: a.value.displayName ?? "",
                    highlight: o.value
                  }, null, 8, ["text", "highlight"])
                ]),
                a.value.muted ? (X(), se("img", KGe)) : Fe("", !0)
              ]),
              W("div", ZGe, _e(i.value), 1)
            ]),
            W("div", JGe, _e(a.value.description), 1),
            n.value.enableReadReceipt ? (X(), se("div", {
              key: 0,
              class: vt(["flex items-center justify-between pt-1", { "text-gray-800": a.value.numberOfUnread > 0 }])
            }, [
              W("div", eYe, [
                et(Wy, {
                  text: c.value ?? "",
                  highlight: u.value
                }, null, 8, ["text", "highlight"])
              ]),
              a.value.numberOfUnread > 0 && !d.value ? (X(), se("div", {
                key: 0,
                class: "flex h-5 min-w-5 items-center justify-center rounded-full bg-blue-400 px-1.5 text-center text-xs leading-none font-semibold text-white",
                style: Qt(r.value.roomListUnreadBadge)
              }, _e(a.value.numberOfUnread > 99 ? "99+" : a.value.numberOfUnread), 5)) : Fe("", !0)
            ], 2)) : Fe("", !0),
            E.value.length > 0 ? (X(), se("div", tYe, [
              (X(!0), se(wt, null, on(E.value, (R) => {
                var K;
                return X(), se("div", {
                  key: R,
                  class: "overflow-hidden rounded-md bg-blue-400 px-1 py-0.5 text-xs text-ellipsis whitespace-nowrap text-white",
                  style: Qt({ backgroundColor: (((K = a.value.pref) == null ? void 0 : K.tagColors) || {})[R] })
                }, _e(R), 5);
              }), 128))
            ])) : Fe("", !0),
            p.value && ke(s).state.imkit.searchType === ke(Wr).Messages ? (X(), se("div", nYe, _e(U.$t("foundMessages", [
              ((B = ke(s).state.imkit.searchedMessageIds.get(U.source.id)) == null ? void 0 : B.length) ?? 0
            ])), 1)) : Fe("", !0)
          ]),
          W("div", {
            class: vt(["absolute right-4 hidden h-8 w-8 items-center justify-center rounded-full bg-white shadow-md hover:scale-110 hover:transform hover:transition sm:group-hover:flex dark:bg-zinc-800", { "flex!": f.value == U.source.id }]),
            onClick: ar(_, ["stop"])
          }, V[1] || (V[1] = [
            W("img", {
              width: "20",
              height: "20",
              src: W9
            }, null, -1)
          ]), 2),
          f.value == U.source.id ? Gt((X(), se("div", rYe, [
            W("div", {
              class: "flex cursor-pointer gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
              onClick: ar(v, ["stop"])
            }, [
              et(xGe, { class: "h-6 w-6" }),
              An(" " + _e(U.$t("tag")), 1)
            ]),
            W("div", {
              class: "flex cursor-pointer gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
              onClick: ar(S, ["stop"])
            }, [
              m.value ? (X(), gt(OGe, {
                key: 0,
                class: "h-6 w-6"
              })) : (X(), gt(IGe, {
                key: 1,
                class: "h-6 w-6"
              })),
              An(" " + _e(m.value ? U.$t("unpin") : U.$t("pin")), 1)
            ]),
            W("div", {
              class: "flex cursor-pointer gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
              onClick: ar(M, ["stop"])
            }, [
              et(vGe, { class: "h-6 w-6" }),
              An(" " + _e(g.value ? U.$t("unhide") : U.$t("hide")), 1)
            ]),
            W("div", {
              class: "flex cursor-pointer gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
              onClick: ar(O, ["stop"])
            }, [
              et(gGe, { class: "h-6 w-6" }),
              An(" " + _e(U.$t("delete")), 1)
            ]),
            l.value ? (X(), se("div", {
              key: 0,
              class: "flex cursor-pointer gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
              onClick: ar(T, ["stop"])
            }, [
              V[2] || (V[2] = W("img", {
                width: "24",
                height: "24",
                src: EQe
              }, null, -1)),
              An(" " + _e(U.$t("removeFromFolder")), 1)
            ])) : y.value.length > 0 ? (X(), se("div", {
              key: 1,
              class: "flex cursor-pointer gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
              onClick: ar(N, ["stop"])
            }, [
              et(Y9, { class: "h-6 w-6" }),
              An(" " + _e(U.$t("addToFolder")), 1)
            ])) : Fe("", !0),
            W("div", {
              class: "flex cursor-pointer gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
              onClick: V[0] || (V[0] = ar(
                () => {
                  ke(s).commit("imkit/setState", { actionMenuRoomId: "" }), ke(s).dispatch("imkit/toggleNotification", e.source.id);
                },
                ["stop"]
              ))
            }, [
              a.value.muted ? (X(), gt($Ge, {
                key: 0,
                class: "h-6 w-6"
              })) : (X(), gt(RGe, {
                key: 1,
                class: "h-6 w-6"
              })),
              An(" " + _e(a.value.muted ? U.$t("unmute") : U.$t("mute")), 1)
            ])
          ])), [
            [
              ke(So),
              () => {
                ke(s).commit("imkit/setState", { actionMenuRoomId: "" });
              }
            ]
          ]) : Fe("", !0)
        ], 2)
      ]);
    };
  }
}), sYe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB60lEQVR4nO2Zzy4EQRCH2wUHJ3F1IeLIwZ9n4B1wE9u9i6rhXLWLo+DGKwiReAESBw/AGxAnJEhcSFZmiUhmd3uYpvVMfcnvXl9qZnp+M0oJgiAIgvAvKeFav0Y6MECPBrmeJhr4SgNvak09KjxZvksrmhBHPq9UdrpUKOh4sz+U/SJNKhTMNy7j1sL0XFqmARUCJqPsnwfoUQMfLSzVhoshjJ/i9/HzpzjC2LiV9gsmzA+FEjbIdRG24XtDsmGUS7ou9zBmeGgJghAWRNRpkHfil2/fZ6izAN1roO3YLSHckPU94C9FI28lhfO02YQw3RZMmO+aCPNhjjd8kBAuAc3mVjjimYQwAPVq4Bffw7kPvc4j9TU9mgzSae62C3zS8iw2SJg74YihpXBlZW3Q94Cus7haG2op/LHlS99DOgvwRVvZhjDwhvdBHUUDrVuFdVSd9D2oq5SBJqzCSqkOg3Tte9jsoZvYJY2w0sB7ORDeTSX7LkzT/gfOlnJUnUotHP/IdvG71GOe5oi61XcIuUw0LQs2Qi4TTcuCjXDLRJuyYCPEMtG2LNgIsUy0LQs2QiwT1rJgwwCf+ZZIHeAzlZVSVB2PzzXvMvY8mWUaUy7QSzRqkI7/5ZfNxkx0XIbaiBNZQRAEQRDUb/EGC4sae12sFiYAAAAASUVORK5CYII=", aYe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAADaUlEQVR4nO2aS2gTURSG4/sBilZxI1grghtBaF0VxKXgq6uKgiiIpJ17k2bOGUVX/neS4mPhQtSFuhUXxZVEW3HlxlU3uqgKrlTEF/jAR+ujlZvpxFaCySQzmUkyB84mZM78H+e/987cuYlEHHHE0TJxGFicsnIdhpXtikJqLVqT76DCtHsEYUSQmpCspqKUgjEuWQ0bpr2nZlApT68SrO6FDVUxPGGECG3Vw5J6GjaEd2j1uCpo0UCdLZHD3mBNuycComtKT2NasrobtuBaUxDuVASrp/kozsaegRnjABaWBTZMbAhbrF/Zl8H68nY20Rm2UN/SRGf5DlvZrtCF+pSGle2Kgf+NuMMcvjVjS3MLjGHBeG+QvV0SRpseWDDGU6a9Tes7cvzcMsl41dTABuGQq08STjV1hwVh0NWWYrtXMiabFlgwbgKYW+isia2S1VdPzrAaCZgwmkxiqdYkrFy7YLz2WsNoHGC87KPBtcVJitTDauoYDQFM+Jyi7Batpbd3aJ5k3Kq2lhF1YEHqt2TsdbVIVhdrqWcEBSxYffIJOuPqEIRUrfWMIIAF421/JrtJkjrhZcko0d1rfztr7xCkfkYUWB0oCjXR79jSKyxGAMzXNfotbPbLMUZAwB8MRncRmrBfMn5UXgNjmQxW6GuTjNWC8MwP2MCApdOhL9qGbg1B2CkY38peS+qdIGwsbh4yHvgFGyiwdMbghH70c+voh31J+Pgf2O8znDFHEq77CRs4sHTs+Usyjs7aECT1psT/JlOEg0VHsLL9hq0TsCrASMYxt54zg+P57O5CFWFN7Ktldo8AsHIszjjr1hwYwDrJeDL9+5C2cOFejG5t7SBg6w4sncnskvu2029hjWRcdT9g64/Zeg0PCjYUYOnY90YyeWXBzHuk01guGI+ChA0PmAvQeaLzS4ovBIR80LDhAnNhGbqvOytZXa4HbPjAXFirX9QLNhLAss5pxMAlIu4wN7mlZat9EE9ZuY7QhfqUwsq1lwVOpy8smj7ON9XQSep7RYdaCrZmNdz4wMgnKg19qCt0wTWmYdm7El5Cb6y1RHfd0Ac09UHN0MV7TowZJ8+sTFQTRGhrqPFMyFcNOzMkY7c+uxjJ2dvZMbntecxWEnrJ0sf5wj7676bWojVVJD6OOOJINEP8AR99+lKlJ3IWAAAAAElFTkSuQmCC", oYe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR4nO2aTU4CQRCFm5W6N7jSiEeAgxjkAO6UmQakaw5QPRCXLlzCRVRAEzd6CfUSSoIrTfET40wbZpA4hdSX1LI7703PvCbhKSUIwtpgzMWW18QDL2iVOEwtaBdI07J95rQJK77Bnm/suwb7wWmmmm60Ccuk9VdOG43zHW3sfdamkg/eVQPML2zWN/iSvYnU87yI6dxqnWz8pFO93tqEFddGvsE3H2xfA3Z9YztZzlgD2D5pcpqefNPJoICKmQV88KC9q5hBmkib43CuE21wjLjpSONXjmZnNBq4Fz1p8lCvX27MXUz3rONp9RRztMFBVHctaBfmL2xi0RECXcUc0hjT3cTi3IX0CyZ+wrajmDMJsu+6vaBVmrtQDIOcMEvklQb5ht1IaIGEFksktEBCy42EFkhosURCCyS03EhogYQWSyS0QELLjYQWSGixREILJLTcSGiBhBZLJLRAQsvN2oWWXrc/xGtBuxAvtNi+Yo5v7G1U9+kZ7q9PqQVwlKjUQoy7i47aEm2sOJoF++joal0l3sQL8OiHlttw0pbhUUybNneGzhJdMzxM8+ByVN9bfiXwj8bgIPWrUg0wT0XNzMWnHN/g0wngdmrDX6ZX6KQNDhY2GymIl6m7yLIgDjiigEr7zSaCriy627Ku/s+GtCS+egRBUP+BT4sLtV3SLOLeAAAAAElFTkSuQmCC", uYe = {
  key: 1,
  class: "relative h-[34px] w-[34px] shrink-0"
}, lYe = { class: "flex w-0 min-w-0 grow flex-col text-left" }, cYe = { class: "overflow-hidden text-sm text-ellipsis whitespace-nowrap text-gray-900 dark:text-gray-300" }, dYe = {
  key: 2,
  width: "20",
  height: "20",
  src: aYe
}, fYe = {
  key: 3,
  width: "20",
  height: "20",
  src: oYe
}, X9 = /* @__PURE__ */ Ze({
  __name: "RoomCell",
  props: {
    source: {}
  },
  setup(t) {
    Wn.extend(P_);
    const e = t, n = Yt(), r = de(
      () => !!n.state.imkit.selectedRoomIdsForCreateFolder[e.source.id]
    ), i = (s) => {
      const a = /* @__PURE__ */ new Date();
      n.commit("imkit/updateField", {
        key: "selectedRoomIdsForCreateFolder",
        value: { [e.source.id]: s ? a : void 0 }
      });
    };
    return (s, a) => (X(), se("div", {
      class: vt(["group relative flex min-h-11 w-full cursor-pointer items-center gap-3 rounded-md p-1 px-2 sm:hover:bg-gray-100 sm:hover:dark:bg-zinc-700", {
        "bg-gray-100 dark:bg-zinc-700 hover:dark:bg-zinc-700": r.value
      }]),
      onClick: a[0] || (a[0] = (o) => i(!r.value))
    }, [
      s.source.avatars.length === 1 ? (X(), gt(Zr, {
        key: 0,
        url: s.source.avatars[0].url,
        name: s.source.avatars[0].name,
        class: "h-[34px]! w-[34px]! shrink-0 rounded-xl text-base"
      }, null, 8, ["url", "name"])) : (X(), se("div", uYe, [
        et(Zr, {
          url: s.source.avatars[1].url,
          name: s.source.avatars[1].name,
          class: "rounded-10px absolute top-0 right-0 h-[26px]! w-[26px]! text-base"
        }, null, 8, ["url", "name"]),
        et(Zr, {
          url: s.source.avatars[0].url,
          name: s.source.avatars[0].name,
          class: vt(["rounded-10px absolute bottom-0 left-0 h-7! w-7! border-2 border-white text-xs group-hover:border-gray-100 dark:border-zinc-800 group-hover:dark:border-zinc-700", { "border-gray-100": r.value }])
        }, null, 8, ["url", "name", "class"])
      ])),
      W("div", lYe, [
        W("div", cYe, _e(s.source.displayName), 1)
      ]),
      r.value ? (X(), se("img", dYe)) : (X(), se("img", fYe))
    ], 2));
  }
}), hYe = { class: "mb-1 flex items-center justify-between text-xl font-medium text-gray-700 dark:text-gray-300" }, pYe = ["placeholder"], mYe = { class: "flex items-center justify-center gap-2" }, gYe = ["disabled"], K9 = /* @__PURE__ */ Ze({
  __name: "UpdateFolderModal",
  props: {
    folderId: {}
  },
  setup(t) {
    const e = $n(), n = t, r = Yt(), i = Se(), s = Se(""), a = de(() => i.value ? i.value.roomIds.map((c) => r.state.imkit.rooms[c]).concat(r.state.imkit.sortedRooms).sort(
      (c, d) => {
        var l, f, p;
        return ((l = c.pref) == null ? void 0 : l.sticky) === ((f = d.pref) == null ? void 0 : f.sticky) ? d.updatedAt - c.updatedAt : (p = c.pref) != null && p.sticky ? -1 : 1;
      }
    ) : r.state.imkit.sortedRooms), o = de(
      () => s.value.length > 0 && Object.keys(r.state.imkit.selectedRoomIdsForCreateFolder).length > 0
    ), u = () => {
      var c;
      r.dispatch("imkit/updateFolder", {
        folderKey: ((c = i.value) == null ? void 0 : c.id) || `folder_${Date.now()}`,
        name: s.value
      });
    };
    return i.value = r.state.imkit.folders[n.folderId], i.value && (s.value = i.value.name, r.commit("imkit/setState", {
      selectedRoomIdsForCreateFolder: i.value.roomIds.reduce(
        (c, d) => (c[d] = !0, c),
        {}
      )
    })), (c, d) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col gap-3 w-[360px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", hYe, _e(i.value ? c.$t("editFolder") : c.$t("createFolder")), 1),
        Gt(W("input", {
          "onUpdate:modelValue": d[0] || (d[0] = (l) => s.value = l),
          type: "text",
          class: "grow rounded-md bg-gray-100 p-2 placeholder-gray-400 outline-none dark:bg-zinc-700",
          placeholder: c.$t("folderName")
        }, null, 8, pYe), [
          [ds, s.value]
        ]),
        et(ke(z0), {
          class: "h-[50vh] overflow-auto",
          "data-key": "id",
          "data-sources": a.value,
          "data-component": X9,
          "wrap-class": "flex flex-col gap-1.5",
          "estimated-size": 44
        }, null, 8, ["data-sources"]),
        W("div", mYe, [
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 grow rounded-lg border border-gray-200 text-base text-gray-800 dark:border-stone-400 dark:text-stone-400",
            onClick: d[1] || (d[1] = () => {
              ke(e).closeAll();
            })
          }, _e(c.$t("cancel")), 1),
          W("button", {
            class: vt(["h-10 grow rounded-lg bg-blue-400 text-base text-white", { "cursor-not-allowed bg-gray-400!": !o.value }]),
            disabled: !o.value,
            onClick: d[2] || (d[2] = () => {
              u(), ke(e).closeAll();
            })
          }, _e(c.$t("confirm")), 11, gYe)
        ])
      ]),
      _: 1
    }));
  }
}), AYe = { class: "mb-1 flex items-center justify-between text-xl font-medium text-gray-700 dark:text-gray-300" }, bYe = { class: "flex items-center justify-center gap-2" }, yYe = /* @__PURE__ */ Ze({
  __name: "DeleteFolderConfirmModal",
  props: {
    folder: {}
  },
  setup(t) {
    const e = $n(), n = t, r = Yt(), i = (s) => {
      r.dispatch("imkit/removeFolder", s);
    };
    return (s, a) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 min-w-[200px] max-w-full rounded-xl p-5 flex flex-col gap-3 max-w-[360px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", AYe, _e(s.$t("confirmToDeleteFolder")), 1),
        W("div", bYe, [
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 w-[100px] grow rounded-lg border border-gray-200 text-base dark:border-stone-400 dark:text-stone-400",
            onClick: a[0] || (a[0] = () => {
              ke(e).closeAll();
            })
          }, _e(s.$t("cancel")), 1),
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 w-[100px] grow rounded-lg bg-blue-400 text-base text-white",
            onClick: a[1] || (a[1] = () => {
              i(n.folder.id), ke(e).closeAll();
            })
          }, _e(s.$t("confirm")), 1)
        ])
      ]),
      _: 1
    }));
  }
}), vYe = {
  key: 0,
  width: "30",
  height: "30",
  src: sYe
}, TYe = {
  key: 1,
  width: "30",
  height: "30",
  src: G9
}, _Ye = { class: "flex flex-col overflow-hidden" }, EYe = { class: "text-basse overflow-hidden text-ellipsis whitespace-nowrap text-gray-900 dark:text-gray-100" }, xYe = { class: "overflow-hidden text-sm text-ellipsis whitespace-nowrap text-gray-500 dark:text-gray-400" }, wYe = {
  key: 2,
  class: "ml-auto flex h-5 min-w-5 items-center justify-center rounded-full bg-blue-400 text-center text-xs leading-none font-semibold text-white"
}, CYe = /* @__PURE__ */ Ze({
  __name: "FolderCell",
  props: {
    source: {}
  },
  setup(t) {
    const e = t, n = Yt(), r = de(() => {
      if (n.state.imkit.searchKeyword.length > 0 && n.state.imkit.searchType === Wr.RoomPrefFolder)
        return n.state.imkit.searchKeyword;
    }), i = de(() => n.state.imkit.selectedFolderId), s = de(() => e.source.roomIds.filter((l) => n.state.imkit.selectedRoomId !== l).reduce((l, f) => {
      const p = n.state.imkit.rooms[f];
      return p ? l + p.numberOfUnread : l;
    }, 0)), a = de(() => n.state.imkit.roomTag), o = de(() => e.source.roomIds.map((l) => n.state.imkit.rooms[l]).filter((l) => a.value ? l && l.roomTags.includes(a.value) : l).length), u = () => {
      n.state.imkit.selectedFolderId === e.source.id ? n.commit("imkit/setState", { selectedFolderId: "" }) : n.commit("imkit/setState", { selectedFolderId: e.source.id });
    }, c = () => {
      const { open: l } = Jn({
        component: yYe,
        attrs: {
          folder: e.source
        }
      });
      l();
    }, d = () => {
      const { open: l } = Jn({
        component: K9,
        attrs: {
          folderId: e.source.id
        }
      });
      l();
    };
    return (l, f) => (X(), se("div", {
      class: "group relative flex min-h-[66px] cursor-pointer items-center gap-3 rounded-lg bg-slate-200 p-2 dark:bg-slate-700",
      onClick: u
    }, [
      i.value === l.source.id ? (X(), se("img", vYe)) : (X(), se("img", TYe)),
      W("div", _Ye, [
        W("div", EYe, [
          et(Wy, {
            text: l.source.name,
            highlight: r.value
          }, null, 8, ["text", "highlight"])
        ]),
        W("div", xYe, _e(o.value ? l.$t("numberOfChatroom", o.value) : l.$t("no-chatroom")), 1)
      ]),
      s.value > 0 ? (X(), se("div", wYe, _e(s.value), 1)) : Fe("", !0),
      W("div", {
        class: "hover:(scale-110 !flex) absolute right-14 hidden h-8 w-8 transform items-center justify-center rounded-full bg-white shadow-md transition group-hover:flex dark:bg-zinc-800",
        onClick: ar(d, ["stop"])
      }, f[0] || (f[0] = [
        W("img", {
          width: "20",
          height: "20",
          src: "https://img.icons8.com/ios-glyphs/30/637289/pencil--v1.png"
        }, null, -1)
      ])),
      W("div", {
        class: "hover:(scale-110 !flex) absolute right-4 hidden h-8 w-8 transform items-center justify-center rounded-full bg-white shadow-md transition group-hover:flex dark:bg-zinc-800",
        onClick: ar(c, ["stop"])
      }, f[1] || (f[1] = [
        W("img", {
          width: "20",
          height: "20",
          src: Q9
        }, null, -1)
      ]))
    ]));
  }
}), SYe = /* @__PURE__ */ Ze({
  __name: "RoomListWrapperCell",
  props: {
    source: {}
  },
  setup(t) {
    return (e, n) => e.source instanceof ke(hm) ? (X(), gt(iYe, {
      key: 0,
      source: e.source
    }, null, 8, ["source"])) : (X(), gt(CYe, {
      key: 1,
      source: e.source
    }, null, 8, ["source"]));
  }
}), IYe = { class: "mb-1 flex items-center justify-between text-xl font-medium text-gray-700 dark:text-gray-300" }, kYe = ["placeholder"], DYe = { class: "mb-2 flex h-12 items-center gap-2 rounded-lg bg-gray-100 p-3 dark:bg-zinc-700" }, MYe = { class: "grow overflow-hidden" }, OYe = ["placeholder"], NYe = {
  key: 0,
  class: "flex flex-col gap-1"
}, LYe = { class: "flex items-center justify-center gap-2" }, PYe = ["disabled"], RYe = /* @__PURE__ */ Ze({
  __name: "MassTextingModal",
  setup(t) {
    const e = $n(), n = Yt(), r = Se(""), i = de(() => n.state.imkit.searchKeyword ? n.state.imkit.searchRooms[Wr.RoomName] || [] : Object.values(n.state.imkit.rooms).sort(
      (p, m) => {
        const g = !!n.state.imkit.selectedRoomIdsForCreateFolder[p.id], y = !!n.state.imkit.selectedRoomIdsForCreateFolder[m.id];
        return g && !y ? -1 : !g && y ? 1 : g && y ? n.state.imkit.selectedRoomIdsForCreateFolder[p.id] - n.state.imkit.selectedRoomIdsForCreateFolder[m.id] : 0;
      }
    )), s = de(() => r.value.length > 0), a = Se(""), o = Se(!1), c = Lh(1e3, async () => {
      a.value !== n.state.imkit.searchKeyword && (a.value ? n.dispatch("imkit/searchRooms", a.value) : n.commit("imkit/setState", {
        searchKeyword: ""
      }));
    }), d = x_(500, c, {
      atBegin: !1
    });
    Ct(a, d);
    const l = de(
      () => !!n.state.imkit.isRequesting[Da.Search]
    ), f = async () => {
      await n.dispatch("imkit/batchSendMessage", {
        message: r.value,
        messageType: "text",
        paras: Object.keys(n.state.imkit.selectedRoomIdsForCreateFolder).map(
          (p) => ({
            room: p
          })
        )
      }), n.commit("imkit/setState", {
        selectedRoomIdsForCreateFolder: {},
        searchKeyword: ""
      });
    };
    return (p, m) => (X(), gt(ke(pr), {
      class: "flex items-center justify-center",
      "content-class": "bg-white dark:bg-zinc-800 rounded-xl p-5 flex flex-col gap-3 w-[360px]",
      "content-transition": "vfm-fade",
      "overlay-transition": "vfm-fade"
    }, {
      default: Zt(() => [
        W("div", IYe, _e(p.$t("massTexting")), 1),
        Gt(W("textarea", {
          "onUpdate:modelValue": m[0] || (m[0] = (g) => r.value = g),
          rows: "3",
          class: "grow rounded-md bg-gray-100 p-2 placeholder-gray-400 outline-hidden dark:bg-zinc-700",
          placeholder: p.$t("inputMessage")
        }, null, 8, kYe), [
          [ds, r.value]
        ]),
        et(ke(z0), {
          class: "h-[50vh] overflow-auto",
          "data-key": "id",
          "data-sources": i.value,
          "data-component": X9,
          "wrap-class": "flex flex-col gap-1.5",
          "estimated-size": 44
        }, {
          header: Zt(() => [
            W("div", DYe, [
              m[7] || (m[7] = W("img", {
                class: "h-6 w-6 cursor-pointer",
                src: H0
              }, null, -1)),
              W("div", MYe, [
                Gt(W("input", {
                  ref: "searchInput",
                  "onUpdate:modelValue": m[1] || (m[1] = (g) => a.value = g),
                  class: "bg-gray-100 placeholder-gray-400 outline-hidden dark:bg-zinc-700",
                  placeholder: p.$t("search"),
                  onCompositionstart: m[2] || (m[2] = (g) => o.value = !0),
                  onCompositionend: m[3] || (m[3] = (g) => o.value = !1)
                }, null, 40, OYe), [
                  [ds, a.value]
                ])
              ]),
              a.value ? (X(), se("img", {
                key: 0,
                src: Kg,
                class: "h-5 w-5 cursor-pointer",
                onClick: m[4] || (m[4] = () => {
                  ke(d).cancel({ upcomingOnly: !0 }), a.value = "", ke(c)();
                })
              })) : Fe("", !0)
            ]),
            l.value ? (X(), se("div", NYe, [
              (X(), se(wt, null, on(10, (g) => W("div", {
                key: g,
                class: "flex gap-3 p-2"
              }, m[8] || (m[8] = [
                W("div", { class: "loading h-[34px] w-[34px] rounded-xl" }, null, -1),
                W("div", { class: "flex grow flex-col justify-center gap-2" }, [
                  W("div", { class: "loading h-3 w-full rounded-md" }),
                  W("div", { class: "loading h-3 w-4/5 rounded-md" })
                ], -1)
              ]))), 64))
            ])) : Fe("", !0)
          ]),
          _: 1
        }, 8, ["data-sources"]),
        W("div", LYe, [
          W("button", {
            class: "disabled:(bg-blue-200 cursor-not-allowed) h-10 grow rounded-lg border border-gray-200 text-base dark:border-stone-400 dark:text-stone-400",
            onClick: m[5] || (m[5] = () => {
              ke(e).closeAll();
            })
          }, _e(p.$t("cancel")), 1),
          W("button", {
            class: vt(["h-10 grow rounded-lg bg-blue-400 text-base text-white", { "cursor-not-allowed bg-gray-400!": !s.value }]),
            disabled: !s.value,
            onClick: m[6] || (m[6] = () => {
              f(), ke(e).closeAll();
            })
          }, _e(p.$t("confirm")), 11, PYe)
        ])
      ]),
      _: 1
    }));
  }
}), BYe = /* @__PURE__ */ mn(RYe, [["__scopeId", "data-v-ae53c7ba"]]), FYe = {}, UYe = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 50 50",
  class: "fill-slate-700 dark:fill-slate-300"
};
function $Ye(t, e) {
  return X(), se("svg", UYe, e[0] || (e[0] = [
    W("g", null, [
      W("path", { d: "M17.005,15.005H7c-2.754,0-4.995,2.241-4.995,4.995v5c0,2.754,2.241,4.995,4.995,4.995h10.005V15.005z" }),
      W("path", { d: "M17.837,40.925c-0.271-0.427-0.704-2.805-0.812-8.93h-0.02H7c-0.123,0-0.243-0.012-0.364-0.018c1.13,3.08,2.197,8.651,2.97,12.7c0.157,0.822,0.635,3.323,3.84,3.323h3.335C19.441,47.999,20,46.368,20,45C20,43.223,19.001,42.08,17.837,40.925z" }),
      W("g", null, [
        W("path", { d: "M39.852,1.999c-1.485,0-2.395,1.359-3.655,3.241c-2.371,3.542-6.314,9.383-17.202,9.727v15.061c11.029,0.298,14.808,6.388,17.316,10.462C37.564,42.528,38.47,44,40.074,44C41.378,44,43,44,43,23C43,1.999,41.029,1.999,39.852,1.999z" }),
        W("path", { d: "M44.977,19.289C44.992,20.467,45,21.699,45,23c0,1.691-0.011,3.263-0.031,4.734c1.752-0.6,2.984-2.2,2.984-4.149C47.954,21.604,46.707,19.928,44.977,19.289z" })
      ])
    ], -1)
  ]));
}
const HYe = /* @__PURE__ */ mn(FYe, [["render", $Ye]]), jYe = { class: "relative overflow-auto" }, zYe = { class: "flex items-center" }, qYe = { class: "mb-2 flex h-12 items-center gap-2 rounded-lg bg-gray-100 p-3 dark:bg-zinc-700" }, VYe = { class: "grow overflow-hidden" }, WYe = ["placeholder"], QYe = {
  key: 0,
  class: "mb-2 flex items-center gap-2 overflow-auto text-sm text-gray-900 dark:text-gray-200"
}, GYe = ["onClick"], YYe = {
  key: 1,
  class: "flex flex-col gap-1"
}, XYe = { class: "absolute right-0 bottom-0 flex flex-col items-end gap-2 p-3" }, KYe = {
  key: 0,
  class: "transform-gpu flex-col items-stretch gap-1 rounded-lg bg-white p-1.5 text-base text-gray-800 shadow-md dark:bg-zinc-800 dark:text-gray-200"
}, ZYe = /* @__PURE__ */ Ze({
  __name: "RoomList",
  setup(t) {
    const e = Yt(), n = Se(""), r = $n(), i = Se(!1), s = Se(), a = de(() => e.state.imkit.sortedRooms), o = de(
      () => e.state.imkit.sortedFolderIds.map((H) => e.state.imkit.folders[H]).filter((H) => H)
    ), u = de(() => e.state.imkit.folders[e.state.imkit.selectedFolderId]), c = de(() => e.state.imkit.searchType), d = de(() => e.state.imkit.searchKeyword ? Object.keys(e.state.imkit.searchRooms) : []), l = de(() => e.state.imkit.roomTag), f = de(() => e.state.imkit.config.settings), p = de(() => {
      if (e.state.imkit.searchKeyword && r.modals.length === 0) {
        if (c.value === Wr.RoomPrefFolder && u.value) {
          const $ = [...e.state.imkit.searchRooms[c.value]], j = u.value.roomIds.map((V) => e.state.imkit.rooms[V]).filter((V) => l.value ? V && V.roomTags.includes(l.value) : V), U = $.findIndex(
            (V) => V.id === u.value.id
          );
          return U > -1 && $.splice(U + 1, 0, ...j), $;
        }
        return e.state.imkit.searchRooms[c.value] || [];
      }
      const H = [...o.value, ...a.value];
      if (u.value) {
        const $ = e.getters["imkit/roomsInSelectedFolder"], j = o.value.findIndex(
          (U) => U.id === u.value.id
        );
        j > -1 && H.splice(j + 1, 0, ...$);
      }
      return H;
    }), m = Se(!1), g = Se(!1), y = Se(!1), b = de(
      () => r.modals.length === 0 && (i.value || m.value || y.value && n.value.length > 0)
    ), E = () => {
      e.dispatch("imkit/fetchRooms");
    }, v = () => {
      g.value = !g.value;
    }, _ = () => {
      const { open: H } = Jn({
        component: K9
      });
      H();
    }, D = () => {
      const { open: H } = Jn({
        component: BYe
      });
      H();
    }, M = Lh(1e3, async () => {
      if (n.value !== e.state.imkit.searchKeyword)
        if (n.value) {
          y.value = !0;
          try {
            await e.dispatch("imkit/searchRooms", n.value);
          } finally {
            y.value = !1;
          }
        } else
          e.commit("imkit/setState", {
            sortedRooms: [],
            numberOfFetchedRooms: 0,
            numberOfTotalRooms: 0,
            folders: {},
            sortedFolderIds: [],
            roomIdsInFolders: {},
            searchKeyword: ""
          }), T();
    }), O = x_(500, M, {
      atBegin: !1
    });
    Ct(n, O), Ct(a, (H) => {
      if (H.length !== 0 && f.value.autoSelectRoomWhenLoaded && !e.state.imkit.selectedRoomId && document.body.clientWidth > 640)
        if (f.value.enableReadReceipt) {
          const $ = Object.values(H).find(
            (j) => j.numberOfUnread === 0
          );
          $ && e.commit("imkit/setState", { selectedRoomId: $.id });
        } else {
          const $ = H[0];
          $ && e.commit("imkit/setState", { selectedRoomId: $.id });
        }
    });
    const T = async () => {
      m.value = !0;
      try {
        await e.dispatch("imkit/fetchPrefs"), await e.dispatch("imkit/fetchRooms");
      } finally {
        m.value = !1;
      }
      await e.dispatch("imkit/fetchRoomsInFolders");
    };
    let N = 0;
    return Tr(() => {
      T(), document.addEventListener("visibilitychange", () => {
        document.hidden ? N = Wn().unix() : Wn().unix() - N > 60 && (T(), e.state.imkit.socket.connect());
      });
    }), (H, $) => (X(), se("div", jYe, [
      et(ke(z0), {
        class: "h-full overflow-auto p-2 transition ease-in-out",
        "data-key": "id",
        "data-sources": p.value,
        "data-component": SYe,
        "wrap-class": "flex flex-col gap-1.5",
        "estimated-size": 66,
        keeps: 60,
        onTobottom: E
      }, {
        header: Zt(() => [
          W("div", zYe, [
            $[6] || ($[6] = W("a", {
              href: "/dashboard",
              class: "mr-2"
            }, [
              W("img", {
                class: "mb-2cursor-pointer",
                src: vQe,
                width: "150"
              })
            ], -1)),
            W("div", qYe, [
              $[5] || ($[5] = W("img", {
                class: "h-6 w-6 cursor-pointer",
                src: H0
              }, null, -1)),
              W("div", VYe, [
                Gt(W("input", {
                  ref_key: "searchInput",
                  ref: s,
                  "onUpdate:modelValue": $[0] || ($[0] = (j) => n.value = j),
                  class: "w-full bg-gray-100 placeholder-gray-400 outline-none dark:bg-zinc-700",
                  placeholder: H.$t("search"),
                  onCompositionstart: $[1] || ($[1] = (j) => i.value = !0),
                  onCompositionend: $[2] || ($[2] = (j) => i.value = !1),
                  onBlur: $[3] || ($[3] = (j) => i.value = !1)
                }, null, 40, WYe), [
                  [ds, n.value]
                ])
              ]),
              n.value ? (X(), se("img", {
                key: 0,
                src: Kg,
                class: "h-5 w-5 cursor-pointer",
                onClick: $[4] || ($[4] = () => {
                  ke(O).cancel({ upcomingOnly: !0 }), n.value = "", ke(M)();
                })
              })) : Fe("", !0)
            ])
          ]),
          d.value.length > 0 && ke(r).modals.length === 0 ? (X(), se("div", QYe, [
            (X(!0), se(wt, null, on(d.value, (j) => (X(), se("div", {
              key: j,
              class: vt(["cursor-pointer rounded-lg p-2 whitespace-nowrap hover:bg-gray-100 hover:dark:bg-white hover:dark:text-gray-900", {
                "bg-gray-100 font-medium text-gray-800": j === c.value
              }]),
              onClick: (U) => ke(e).commit("imkit/setState", {
                searchType: j
              })
            }, _e(H.$t(j)), 11, GYe))), 128))
          ])) : Fe("", !0),
          b.value ? (X(), se("div", YYe, [
            (X(), se(wt, null, on(20, (j) => W("div", {
              key: j,
              class: "flex gap-3 p-2"
            }, $[7] || ($[7] = [
              W("div", { class: "loading h-[50px] w-[50px] rounded-2xl bg-white dark:bg-zinc-800" }, null, -1),
              W("div", { class: "flex grow flex-col justify-center gap-2" }, [
                W("div", { class: "loading h-5 w-full rounded-md bg-white dark:bg-zinc-800" }),
                W("div", { class: "loading h-4 w-4/5 rounded-md bg-white dark:bg-zinc-800" })
              ], -1)
            ]))), 64))
          ])) : Fe("", !0)
        ]),
        _: 1
      }, 8, ["data-sources"]),
      Gt((X(), se("div", XYe, [
        et(Lu, { name: "slide-fade" }, {
          default: Zt(() => [
            g.value ? (X(), se("div", KYe, [
              f.value.massTextingEnabled ? (X(), se("div", {
                key: 0,
                class: "flex cursor-pointer items-center justify-start gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
                onClick: D
              }, [
                et(HYe, { class: "h-6 w-6" }),
                An(" " + _e(H.$t("massTexting")), 1)
              ])) : Fe("", !0),
              W("div", {
                class: "flex cursor-pointer items-center justify-start gap-2 rounded p-2 hover:bg-gray-100 hover:dark:bg-zinc-700",
                onClick: _
              }, [
                et(Y9, { class: "h-6 w-6" }),
                An(" " + _e(H.$t("createFolder")), 1)
              ])
            ])) : Fe("", !0)
          ]),
          _: 1
        }),
        W("button", {
          class: "flex h-12 w-12 cursor-pointer items-center justify-center rounded-full bg-slate-500 shadow-md hover:scale-110 hover:transform hover:transition sm:group-hover:flex",
          onClick: ar(v, ["stop"])
        }, $[8] || ($[8] = [
          W("img", {
            width: "30",
            height: "30",
            src: TQe
          }, null, -1)
        ]))
      ])), [
        [
          ke(So),
          () => {
            g.value = !1;
          }
        ]
      ])
    ]));
  }
}), qXe = /* @__PURE__ */ mn(ZYe, [["__scopeId", "data-v-212fdf74"]]);
function QS(t) {
  var e, n, r;
  return t.type.indexOf("mouse") !== -1 ? t.clientX : (r = (n = (e = t.touches) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0 ? void 0 : n.clientX) !== null && r !== void 0 ? r : 0;
}
function GS(t) {
  var e, n, r;
  return t.type.indexOf("mouse") !== -1 ? t.clientY : (r = (n = (e = t.touches) === null || e === void 0 ? void 0 : e[0]) === null || n === void 0 ? void 0 : n.clientY) !== null && r !== void 0 ? r : 0;
}
(function() {
  let t = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        return t = !0, !0;
      }
    });
    window.addEventListener("test", null, e);
  } catch {
  }
  return t;
})();
const JYe = {
  install(t, e) {
    var n = Object.assign({}, {
      // CORE
      touchClass: "",
      namespace: "touch",
      // CLICK/TAP
      disableClick: !1,
      tapTolerance: 10,
      // px
      touchHoldTolerance: 400,
      // ms
      longTapTimeInterval: 400,
      // ms
      rollOverFrequency: 100,
      // ms
      // DRAG
      dragFrequency: 10,
      // ms
      dragOutside: !1,
      // SWIPE
      swipeTolerance: 100,
      // px
      swipeConeSize: 0.75,
      // number between 0 to 1
      // ZOOM
      zoomFrequency: 10,
      // ms
      zoomDistance: 10,
      // px
      zoomInOutDistance: 100
      // px
      // NOTE: When adding props here, update `index.d.ts` as well!!
    }, e);
    function r(v) {
      var _ = this.$$touchObj, D = v.type.indexOf("touch") >= 0, S = v.type.indexOf("mouse") >= 0, M = this;
      D && (_.lastTouchStartTime = v.timeStamp), !(S && _.lastTouchStartTime && v.timeStamp - _.lastTouchStartTime < 350) && (_.touchStarted || (p(this), _.touchStarted = !0, _.touchMoved = !1, _.swipeOutBounded = !1, _.isZooming = !1, _.startX = QS(v), _.startY = GS(v), _.currentX = 0, _.currentY = 0, _.touchStartTime = v.timeStamp, _.hasSwipe = l(_, "swipe") || l(_, "swipe.left") || l(_, "swipe.right") || l(_, "swipe.top") || l(_, "swipe.bottom"), _.hasZoom = l(_, "zoom") || l(_, "zoom.in") || l(_, "zoom.out"), l(_, "hold") && (_.touchHoldTimer = setTimeout(function() {
        _.touchHoldTimer = null, f(v, M, "hold");
      }, _.options.touchHoldTolerance)), f(v, this, "press")));
    }
    function i(v) {
      var _ = this.$$touchObj;
      if (_.touchStarted == !0)
        s(v, _, !1);
      else if (l(_, "rollover") && v.clientX != null) {
        var D = v;
        const S = _.element.getBoundingClientRect();
        D.clientX >= S.left && D.clientX <= S.right && D.clientY >= S.top && D.clientY <= S.bottom && s(v, _, !0);
      }
    }
    function s(v, _ = null, D = !1) {
      _ == null && (_ = this.$$touchObj);
      var S = QS(v), M = GS(v), O = _.currentX != S || _.currentY != M;
      if (_.currentX = S, _.currentY = M, !D)
        if (_.touchMoved) {
          if (_.hasSwipe && !_.swipeOutBounded) {
            var N = _.options.swipeTolerance;
            Math.abs(_.startX - _.currentX) / Math.abs(_.startY - _.currentY) > _.options.swipeConeSize && Math.abs(_.startY - _.currentY) / Math.abs(_.startX - _.currentX) > _.options.swipeConeSize && (_.swipeOutBounded = Math.abs(_.startY - _.currentY) < N && Math.abs(_.startX - _.currentX) < N);
          }
        } else {
          var T = _.options.tapTolerance;
          _.touchMoved = Math.abs(_.startX - _.currentX) > T || Math.abs(_.startY - _.currentY) > T, _.touchMoved && (g(_), f(v, _.element, "drag.once"));
        }
      if (O && l(_, "rollover")) {
        var H = v.timeStamp;
        (_.touchRollTime == null || H > _.touchRollTime + _.options.rollOverFrequency) && (_.touchRollTime = H, f(v, _.element, "rollover"));
      }
      if (!D) {
        if (_.touchStarted && _.touchMoved && O && l(_, "drag")) {
          var H = v.timeStamp;
          (_.touchDragTime == null || H > _.touchDragTime + _.options.dragFrequency) && (_.touchDragTime = H, f(v, _.element, "drag"));
        }
        if (_.touchStarted && _.hasZoom) {
          var H = v.timeStamp;
          (_.touchZoomTime == null || H > _.touchZoomTime + _.options.zoomFrequency) && (_.touchZoomTime = H, a(_, v));
        }
      }
    }
    function a(v, _) {
      const D = _.changedTouches;
      if (D.length !== 2) {
        v.isZooming = !1;
        return;
      }
      const S = Math.sqrt(
        Math.pow(D[0].clientX - D[1].clientX, 2) + // horizontal distance
        Math.pow(D[0].clientY - D[1].clientY, 2)
        // vertical distance
      );
      if (!v.isZooming) {
        v.isZooming = !0, v.initialZoomDistance = S;
        return;
      }
      const M = S / v.initialZoomDistance;
      l(v, "zoom") && Math.abs(M - 1) > v.options.zoomDistance / v.initialZoomDistance && f(_, v.element, "zoom", M), (l(v, "zoom.in") || l(v, "zoom.out")) && Math.abs(S - v.initialZoomDistance) > v.options.zoomInOutDistance && (S > v.initialZoomDistance ? f(_, v.element, "zoom.in") : f(_, v.element, "zoom.out")), v.isZooming = !1;
    }
    function o() {
      var v = this.$$touchObj;
      v.touchStarted == !0 && (g(v), m(this), v.touchStarted = v.touchMoved = !1, v.startX = v.startY = 0);
    }
    function u(v) {
      var _ = this.$$touchObj;
      if (_.touchStarted == !0) {
        var D = v.type.indexOf("touch") >= 0, S = v.type.indexOf("mouse") >= 0;
        D && (_.lastTouchEndTime = v.timeStamp);
        var M = D && !_.touchHoldTimer;
        if (g(_), _.touchStarted = !1, m(this), S && _.lastTouchEndTime && v.timeStamp - _.lastTouchEndTime < 350)
          return;
        if (f(v, this, "release"), _.touchMoved) {
          if (_.hasSwipe && !_.swipeOutBounded) {
            var O = _.options.swipeTolerance, T, N = Math.abs(_.startY - _.currentY), H = Math.abs(_.startX - _.currentX);
            (N > O || H > O) && (H > O ? T = _.startX > _.currentX ? "left" : "right" : T = _.startY > _.currentY ? "top" : "bottom", l(_, "swipe." + T) ? f(v, this, "swipe." + T, T) : f(v, this, "swipe", T));
          }
        } else if (l(_, "longtap") && v.timeStamp - _.touchStartTime > _.options.longTapTimeInterval)
          v.cancelable && v.preventDefault(), f(v, this, "longtap");
        else if (l(_, "hold") && M) {
          v.cancelable && v.preventDefault();
          return;
        } else
          f(v, this, "tap");
      }
    }
    function c() {
      p(this);
    }
    function d() {
      m(this);
    }
    function l(v, _) {
      var D = v.callbacks[_];
      return D != null && D.length > 0;
    }
    function f(v, _, D, S) {
      var M = _.$$touchObj, O = M.callbacks[D];
      if (O == null || O.length === 0)
        return null;
      for (var T = 0; T < O.length; T++) {
        var N = O[T];
        N.modifiers.stop && v.stopPropagation(), N.modifiers.prevent && v.preventDefault(), !(N.modifiers.self && v.target !== v.currentTarget) && typeof N.value == "function" && (S ? N.value(S, v) : N.value(v));
      }
    }
    function p(v) {
      var _ = v.$$touchObj.options.touchClass;
      _ && v.classList.add(_);
    }
    function m(v) {
      var _ = v.$$touchObj.options.touchClass;
      _ && v.classList.remove(_);
    }
    function g(v) {
      v && v.touchHoldTimer && (clearTimeout(v.touchHoldTimer), v.touchHoldTimer = null);
    }
    function y(v, _) {
      var D = v.$$touchObj || {
        element: v,
        // an object contains all callbacks registered,
        // key is event name, value is an array
        callbacks: {},
        // prevent bind twice, set to true when event bound
        hasBindTouchEvents: !1,
        // default options, would be override by v-touch-options
        options: n,
        events: {}
      };
      return _ && (D.options = Object.assign({}, D.options, _)), v.$$touchObj = D, v.$$touchObj;
    }
    function b(v) {
      for (const _ in v)
        if (v.hasOwnProperty(_)) {
          const [D, S] = v[_];
          D.addEventListener(_, S);
        }
    }
    function E(v) {
      for (const _ in v)
        if (v.hasOwnProperty(_)) {
          const [D, S] = v[_];
          D.removeEventListener(_, S);
        }
    }
    t.directive(n.namespace, {
      beforeMount: function(v, _) {
        var D = y(v), S = _.arg || "tap";
        switch (S) {
          case "swipe":
            var M = _.modifiers;
            if (M.left || M.right || M.top || M.bottom) {
              for (var O in _.modifiers)
                if (["left", "right", "top", "bottom"].indexOf(O) >= 0) {
                  var T = "swipe." + O;
                  D.callbacks[T] = D.callbacks[T] || [], D.callbacks[T].push(_);
                }
            } else
              D.callbacks.swipe = D.callbacks.swipe || [], D.callbacks.swipe.push(_);
            break;
          case "press":
          case "drag":
            _.modifiers.disablePassive;
          default:
            D.callbacks[S] = D.callbacks[S] || [], D.callbacks[S].push(_);
        }
        D.hasBindTouchEvents || (D.options.dragOutside ? (D.events.touchstart = [v, r], D.events.touchmove = [window, i.bind(v)], D.events.touchcancel = [window, o.bind(v)], D.events.touchend = [window, u.bind(v)]) : (D.events.touchstart = [v, r], D.events.touchmove = [v, i], D.events.touchcancel = [v, o], D.events.touchend = [v, u]), D.options.disableClick || (D.options.dragOutside ? (D.events.mousedown = [v, r], D.events.mousemove = [window, i.bind(v)], D.events.mouseup = [window, u.bind(v)], D.events.mouseenter = [v, c], D.events.mouseleave = [v, d]) : (D.events.mousedown = [v, r], D.events.mousemove = [v, s], D.events.mouseup = [v, u], D.events.mouseenter = [v, c], D.events.mouseleave = [v, d])), b(D.events), D.hasBindTouchEvents = !0);
      },
      unmounted: function(v) {
        var _ = v.$$touchObj;
        g(_), _ && _.events && (E(_.events), _.events = {}), delete v.$$touchObj;
      }
    }), t.directive(`${n.namespace}-class`, {
      beforeMount: function(v, _) {
        y(v, {
          touchClass: _.value
        });
      }
    }), t.directive(`${n.namespace}-options`, {
      beforeMount: function(v, _) {
        y(v, _.value);
      }
    });
  }
};
function Jp(t, e, n) {
  const { url: r } = e, i = r == null ? void 0 : r.split("?")[0];
  if (!i) return;
  const s = {};
  s[i] = t == 0 ? /* @__PURE__ */ new Date() : null, n.commit("imkit/updateField", {
    key: "isRequesting",
    value: s
  });
}
const eXe = async (t) => {
  localStorage.getItem("imkit-token") && (localStorage.removeItem("imkit-token"), window.location.reload());
};
function tXe(t, e) {
  const { domain: n } = t, r = Qn.create({
    baseURL: n,
    timeout: 1e4
  });
  return r.interceptors.request.use(
    (i) => {
      Jp(0, i, e);
      const s = new b4({
        "IM-Authorization": e.state.imkit.config.token,
        "IM-Client-Key": e.state.imkit.config.clientKey
      });
      return i.headers = s, i;
    },
    (i) => {
      const { config: s } = i;
      return Jp(1, s, e), Promise.reject(i);
    }
  ), r.interceptors.response.use(
    (i) => {
      const { config: s } = i;
      return Jp(1, s, e), i;
    },
    async (i) => {
      var a;
      const { config: s } = i;
      if (Jp(1, s, e), ((a = i.response) == null ? void 0 : a.status) === 401) {
        await eXe();
        const o = new b4({
          "IM-Authorization": e.state.imkit.config.token,
          "IM-Client-Key": e.state.imkit.config.clientKey
        });
        return s.headers = o, Qn.request(s);
      }
      return Promise.reject(i);
    }
  ), r;
}
function nXe(t, e) {
  const { domain: n, clientKey: r, token: i } = t, s = pf(n, {
    forceBase64: !0,
    transports: ["websocket", "webtransport"],
    reconnection: !0,
    reconnectionAttempts: 1 / 0,
    reconnectionDelay: 1e3,
    reconnectionDelayMax: 5e3
  });
  return s.on("connect", () => {
    s.emit("auth2", i, { CLIENT_KEY: r, Authorization: i });
  }), s.on("disconnect", (a) => {
    s.active || (s.connect(), console.log(a));
  }), s.on("connect_error", (a) => {
    s.active || (s.connect(), console.log(a.message));
  }), s.on("chat message", (a) => {
    var d;
    const o = Fn.createReactive(a), u = new Ma(a.sender), c = e.state.imkit.config.callbacks;
    (d = c == null ? void 0 : c.onMessageReceived) == null || d.call(c, o, u), e.dispatch("imkit/handleMessageFromSocket", o);
  }), s.on("room", (a) => {
    e.dispatch("imkit/handleRoomFromSocket", a);
  }), s.on("lastRead", (a) => {
    const { roomID: o, memberID: u, messageID: c } = a;
    e.dispatch("imkit/handleLastReadFromSocket", {
      roomId: o,
      uid: u,
      messageId: c
    });
  }), s.on("roomPref", (a) => {
    const { room: o, ...u } = a;
    o && (e.commit("imkit/updateRoom", { id: o, pref: u }), u.sticky !== void 0 && e.dispatch("imkit/aggregateRoomsAndFolders"));
  }), s.on("myPrefChange", (a) => {
    e.dispatch("imkit/handlePrefChangeFromSocket", a);
  }), s.on("myPrefDelete", (a) => {
    e.dispatch("imkit/handlePrefDeleteFromSocket", a);
  }), s.on("typing", (a) => {
    e.dispatch("imkit/handleTypingFromSocket", a);
  }), s;
}
const VXe = {
  install: async (t, e) => {
    console.log("IMKIT version:", jN);
    const { store: n, config: r } = e;
    n.hasModule("imkit") || n.registerModule("imkit", iD);
    let i = "";
    try {
      const { id: o, _id: u } = T7(
        r.token
      );
      i = o || u;
    } catch (o) {
      console.log(o);
    }
    const s = tXe(r, n), a = nXe(r, n);
    n.commit("imkit/setState", { config: r, uid: i, axios: s, socket: a }), t.use(DP()), t.use(zr), t.use(JYe, {
      disableClick: !1
    }), t.directive("src", async (o, u) => {
      const { value: c, oldValue: d } = u;
      if (c.startsWith("data:")) {
        o.src = c;
        return;
      }
      const { imageCache: l } = n.state.imkit;
      if (d === void 0 || c !== d) {
        if (l.has(c)) {
          o.src = l.get(c);
          return;
        }
        try {
          o.classList.add("opacity-0");
          const f = await s.get(c, {
            responseType: "arraybuffer",
            onDownloadProgress: (g) => {
              const { total: y } = g;
              y && n.commit("imkit/updateField", {
                key: "downloadProgresses",
                value: { [c]: g.loaded / y }
              });
            }
          }), p = btoa(
            new Uint8Array(f.data).reduce(
              (g, y) => g + String.fromCharCode(y),
              ""
            )
          ), m = `data:${f.headers["content-type"]};base64,${p}`;
          l.set(c, m), o.src = m;
        } catch {
          o.src = c;
        }
        o.classList.remove("opacity-0");
      }
    });
  }
};
export {
  jXe as ChatRoom,
  zXe as ChatRoomInfo,
  Fn as Message,
  aXe as ModalsContainer,
  qXe as RoomList,
  Ma as User,
  VXe as default
};
